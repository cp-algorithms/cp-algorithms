{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"code_of_conduct.html","title":"Code of conduct","text":"<p>We endorse and follow the code of conduct of the International Olympiad of Informatics, available at the IOI website.</p>"},{"location":"preview.html","title":"Preview","text":""},{"location":"preview.html#article-preview","title":"Article Preview","text":"<p>Information for contributors</p>  # Example article  $$a^2 + b^2 = c^2$$  ```cpp int gcd (int a, int b) {     if (b == 0)         return a;     else         return gcd (b, a % b); } ``` Preview (Ctrl + Enter) <p></p>"},{"location":"tags.html","title":"Tags","text":"<p>This file contains a global index of all tags used on the pages.</p>"},{"location":"tags.html#tag:original","title":"Original","text":"<ul> <li>            0-1 BFS          </li> <li>            Basic Geometry          </li> <li>            Binary Search          </li> <li>            Bit manipulation          </li> <li>            Continued fractions          </li> <li>            Convex hull trick and Li Chao tree          </li> <li>            Deleting from a data structure in O(T(n) log n)          </li> <li>            Divide and Conquer DP          </li> <li>            Factoring Exponentiation          </li> <li>            Half-plane intersection - S&amp;I Algorithm in O(N log N)          </li> <li>            Integer factorization          </li> <li>            Introduction to Dynamic Programming          </li> <li>            Knapsack Problem          </li> <li>            Knuth's Optimization          </li> <li>            Kraut &amp; Determinant          </li> <li>            Lattice points of non-lattice polygon          </li> <li>            MEX task (Minimal Excluded element in an array)          </li> <li>            Manhattan Distance          </li> <li>            Maximum flow - MPM algorithm          </li> <li>            Minimum Enclosing Circle          </li> <li>            Minkowski sum of convex polygons          </li> <li>            Montgomery Multiplication          </li> <li>            Number of divisors / sum of divisors          </li> <li>            Operations on polynomials and series          </li> <li>            Point location in O(log N)          </li> <li>            Primality tests          </li> <li>            Second best Minimum Spanning Tree - Using Kruskal and Lowest Common Ancestor          </li> <li>            Simulated Annealing          </li> <li>            Sparse Table          </li> <li>            Sqrt Tree          </li> <li>            Stars and bars          </li> <li>            Strong Orientation          </li> <li>            Tortoise and Hare Algorithm (Linked List cycle detection)          </li> </ul>"},{"location":"tags.html#tag:translated","title":"Translated","text":"<ul> <li>            15 Puzzle Game: Existence Of The Solution          </li> <li>            2-SAT          </li> <li>            Aho-Corasick algorithm          </li> <li>            Arbitrary-Precision Arithmetic          </li> <li>            Area of simple polygon          </li> <li>            Assignment problem          </li> <li>            Balanced Ternary          </li> <li>            Balanced bracket sequences          </li> <li>            Bellman-Ford - finding shortest paths with negative weights          </li> <li>            Binary Exponentiation          </li> <li>            Binomial Coefficients          </li> <li>            Bipartite Graph Check          </li> <li>            Breadth First Search          </li> <li>            Burnside's lemma / P\u00f3lya enumeration theorem          </li> <li>            Catalan Numbers          </li> <li>            Check if points belong to the convex polygon in O(log N)          </li> <li>            Check if two segments intersect          </li> <li>            Checking a graph for acyclicity and finding a cycle in O(M)          </li> <li>            Chinese Remainder Theorem          </li> <li>            Circle-Circle Intersection          </li> <li>            Circle-Line Intersection          </li> <li>            Common tangents to two circles          </li> <li>            Convex hull construction          </li> <li>            Counting labeled graphs          </li> <li>            Delaunay triangulation and Voronoi diagram          </li> <li>            Depth First Search          </li> <li>            Dijkstra - finding shortest paths from given vertex          </li> <li>            Dijkstra on sparse graphs          </li> <li>            Discrete Log          </li> <li>            Discrete Root          </li> <li>            Disjoint Set Union          </li> <li>            Dynamic Programming on Broken Profile. Problem \"Parquet\"          </li> <li>            D\u00b4Esopo-Pape algorithm          </li> <li>            Edge connectivity / Vertex connectivity          </li> <li>            Enumerating submasks of a bitmask          </li> <li>            Euclidean algorithm for computing the greatest common divisor          </li> <li>            Euler's totient function          </li> <li>            Eulerian Path          </li> <li>            Expression parsing          </li> <li>            Extended Euclidean Algorithm          </li> <li>            Factorial modulo p          </li> <li>            Fast Fourier transform          </li> <li>            Fenwick Tree          </li> <li>            Fibonacci Numbers          </li> <li>            Finding Articulation Points in O(N+M)          </li> <li>            Finding Bridges Online          </li> <li>            Finding Bridges in O(N+M)          </li> <li>            Finding Connected Components          </li> <li>            Finding Power of Factorial Divisor          </li> <li>            Finding a Negative Cycle in the Graph          </li> <li>            Finding faces of a planar graph          </li> <li>            Finding repetitions          </li> <li>            Finding the equation of a line for a segment          </li> <li>            Finding the largest zero submatrix          </li> <li>            Finding the nearest pair of points          </li> <li>            Flows with demands          </li> <li>            Floyd-Warshall - finding all shortest paths          </li> <li>            Games on arbitrary graphs          </li> <li>            Gauss &amp; Determinant          </li> <li>            Gauss &amp; System of Linear Equations          </li> <li>            Generating all K-combinations          </li> <li>            Gray code          </li> <li>            Heavy-light decomposition          </li> <li>            Hungarian Algorithm          </li> <li>            Integration by Simpson's formula          </li> <li>            Intersection Point of Lines          </li> <li>            Intersection of Segments          </li> <li>            Josephus problem          </li> <li>            K-th order statistic in O(N)          </li> <li>            Kirchhoff Theorem          </li> <li>            Kuhn's Algorithm - Maximum Bipartite Matching          </li> <li>            Length of the union of segments          </li> <li>            Linear Congruence Equation          </li> <li>            Linear Diophantine Equations          </li> <li>            Linear Sieve          </li> <li>            Longest increasing subsequence          </li> <li>            Lowest Common Ancestor          </li> <li>            Lowest Common Ancestor - Binary Lifting          </li> <li>            Lowest Common Ancestor - Farach-Colton and Bender algorithm          </li> <li>            Lowest Common Ancestor - Tarjan's off-line algorithm          </li> <li>            Lyndon factorization          </li> <li>            Manacher's Algorithm - Finding all sub-palindromes in O(N)          </li> <li>            Maximum flow - Dinic's algorithm          </li> <li>            Maximum flow - Ford-Fulkerson and Edmonds-Karp          </li> <li>            Maximum flow - Push-relabel algorithm          </li> <li>            Maximum flow - Push-relabel algorithm improved          </li> <li>            Minimum Spanning Tree - Kruskal          </li> <li>            Minimum Spanning Tree - Kruskal with Disjoint Set Union          </li> <li>            Minimum Spanning Tree - Prim's Algorithm          </li> <li>            Minimum Stack / Minimum Queue          </li> <li>            Minimum-cost flow          </li> <li>            Modular Inverse          </li> <li>            Newton's method for finding roots          </li> <li>            Number of paths of fixed length / Shortest paths of fixed length          </li> <li>            Optimal schedule of jobs given their deadlines and durations          </li> <li>            Oriented area of a triangle          </li> <li>            Pick's Theorem - area of lattice polygons          </li> <li>            Placing Bishops on a Chessboard          </li> <li>            Prefix function - Knuth-Morris-Pratt          </li> <li>            Primitive Root          </li> <li>            Pr\u00fcfer code          </li> <li>            RMQ task (Range Minimum Query - the smallest element in an interval)          </li> <li>            Rabin-Karp for String Matching          </li> <li>            Randomized Heap          </li> <li>            Rank of a matrix          </li> <li>            Scheduling jobs on one machine          </li> <li>            Scheduling jobs on two machines          </li> <li>            Search for a pair of intersecting segments          </li> <li>            Search the subsegment with the maximum/minimum sum          </li> <li>            Segment Tree          </li> <li>            Sieve of Eratosthenes          </li> <li>            Solve RMQ by finding LCA          </li> <li>            Sprague-Grundy theorem. Nim          </li> <li>            Sqrt Decomposition          </li> <li>            String Hashing          </li> <li>            Strongly Connected Components and Condensation Graph          </li> <li>            Suffix Array          </li> <li>            Suffix Automaton          </li> <li>            Suffix Tree          </li> <li>            Ternary Search          </li> <li>            The Inclusion-Exclusion Principle          </li> <li>            The Stern-Brocot Tree and Farey Sequences          </li> <li>            Topological Sorting          </li> <li>            Treap          </li> <li>            Tree painting          </li> <li>            Vertical decomposition          </li> <li>            Z-function          </li> </ul>"},{"location":"algebra/all-submasks.html","title":"Submask Enumeration","text":"","tags":["Translated"]},{"location":"algebra/all-submasks.html#enumerating-all-submasks-of-a-given-mask","title":"Enumerating all submasks of a given mask","text":"<p>Given a bitmask $m$, you want to efficiently iterate through all of its submasks, that is, masks $s$ in which only bits that were included in mask $m$ are set.</p> <p>Consider the implementation of this algorithm, based on tricks with bit operations:</p> <pre><code>int s = m;\nwhile (s &gt; 0) {\n ... you can use s ...\n s = (s-1) &amp; m;\n}\n</code></pre> <p>or, using a more compact <code>for</code> statement:</p> <pre><code>for (int s=m; s; s=(s-1)&amp;m)\n ... you can use s ...\n</code></pre> <p>In both variants of the code, the submask equal to zero will not be processed. We can either process it outside the loop, or use a less elegant design, for example:</p> <pre><code>for (int s=m; ; s=(s-1)&amp;m) {\n ... you can use s ...\n if (s==0)  break;\n}\n</code></pre> <p>Let us examine why the above code visits all submasks of $m$, without repetition, and in descending order.</p> <p>Suppose we have a current bitmask $s$, and we want to move on to the next bitmask. By subtracting from the mask $s$ one unit, we will remove the rightmost set bit and all bits to the right of it will become 1. Then we remove all the \"extra\" one bits that are not included in the mask $m$ and therefore can't be a part of a submask. We do this removal by using the bitwise operation <code>(s-1) &amp; m</code>. As a result, we \"cut\" mask $s-1$ to determine the highest value that it can take, that is, the next submask after $s$ in descending order.</p> <p>Thus, this algorithm generates all submasks of this mask in descending order, performing only two operations per iteration.</p> <p>A special case is when $s = 0$. After executing $s-1$ we get a mask where all bits are set (bit representation of -1), and after <code>(s-1) &amp; m</code> we will have that $s$ will be equal to $m$. Therefore, with the mask $s = 0$ be careful \u2014 if the loop does not end at zero, the algorithm may enter an infinite loop.</p>","tags":["Translated"]},{"location":"algebra/all-submasks.html#iterating-through-all-masks-with-their-submasks-complexity-o3n","title":"Iterating through all masks with their submasks. Complexity $O(3^n)$","text":"<p>In many problems, especially those that use bitmask dynamic programming, you want to iterate through all bitmasks and for each mask, iterate through all of its submasks:</p> <pre><code>for (int m=0; m&lt;(1&lt;&lt;n); ++m)\n    for (int s=m; s; s=(s-1)&amp;m)\n ... s and m ...\n</code></pre> <p>Let's prove that the inner loop will execute a total of $O(3^n)$ iterations.</p> <p>First proof: Consider the $i$-th bit. There are exactly three options for it:</p> <ol> <li>it is not included in the mask $m$ (and therefore not included in submask $s$),</li> <li>it is included in $m$, but not included in $s$, or</li> <li>it is included in both $m$ and $s$.</li> </ol> <p>As there are a total of $n$ bits, there will be $3^n$ different combinations.</p> <p>Second proof: Note that if mask $m$ has $k$ enabled bits, then it will have $2^k$ submasks. As we have a total of $\\binom{n}{k}$ masks with $k$ enabled bits (see binomial coefficients), then the total number of combinations for all masks will be:</p> $$\\sum_{k=0}^n \\binom{n}{k} \\cdot 2^k$$ <p>To calculate this number, note that the sum above is equal to the expansion of $(1+2)^n$ using the binomial theorem. Therefore, we have $3^n$ combinations, as we wanted to prove.</p>","tags":["Translated"]},{"location":"algebra/all-submasks.html#practice-problems","title":"Practice Problems","text":"<ul> <li>Atcoder - Close Group</li> <li>Codeforces - Nuclear Fusion</li> <li>Codeforces - Sandy and Nuts</li> <li>Uva 1439 - Exclusive Access 2</li> <li>UVa 11825 - Hackers' Crackdown</li> </ul>","tags":["Translated"]},{"location":"algebra/balanced-ternary.html","title":"Balanced Ternary","text":"<p>This is a non-standard but still positional numeral system. Its feature is that digits can have one of the values <code>-1</code>, <code>0</code> and <code>1</code>. Nevertheless, its base is still <code>3</code> (because there are three possible values). Since it is not convenient to write <code>-1</code> as a digit, we'll use letter <code>Z</code> further for this purpose. If you think it is quite a strange system - look at the picture - here is one of the computers utilizing it.</p> <p>So here are few first numbers written in balanced ternary:</p> <pre><code>    0    0\n    1    1\n    2    1Z\n    3    10\n    4    11\n    5    1ZZ\n    6    1Z0\n    7    1Z1\n    8    10Z\n    9    100\n</code></pre> <p>This system allows you to write negative values without leading minus sign: you can simply invert digits in any positive number.</p> <pre><code>    -1   Z\n    -2   Z1\n    -3   Z0\n    -4   ZZ\n    -5   Z11\n</code></pre> <p>Note that a negative number starts with <code>Z</code> and positive with <code>1</code>.</p>","tags":["Translated"]},{"location":"algebra/balanced-ternary.html#conversion-algorithm","title":"Conversion algorithm","text":"<p>It is easy to represent a given number in balanced ternary via temporary representing it in normal ternary number system. When value is in standard ternary, its digits are either <code>0</code> or <code>1</code> or <code>2</code>. Iterating from the lowest digit we can safely skip any <code>0</code>s and <code>1</code>s, however <code>2</code> should be turned into <code>Z</code> with adding <code>1</code> to the next digit. Digits <code>3</code> should be turned into <code>0</code> on the same terms - such digits are not present in the number initially but they can be encountered after increasing some <code>2</code>s.</p> <p>Example 1: Let us convert <code>64</code> to balanced ternary. At first we use normal ternary to rewrite the number:</p> $$ 64_{10} = 02101_{3} $$ <p>Let us process it from the least significant (rightmost) digit:</p> <ul> <li><code>1</code>,<code>0</code> and <code>1</code> are skipped as it is.( Because <code>0</code> and <code>1</code> are allowed in balanced ternary )</li> <li><code>2</code> is turned into <code>Z</code> increasing the digit to its left, so we get <code>1Z101</code>.</li> </ul> <p>The final result is <code>1Z101</code>.</p> <p>Let us convert it back to the decimal system by adding the weighted positional values:</p> $$ 1Z101 = 81 \\cdot 1 + 27 \\cdot (-1) + 9 \\cdot 1 + 3 \\cdot 0 + 1 \\cdot 1 = 64_{10} $$ <p>Example 2: Let us convert <code>237</code> to balanced ternary. At first we use normal ternary to rewrite the number:</p> $$ 237_{10} = 22210_{3} $$ <p>Let us process it from the least significant (rightmost) digit:</p> <ul> <li><code>0</code> and <code>1</code> are skipped as it is.( Because <code>0</code> and <code>1</code> are allowed in balanced ternary )</li> <li><code>2</code> is turned into <code>Z</code> increasing the digit to its left, so we get <code>23Z10</code>.</li> <li><code>3</code> is turned into <code>0</code> increasing the digit to its left, so we get <code>30Z10</code>.</li> <li><code>3</code> is turned into <code>0</code> increasing the digit to its left( which is by default <code>0</code> ), and so we get <code>100Z10</code>.</li> </ul> <p>The final result is <code>100Z10</code>.</p> <p>Let us convert it back to the decimal system by adding the weighted positional values:</p> $$ 100Z10 = 243 \\cdot 1 + 81 \\cdot 0 + 27 \\cdot 0 + 9 \\cdot (-1) + 3 \\cdot 1 + 1 \\cdot 0 = 237_{10} $$","tags":["Translated"]},{"location":"algebra/balanced-ternary.html#practice-problems","title":"Practice Problems","text":"<ul> <li>Topcoder SRM 604, Div1-250</li> </ul>","tags":["Translated"]},{"location":"algebra/big-integer.html","title":"Arbitrary-Precision Arithmetic","text":"<p>Arbitrary-Precision arithmetic, also known as \"bignum\" or simply \"long arithmetic\" is a set of data structures and algorithms which allows to process much greater numbers than can be fit in standard data types. Here are several types of arbitrary-precision arithmetic.</p>","tags":["Translated"]},{"location":"algebra/big-integer.html#classical-integer-long-arithmetic","title":"Classical Integer Long Arithmetic","text":"<p>The main idea is that the number is stored as an array of its \"digits\" in some base. Several most frequently used bases are decimal, powers of decimal ($10^4$ or $10^9$) and binary.</p> <p>Operations on numbers in this form are performed using \"school\" algorithms of column addition, subtraction, multiplication and division. It's also possible to use fast multiplication algorithms: fast Fourier transform and Karatsuba algorithm.</p> <p>Here we describe long arithmetic for only non-negative integers. To extend the algorithms to handle negative integers one has to introduce and maintain additional \"negative number\" flag or use two's complement integer representation.</p>","tags":["Translated"]},{"location":"algebra/big-integer.html#data-structure","title":"Data Structure","text":"<p>We'll store numbers as a <code>vector&lt;int&gt;</code>, in which each element is a single \"digit\" of the number.</p> <pre><code>typedef vector&lt;int&gt; lnum;\n</code></pre> <p>To improve performance we'll use $10^9$ as the base, so that each \"digit\" of the long number contains 9 decimal digits at once.</p> <pre><code>const int base = 1000*1000*1000;\n</code></pre> <p>Digits will be stored in order from least to most significant. All operations will be implemented so that after each of them the result doesn't have any leading zeros, as long as operands didn't have any leading zeros either. All operations which might result in a number with leading zeros should be followed by code which removes them. Note that in this representation there are two valid notations for number zero: an empty vector, and a vector with a single zero digit.</p>","tags":["Translated"]},{"location":"algebra/big-integer.html#output","title":"Output","text":"<p>Printing the long integer is the easiest operation. First we print the last element of the vector (or 0 if the vector is empty), followed by the rest of the elements padded with leading zeros if necessary so that they are exactly 9 digits long.</p> <pre><code>printf (\"%d\", a.empty() ? 0 : a.back());\nfor (int i=(int)a.size()-2; i&gt;=0; --i)\n    printf (\"%09d\", a[i]);\n</code></pre> <p>Note that we cast <code>a.size()</code> to integer to avoid unsigned integer underflow if vector contains less than 2 elements.</p>","tags":["Translated"]},{"location":"algebra/big-integer.html#input","title":"Input","text":"<p>To read a long integer, read its notation into a <code>string</code> and then convert it to \"digits\":</p> <pre><code>for (int i=(int)s.length(); i&gt;0; i-=9)\n    if (i &lt; 9)\n        a.push_back (atoi (s.substr (0, i).c_str()));\n    else\n        a.push_back (atoi (s.substr (i-9, 9).c_str()));\n</code></pre> <p>If we use an array of <code>char</code> instead of a <code>string</code>, the code will be even shorter:</p> <pre><code>for (int i=(int)strlen(s); i&gt;0; i-=9) {\n    s[i] = 0;\n    a.push_back (atoi (i&gt;=9 ? s+i-9 : s));\n}\n</code></pre> <p>If the input can contain leading zeros, they can be removed as follows:</p> <pre><code>while (a.size() &gt; 1 &amp;&amp; a.back() == 0)\n    a.pop_back();\n</code></pre>","tags":["Translated"]},{"location":"algebra/big-integer.html#addition","title":"Addition","text":"<p>Increment long integer $a$ by $b$ and store result in $a$:</p> <pre><code>int carry = 0;\nfor (size_t i=0; i&lt;max(a.size(),b.size()) || carry; ++i) {\n    if (i == a.size())\n        a.push_back (0);\n    a[i] += carry + (i &lt; b.size() ? b[i] : 0);\n    carry = a[i] &gt;= base;\n    if (carry)  a[i] -= base;\n}\n</code></pre>","tags":["Translated"]},{"location":"algebra/big-integer.html#subtraction","title":"Subtraction","text":"<p>Decrement long integer $a$ by $b$ ($a \\ge b$) and store result in $a$:</p> <pre><code>int carry = 0;\nfor (size_t i=0; i&lt;b.size() || carry; ++i) {\n    a[i] -= carry + (i &lt; b.size() ? b[i] : 0);\n    carry = a[i] &lt; 0;\n    if (carry)  a[i] += base;\n}\nwhile (a.size() &gt; 1 &amp;&amp; a.back() == 0)\n    a.pop_back();\n</code></pre> <p>Note that after performing subtraction we remove leading zeros to keep up with the premise that our long integers don't have leading zeros.</p>","tags":["Translated"]},{"location":"algebra/big-integer.html#multiplication-by-short-integer","title":"Multiplication by short integer","text":"<p>Multiply long integer $a$ by short integer $b$ ($b &lt; base$) and store result in $a$:</p> <pre><code>int carry = 0;\nfor (size_t i=0; i&lt;a.size() || carry; ++i) {\n    if (i == a.size())\n        a.push_back (0);\n    long long cur = carry + a[i] * 1ll * b;\n    a[i] = int (cur % base);\n    carry = int (cur / base);\n}\nwhile (a.size() &gt; 1 &amp;&amp; a.back() == 0)\n    a.pop_back();\n</code></pre> <p>Additional optimization: If runtime is extremely important, you can try to replace two divisions with one by finding only integer result of division (variable <code>carry</code>) and then use it to find modulo using multiplication. This usually makes the code faster, though not dramatically.</p>","tags":["Translated"]},{"location":"algebra/big-integer.html#multiplication-by-long-integer","title":"Multiplication by long integer","text":"<p>Multiply long integers $a$ and $b$ and store result in $c$:</p> <pre><code>lnum c (a.size()+b.size());\nfor (size_t i=0; i&lt;a.size(); ++i)\n    for (int j=0, carry=0; j&lt;(int)b.size() || carry; ++j) {\n        long long cur = c[i+j] + a[i] * 1ll * (j &lt; (int)b.size() ? b[j] : 0) + carry;\n        c[i+j] = int (cur % base);\n        carry = int (cur / base);\n    }\nwhile (c.size() &gt; 1 &amp;&amp; c.back() == 0)\n    c.pop_back();\n</code></pre>","tags":["Translated"]},{"location":"algebra/big-integer.html#division-by-short-integer","title":"Division by short integer","text":"<p>Divide long integer $a$ by short integer $b$ ($b &lt; base$), store integer result in $a$ and remainder in <code>carry</code>:</p> <pre><code>int carry = 0;\nfor (int i=(int)a.size()-1; i&gt;=0; --i) {\n    long long cur = a[i] + carry * 1ll * base;\n    a[i] = int (cur / b);\n    carry = int (cur % b);\n}\nwhile (a.size() &gt; 1 &amp;&amp; a.back() == 0)\n    a.pop_back();\n</code></pre>","tags":["Translated"]},{"location":"algebra/big-integer.html#long-integer-arithmetic-for-factorization-representation","title":"Long Integer Arithmetic for Factorization Representation","text":"<p>The idea is to store the integer as its factorization, i.e. the powers of primes which divide it.</p> <p>This approach is very easy to implement, and allows to do multiplication and division easily (asymptotically faster than the classical method), but not addition or subtraction. It is also very memory-efficient compared to the classical approach.</p> <p>This method is often used for calculations modulo non-prime number M; in this case a number is stored as powers of divisors of M which divide the number, plus the remainder modulo M.</p>","tags":["Translated"]},{"location":"algebra/big-integer.html#long-integer-arithmetic-in-prime-modulos-garner-algorithm","title":"Long Integer Arithmetic in prime modulos (Garner Algorithm)","text":"<p>The idea is to choose a set of prime numbers (typically they are small enough to fit into standard integer data type) and to store an integer as a vector of remainders from division of the integer by each of those primes.</p> <p>Chinese remainder theorem states that this representation is sufficient to uniquely restore any number from 0 to product of these primes minus one. Garner algorithm allows to restore the number from such representation to normal integer.</p> <p>This method allows to save memory compared to the classical approach (though the savings are not as dramatic as in factorization representation). Besides, it allows to perform fast addition, subtraction and multiplication in time proportional to the number of prime numbers used as modulos (see Chinese remainder theorem article for implementation).</p> <p>The tradeoff is that converting the integer back to normal form is rather laborious and requires implementing classical arbitrary-precision arithmetic with multiplication. Besides, this method doesn't support division.</p>","tags":["Translated"]},{"location":"algebra/big-integer.html#fractional-arbitrary-precision-arithmetic","title":"Fractional Arbitrary-Precision Arithmetic","text":"<p>Fractions occur in programming competitions less frequently than integers, and long arithmetic is much trickier to implement for fractions, so programming competitions feature only a small subset of fractional long arithmetic.</p>","tags":["Translated"]},{"location":"algebra/big-integer.html#arithmetic-in-irreducible-fractions","title":"Arithmetic in Irreducible Fractions","text":"<p>A number is represented as an irreducible fraction $\\frac{a}{b}$, where $a$ and $b$ are integers. All operations on fractions can be represented as operations on integer numerators and denominators of these fractions. Usually this requires using classical arbitrary-precision arithmetic for storing numerator and denominator, but sometimes a built-in 64-bit integer data type suffices.</p>","tags":["Translated"]},{"location":"algebra/big-integer.html#storing-floating-point-position-as-separate-type","title":"Storing Floating Point Position as Separate Type","text":"<p>Sometimes a problem requires handling very small or very large numbers without allowing overflow or underflow. Built-in double data type uses 8-10 bytes and allows values of the exponent in $[-308; 308]$ range, which sometimes might be insufficient.</p> <p>The approach is very simple: a separate integer variable is used to store the value of the exponent, and after each operation the floating-point number is normalized, i.e. returned to $[0.1; 1)$ interval by adjusting the exponent accordingly. </p> <p>When two such numbers are multiplied or divided, their exponents should be added or subtracted, respectively. When numbers are added or subtracted, they have to be brought to common exponent first by multiplying one of them by 10 raised to the power equal to the difference of exponent values.</p> <p>As a final note, the exponent base doesn't have to equal 10. Based on the internal representation of floating-point numbers, it makes most sense to use 2 as the exponent base.</p>","tags":["Translated"]},{"location":"algebra/big-integer.html#practice-problems","title":"Practice Problems","text":"<ul> <li>UVA - How Many Fibs?</li> <li>UVA - Product</li> <li>UVA - Maximum Sub-sequence Product</li> <li>SPOJ - Fast Multiplication</li> <li>SPOJ - GCD2</li> <li>UVA - Division</li> <li>UVA - Fibonacci Freeze</li> <li>UVA - Krakovia</li> <li>UVA - Simplifying Fractions</li> <li>UVA - 500!</li> <li>Hackerrank - Factorial digit sum</li> <li>UVA - Immortal Rabbits</li> <li>SPOJ - 0110SS</li> <li>Codeforces - Notepad</li> </ul>","tags":["Translated"]},{"location":"algebra/binary-exp.html","title":"Binary Exponentiation","text":"<p>Binary exponentiation (also known as exponentiation by squaring) is a trick which allows to calculate $a^n$ using only $O(\\log n)$ multiplications (instead of $O(n)$ multiplications required by the naive approach).</p> <p>It also has important applications in many tasks unrelated to arithmetic, since it can be used with any operations that have the property of associativity:</p> $$(X \\cdot Y) \\cdot Z = X \\cdot (Y \\cdot Z)$$ <p>Most obviously this applies to modular multiplication, to multiplication of matrices and to other problems which we will discuss below.</p>","tags":["Translated"]},{"location":"algebra/binary-exp.html#algorithm","title":"Algorithm","text":"<p>Raising $a$ to the power of $n$ is expressed naively as multiplication by $a$ done $n - 1$ times: $a^{n} = a \\cdot a \\cdot \\ldots \\cdot a$. However, this approach is not practical for large $a$ or $n$.</p> <p>$a^{b+c} = a^b \\cdot a^c$ and $a^{2b} = a^b \\cdot a^b = (a^b)^2$.</p> <p>The idea of binary exponentiation is, that we split the work using the binary representation of the exponent.</p> <p>Let's write $n$ in base 2, for example:</p> $$3^{13} = 3^{1101_2} = 3^8 \\cdot 3^4 \\cdot 3^1$$ <p>Since the number $n$ has exactly $\\lfloor \\log_2 n \\rfloor + 1$ digits in base 2, we only need to perform $O(\\log n)$ multiplications, if we know the powers $a^1, a^2, a^4, a^8, \\dots, a^{2^{\\lfloor \\log n \\rfloor}}$.</p> <p>So we only need to know a fast way to compute those. Luckily this is very easy, since an element in the sequence is just the square of the previous element.</p> $$\\begin{align} 3^1 &amp;= 3 \\\\ 3^2 &amp;= \\left(3^1\\right)^2 = 3^2 = 9 \\\\ 3^4 &amp;= \\left(3^2\\right)^2 = 9^2 = 81 \\\\ 3^8 &amp;= \\left(3^4\\right)^2 = 81^2 = 6561 \\end{align}$$ <p>So to get the final answer for $3^{13}$, we only need to multiply three of them (skipping $3^2$ because the corresponding bit in $n$ is not set): $3^{13} = 6561 \\cdot 81 \\cdot 3 = 1594323$</p> <p>The final complexity of this algorithm is $O(\\log n)$: we have to compute $\\log n$ powers of $a$, and then have to do at most $\\log n$ multiplications to get the final answer from them.</p> <p>The following recursive approach expresses the same idea:</p> $$a^n = \\begin{cases} 1 &amp;\\text{if } n == 0 \\\\ \\left(a^{\\frac{n}{2}}\\right)^2 &amp;\\text{if } n &gt; 0 \\text{ and } n \\text{ even}\\\\ \\left(a^{\\frac{n - 1}{2}}\\right)^2 \\cdot a &amp;\\text{if } n &gt; 0 \\text{ and } n \\text{ odd}\\\\ \\end{cases}$$","tags":["Translated"]},{"location":"algebra/binary-exp.html#implementation","title":"Implementation","text":"<p>First the recursive approach, which is a direct translation of the recursive formula:</p> <pre><code>long long binpow(long long a, long long b) {\n    if (b == 0)\n        return 1;\n    long long res = binpow(a, b / 2);\n    if (b % 2)\n        return res * res * a;\n    else\n        return res * res;\n}\n</code></pre> <p>The second approach accomplishes the same task without recursion. It computes all the powers in a loop, and multiplies the ones with the corresponding set bit in $n$. Although the complexity of both approaches is identical, this approach will be faster in practice since we don't have the overhead of the recursive calls.</p> <pre><code>long long binpow(long long a, long long b) {\n    long long res = 1;\n    while (b &gt; 0) {\n        if (b &amp; 1)\n            res = res * a;\n        a = a * a;\n        b &gt;&gt;= 1;\n    }\n    return res;\n}\n</code></pre>","tags":["Translated"]},{"location":"algebra/binary-exp.html#applications","title":"Applications","text":"","tags":["Translated"]},{"location":"algebra/binary-exp.html#effective-computation-of-large-exponents-modulo-a-number","title":"Effective computation of large exponents modulo a number","text":"<p>Problem: Compute $x^n \\bmod m$. This is a very common operation. For instance it is used in computing the modular multiplicative inverse.</p> <p>Solution: Since we know that the modulo operator doesn't interfere with multiplications ($a \\cdot b \\equiv (a \\bmod m) \\cdot (b \\bmod m) \\pmod m$), we can directly use the same code, and just replace every multiplication with a modular multiplication:</p> <pre><code>long long binpow(long long a, long long b, long long m) {\n    a %= m;\n    long long res = 1;\n    while (b &gt; 0) {\n        if (b &amp; 1)\n            res = res * a % m;\n        a = a * a % m;\n        b &gt;&gt;= 1;\n    }\n    return res;\n}\n</code></pre> <p>Note: It's possible to speed this algorithm for large $b &gt;&gt; m$. If $m$ is a prime number $x^n \\equiv x^{n \\bmod (m-1)} \\pmod{m}$ for prime $m$, and $x^n \\equiv x^{n \\bmod{\\phi(m)}} \\pmod{m}$ for composite $m$. This follows directly from Fermat's little theorem and Euler's theorem, see the article about Modular Inverses for more details.</p>","tags":["Translated"]},{"location":"algebra/binary-exp.html#effective-computation-of-fibonacci-numbers","title":"Effective computation of Fibonacci numbers","text":"<p>Problem: Compute $n$-th Fibonacci number $F_n$.</p> <p>Solution: For more details, see the Fibonacci Number article. We will only go through an overview of the algorithm. To compute the next Fibonacci number, only the two previous ones are needed, as $F_n = F_{n-1} + F_{n-2}$. We can build a $2 \\times 2$ matrix that describes this transformation: the transition from $F_i$ and $F_{i+1}$ to $F_{i+1}$ and $F_{i+2}$. For example, applying this transformation to the pair $F_0$ and $F_1$ would change it into $F_1$ and $F_2$. Therefore, we can raise this transformation matrix to the $n$-th power to find $F_n$ in time complexity $O(\\log n)$.</p>","tags":["Translated"]},{"location":"algebra/binary-exp.html#applying-a-permutation-k-times","title":"Applying a permutation $k$ times","text":"<p>Problem: You are given a sequence of length $n$. Apply to it a given permutation $k$ times.</p> <p>Solution: Simply raise the permutation to $k$-th power using binary exponentiation, and then apply it to the sequence. This will give you a time complexity of $O(n \\log k)$.</p> <pre><code>vector&lt;int&gt; applyPermutation(vector&lt;int&gt; sequence, vector&lt;int&gt; permutation) {\n    vector&lt;int&gt; newSequence(sequence.size());\n    for(int i = 0; i &lt; sequence.size(); i++) {\n        newSequence[i] = sequence[permutation[i]];\n    }\n    return newSequence;\n}\n\nvector&lt;int&gt; permute(vector&lt;int&gt; sequence, vector&lt;int&gt; permutation, long long k) {\n    while (k &gt; 0) {\n        if (k &amp; 1) {\n            sequence = applyPermutation(sequence, permutation);\n        }\n        permutation = applyPermutation(permutation, permutation);\n        k &gt;&gt;= 1;\n    }\n    return sequence;\n}\n</code></pre> <p>Note: This task can be solved more efficiently in linear time by building the permutation graph and considering each cycle independently. You could then compute $k$ modulo the size of the cycle and find the final position for each number which is part of this cycle.</p>","tags":["Translated"]},{"location":"algebra/binary-exp.html#fast-application-of-a-set-of-geometric-operations-to-a-set-of-points","title":"Fast application of a set of geometric operations to a set of points","text":"<p>Problem: Given $n$ points $p_i$, apply $m$ transformations to each of these points. Each transformation can be a shift, a scaling or a rotation around a given axis by a given angle. There is also a \"loop\" operation which applies a given list of transformations $k$ times (\"loop\" operations can be nested). You should apply all transformations faster than $O(n \\cdot length)$, where $length$ is the total number of transformations to be applied (after unrolling \"loop\" operations).</p> <p>Solution: Let's look at how the different types of transformations change the coordinates:</p> <ul> <li>Shift operation: adds a different constant to each of the coordinates.</li> <li>Scaling operation: multiplies each of the coordinates by a different constant.</li> <li>Rotation operation: the transformation is more complicated (we won't go in details here), but each of the new coordinates still can be represented as a linear combination of the old ones.</li> </ul> <p>As you can see, each of the transformations can be represented as a linear operation on the coordinates. Thus, a transformation can be written as a $4 \\times 4$ matrix of the form:</p> $$\\begin{pmatrix} a_{11} &amp; a_ {12} &amp; a_ {13} &amp; a_ {14} \\\\ a_{21} &amp; a_ {22} &amp; a_ {23} &amp; a_ {24} \\\\ a_{31} &amp; a_ {32} &amp; a_ {33} &amp; a_ {34} \\\\ a_{41} &amp; a_ {42} &amp; a_ {43} &amp; a_ {44} \\end{pmatrix}$$ <p>that, when multiplied by a vector with the old coordinates and a unit gives a new vector with the new coordinates and a unit:</p> $$\\begin{pmatrix} x &amp; y &amp; z &amp; 1 \\end{pmatrix} \\cdot \\begin{pmatrix} a_{11} &amp; a_ {12} &amp; a_ {13} &amp; a_ {14} \\\\ a_{21} &amp; a_ {22} &amp; a_ {23} &amp; a_ {24} \\\\ a_{31} &amp; a_ {32} &amp; a_ {33} &amp; a_ {34} \\\\ a_{41} &amp; a_ {42} &amp; a_ {43} &amp; a_ {44} \\end{pmatrix}  = \\begin{pmatrix} x' &amp; y' &amp; z' &amp; 1 \\end{pmatrix}$$ <p>(Why introduce a fictitious fourth coordinate, you ask? That is the beauty of homogeneous coordinates, which find great application in computer graphics. Without this, it would not be possible to implement affine operations like the shift operation as a single matrix multiplication, as it requires us to add a constant to the coordinates. The affine transformation becomes a linear transformation in the higher dimension!)</p> <p>Here are some examples of how transformations are represented in matrix form:</p> <ul> <li>Shift operation: shift $x$ coordinate by $5$, $y$ coordinate by $7$ and $z$ coordinate by $9$.</li> </ul> $$\\begin{pmatrix} 1 &amp; 0 &amp; 0 &amp; 0 \\\\ 0 &amp; 1 &amp; 0 &amp; 0 \\\\ 0 &amp; 0 &amp; 1 &amp; 0 \\\\ 5 &amp; 7 &amp; 9 &amp; 1 \\end{pmatrix}$$ <ul> <li>Scaling operation: scale the $x$ coordinate by $10$ and the other two by $5$.</li> </ul> $$\\begin{pmatrix} 10 &amp; 0 &amp; 0 &amp; 0 \\\\ 0 &amp; 5 &amp; 0 &amp; 0 \\\\ 0 &amp; 0 &amp; 5 &amp; 0 \\\\ 0 &amp; 0 &amp; 0 &amp; 1 \\end{pmatrix}$$ <ul> <li>Rotation operation: rotate $\\theta$ degrees around the $x$ axis following the right-hand rule (counter-clockwise direction).</li> </ul> $$\\begin{pmatrix} 1 &amp; 0 &amp; 0 &amp; 0 \\\\ 0 &amp; \\cos \\theta &amp; -\\sin \\theta &amp; 0 \\\\ 0 &amp; \\sin \\theta &amp; \\cos \\theta &amp; 0 \\\\ 0 &amp; 0 &amp; 0 &amp; 1 \\end{pmatrix}$$ <p>Now, once every transformation is described as a matrix, the sequence of transformations can be described as a product of these matrices, and a \"loop\" of $k$ repetitions can be described as the matrix raised to the power of $k$ (which can be calculated using binary exponentiation in $O(\\log{k})$). This way, the matrix which represents all transformations can be calculated first in $O(m \\log{k})$, and then it can be applied to each of the $n$ points in $O(n)$ for a total complexity of $O(n + m \\log{k})$.</p>","tags":["Translated"]},{"location":"algebra/binary-exp.html#number-of-paths-of-length-k-in-a-graph","title":"Number of paths of length $k$ in a graph","text":"<p>Problem: Given a directed unweighted graph of $n$ vertices, find the number of paths of length $k$ from any vertex $u$ to any other vertex $v$.</p> <p>Solution: This problem is considered in more detail in a separate article. The algorithm consists of raising the adjacency matrix $M$ of the graph (a matrix where $m_{ij} = 1$ if there is an edge from $i$ to $j$, or $0$ otherwise) to the $k$-th power. Now $m_{ij}$ will be the number of paths of length $k$ from $i$ to $j$. The time complexity of this solution is $O(n^3 \\log k)$.</p> <p>Note: In that same article, another variation of this problem is considered: when the edges are weighted and it is required to find the minimum weight path containing exactly $k$ edges. As shown in that article, this problem is also solved by exponentiation of the adjacency matrix. The matrix would have the weight of the edge from $i$ to $j$, or $\\infty$ if there is no such edge. Instead of the usual operation of multiplying two matrices, a modified one should be used: instead of multiplication, both values are added, and instead of a summation, a minimum is taken. That is: $result_{ij} = \\min\\limits_{1\\ \\leq\\ k\\ \\leq\\ n}(a_{ik} + b_{kj})$.</p>","tags":["Translated"]},{"location":"algebra/binary-exp.html#variation-of-binary-exponentiation-multiplying-two-numbers-modulo-m","title":"Variation of binary exponentiation: multiplying two numbers modulo $m$","text":"<p>Problem: Multiply two numbers $a$ and $b$ modulo $m$. $a$ and $b$ fit in the built-in data types, but their product is too big to fit in a 64-bit integer. The idea is to compute $a \\cdot b \\pmod m$ without using bignum arithmetics.</p> <p>Solution: We simply apply the binary construction algorithm described above, only performing additions instead of multiplications. In other words, we have \"expanded\" the multiplication of two numbers to $O (\\log m)$ operations of addition and multiplication by two (which, in essence, is an addition).</p> $$a \\cdot b = \\begin{cases} 0 &amp;\\text{if }a = 0 \\\\ 2 \\cdot \\frac{a}{2} \\cdot b &amp;\\text{if }a &gt; 0 \\text{ and }a \\text{ even} \\\\ 2 \\cdot \\frac{a-1}{2} \\cdot b + b &amp;\\text{if }a &gt; 0 \\text{ and }a \\text{ odd} \\end{cases}$$ <p>Note: You can solve this task in a different way by using floating-point operations. First compute the expression $\\frac{a \\cdot b}{m}$ using floating-point numbers and cast it to an unsigned integer $q$. Subtract $q \\cdot m$ from $a \\cdot b$ using unsigned integer arithmetics and take it modulo $m$ to find the answer. This solution looks rather unreliable, but it is very fast, and very easy to implement. See here for more information.</p>","tags":["Translated"]},{"location":"algebra/binary-exp.html#practice-problems","title":"Practice Problems","text":"<ul> <li>UVa 1230 - MODEX</li> <li>UVa 374 - Big Mod</li> <li>UVa 11029 - Leading and Trailing</li> <li>Codeforces - Parking Lot</li> <li>leetcode - Count good numbers</li> <li>Codechef - Chef and Riffles</li> <li>Codeforces - Decoding Genome</li> <li>Codeforces - Neural Network Country</li> <li>Codeforces - Magic Gems</li> <li>SPOJ - The last digit</li> <li>SPOJ - Locker</li> <li>LA - 3722 Jewel-eating Monsters</li> <li>SPOJ - Just add it</li> <li>Codeforces - Stairs and Lines</li> </ul>","tags":["Translated"]},{"location":"algebra/bit-manipulation.html","title":"Bit manipulation","text":"","tags":["Original"]},{"location":"algebra/bit-manipulation.html#binary-number","title":"Binary number","text":"<p>A binary number is a number expressed in the base-2 numeral system or binary numeral system, it is a method of mathematical expression which uses only two symbols: typically \"0\" (zero) and \"1\" (one).</p> <p>We say that a certain bit is set, if it is one, and cleared if it is zero.</p> <p>The binary number $(a_k a_{k-1} \\dots a_1 a_0)_2$ represents the number:</p> $$(a_k a_{k-1} \\dots a_1 a_0)_2 = a_k \\cdot 2^k + a_{k-1} \\cdot 2^{k-1} + \\dots + a_1 \\cdot 2^1 + a_0 \\cdot 2^0.$$ <p>For instance the binary number $1101_2$ represents the number $13$:</p> $$\\begin{align} 1101_2 &amp;= 1 \\cdot 2^3 + 1 \\cdot 2^2 + 0 \\cdot 2^1 + 1 \\cdot 2^0 \\\\        &amp;= 1\\cdot 8 + 1 \\cdot 4 + 0 \\cdot 2 + 1 \\cdot 1 = 13 \\end{align}$$ <p>Computers represent integers as binary numbers. Positive integers (both signed and unsigned) are just represented with their binary digits, and negative signed numbers (which can be positive and negative) are usually represented with the Two's complement.</p> <pre><code>unsigned int unsigned_number = 13;\nassert(unsigned_number == 0b1101);\n\nint positive_signed_number = 13;\nassert(positive_signed_number == 0b1101);\n\nint negative_signed_number = -13;\nassert(negative_signed_number == 0b1111'1111'1111'1111'1111'1111'1111'0011);\n</code></pre> <p>CPUs are very fast manipulating those bits with specific operations. For some problems we can take these binary number representations to our advantage, and speed up the execution time. And for some problems (typically in combinatorics or dynamic programming) where we want to track which objects we already picked from a given set of objects, we can just use an large enough integer where each digit represents an object and depending on if we pick or drop the object we set or clear the digit.</p>","tags":["Original"]},{"location":"algebra/bit-manipulation.html#bit-operators","title":"Bit operators","text":"<p>All those introduced operators are instant (same speed as an addition) on a CPU for fixed-length integers.</p>","tags":["Original"]},{"location":"algebra/bit-manipulation.html#bitwise-operators","title":"Bitwise operators","text":"<ul> <li> <p>$\\&amp;$ : The bitwise AND operator compares each bit of its first operand with the corresponding bit of its second operand.      If both bits are 1, the corresponding result bit is set to 1. Otherwise, the corresponding result bit is set to 0.</p> </li> <li> <p>$|$ : The bitwise inclusive OR operator compares each bit of its first operand with the corresponding bit of its second operand.     If one of the two bits is 1, the corresponding result bit is set to 1. Otherwise, the corresponding result bit is set to 0.</p> </li> <li> <p>$\\wedge$ : The bitwise exclusive OR (XOR) operator compares each bit of its first operand with the corresponding bit of its second operand.     If one bit is 0 and the other bit is 1, the corresponding result bit is set to 1. Otherwise, the corresponding result bit is set to 0.</p> </li> <li> <p>$\\sim$ : The bitwise complement (NOT) operator flips each bit of a number, if a bit is set the operator will clear it, if it is cleared the operator sets it.</p> </li> </ul> <p>Examples:</p> <pre><code>n         = 01011000\nn-1       = 01010111\n--------------------\nn &amp; (n-1) = 01010000\n</code></pre> <pre><code>n         = 01011000\nn-1       = 01010111\n--------------------\nn | (n-1) = 01011111\n</code></pre> <pre><code>n         = 01011000\nn-1       = 01010111\n--------------------\nn ^ (n-1) = 00001111\n</code></pre> <pre><code>n         = 01011000\n--------------------\n~n        = 10100111\n</code></pre>","tags":["Original"]},{"location":"algebra/bit-manipulation.html#shift-operators","title":"Shift operators","text":"<p>There are two operators for shifting bits.</p> <ul> <li> <p>$\\gg$ Shifts a number to the right by removing the last few binary digits of the number.     Each shift by one represents an integer division by 2, so a right shift by $k$ represents an integer division by $2^k$.</p> <p>E.g. $5 \\gg 2 = 101_2 \\gg 2 = 1_2 = 1$ which is the same as $\\frac{5}{2^2} = \\frac{5}{4} = 1$. For a computer though shifting some bits is a lot faster than doing divisions.</p> </li> <li> <p>$\\ll$ Shifts a number to left by appending zero digits.     In similar fashion to a right shift by $k$, a left shift by $k$ represents a multiplication by $2^k$.</p> <p>E.g. $5 \\ll 3 = 101_2 \\ll 3 = 101000_2 = 40$ which is the same as $5 \\cdot 2^3 = 5 \\cdot 8 = 40$.</p> <p>Notice however that for a fixed-length integer that means dropping the most left digits, and if you shift too much you end up with the number $0$.</p> </li> </ul>","tags":["Original"]},{"location":"algebra/bit-manipulation.html#useful-tricks","title":"Useful tricks","text":"","tags":["Original"]},{"location":"algebra/bit-manipulation.html#setflipclear-a-bit","title":"Set/flip/clear a bit","text":"<p>Using bitwise shifts and some basic bitwise operations we can easily set, flip or clear a bit. $1 \\ll x$ is a number with only the $x$-th bit set, while $\\sim(1 \\ll x)$ is a number with all bits set except the $x$-th bit.</p> <ul> <li>$n ~|~ (1 \\ll x)$ sets the $x$-th bit in the number $n$</li> <li>$n ~\\wedge~ (1 \\ll x)$ flips the $x$-th bit in the number $n$</li> <li>$n ~\\&amp;~ \\sim(1 \\ll x)$ clears the $x$-th bit in the number $n$</li> </ul>","tags":["Original"]},{"location":"algebra/bit-manipulation.html#check-if-a-bit-is-set","title":"Check if a bit is set","text":"<p>The value of the $x$-th bit can be checked by shifting the number $x$ positions to the right, so that the $x$-th bit is at the unit place, after which we can extract it by performing a bitwise &amp; with 1.</p> <pre><code>bool is_set(unsigned int number, int x) {\n    return (number &gt;&gt; x) &amp; 1;\n}\n</code></pre>","tags":["Original"]},{"location":"algebra/bit-manipulation.html#check-if-the-number-is-divisible-by-a-power-of-2","title":"Check if the number is divisible by a power of 2","text":"<p>Using the and operation, we can check if a number $n$ is even because $n ~\\&amp;~ 1 = 0$ if $n$ is even, and $n ~\\&amp;~ 1 = 1$ if $n$ is odd. More generally, $n$ is divisible by $2^{k}$ exactly when $n ~\\&amp;~ (2^{k} \u2212 1) = 0$.</p> <pre><code>bool isDivisibleByPowerOf2(int n, int k) {\n    int powerOf2 = 1 &lt;&lt; k;\n    return (n &amp; (powerOf2 - 1)) == 0;\n}\n</code></pre> <p>We can calculate $2^{k}$ by left shifting 1 by $k$ positions. The trick works, because $2^k - 1$ is a number that consists of exactly $k$ ones. And a number that is divisible by $2^k$ must have zero digits in those places.</p>","tags":["Original"]},{"location":"algebra/bit-manipulation.html#check-if-an-integer-is-a-power-of-2","title":"Check if an integer is a power of 2","text":"<p>A power of two is a number that has only a single bit in it (e.g. $32 = 0010~0000_2$), while the predecessor of that number has that digit not set and all the digits after it set ($31 = 0001~1111_2$). So the bitwise AND of a number with it's predecessor will always be 0, as they don't have any common digits set. You can easily check that this only happens for the the power of twos and for the number $0$ which already has no digit set.</p> <pre><code>bool isPowerOfTwo(unsigned int n) {\n    return n &amp;&amp; !(n &amp; (n - 1));\n}\n</code></pre>","tags":["Original"]},{"location":"algebra/bit-manipulation.html#clear-the-right-most-set-bit","title":"Clear the right-most set bit","text":"<p>The expression $n ~\\&amp;~ (n-1)$ can be used to turn off the rightmost set bit of a number $n$. This works because the expression $n-1$ flips all bits after the rightmost set bit of $n$, including the rightmost set bit. So all those digits are different from the original number, and by doing a bitwise AND they are all set to 0, giving you the original number $n$ with the rightmost set bit flipped.</p> <p>For example, consider the number $52 = 0011~0100_2$:</p> <pre><code>n         = 00110100\nn-1       = 00110011\n--------------------\nn &amp; (n-1) = 00110000\n</code></pre>","tags":["Original"]},{"location":"algebra/bit-manipulation.html#brian-kernighans-algorithm","title":"Brian Kernighan's algorithm","text":"<p>We can count the number of bits set with the above expression.</p> <p>The idea is to consider only the set bits of an integer by turning off its rightmost set bit (after counting it), so the next iteration of the loop considers the Next Rightmost bit.</p> <pre><code>int countSetBits(int n)\n{\n    int count = 0;\n    while (n)\n    {\n        n = n &amp; (n - 1);\n        count++;\n    }\n    return count;\n}\n</code></pre>","tags":["Original"]},{"location":"algebra/bit-manipulation.html#count-set-bits-upto-n","title":"Count set bits upto $n$","text":"<p>To count the number of set bits of all numbers upto the number $n$ (inclusive), we can run the Brian Kernighan's algorithm on all numbers upto $n$. But this will result in a \"Time Limit Exceeded\" in contest submissions. </p> <p>We can use the fact that for numbers upto $2^x$ (i.e. from $1$ to $2^x - 1$) there are $x \\cdot 2^{x-1}$ set bits. This can be visualised as follows. <pre><code>0 -&gt;   0 0 0 0\n1 -&gt;   0 0 0 1\n2 -&gt;   0 0 1 0\n3 -&gt;   0 0 1 1\n4 -&gt;   0 1 0 0\n5 -&gt;   0 1 0 1\n6 -&gt;   0 1 1 0\n7 -&gt;   0 1 1 1\n8 -&gt;   1 0 0 0\n</code></pre></p> <p>We can see that the all the columns except the leftmost have $4$ (i.e. $2^2$) set bits each, i.e. upto the number $2^3 - 1$, the number of set bits is $3 \\cdot 2^{3-1}$.</p> <p>With the new knowledge in hand we can come up with the following algorithm:</p> <ul> <li>Find the highest power of $2$ that is lesser than or equal to the given number. Let this number be $x$.</li> <li>Calculate the number of set bits from $1$ to $2^x - 1$ by using the formula $x \\cdot 2^{x-1}$.</li> <li>Count the no. of set bits in the most significant bit from $2^x$ to $n$ and add it.</li> <li>Subtract $2^x$ from $n$ and repeat the above steps using the new $n$.</li> </ul> <pre><code>int countSetBits(int n) {\n        int count = 0;\n        while (n &gt; 0) {\n            int x = std::bit_width(n) - 1;\n            count += x &lt;&lt; (x - 1);\n            n -= 1 &lt;&lt; x;\n            count += n + 1;\n        }\n        return count;\n}\n</code></pre>","tags":["Original"]},{"location":"algebra/bit-manipulation.html#additional-tricks","title":"Additional tricks","text":"<ul> <li>$n ~\\&amp;~ (n + 1)$ clears all trailing ones: $0011~0111_2 \\rightarrow 0011~0000_2$.</li> <li>$n ~|~ (n + 1)$ sets the last cleared bit: $0011~0101_2 \\rightarrow 0011~0111_2$.</li> <li>$n ~\\&amp;~ -n$ extracts the last set bit: $0011~0100_2 \\rightarrow 0000~0100_2$.</li> </ul> <p>Many more can be found in the book Hacker's Delight.</p>","tags":["Original"]},{"location":"algebra/bit-manipulation.html#language-and-compiler-support","title":"Language and compiler support","text":"<p>C++ supports some of those operations since C++20 via the bit standard library:</p> <ul> <li><code>has_single_bit</code>: checks if the number is a power of two</li> <li><code>bit_ceil</code> / <code>bit_floor</code>: round up/down to the next power of two</li> <li><code>rotl</code> / <code>rotr</code>: rotate the bits in the number</li> <li><code>countl_zero</code> / <code>countr_zero</code> / <code>countl_one</code> / <code>countr_one</code>: count the leading/trailing zeros/ones</li> <li><code>popcount</code>: count the number of set bits</li> </ul> <p>Additionally, there are also predefined functions in some compilers that help working with bits. E.g. GCC defines a list at Built-in Functions Provided by GCC that also work in older versions of C++:</p> <ul> <li><code>__builtin_popcount(unsigned int)</code> returns the number of set bits (<code>__builtin_popcount(0b0001'0010'1100) == 4</code>)</li> <li><code>__builtin_ffs(int)</code> finds the index of the first (most right) set bit (<code>__builtin_ffs(0b0001'0010'1100) == 3</code>)</li> <li><code>__builtin_clz(unsigned int)</code> the count of leading zeros (<code>__builtin_clz(0b0001'0010'1100) == 23</code>)</li> <li><code>__builtin_ctz(unsigned int)</code> the count of trailing zeros (<code>__builtin_ctz(0b0001'0010'1100) == 2</code>)</li> <li><code>__builtin_parity(x)</code> the parity (even or odd) of the number of ones in the bit representation</li> </ul> <p>Note that some of the operations (both the C++20 functions and the Compiler Built-in ones) might be quite slow in GCC if you don't enable a specific compiler target with <code>#pragma GCC target(\"popcnt\")</code>.</p>","tags":["Original"]},{"location":"algebra/bit-manipulation.html#practice-problems","title":"Practice Problems","text":"<ul> <li>Codeforces - Raising Bacteria</li> <li>Codeforces - Fedor and New Game</li> <li>Codeforces - And Then There Were K</li> </ul>","tags":["Original"]},{"location":"algebra/chinese-remainder-theorem.html","title":"Chinese Remainder Theorem","text":"<p>The Chinese Remainder Theorem (which will be referred to as CRT in the rest of this article) was discovered by Chinese mathematician Sun Zi.</p>","tags":["Translated"]},{"location":"algebra/chinese-remainder-theorem.html#formulation","title":"Formulation","text":"<p>Let $m = m_1 \\cdot m_2 \\cdots m_k$, where $m_i$ are pairwise coprime. In addition to $m_i$, we are also given a system of congruences</p> $$\\left\\{\\begin{array}{rcl}     a &amp; \\equiv &amp; a_1 \\pmod{m_1} \\\\     a &amp; \\equiv &amp; a_2 \\pmod{m_2} \\\\       &amp; \\vdots &amp; \\\\     a &amp; \\equiv &amp; a_k \\pmod{m_k} \\end{array}\\right.$$ <p>where $a_i$ are some given constants. The original form of CRT then states that the given system of congruences always has one and exactly one solution modulo $m$.</p> <p>E.g. the system of congruences</p> $$\\left\\{\\begin{array}{rcl}     a &amp; \\equiv &amp; 2 \\pmod{3} \\\\     a &amp; \\equiv &amp; 3 \\pmod{5} \\\\     a &amp; \\equiv &amp; 2 \\pmod{7} \\end{array}\\right.$$ <p>has the solution $23$ modulo $105$, because $23 \\bmod{3} = 2$, $23 \\bmod{5} = 3$, and $23 \\bmod{7} = 2$. We can write down every solution as $23 + 105\\cdot k$ for $k \\in \\mathbb{Z}$.</p>","tags":["Translated"]},{"location":"algebra/chinese-remainder-theorem.html#corollary","title":"Corollary","text":"<p>A consequence of the CRT is that the equation</p> $$x \\equiv a \\pmod{m}$$ <p>is equivalent to the system of equations</p> $$\\left\\{\\begin{array}{rcl}     x &amp; \\equiv &amp; a_1 \\pmod{m_1} \\\\       &amp; \\vdots &amp; \\\\     x &amp; \\equiv &amp; a_k \\pmod{m_k} \\end{array}\\right.$$ <p>(As above, assume that $m = m_1 m_2 \\cdots m_k$ and $m_i$ are pairwise coprime).</p>","tags":["Translated"]},{"location":"algebra/chinese-remainder-theorem.html#solution-for-two-moduli","title":"Solution for Two Moduli","text":"<p>Consider a system of two equations for coprime $m_1, m_2$:</p> $$ \\left\\{\\begin{align}     a &amp;\\equiv a_1 \\pmod{m_1} \\\\     a &amp;\\equiv a_2 \\pmod{m_2} \\\\ \\end{align}\\right. $$ <p>We want to find a solution for $a \\pmod{m_1 m_2}$. Using the Extended Euclidean Algorithm we can find B\u00e9zout coefficients $n_1, n_2$ such that</p> $$n_1 m_1 + n_2 m_2 = 1.$$ <p>In fact $n_1$ and $n_2$ are just the modular inverses of $m_1$ and $m_2$ modulo $m_2$ and $m_1$. We have $n_1 m_1 \\equiv 1 \\pmod{m_2}$ so $n_1 \\equiv m_1^{-1} \\pmod{m_2}$, and vice versa $n_2 \\equiv m_2^{-1} \\pmod{m_1}$. </p> <p>With those two coefficients we can define a solution:</p> $$a = a_1 n_2 m_2 + a_2 n_1 m_1 \\bmod{m_1 m_2}$$ <p>It's easy to verify that this is indeed a solution by computing $a \\bmod{m_1}$ and $a \\bmod{m_2}$.</p> $$ \\begin{array}{rcll} a &amp; \\equiv &amp; a_1 n_2 m_2 + a_2 n_1 m_1 &amp; \\pmod{m_1}\\\\   &amp; \\equiv &amp; a_1 (1 - n_1 m_1) + a_2 n_1 m_1 &amp; \\pmod{m_1}\\\\   &amp; \\equiv &amp; a_1 - a_1 n_1 m_1 + a_2 n_1 m_1 &amp; \\pmod{m_1}\\\\   &amp; \\equiv &amp; a_1 &amp; \\pmod{m_1} \\end{array} $$ <p>Notice, that the Chinese Remainder Theorem also guarantees, that only 1 solution exists modulo $m_1 m_2$. This is also easy to prove.</p> <p>Lets assume that you have two different solutions $x$ and $y$. Because $x \\equiv a_i \\pmod{m_i}$ and $y \\equiv a_i \\pmod{m_i}$, it follows that $x \u2212 y \\equiv 0 \\pmod{m_i}$ and therefore $x \u2212 y \\equiv 0 \\pmod{m_1 m_2}$ or equivalently $x \\equiv y \\pmod{m_1 m_2}$. So $x$ and $y$ are actually the same solution.</p>","tags":["Translated"]},{"location":"algebra/chinese-remainder-theorem.html#solution-for-general-case","title":"Solution for General Case","text":"","tags":["Translated"]},{"location":"algebra/chinese-remainder-theorem.html#inductive-solution","title":"Inductive Solution","text":"<p>As $m_1 m_2$ is coprime to $m_3$, we can inductively repeatedly apply the solution for two moduli for any number of moduli. First you compute $b_2 := a \\pmod{m_1 m_2}$ using the first two congruences, then you can compute $b_3 := a \\pmod{m_1 m_2 m_3}$ using the congruences $a \\equiv b_2 \\pmod{m_1 m_2}$ and $a \\equiv a_3 \\pmod {m_3}$, etc.</p>","tags":["Translated"]},{"location":"algebra/chinese-remainder-theorem.html#direct-construction","title":"Direct Construction","text":"<p>A direct construction similar to Lagrange interpolation is possible.</p> <p>Let $M_i := \\prod_{i \\neq j} m_j$, the product of all moduli but $m_i$, and $N_i$ the modular inverses $N_i := M_i^{-1} \\bmod{m_i}$. Then a solution to the system of congruences is:</p> $$a \\equiv \\sum_{i=1}^k a_i M_i N_i \\pmod{m_1 m_2 \\cdots m_k}$$ <p>We can check this is indeed a solution, by computing $a \\bmod{m_i}$ for all $i$. Because $M_j$ is a multiple of $m_i$ for $i \\neq j$ we have</p> $$\\begin{array}{rcll} a &amp; \\equiv &amp; \\sum_{j=1}^k a_j M_j N_j &amp; \\pmod{m_i} \\\\   &amp; \\equiv &amp; a_i M_i N_i              &amp; \\pmod{m_i} \\\\   &amp; \\equiv &amp; a_i M_i M_i^{-1}         &amp; \\pmod{m_i} \\\\   &amp; \\equiv &amp; a_i                      &amp; \\pmod{m_i} \\end{array}$$","tags":["Translated"]},{"location":"algebra/chinese-remainder-theorem.html#implementation","title":"Implementation","text":"<pre><code>struct Congruence {\n    long long a, m;\n};\n\nlong long chinese_remainder_theorem(vector&lt;Congruence&gt; const&amp; congruences) {\n    long long M = 1;\n    for (auto const&amp; congruence : congruences) {\n        M *= congruence.m;\n    }\n\n    long long solution = 0;\n    for (auto const&amp; congruence : congruences) {\n        long long a_i = congruence.a;\n        long long M_i = M / congruence.m;\n        long long N_i = mod_inv(M_i, congruence.m);\n        solution = (solution + a_i * M_i % M * N_i) % M;\n    }\n    return solution;\n}\n</code></pre>","tags":["Translated"]},{"location":"algebra/chinese-remainder-theorem.html#solution-for-not-coprime-moduli","title":"Solution for not coprime moduli","text":"<p>As mentioned, the algorithm above only works for coprime moduli $m_1, m_2, \\dots m_k$.</p> <p>In the not coprime case, a system of congruences has exactly one solution modulo $\\text{lcm}(m_1, m_2, \\dots, m_k)$, or has no solution at all.</p> <p>E.g. in the following system, the first congruence implies that the solution is odd, and the second congruence implies that the solution is even. It's not possible that a number is both odd and even, therefore there is clearly no solution.</p> $$\\left\\{\\begin{align}     a &amp; \\equiv 1 \\pmod{4} \\\\     a &amp; \\equiv 2 \\pmod{6} \\end{align}\\right.$$ <p>It is pretty simple to determine if a system has a solution. And if it has one, we can use the original algorithm to solve a slightly modified system of congruences.</p> <p>A single congruence $a \\equiv a_i \\pmod{m_i}$ is equivalent to the system of congruences $a \\equiv a_i \\pmod{p_j^{n_j}}$ where $p_1^{n_1} p_2^{n_2}\\cdots p_k^{n_k}$ is the prime factorization of $m_i$.</p> <p>With this fact, we can modify the system of congruences into a system, that only has prime powers as moduli. E.g. the above system of congruences is equivalent to:</p> $$\\left\\{\\begin{array}{ll}     a \\equiv 1          &amp; \\pmod{4} \\\\     a \\equiv 2 \\equiv 0 &amp; \\pmod{2} \\\\     a \\equiv 2          &amp; \\pmod{3} \\end{array}\\right.$$ <p>Because originally some moduli had common factors, we will get some congruences moduli based on the same prime, however possibly with different prime powers.</p> <p>You can observe, that the congruence with the highest prime power modulus will be the strongest congruence of all congruences based on the same prime number. Either it will give a contradiction with some other congruence, or it will imply already all other congruences.</p> <p>In our case, the first congruence $a \\equiv 1 \\pmod{4}$ implies $a \\equiv 1 \\pmod{2}$, and therefore contradicts the second congruence $a \\equiv 0 \\pmod{2}$. Therefore this system of congruences has no solution.</p> <p>If there are no contradictions, then the system of equation has a solution. We can ignore all congruences except the ones with the highest prime power moduli. These moduli are now coprime, and therefore we can solve this one with the algorithm discussed in the sections above.</p> <p>E.g. the following system has a solution modulo $\\text{lcm}(10, 12) = 60$.</p> $$\\left\\{\\begin{align}     a &amp; \\equiv 3 \\pmod{10} \\\\     a &amp; \\equiv 5 \\pmod{12} \\end{align}\\right.$$ <p>The system of congruence is equivalent to the system of congruences:</p> $$\\left\\{\\begin{align}     a &amp; \\equiv 3 \\equiv 1 \\pmod{2} \\\\     a &amp; \\equiv 3 \\equiv 3 \\pmod{5} \\\\     a &amp; \\equiv 5 \\equiv 1 \\pmod{4} \\\\     a &amp; \\equiv 5 \\equiv 2 \\pmod{3} \\end{align}\\right.$$ <p>The only congruence with same prime modulo are $a \\equiv 1 \\pmod{4}$ and $a \\equiv 1 \\pmod{2}$. The first one already implies the second one, so we can ignore the second one, and solve the following system with coprime moduli instead:</p> $$\\left\\{\\begin{align}     a &amp; \\equiv 3 \\equiv 3 \\pmod{5} \\\\     a &amp; \\equiv 5 \\equiv 1 \\pmod{4} \\\\     a &amp; \\equiv 5 \\equiv 2 \\pmod{3} \\end{align}\\right.$$ <p>It has the solution $53 \\pmod{60}$, and indeed $53 \\bmod{10} = 3$ and $53 \\bmod{12} = 5$.</p>","tags":["Translated"]},{"location":"algebra/chinese-remainder-theorem.html#garners-algorithm","title":"Garner's Algorithm","text":"<p>Another consequence of the CRT is that we can represent big numbers using an array of small integers.</p> <p>Instead of doing a lot of computations with very large numbers numbers, which might be expensive (think of doing divisions with 1000-digit numbers), you can pick a couple of coprime moduli and represent the large number as a system of congruences, and perform all operations on the system of equations. Any number $a$ less than $m_1 m_2 \\cdots m_k$ can be represented as an array $a_1, \\ldots, a_k$, where $a \\equiv a_i \\pmod{m_i}$.</p> <p>By using the above algorithm, you can again reconstruct the large number whenever you need it.</p> <p>Alternatively you can represent the number in the mixed radix representation:</p> $$a = x_1 + x_2 m_1 + x_3 m_1 m_2 + \\ldots + x_k m_1 \\cdots m_{k-1} \\text{ with }x_i \\in [0, m_i)$$ <p>Garner's algorithm, which is discussed in the dedicated article Garner's algorithm, computes the coefficients $x_i$. And with those coefficients you can restore the full number.</p>","tags":["Translated"]},{"location":"algebra/chinese-remainder-theorem.html#practice-problems","title":"Practice Problems:","text":"<ul> <li>Google Code Jam - Golf Gophers</li> <li>Hackerrank - Number of sequences</li> <li>Codeforces - Remainders Game</li> </ul>","tags":["Translated"]},{"location":"algebra/continued-fractions.html","title":"Continued fractions","text":"","tags":["Original"]},{"location":"algebra/continued-fractions.html#continued-fractions","title":"Continued fractions","text":"<p>Continued fraction is a representation of a real number as a specific convergent sequence of rational numbers. They are useful in competitive programming because they are easy to compute and can be efficiently used to find the best possible rational approximation of the underlying real number (among all numbers whose denominator doesn't exceed a given value).</p> <p>Besides that, continued fractions are closely related to Euclidean algorithm which makes them useful in a bunch of number-theoretical problems.</p>","tags":["Original"]},{"location":"algebra/continued-fractions.html#continued-fraction-representation","title":"Continued fraction representation","text":"<p>Definition</p> <p>Let $a_0, a_1, \\dots, a_k \\in \\mathbb Z$ and $a_1, a_2, \\dots, a_k \\geq 1$. Then the expression</p> $$r=a_0 + \\frac{1}{a_1 + \\frac{1}{\\dots + \\frac{1}{a_k}}},$$ <p>is called the continued fraction representation of the rational number $r$ and is denoted shortly as $r=[a_0;a_1,a_2,\\dots,a_k]$.</p> Example <p>Let $r = \\frac{5}{3}$. There are two ways to represent it as a continued fraction:</p> $$ \\begin{align} r = [1;1,1,1] &amp;= 1+\\frac{1}{1+\\frac{1}{1+\\frac{1}{1}}},\\\\ r = [1;1,2] &amp;= 1+\\frac{1}{1+\\frac{1}{2}}. \\end{align} $$ <p>It can be proven that any rational number can be represented as a continued fraction in exactly $2$ ways:</p> $$r = [a_0;a_1,\\dots,a_k,1] = [a_0;a_1,\\dots,a_k+1].$$ <p>Moreover, the length $k$ of such continued fraction is estimated as $k = O(\\log \\min(p, q))$ for $r=\\frac{p}{q}$.</p> <p>The reasoning behind this will be clear once we delve into the details of the continued fraction construction.</p> <p>Definition</p> <p>Let $a_0,a_1,a_2, \\dots$ be an integer sequence such that $a_1, a_2, \\dots \\geq 1$. Let $r_k = [a_0; a_1, \\dots, a_k]$. Then the expression</p> $$r = a_0 + \\frac{1}{a_1 + \\frac{1}{a_2+\\dots}} = \\lim\\limits_{k \\to \\infty} r_k.$$ <p>is called the continued fraction representation of the irrational number $r$ and is denoted shortly as $r = [a_0;a_1,a_2,\\dots]$.</p> <p>Note that for $r=[a_0;a_1,\\dots]$ and integer $k$, it holds that $r+k = [a_0+k; a_1, \\dots]$.</p> <p>Another important observation is that $\\frac{1}{r}=[0;a_0, a_1, \\dots]$ when $a_0 &gt; 0$ and $\\frac{1}{r} = [a_1; a_2, \\dots]$ when $a_0 = 0$.</p> <p>Definition</p> <p>In the definition above, rational numbers $r_0, r_1, r_2, \\dots$ are called the convergents of $r$.</p> <p>Correspondingly, individual $r_k = [a_0; a_1, \\dots, a_k] = \\frac{p_k}{q_k}$ is called the $k$-th convergent of $r$.</p> Example <p>Consider $r = [1; 1, 1, 1, \\dots]$. It can be proven by induction that $r_k = \\frac{F_{k+2}}{F_{k+1}}$, where $F_k$ is the Fibonacci sequence defined as $F_0 = 0$, $F_1 = 1$ and $F_{k} = F_{k-1} + F_{k-2}$. From the Binet's formula, it is known that</p> $$r_k = \\frac{\\phi^{k+2} - \\psi^{k+2}}{\\phi^{k+1} - \\psi^{k+1}},$$ <p>where $\\phi = \\frac{1+\\sqrt{5}}{2} \\approx 1.618$ is the golden ratio and $\\psi = \\frac{1-\\sqrt{5}}{2} = -\\frac{1}{\\phi} \\approx -0.618$. Thus,</p> $$r = 1+\\frac{1}{1+\\frac{1}{1+\\dots}}=\\lim\\limits_{k \\to \\infty} r_k = \\phi = \\frac{1+\\sqrt{5}}{2}.$$ <p>Note that in this specific case, an alternative way to find $r$ would be to solve the equation</p> $$r = 1+\\frac{1}{r} \\implies r^2 = r + 1. $$ <p>Definition</p> <p>Let $r_k = [a_0; a_1, \\dots, a_{k-1}, a_k]$. The numbers $[a_0; a_1, \\dots, a_{k-1}, t]$ for $1 \\leq t \\leq a_k$ are called semiconvergents.</p> <p>We will typically refer to (semi)convergents that are greater than $r$ as upper (semi)convergents and to those that are less than $r$ as lower (semi)convergents.</p> <p>Definition</p> <p>Complementary to convergents, we define the complete quotients as $s_k = [a_k; a_{k+1}, a_{k+2}, \\dots]$.</p> <p>Correspondingly, we will call an individual $s_k$ the $k$-th complete quotient of $r$.</p> <p>From the definitions above, one can conclude that $s_k \\geq 1$ for $k \\geq 1$.</p> <p>Treating $[a_0; a_1, \\dots, a_k]$ as a formal algebraic expression and allowing arbitrary real numbers instead of $a_i$, we obtain</p> $$r = [a_0; a_1, \\dots, a_{k-1}, s_k].$$ <p>In particular, $r = [s_0] = s_0$. On the other hand, we can express $s_k$ as</p> $$s_k = [a_k; s_{k+1}] = a_k + \\frac{1}{s_{k+1}},$$ <p>meaning that we can compute $a_k = \\lfloor s_k \\rfloor$ and $s_{k+1} = (s_k - a_k)^{-1}$ from $s_k$.</p> <p>The sequence $a_0, a_1, \\dots$ is well-defined unless $s_k=a_k$ which only happens when $r$ is a rational number.</p> <p>Thus the continued fraction representation is uniquely defined for any irrational number $r$.</p>","tags":["Original"]},{"location":"algebra/continued-fractions.html#implementation","title":"Implementation","text":"<p>In the code snippets we will mostly assume finite continued fractions.</p> <p>From $s_k$, the transition to $s_{k+1}$ looks like</p> $$s_k =\\left\\lfloor s_k \\right\\rfloor + \\frac{1}{s_{k+1}}.$$ <p>From this expression, the next complete quotient $s_{k+1}$ is obtained as</p> $$s_{k+1} = \\left(s_k-\\left\\lfloor s_k\\right\\rfloor\\right)^{-1}.$$ <p>For $s_k=\\frac{p}{q}$ it means that</p> $$ s_{k+1} = \\left(\\frac{p}{q}-\\left\\lfloor \\frac{p}{q} \\right\\rfloor\\right)^{-1} = \\frac{q}{p-q\\cdot \\lfloor \\frac{p}{q} \\rfloor} = \\frac{q}{p \\bmod q}. $$ <p>Thus, the computation of a continued fraction representation for $r=\\frac{p}{q}$ follows the steps of the Euclidean algorithm for $p$ and $q$.</p> <p>From this also follows that $\\gcd(p_k, q_k) = 1$ for $\\frac{p_k}{q_k} = [a_0; a_1, \\dots, a_k]$. Hence, convergents are always irreducible.</p> C++Python <pre><code>auto fraction(int p, int q) {\n    vector&lt;int&gt; a;\n    while(q) {\n        a.push_back(p / q);\n        tie(p, q) = make_pair(q, p % q);\n    }\n    return a;\n}\n</code></pre> <pre><code>def fraction(p, q):\n    a = []\n    while q:\n        a.append(p // q)\n        p, q = q, p % q\n    return a\n</code></pre>","tags":["Original"]},{"location":"algebra/continued-fractions.html#key-results","title":"Key results","text":"<p>To provide some motivation for further study of continued fraction, we give some key facts now.</p> Recurrence <p>For the convergents $r_k = \\frac{p_k}{q_k}$, the following recurrence stands, allowing their fast computation:</p> $$\\frac{p_k}{q_k}=\\frac{a_k p_{k-1} + p_{k-2}}{a_k q_{k-1} + q_{k-2}},$$ <p>where $\\frac{p_{-1}}{q_{-1}}=\\frac{1}{0}$ and $\\frac{p_{-2}}{q_{-2}}=\\frac{0}{1}$.</p> Deviations <p>The deviation of $r_k = \\frac{p_k}{q_k}$ from $r$ can be generally estimated as</p> $$\\left|\\frac{p_k}{q_k}-r\\right| \\leq \\frac{1}{q_k q_{k+1}} \\leq \\frac{1}{q_k^2}.$$ <p>Multiplying both sides with $q_k$, we obtain alternate estimation:</p> $$|p_k - q_k r| \\leq \\frac{1}{q_{k+1}}.$$ <p>From the recurrence above it follows that $q_k$ grows at least as fast as Fibonacci numbers.</p> <p>On the picture below you may see the visualization of how convergents $r_k$ approach $r=\\frac{1+\\sqrt 5}{2}$:</p> <p></p> <p>$r=\\frac{1+\\sqrt 5}{2}$ is depicted by blue dotted line. Odd convergents approach it from above and even convergents approach it from below.</p> Lattice hulls <p>Consider convex hulls of points above and below the line $y=rx$.</p> <p>Odd convergents $(q_k;p_k)$ are the vertices of the upper hull, while the even convergents $(q_k;p_k)$ are the vertices of the bottom hull.</p> <p>All integers vertices on the hulls are obtained as $(q;p)$ such that</p> $$\\frac{p}{q} = \\frac{tp_{k-1} + p_{k-2}}{tq_{k-1} + q_{k-2}}$$ <p>for integer $0 \\leq t \\leq a_k$. In other words, the set of lattice points on the hulls corresponds to the set of semiconvergents.</p> <p>On the picture below, you may see the convergents and semiconvergents (intermediate gray points) of $r=\\frac{9}{7}$.</p> <p></p> Best approximations <p>Let $\\frac{p}{q}$ be the fraction to minimize $\\left|r-\\frac{p}{q}\\right|$ subject to $q \\leq x$ for some $x$.</p> <p>Then $\\frac{p}{q}$ is a semiconvergent of $r$.</p> <p>The last fact allows to find the best rational approximations of $r$ by checking its semiconvergents.</p> <p>Below you will find the further explanation and a bit of intuition and interpretation for these facts.</p>","tags":["Original"]},{"location":"algebra/continued-fractions.html#convergents","title":"Convergents","text":"<p>Let's take a closer look at the convergents that were defined earlier. For $r=[a_0, a_1, a_2, \\dots]$, its convergents are</p> $$\\begin{gather} r_0=[a_0],\\\\r_1=[a_0, a_1],\\\\ \\dots,\\\\ r_k=[a_0, a_1, \\dots, a_k]. \\end{gather}$$ <p>Convergents are the core concept of continued fractions, so it is important to study their properties.</p> <p>For the number $r$, its $k$-th convergent $r_k = \\frac{p_k}{q_k}$ can be computed as</p> $$r_k = \\frac{P_k(a_0,a_1,\\dots,a_k)}{P_{k-1}(a_1,\\dots,a_k)} = \\frac{a_k p_{k-1} + p_{k-2}}{a_k q_{k-1} + q_{k-2}},$$ <p>where $P_k(a_0,\\dots,a_k)$ is the continuant, a multivariate polynomial defined as</p> $$P_k(x_0,x_1,\\dots,x_k) = \\det \\begin{bmatrix} x_k &amp; 1 &amp; 0 &amp; \\dots &amp; 0 \\\\ -1 &amp; x_{k-1} &amp; 1 &amp; \\dots &amp; 0 \\\\ 0 &amp; -1 &amp; x_2 &amp; . &amp; \\vdots \\\\ \\vdots &amp; \\vdots &amp; . &amp; \\ddots &amp; 1 \\\\ 0 &amp; 0 &amp; \\dots &amp; -1 &amp; x_0 \\end{bmatrix}_{\\textstyle .}$$ <p>Thus, $r_k$ is a weighted mediant of $r_{k-1}$ and $r_{k-2}$.</p> <p>For consistency, two additional convergents $r_{-1} = \\frac{1}{0}$ and $r_{-2} = \\frac{0}{1}$ are defined.</p> Detailed explanation <p>The numerator and the denominator of $r_k$ can be seen as multivariate polynomials of $a_0, a_1, \\dots, a_k$:</p> $$r_k = \\frac{P_k(a_0, a_1, \\dots, a_k)}{Q_k(a_0,a_1, \\dots, a_k)}.$$ <p>From the definition of convergents,</p> $$r_k = a_0 + \\frac{1}{[a_1;a_2,\\dots, a_k]}= a_0 + \\frac{Q_{k-1}(a_1, \\dots, a_k)}{P_{k-1}(a_1, \\dots, a_k)} = \\frac{a_0 P_{k-1}(a_1, \\dots, a_k) + Q_{k-1}(a_1, \\dots, a_k)}{P_{k-1}(a_1, \\dots, a_k)}.$$ <p>From this follows $Q_k(a_0, \\dots, a_k) = P_{k-1}(a_1, \\dots, a_k)$. This yields the relation</p> $$P_k(a_0, \\dots, a_k) = a_0 P_{k-1}(a_1, \\dots, a_k) + P_{k-2}(a_2, \\dots, a_k).$$ <p>Initially, $r_0 = \\frac{a_0}{1}$ and $r_1 = \\frac{a_0 a_1 + 1}{a_1}$, thus</p> $$\\begin{align}P_0(a_0)&amp;=a_0,\\\\ P_1(a_0, a_1) &amp;= a_0 a_1 + 1.\\end{align}$$ <p>For consistency, it is convenient to define $P_{-1} = 1$ and $P_{-2}=0$ and formally say that $r_{-1} = \\frac{1}{0}$ and $r_{-2}=\\frac{0}{1}$.</p> <p>From numerical analysis, it is known that the determinant of an arbitrary tridiagonal matrix</p> $$T_k = \\det \\begin{bmatrix} a_0 &amp; b_0 &amp; 0 &amp; \\dots &amp; 0 \\\\ c_0 &amp; a_1 &amp; b_1 &amp; \\dots &amp; 0 \\\\ 0 &amp; c_1 &amp; a_2 &amp; . &amp; \\vdots \\\\ \\vdots &amp; \\vdots &amp; . &amp; \\ddots &amp; c_{k-1} \\\\ 0 &amp; 0 &amp; \\dots &amp; b_{k-1} &amp; a_k \\end{bmatrix}$$ <p>can be computed recursively as $T_k = a_k T_{k-1} - b_{k-1} c_{k-1} T_{k-2}$. Comparing it to $P_k$, we get a direct expression</p> $$P_k = \\det \\begin{bmatrix} x_k &amp; 1 &amp; 0 &amp; \\dots &amp; 0 \\\\ -1 &amp; x_{k-1} &amp; 1 &amp; \\dots &amp; 0 \\\\ 0 &amp; -1 &amp; x_2 &amp; . &amp; \\vdots \\\\ \\vdots &amp; \\vdots &amp; . &amp; \\ddots &amp; 1 \\\\ 0 &amp; 0 &amp; \\dots &amp; -1 &amp; x_0 \\end{bmatrix}_{\\textstyle .}$$ <p>This polynomial is also known as the continuant due to its close relation with continued fraction. The continuant won't change if the sequence on the main diagonal is reversed. This yields an alternative formula to compute it:</p> $$P_k(a_0, \\dots, a_k) = a_k P_{k-1}(a_0, \\dots, a_{k-1}) + P_{k-2}(a_0, \\dots, a_{k-2}).$$","tags":["Original"]},{"location":"algebra/continued-fractions.html#implementation_1","title":"Implementation","text":"<p>We will compute the convergents as a pair of sequences $p_{-2}, p_{-1}, p_0, p_1, \\dots, p_k$ and $q_{-2}, q_{-1}, q_0, q_1, \\dots, q_k$:</p> C++Python <pre><code>auto convergents(vector&lt;int&gt; a) {\n    vector&lt;int&gt; p = {0, 1};\n    vector&lt;int&gt; q = {1, 0};\n    for(auto it: a) {\n        p.push_back(p[p.size() - 1] * it + p[p.size() - 2]);\n        q.push_back(q[q.size() - 1] * it + q[q.size() - 2]);\n    }\n    return make_pair(p, q);\n}\n</code></pre> <pre><code>def convergents(a):\n    p = [0, 1]\n    q = [1, 0]\n    for it in a:\n        p.append(p[-1]*it + p[-2])\n        q.append(q[-1]*it + q[-2])\n    return p, q\n</code></pre>","tags":["Original"]},{"location":"algebra/continued-fractions.html#trees-of-continued-fractions","title":"Trees of continued fractions","text":"<p>There are two major ways to unite all possible continued fractions into useful tree structures.</p>","tags":["Original"]},{"location":"algebra/continued-fractions.html#stern-brocot-tree","title":"Stern-Brocot tree","text":"<p>The Stern-Brocot tree is a binary search tree that contains all distinct positive rational numbers.</p> <p>The tree generally looks as follows:</p> The image by Aaron Rotenberg is licensed under CC BY-SA 3.0 <p>Fractions $\\frac{0}{1}$ and $\\frac{1}{0}$ are \"virtually\" kept on the left and right sides of the tree correspondingly.</p> <p>Then the fraction in a node is a mediant $\\frac{a+c}{b+d}$ of two fractions $\\frac{a}{b}$ and $\\frac{c}{d}$ above it.</p> <p>The recurrence $\\frac{p_k}{q_k}=\\frac{a_k p_{k-1} + p_{k-2}}{a_k q_{k-1} + q_{k-2}}$ means that the continued fraction representation encodes the path to $\\frac{p_k}{q_k}$ in the tree. To find $[a_0; a_1, \\dots, a_{k}, 1]$, one has to make $a_0$ moves to the right, $a_1$ moves to the left, $a_2$ moves to the right and so on up to $a_k$.</p> <p>The parent of $[a_0; a_1, \\dots, a_k,1]$ then is the fraction obtained by taking one step back in the last used direction.</p> <p>In other words, it is $[a_0; a_1, \\dots, a_k-1,1]$ when $a_k &gt; 1$ and $[a_0; a_1, \\dots, a_{k-1}, 1]$ when $a_k = 1$.</p> <p>Thus the children of $[a_0; a_1, \\dots, a_k, 1]$ are $[a_0; a_1, \\dots, a_k+1, 1]$ and $[a_0; a_1, \\dots, a_k, 1, 1]$.</p> <p>Let's index the Stern-Brocot tree. The root vertex is assigned an index $1$. Then for a vertex $v$, the index of its left child is assigned by changing the leading bit of $v$ from $1$ to $10$ and for the right child, it's assigned by changing the leading bit from $1$ to $11$:</p> <p>In this indexing, the continued fraction representation of a rational number specifies the run-length encoding of its binary index.</p> <p>For $\\frac{5}{2} = [2;2] = [2;1,1]$, its index is $1011_2$ and its run-length encoding, considering bits in the ascending order, is $[2;1,1]$.</p> <p>Another example is $\\frac{2}{5} = [0;2,2]=[0;2,1,1]$, which has index $1100_2$ and its run-length encoding is, indeed, $[0;2,2]$.</p> <p>It is worth noting that the Stern-Brocot tree is, in fact, a treap. That is, it is a binary search tree by $\\frac{p}{q}$, but it is a heap by both $p$ and $q$.</p> <p>Comparing continued fractions</p> <p>You're given $A=[a_0; a_1, \\dots, a_n]$ and $B=[b_0; b_1, \\dots, b_m]$. Which fraction is smaller?</p> Solution <p>Assume for now that $A$ and $B$ are irrational and their continued fraction representations denote an infinite descent in the Stern-Brocot tree.</p> <p>As we already mentioned, in this representation $a_0$ denotes the number of right turns in the descent, $a_1$ denotes the number of consequent left turns and so on. Therefore, when we compare $a_k$ and $b_k$, if $a_k = b_k$ we should just move on to comparing $a_{k+1}$ and $b_{k+1}$. Otherwise, if we're at right descents, we should check if $a_k &lt; b_k$ and if we're at left descents, we should check if $a_k &gt; b_k$ to tell whether $A &lt; B$.</p> <p>In other words, for irrational $A$ and $B$ it would be $A &lt; B$ if and only if $(a_0, -a_1, a_2, -a_3, \\dots) &lt; (b_0, -b_1, b_2, -b_3, \\dots)$ with lexicographical comparison.</p> <p>Now, formally using $\\infty$ as an element of continued fraction representation it is possible to emulate irrational numbers $A-\\varepsilon$ and $A+\\varepsilon$, that is, elements that are smaller (greater) than $A$, but greater (smaller) than any other real number. Specifically, for $A=[a_0; a_1, \\dots, a_n]$, one of these two elements can be emulated as $[a_0; a_1, \\dots, a_n, \\infty]$ and the other can be emulated as $[a_0; a_1, \\dots, a_n - 1, 1, \\infty]$.</p> <p>Which one corresponds to $A-\\varepsilon$ and which one to $A+\\varepsilon$ can be determined by the parity of $n$ or by comparing them as irrational numbers.</p> Python <pre><code># check if a &lt; b assuming that a[-1] = b[-1] = infty and a != b\ndef less(a, b):\n    a = [(-1)**i*a[i] for i in range(len(a))]\n    b = [(-1)**i*b[i] for i in range(len(b))]\n    return a &lt; b\n\n# [a0; a1, ..., ak] -&gt; [a0, a1, ..., ak-1, 1]\ndef expand(a):\n    if a: # empty a = inf\n        a[-1] -= 1\n        a.append(1)\n    return a\n\n# return a-eps, a+eps\ndef pm_eps(a):\n    b = expand(a.copy())\n    a.append(float('inf'))\n    b.append(float('inf'))\n    return (a, b) if less(a, b) else (b, a)\n</code></pre> <p>Best inner point</p> <p>You're given $\\frac{0}{1} \\leq \\frac{p_0}{q_0} &lt; \\frac{p_1}{q_1} \\leq \\frac{1}{0}$. Find the rational number $\\frac{p}{q}$ such that $(q; p)$ is lexicographically smallest and $\\frac{p_0}{q_0} &lt; \\frac{p}{q} &lt; \\frac{p_1}{q_1}$.</p> Solution <p>In terms of the Stern-Brocot tree it means that we need to find the LCA of $\\frac{p_0}{q_0}$ and $\\frac{p_1}{q_1}$. Due to the connection between Stern-Brocot tree and continued fraction, this LCA would roughly correspond to the largest common prefix of continued fraction representations for $\\frac{p_0}{q_0}$ and $\\frac{p_1}{q_1}$.</p> <p>So, if $\\frac{p_0}{q_0} = [a_0; a_1, \\dots, a_{k-1}, a_k, \\dots]$ and $\\frac{p_1}{q_1} = [a_0; a_1, \\dots, a_{k-1}, b_k, \\dots]$ are irrational numbers, the LCA is $[a_0; a_1, \\dots, \\min(a_k, b_k)+1]$.</p> <p>For rational $r_0$ and $r_1$, one of them could be the LCA itself which would require us to casework it. To simplify the solution for rational $r_0$ and $r_1$, it is possible to use continued fraction representation of $r_0 + \\varepsilon$ and $r_1 - \\varepsilon$ which was derived in the previous problem.</p> Python <pre><code># finds lexicographically smallest (q, p)\n# such that p0/q0 &lt; p/q &lt; p1/q1\ndef middle(p0, q0, p1, q1):\n    a0 = pm_eps(fraction(p0, q0))[1]\n    a1 = pm_eps(fraction(p1, q1))[0]\n    a = []\n    for i in range(min(len(a0), len(a1))):\n        a.append(min(a0[i], a1[i]))\n        if a0[i] != a1[i]:\n            break\n    a[-1] += 1\n    p, q = convergents(a)\n    return p[-1], q[-1]\n</code></pre> <p>GCJ 2019, Round 2 - New Elements: Part 2</p> <p>You're given $N$ positive integer pairs $(C_i, J_i)$. You need to find a positive integer pair $(x, y)$ such that $C_i x + J_i y$ is a strictly increasing sequence.</p> <p>Among such pairs, find the lexicographically minimum one.</p> Solution <p>Rephrasing the statement, $A_i x + B_i y$ must be positive for all $i$, where $A_i = C_i - C_{i-1}$ and $B_i = J_i - J_{i-1}$.</p> <p>Among such equations we have four significant groups for $A_i x + B_i y &gt; 0$:</p> <ol> <li>$A_i, B_i &gt; 0$ can be ignored since we're looking for $x, y &gt; 0$.</li> <li>$A_i, B_i \\leq 0$ would provide \"IMPOSSIBLE\" as an answer.</li> <li>$A_i &gt; 0$, $B_i \\leq 0$. Such constraints are equivalent to $\\frac{y}{x} &lt; \\frac{A_i}{-B_i}$.</li> <li>$A_i \\leq 0$, $B_i &gt; 0$. Such constraints are equivalent to $\\frac{y}{x} &gt; \\frac{-A_i}{B_i}$.</li> </ol> <p>Let $\\frac{p_0}{q_0}$ be the largest $\\frac{-A_i}{B_i}$ from the fourth group and $\\frac{p_1}{q_1}$ be the smallest $\\frac{A_i}{-B_i}$ from the third group.</p> <p>The problem is now, given $\\frac{p_0}{q_0} &lt; \\frac{p_1}{q_1}$, find a fraction $\\frac{p}{q}$ such that $(q;p)$ is lexicographically smallest and $\\frac{p_0}{q_0} &lt; \\frac{p}{q} &lt; \\frac{p_1}{q_1}$.</p> Python <pre><code>    def solve():\n    n = int(input())\n    C = [0] * n\n    J = [0] * n\n    # p0/q0 &lt; y/x &lt; p1/q1\n    p0, q0 = 0, 1\n    p1, q1 = 1, 0\n    fail = False\n    for i in range(n):\n        C[i], J[i] = map(int, input().split())\n        if i &gt; 0:\n            A = C[i] - C[i-1]\n            B = J[i] - J[i-1]\n            if A &lt;= 0 and B &lt;= 0:\n                fail = True\n            elif B &gt; 0 and A &lt; 0: # y/x &gt; (-A)/B if B &gt; 0\n                if (-A)*q0 &gt; p0*B:\n                    p0, q0 = -A, B\n            elif B &lt; 0 and A &gt; 0: # y/x &lt; A/(-B) if B &lt; 0\n                if A*q1 &lt; p1*(-B):\n                    p1, q1 = A, -B\n    if p0*q1 &gt;= p1*q0 or fail:\n        return 'IMPOSSIBLE'\n\n    p, q = middle(p0, q0, p1, q1)\n    return str(q) + ' ' + str(p)\n</code></pre>","tags":["Original"]},{"location":"algebra/continued-fractions.html#calkin-wilf-tree","title":"Calkin-Wilf tree","text":"<p>A somewhat simpler way to organize continued fractions in a binary tree is the Calkin-Wilf tree.</p> <p>The tree generally looks like this:</p> The image by Olli Niemitalo, Proz is licensed under CC0 1.0 <p>In the root of the tree, the number $\\frac{1}{1}$ is located. Then, for the vertex with a number $\\frac{p}{q}$, its children are $\\frac{p}{p+q}$ and $\\frac{p+q}{q}$.</p> <p>Unlike the Stern-Brocot tree, the Calkin-Wilf tree is not a binary search tree, so it can't be used to perform rational binary search.</p> <p>In the Calkin-Wilf tree, the direct parent of a fraction $\\frac{p}{q}$ is $\\frac{p-q}{q}$ when $p&gt;q$ and $\\frac{p}{q-p}$ otherwise.</p> <p>For the Stern-Brocot tree, we used the recurrence for convergents. To draw the connection between the continued fraction and the Calkin-Wilf tree, we should recall the recurrence for complete quotients. If $s_k = \\frac{p}{q}$, then $s_{k+1} = \\frac{q}{p \\mod q} = \\frac{q}{p-\\lfloor p/q \\rfloor \\cdot q}$.</p> <p>On the other hand, if we repeatedly go from $s_k = \\frac{p}{q}$ to its parent in the Calkin-Wilf tree when $p &gt; q$, we will end up in $\\frac{p \\mod q}{q} = \\frac{1}{s_{k+1}}$. If we continue doing so, we will end up in $s_{k+2}$, then $\\frac{1}{s_{k+3}}$ and so on. From this we can deduce that:</p> <ol> <li>When $a_0&gt; 0$, the direct parent of $[a_0; a_1, \\dots, a_k]$ in the Calkin-Wilf tree is $\\frac{p-q}{q}=[a_0 - 1; a_1, \\dots, a_k]$.</li> <li>When $a_0 = 0$ and $a_1 &gt; 1$, its direct parent is $\\frac{p}{q-p} = [0; a_1 - 1, a_2, \\dots, a_k]$.</li> <li>And when $a_0 = 0$ and $a_1 = 1$, its direct parent is $\\frac{p}{q-p} = [a_2; a_3, \\dots, a_k]$.</li> </ol> <p>Correspondingly, children of $\\frac{p}{q} = [a_0; a_1, \\dots, a_k]$ are</p> <ol> <li>$\\frac{p+q}{q}=1+\\frac{p}{q}$, which is $[a_0+1; a_1, \\dots, a_k]$,</li> <li>$\\frac{p}{p+q} = \\frac{1}{1+\\frac{q}{p}}$, which is $[0, 1, a_0, a_1, \\dots, a_k]$ for $a_0 &gt; 0$ and $[0, a_1+1, a_2, \\dots, a_k]$ for $a_0=0$.</li> </ol> <p>Noteworthy, if we enumerate vertices of the Calkin-Wilf tree in the breadth-first search order (that is, the root has a number $1$, and the children of the vertex $v$ have indices $2v$ and $2v+1$ correspondingly), the index of the rational number in the Calkin-Wilf tree would be the same as in the Stern-Brocot tree.</p> <p>Thus, numbers on the same levels of the Stern-Brocot tree and the Calkin-Wilf tree are the same, but their ordering differs through the bit-reversal permutation.</p>","tags":["Original"]},{"location":"algebra/continued-fractions.html#convergence","title":"Convergence","text":"<p>For the number $r$ and its $k$-th convergent $r_k=\\frac{p_k}{q_k}$ the following formula stands:</p> $$r_k = a_0 + \\sum\\limits_{i=1}^k \\frac{(-1)^{i-1}}{q_i q_{i-1}}.$$ <p>In particular, it means that </p> $$r_k - r_{k-1} = \\frac{(-1)^{k-1}}{q_k q_{k-1}}$$ <p>and </p> $$p_k q_{k-1} - p_{k-1} q_k = (-1)^{k-1}.$$ <p>From this we can conclude that</p> $$\\left| r-\\frac{p_k}{q_k} \\right| \\leq \\frac{1}{q_{k+1}q_k} \\leq \\frac{1}{q_k^2}.$$ <p>The latter inequality is due to the fact that $r_k$ and $r_{k+1}$ are generally located on different sides of $r$, thus</p> $$|r-r_k| = |r_k-r_{k+1}|-|r-r_{k+1}| \\leq |r_k - r_{k+1}|.$$ Detailed explanation <p>To estimate $|r-r_k|$, we start by estimating the difference between adjacent convergents. By definition,</p> $$\\frac{p_k}{q_k} - \\frac{p_{k-1}}{q_{k-1}} = \\frac{p_k q_{k-1} - p_{k-1} q_k}{q_k q_{k-1}}.$$ <p>Replacing $p_k$ and $q_k$ in the numerator with their recurrences, we get</p> $$\\begin{align} p_k q_{k-1} - p_{k-1} q_k &amp;= (a_k p_{k-1} + p_{k-2}) q_{k-1} - p_{k-1} (a_k q_{k-1} + q_{k-2}) \\\\&amp;= p_{k-2} q_{k-1} - p_{k-1} q_{k-2},\\end{align}$$ <p>thus the numerator of $r_k - r_{k-1}$ is always the negated numerator of $r_{k-1} - r_{k-2}$. It, in turn, equals to $1$ for</p> $$r_1 - r_0=\\left(a_0+\\frac{1}{a_1}\\right)-a_0=\\frac{1}{a_1},$$ <p>thus</p> $$r_k - r_{k-1} = \\frac{(-1)^{k-1}}{q_k q_{k-1}}.$$ <p>This yields an alternative representation of $r_k$ as a partial sum of infinite series:</p> $$r_k = (r_k - r_{k-1}) + \\dots + (r_1 - r_0) + r_0 = a_0 + \\sum\\limits_{i=1}^k \\frac{(-1)^{i-1}}{q_i q_{i-1}}.$$ <p>From the recurrent relation it follows that $q_k$ monotonously increases at least as fast as Fibonacci numbers, thus</p> $$r = \\lim\\limits_{k \\to \\infty} r_k = a_0 + \\sum\\limits_{i=1}^\\infty \\frac{(-1)^{i-1}}{q_i q_{i-1}}$$ <p>is always well-defined, as the underlying series always converge. Noteworthy, the residual series</p> $$r-r_k = \\sum\\limits_{i=k+1}^\\infty \\frac{(-1)^{i-1}}{q_i q_{i-1}}$$ <p>has the same sign as $(-1)^k$ due to how fast $q_i q_{i-1}$ decreases. Hence even-indexed $r_k$ approach $r$ from below while odd-indexed $r_k$ approach it from above:</p> <p> Convergents of $r=\\phi = \\frac{1+\\sqrt{5}}{2}=[1;1,1,\\dots]$ and their distance from $r$.</p> <p>From this picture we can see that</p> $$|r-r_k| = |r_k - r_{k+1}| - |r-r_{k+1}| \\leq |r_k - r_{k+1}|,$$ <p>thus the distance between $r$ and $r_k$ is never larger than the distance between $r_k$ and $r_{k+1}$:</p> $$\\left|r-\\frac{p_k}{q_k}\\right| \\leq \\frac{1}{q_k q_{k+1}} \\leq \\frac{1}{q_k^2}.$$ <p>Extended Euclidean?</p> <p>You're given $A, B, C \\in \\mathbb Z$. Find $x, y \\in \\mathbb Z$ such that $Ax + By = C$.</p> Solution <p>Although this problem is typically solved with the extended Euclidean algorithm, there is a simple and straightforward solution with continued fractions.</p> <p>Let $\\frac{A}{B}=[a_0; a_1, \\dots, a_k]$. It was proved above that $p_k q_{k-1} - p_{k-1} q_k = (-1)^{k-1}$. Substituting $p_k$ and $q_k$ with $A$ and $B$, we get</p> $$Aq_{k-1} - Bp_{k-1} = (-1)^{k-1} g,$$ <p>where $g = \\gcd(A, B)$. If $C$ is divisible by $g$, then the solution is $x = (-1)^{k-1}\\frac{C}{g} q_{k-1}$ and $y = (-1)^{k}\\frac{C}{g} p_{k-1}$.</p> Python <pre><code># return (x, y) such that Ax+By=C\n# assumes that such (x, y) exists\ndef dio(A, B, C):\n    p, q = convergents(fraction(A, B))\n    C //= A // p[-1] # divide by gcd(A, B)\n    t = (-1) if len(p) % 2 else 1\n    return t*C*q[-2], -t*C*p[-2]\n</code></pre>","tags":["Original"]},{"location":"algebra/continued-fractions.html#linear-fractional-transformations","title":"Linear fractional transformations","text":"<p>Another important concept for continued fractions are the so-called linear fractional transformations.</p> <p>Definition</p> <p>A linear fractional transformation is a function $f : \\mathbb R \\to \\mathbb R$ such that $f(x) = \\frac{ax+b}{cx+d}$ for some $a,b,c,d \\in \\mathbb R$.</p> <p>A composition $(L_0 \\circ L_1)(x) = L_0(L_1(x))$ of linear fractional transforms $L_0(x)=\\frac{a_0 x + b_0}{c_0 x + d_0}$ and $L_1(x)=\\frac{a_1 x + b_1}{c_1 x + d_1}$ is itself a linear fractional transform:</p> $$\\frac{a_0\\frac{a_1 x + b_1}{c_1 x + d_1} + b_0}{c_0 \\frac{a_1 x + b_1}{c_1 x + d_1} + d_0} = \\frac{a_0(a_1 x + b_1) + b_0 (c_1 x + d_1)}{c_0 (a_1 x + b_1) + d_0 (c_1 x + d_1)} = \\frac{(a_0 a_1 + b_0 c_1) x + (a_0 b_1 + b_0 d_1)}{(c_0 a_1 + d_0 c_1) x + (c_0 b_1 + d_0 d_1)}.$$ <p>Inverse of a linear fractional transform, is also a linear fractional transform:</p> $$y = \\frac{ax+b}{cx+d} \\iff y(cx+d) = ax + b \\iff x = -\\frac{dy-b}{cy-a}.$$ <p>DMOPC '19 Contest 7 P4 - Bob and Continued Fractions</p> <p>You're given an array of positive integers $a_1, \\dots, a_n$. You need to answer $m$ queries. Each query is to compute $[a_l; a_{l+1}, \\dots, a_r]$.</p> Solution <p>We can solve this problem with the segment tree if we're able to concatenate continued fractions.</p> <p>It's generally true that $[a_0; a_1, \\dots, a_k, b_0, b_1, \\dots, b_k] = [a_0; a_1, \\dots, a_k, [b_1; b_2, \\dots, b_k]]$.</p> <p>Let's denote $L_{k}(x) = [a_k; x] = a_k + \\frac{1}{x} = \\frac{a_k\\cdot x+1}{1\\cdot x + 0}$. Note that $L_k(\\infty) = a_k$. In this notion, it holds that</p> $$[a_0; a_1, \\dots, a_k, x] = [a_0; [a_1; [\\dots; [a_k; x]]]] = (L_0 \\circ L_1 \\circ \\dots \\circ L_k)(x) = \\frac{p_k x + p_{k-1}}{q_k x + q_{k-1}}.$$ <p>Thus, the problem boils down to the computation of</p> $$(L_l \\circ L_{l+1} \\circ \\dots \\circ L_r)(\\infty).$$ <p>Composition of transforms is associative, so it's possible to compute in each node of a segment tree the composition of transforms in its subtree.</p> <p>Linear fractional transformation of a continued fraction</p> <p>Let $L(x) = \\frac{ax+b}{cx+d}$. Compute the continued fraction representation $[b_0; b_1, \\dots, b_m]$ of $L(A)$ for $A=[a_0; a_1, \\dots, a_n]$.</p> <p>This allows to compute $A + \\frac{p}{q} = \\frac{qA + p}{q}$ and $A \\cdot \\frac{p}{q} = \\frac{p A}{q}$ for any $\\frac{p}{q}$.</p> Solution <p>As we noted above, $[a_0; a_1, \\dots, a_k] = (L_{a_0} \\circ L_{a_1} \\circ \\dots \\circ L_{a_k})(\\infty)$, hence $L([a_0; a_1, \\dots, a_k]) = (L \\circ L_{a_0} \\circ L_{a_1} \\circ \\dots L_{a_k})(\\infty)$.</p> <p>Hence, by consequentially adding $L_{a_0}$, $L_{a_1}$ and so on we would be able to compute</p> $$(L \\circ L_{a_0} \\circ \\dots \\circ L_{a_k})(x) = L\\left(\\frac{p_k x + p_{k-1}}{q_k x + q_{k-1}}\\right)=\\frac{a_k x + b_k}{c_k x + d_k}.$$ <p>Since $L(x)$ is invertible, it is also monotonous in $x$. Therefore, for any $x \\geq 0$ it holds that $L(\\frac{p_k x + p_{k-1}}{q_k x + q_{k-1}})$ is between $L(\\frac{p_k}{q_k}) = \\frac{a_k}{c_k}$ and $L(\\frac{p_{k-1}}{q_{k-1}}) = \\frac{b_k}{d_k}$.</p> <p>Moreover, for $x=[a_{k+1}; \\dots, a_n]$ it is equal to $L(A)$. Hence, $b_0 = \\lfloor L(A) \\rfloor$ is between $\\lfloor L(\\frac{p_k}{q_k}) \\rfloor$ and $\\lfloor L(\\frac{p_{k-1}}{q_{k-1}}) \\rfloor$. When they're equal, they're also equal to $b_0$.</p> <p>Note that $L(A) = (L_{b_0} \\circ L_{b_1} \\circ \\dots \\circ L_{b_m})(\\infty)$. Knowing $b_0$, we can compose $L_{b_0}^{-1}$ with the current transform and continue adding $L_{a_{k+1}}$, $L_{a_{k+2}}$ and so on, looking for new floors to agree, from which we would be able to deduce $b_1$ and so on until we recover all values of $[b_0; b_1, \\dots, b_m]$.</p> <p>Continued fraction arithmetics</p> <p>Let $A=[a_0; a_1, \\dots, a_n]$ and $B=[b_0; b_1, \\dots, b_m]$. Compute the continued fraction representations of $A+B$ and $A \\cdot B$.</p> Solution <p>Idea here is similar to the previous problem, but instead of $L(x) = \\frac{ax+b}{cx+d}$ you should consider bilinear fractional transform $L(x, y) = \\frac{axy+bx+cy+d}{exy+fx+gy+h}$.</p> <p>Rather than $L(x) \\mapsto L(L_{a_k}(x))$ you would change your current transform as $L(x, y) \\mapsto L(L_{a_k}(x), y)$ or $L(x, y) \\mapsto L(x, L_{b_k}(y))$.</p> <p>Then, you check if $\\lfloor \\frac{a}{e} \\rfloor = \\lfloor \\frac{b}{f} \\rfloor = \\lfloor \\frac{c}{g} \\rfloor = \\lfloor \\frac{d}{h} \\rfloor$ and if they all agree, you use this value as $c_k$ in the resulting fraction and change the transform as</p> $$L(x, y) \\mapsto \\frac{1}{L(x, y) - c_k}.$$ <p>Definition</p> <p>A continued fraction $x = [a_0; a_1, \\dots]$ is said to be periodic if $x = [a_0; a_1, \\dots, a_k, x]$ for some $k$.</p> <p>A continued fraction $x = [a_0; a_1, \\dots]$ is said to be eventually periodic if $x = [a_0; a_1, \\dots, a_k, y]$, where $y$ is periodic.</p> <p>For $x = [1; 1, 1, \\dots]$ it holds that $x = 1 + \\frac{1}{x}$, thus $x^2 = x + 1$. There is a generic connection between periodic continued fractions and quadratic equations. Consider the following equation:</p> $$ x = [a_0; a_1, \\dots, a_k, x].$$ <p>On one hand, this equation means that the continued fraction representation of $x$ is periodic with the period $k+1$.</p> <p>On the other hand, using the formula for convergents, this equation means that</p> $$x = \\frac{p_k x + p_{k-1}}{q_k x + q_{k-1}}.$$ <p>That is, $x$ is a linear fractional transformation of itself. It follows from the equation that $x$ is a root of the second degree equation:</p> $$q_k x^2 + (q_{k-1}-p_k)x - p_{k-1} = 0.$$ <p>Similar reasoning stands for continued fractions that are eventually periodic, that is $x = [a_0; a_1, \\dots, a_k, y]$ for $y=[b_0; b_1, \\dots, b_k, y]$. Indeed, from first equation we derive that $x = L_0(y)$ and from second equation that $y = L_1(y)$, where $L_0$ and $L_1$ are linear fractional transformations. Therefore,</p> $$x = (L_0 \\circ L_1)(y) = (L_0 \\circ L_1 \\circ L_0^{-1})(x).$$ <p>One can further prove (and it was first done by Lagrange) that for arbitrary quadratic equation $ax^2+bx+c=0$ with integer coefficients, its solution $x$ is an eventually periodic continued fraction.</p> <p>Quadratic irrationality</p> <p>Find the continued fraction of $\\alpha = \\frac{x+y\\sqrt{n}}{z}$ where $x, y, z, n \\in \\mathbb Z$ and $n &gt; 0$ is not a perfect square.</p> Solution <p>For the $k$-th complete quotient $s_k$ of the number it generally holds that</p> $$\\alpha = [a_0; a_1, \\dots, a_{k-1}, s_k] = \\frac{s_k p_{k-1} + p_{k-2}}{s_k q_{k-1} + q_{k-2}}.$$ <p>Therefore, </p> $$s_k = -\\frac{\\alpha q_{k-1} - p_{k-1}}{\\alpha q_k - p_k} = -\\frac{q_{k-1} y \\sqrt n + (x q_{k-1} - z p_{k-1})}{q_k y \\sqrt n + (xq_k-zp_k)}.$$ <p>Multiplying the numerator and denominator by $(xq_k - zp_k) - q_k y \\sqrt n$, we'll get rid of $\\sqrt n$ in the denominator, thus the complete quotients are of form</p> $$s_k = \\frac{x_k + y_k \\sqrt n}{z_k}.$$ <p>Let's find $s_{k+1}$, assuming that $s_k$ is known.</p> <p>First of all, $a_k = \\lfloor s_k \\rfloor = \\left\\lfloor \\frac{x_k + y_k \\lfloor \\sqrt n \\rfloor}{z_k} \\right\\rfloor$. Then,</p> $$s_{k+1} = \\frac{1}{s_k-a_k} = \\frac{z_k}{(x_k - z_k a_k) + y_k \\sqrt n} = \\frac{z_k (x_k - y_k a_k) - y_k z_k \\sqrt n}{(x_k - y_k a_k)^2 - y_k^2 n}.$$ <p>Thus, if we denote $t_k = x_k - y_k a_k$, it will hold that</p> $$\\begin{align}x_{k+1} &amp;=&amp; z_k t_k, \\\\ y_{k+1} &amp;=&amp; -y_k z_k, \\\\ z_{k+1} &amp;=&amp; t_k^2 - y_k^2 n.\\end{align}$$ <p>Nice thing about such representation is that if we reduce $x_{k+1}, y_{k+1}, z_{k+1}$ by their greatest common divisor, the result would be unique. Therefore, we may use it to check whether the current state has already been repeated and also to check where was the previous index that had this state.</p> <p>Below is the code to compute the continued fraction representation for $\\alpha = \\sqrt n$:</p> Python <pre><code># compute the continued fraction of sqrt(n)\ndef sqrt(n):\n    n0 = math.floor(math.sqrt(n))\n    x, y, z = 1, 0, 1\n    a = []\n    def step(x, y, z):\n        a.append((x * n0 + y) // z)\n        t = y - a[-1]*z\n        x, y, z = -z*x, z*t, t**2 - n*x**2\n        g = math.gcd(x, math.gcd(y, z))\n        return x // g, y // g, z // g\n\n    used = dict()\n    for i in range(n):\n        used[x, y, z] = i\n        x, y, z = step(x, y, z)\n        if (x, y, z) in used:\n            return a\n</code></pre> <p>Using the same <code>step</code> function but different initial $x$, $y$ and $z$ it is possible to compute it for arbitrary $\\frac{x+y \\sqrt{n}}{z}$.</p> <p>Tavrida NU Akai Contest - Continued Fraction</p> <p>You're given $x$ and $k$, $x$ is not a perfect square. Let $\\sqrt x = [a_0; a_1, \\dots]$, find $\\frac{p_k}{q_k}=[a_0; a_1, \\dots, a_k]$ for $0 \\leq k \\leq 10^9$.</p> Solution <p>After computing the period of $\\sqrt x$, it is possible to compute $a_k$ using binary exponentiation on the linear fractional transformation induced by the continued fraction representation. To find the resulting transformation, you compress the period of size $T$ into a single transformation and repeat it $\\lfloor \\frac{k-1}{T}\\rfloor$ times, after which you manually combine it with the remaining transformations.</p> Python <pre><code>x, k = map(int, input().split())\n\nmod = 10**9+7\n\n# compose (A[0]*x + A[1]) / (A[2]*x + A[3]) and (B[0]*x + B[1]) / (B[2]*x + B[3])\ndef combine(A, B):\n    return [t % mod for t in [A[0]*B[0]+A[1]*B[2], A[0]*B[1]+A[1]*B[3], A[2]*B[0]+A[3]*B[2], A[2]*B[1]+A[3]*B[3]]]\n\nA = [1, 0, 0, 1] # (x + 0) / (0*x + 1) = x\n\na = sqrt(x)\n\nT = len(a) - 1 # period of a\n\n# apply ak + 1/x = (ak*x+1)/(1x+0) to (Ax + B) / (Cx + D)\nfor i in reversed(range(1, len(a))):\n    A = combine([a[i], 1, 1, 0], A)\n\ndef bpow(A, n):\n    return [1, 0, 0, 1] if not n else combine(A, bpow(A, n-1)) if n % 2 else bpow(combine(A, A), n // 2)\n\n\nC = (0, 1, 0, 0) # = 1 / 0\nwhile k % T:\n    i = k % T\n    C = combine([a[i], 1, 1, 0], C)\n    k -= 1\n\nC = combine(bpow(A, k // T), C)\nC = combine([a[0], 1, 1, 0], C)\nprint(str(C[1]) + '/' + str(C[3]))\n</code></pre>","tags":["Original"]},{"location":"algebra/continued-fractions.html#geometric-interpretation","title":"Geometric interpretation","text":"<p>Let $\\vec r_k = (q_k;p_k)$ for the convergent $r_k = \\frac{p_k}{q_k}$. Then, the following recurrence holds:</p> $$\\vec r_k = a_k \\vec r_{k-1} + \\vec r_{k-2}.$$ <p>Let $\\vec r = (1;r)$. Then, each vector $(x;y)$ corresponds to the number that is equal to its slope coefficient $\\frac{y}{x}$.</p> <p>With the notion of pseudoscalar product $(x_1;y_1) \\times (x_2;y_2) = x_1 y_2 - x_2 y_1$, it can be shown (see the explanation below) that</p> $$s_k = -\\frac{\\vec r_{k-2} \\times \\vec r}{\\vec r_{k-1} \\times \\vec r} = \\left|\\frac{\\vec r_{k-2} \\times \\vec r}{\\vec r_{k-1} \\times \\vec r}\\right|.$$ <p>The last equation is due to the fact that $r_{k-1}$ and $r_{k-2}$ lie on the different sides of $r$, thus pseudoscalar products of $\\vec r_{k-1}$ and $\\vec r_{k-2}$ with $\\vec r$ have distinct signs. With $a_k = \\lfloor s_k \\rfloor$ in mind, formula for $\\vec r_k$ now looks like</p> $$\\vec r_k = \\vec r_{k-2} + \\left\\lfloor \\left| \\frac{\\vec r \\times \\vec r_{k-2}}{\\vec r \\times \\vec r_{k-1}}\\right|\\right\\rfloor \\vec r_{k-1}.$$ <p>Note that $\\vec r_k \\times r = (q;p) \\times (1;r) = qr - p$, thus</p> $$a_k = \\left\\lfloor \\left| \\frac{q_{k-1}r-p_{k-1}}{q_{k-2}r-p_{k-2}} \\right| \\right\\rfloor.$$ Explanation <p>As we have already noted, $a_k = \\lfloor s_k \\rfloor$, where $s_k = [a_k; a_{k+1}, a_{k+2}, \\dots]$. On the other hand, from the convergent recurrence we derive that</p> $$r = [a_0; a_1, \\dots, a_{k-1}, s_k] = \\frac{s_k p_{k-1} + p_{k-2}}{s_k q_{k-1} + q_{k-2}}.$$ <p>In vector form, it rewrites as</p> $$\\vec r \\parallel s_k \\vec r_{k-1} + \\vec r_{k-2},$$ <p>meaning that $\\vec r$ and $s_k \\vec r_{k-1} + \\vec r_{k-2}$ are collinear (that is, have the same slope coefficient). Taking the pseudoscalar product of both parts with $\\vec r$, we get</p> $$0 = s_k (\\vec r_{k-1} \\times \\vec r) + (\\vec r_{k-2} \\times \\vec r),$$ <p>which yields the final formula</p> $$s_k = -\\frac{\\vec r_{k-2} \\times \\vec r}{\\vec r_{k-1} \\times \\vec r}.$$ <p>Nose stretching algorithm</p> <p>Each time you add $\\vec r_{k-1}$ to the vector $\\vec p$, the value of $\\vec p \\times \\vec r$ is increased by $\\vec r_{k-1} \\times \\vec r$.</p> <p>Thus, $a_k=\\lfloor s_k \\rfloor$ is the maximum integer number of $\\vec r_{k-1}$ vectors that can be added to $\\vec r_{k-2}$ without changing the sign of the cross product with $\\vec r$.</p> <p>In other words, $a_k$ is the maximum integer number of times you can add $\\vec r_{k-1}$ to $\\vec r_{k-2}$ without crossing the line defined by $\\vec r$:</p> <p> Convergents of $r=\\frac{7}{9}=[0;1,3,2]$. Semiconvergents correspond to intermediate points between gray arrows.</p> <p>On the picture above, $\\vec r_2 = (4;3)$ is obtained by repeatedly adding $\\vec r_1 = (1;1)$ to $\\vec r_0 = (1;0)$.</p> <p>When it is not possible to further add $\\vec r_1$ to $\\vec r_0$ without crossing the $y=rx$ line, we go to the other side and repeatedly add $\\vec r_2$ to $\\vec r_1$ to obtain $\\vec r_3 = (9;7)$.</p> <p>This procedure generates exponentially longer vectors, that approach the line.</p> <p>For this property, the procedure of generating consequent convergent vectors was dubbed the nose stretching algorithm by Boris Delaunay.</p> <p>If we look on the triangle drawn on points $\\vec r_{k-2}$, $\\vec r_{k}$ and $\\vec 0$ we will notice that its doubled area is</p> $$|\\vec r_{k-2} \\times \\vec r_k| = |\\vec r_{k-2} \\times (\\vec r_{k-2} + a_k \\vec r_{k-1})| = a_k |\\vec r_{k-2} \\times \\vec r_{k-1}| = a_k.$$ <p>Combined with the Pick's theorem, it means that there are no lattice points strictly inside the triangle and the only lattice points on its border are $\\vec 0$ and $\\vec r_{k-2} + t \\cdot \\vec r_{k-1}$ for all integer $t$ such that $0 \\leq t \\leq a_k$. When joined for all possible $k$ it means that there are no integer points in the space between polygons formed by even-indexed and odd-indexed convergent vectors.</p> <p>This, in turn, means that $\\vec r_k$ with odd coefficients form a convex hull of lattice points with $x \\geq 0$ above the line $y=rx$, while $\\vec r_k$ with even coefficients form a convex hull of lattice points with $x &gt; 0$ below the line $y=rx$.</p> <p>Definition</p> <p>These polygons are also known as Klein polygons, named after Felix Klein who first suggested this geometric interpretation to the continued fractions.</p>","tags":["Original"]},{"location":"algebra/continued-fractions.html#problem-examples","title":"Problem examples","text":"<p>Now that the most important facts and concepts were introduced, it is time to delve into specific problem examples.</p> <p>Convex hull under the line</p> <p>Find the convex hull of lattice points $(x;y)$ such that $0 \\leq x \\leq N$ and $0 \\leq y \\leq rx$ for $r=[a_0;a_1,\\dots,a_k]=\\frac{p_k}{q_k}$.</p> Solution <p>If we were considering the unbounded set $0 \\leq x$, the upper convex hull would be given by the line $y=rx$ itself.</p> <p>However, with additional constraint $x \\leq N$ we'd need to eventually deviate from the line to maintain proper convex hull.</p> <p>Let $t = \\lfloor \\frac{N}{q_k}\\rfloor$, then first $t$ lattice points on the hull after $(0;0)$ are $\\alpha \\cdot (q_k; p_k)$ for integer $1 \\leq \\alpha \\leq t$.</p> <p>However $(t+1)(q_k; p_k)$ can't be next lattice point since $(t+1)q_k$ is greater than $N$.</p> <p>To get to the next lattice points in the hull, we should get to the point $(x;y)$ which diverges from $y=rx$ by the smallest margin, while maintaining $x \\leq N$.</p> <p> Convex hull of lattice points under $y=\\frac{4}{7}x$ for $0 \\leq x \\leq 19$ consists of points $(0;0), (7;4), (14;8), (16;9), (18;10), (19;10)$.</p> <p>Let $(x; y)$ be the last current point in the convex hull. Then the next point $(x'; y')$ is such that $x' \\leq N$ and $(x'; y') - (x; y) = (\\Delta x; \\Delta y)$ is as close to the line $y=rx$ as possible. In other words, $(\\Delta x; \\Delta y)$ maximizes $r \\Delta x - \\Delta y$ subject to $\\Delta x \\leq N - x$ and $\\Delta y \\leq r \\Delta x$.</p> <p>Points like that lie on the convex hull of lattice points below $y=rx$. In other words, $(\\Delta x; \\Delta y)$ must be a lower semiconvergent of $r$.</p> <p>That being said, $(\\Delta x; \\Delta y)$ is of form $(q_{i-1}; p_{i-1}) + t \\cdot (q_i; p_i)$ for some odd number $i$ and $0 \\leq t &lt; a_i$.</p> <p>To find such $i$, we can traverse all possible $i$ starting from the largest one and use $t = \\lfloor \\frac{N-x-q_{i-1}}{q_i} \\rfloor$ for $i$ such that $N-x-q_{i-1} \\geq 0$.</p> <p>With $(\\Delta x; \\Delta y) = (q_{i-1}; p_{i-1}) + t \\cdot (q_i; p_i)$, the condition $\\Delta y \\leq r \\Delta x$ would be preserved by semiconvergent properties.</p> <p>And $t &lt; a_i$ would hold because we already exhausted semiconvergents obtained from $i+2$, hence $x + q_{i-1} + a_i q_i = x+q_{i+1}$ is greater than $N$.</p> <p>Now that we may add $(\\Delta x; \\Delta y)$, to $(x;y)$ for $k = \\lfloor \\frac{N-x}{\\Delta x} \\rfloor$ times before we exceed $N$, after which we would try the next semiconvergent.</p> C++Python <pre><code>// returns [ah, ph, qh] such that points r[i]=(ph[i], qh[i]) constitute upper convex hull\n// of lattice points on 0 &lt;= x &lt;= N and 0 &lt;= y &lt;= r * x, where r = [a0; a1, a2, ...]\n// and there are ah[i]-1 integer points on the segment between r[i] and r[i+1]\nauto hull(auto a, int N) {\n    auto [p, q] = convergents(a);\n    int t = N / q.back();\n    vector ah = {t};\n    vector ph = {0, t*p.back()};\n    vector qh = {0, t*q.back()};\n\n    for(int i = q.size() - 1; i &gt;= 0; i--) {\n        if(i % 2) {\n            while(qh.back() + q[i - 1] &lt;= N) {\n                t = (N - qh.back() - q[i - 1]) / q[i];\n                int dp = p[i - 1] + t * p[i];\n                int dq = q[i - 1] + t * q[i];\n                int k = (N - qh.back()) / dq;\n                ah.push_back(k);\n                ph.push_back(ph.back() + k * dp);\n                qh.push_back(qh.back() + k * dq);\n            }\n        }\n    }\n    return make_tuple(ah, ph, qh);\n}\n</code></pre> <pre><code># returns [ah, ph, qh] such that points r[i]=(ph[i], qh[i]) constitute upper convex hull\n# of lattice points on 0 &lt;= x &lt;= N and 0 &lt;= y &lt;= r * x, where r = [a0; a1, a2, ...]\n# and there are ah[i]-1 integer points on the segment between r[i] and r[i+1]\ndef hull(a, N):\n    p, q = convergents(a)\n    t = N // q[-1]\n    ah = [t]\n    ph = [0, t*p[-1]]\n    qh = [0, t*q[-1]]\n    for i in reversed(range(len(q))):\n        if i % 2 == 1:\n            while qh[-1] + q[i-1] &lt;= N:\n                t = (N - qh[-1] - q[i-1]) // q[i]\n                dp = p[i-1] + t*p[i]\n                dq = q[i-1] + t*q[i]\n                k = (N - qh[-1]) // dq\n                ah.append(k)\n                ph.append(ph[-1] + k * dp)\n                qh.append(qh[-1] + k * dq)\n    return ah, ph, qh\n</code></pre> <p>Timus - Crime and Punishment</p> <p>You're given integer numbers $A$, $B$ and $N$. Find $x \\geq 0$ and $y \\geq 0$ such that $Ax + By \\leq N$ and $Ax + By$ is the maximum possible.</p> Solution <p>In this problem it holds that $1 \\leq A, B, N \\leq 2 \\cdot 10^9$, so it can be solved in $O(\\sqrt N)$. However, there is $O(\\log N)$ solution with continued fractions.</p> <p>For our convenience, we will invert the direction of $x$ by doing a substitution $x \\mapsto \\lfloor \\frac{N}{A}\\rfloor - x$, so that now we need to find the point $(x; y)$ such that $0 \\leq x \\leq \\lfloor \\frac{N}{A} \\rfloor$, $By - Ax \\leq N \\;\\bmod\\; A$ and $By - Ax$ is the maximum possible. Optimal $y$ for each $x$ has a value of $\\lfloor \\frac{Ax + (N \\bmod A)}{B} \\rfloor$.</p> <p>To treat it more generically, we will write a function that finds the best point on $0 \\leq x \\leq N$ and $y = \\lfloor \\frac{Ax+B}{C} \\rfloor$.</p> <p>Core solution idea in this problem essentially repeats the previous problem, but instead of using lower semiconvergents to diverge from line, you use upper semiconvergents to get closer to the line without crossing it and without violating $x \\leq N$. Unfortunately, unlike the previous problem, you need to make sure that you don't cross the $y=\\frac{Ax+B}{C}$ line while getting closer to it, so you should keep it in mind when calculating semiconvergent's coefficient $t$.</p> Python <pre><code># (x, y) such that y = (A*x+B) // C,\n# Cy - Ax is max and 0 &lt;= x &lt;= N.\ndef closest(A, B, C, N):\n    # y &lt;= (A*x + B)/C &lt;=&gt; diff(x, y) &lt;= B\n    def diff(x, y):\n        return C*y-A*x\n    a = fraction(A, C)\n    p, q = convergents(a)\n    ph = [B // C]\n    qh = [0]\n    for i in range(2, len(q) - 1):\n        if i % 2 == 0:\n            while diff(qh[-1] + q[i+1], ph[-1] + p[i+1]) &lt;= B:\n                t = 1 + (diff(qh[-1] + q[i-1], ph[-1] + p[i-1]) - B - 1) // abs(diff(q[i], p[i]))\n                dp = p[i-1] + t*p[i]\n                dq = q[i-1] + t*q[i]\n                k = (N - qh[-1]) // dq\n                if k == 0:\n                    return qh[-1], ph[-1]\n                if diff(dq, dp) != 0:\n                    k = min(k, (B - diff(qh[-1], ph[-1])) // diff(dq, dp))\n                qh.append(qh[-1] + k*dq)\n                ph.append(ph[-1] + k*dp)\n    return qh[-1], ph[-1]\n\ndef solve(A, B, N):\n    x, y = closest(A, N % A, B, N // A)\n    return N // A - x, y\n</code></pre> <p>June Challenge 2017 - Euler Sum</p> <p>Compute $\\sum\\limits_{x=1}^N \\lfloor ex \\rfloor$, where $e = [2; 1, 2, 1, 1, 4, 1, 1, 6, 1, \\dots, 1, 2n, 1, \\dots]$ is the Euler's number and $N \\leq 10^{4000}$.</p> Solution <p>This sum is equal to the number of lattice point $(x;y)$ such that $1 \\leq x \\leq N$ and $1 \\leq y \\leq ex$.    </p> <p>After constructing the convex hull of the points below $y=ex$, this number can be computed using Pick's theorem:</p> C++Python <pre><code>// sum floor(k * x) for k in [1, N] and x = [a0; a1, a2, ...]\nint sum_floor(auto a, int N) {\n    N++;\n    auto [ah, ph, qh] = hull(a, N);\n\n    // The number of lattice points within a vertical right trapezoid\n    // on points (0; 0) - (0; y1) - (dx; y2) - (dx; 0) that has\n    // a+1 integer points on the segment (0; y1) - (dx; y2).\n    auto picks = [](int y1, int y2, int dx, int a) {\n        int b = y1 + y2 + a + dx;\n        int A = (y1 + y2) * dx;\n        return (A - b + 2) / 2 + b - (y2 + 1);\n    };\n\n    int ans = 0;\n    for(size_t i = 1; i &lt; qh.size(); i++) {\n        ans += picks(ph[i - 1], ph[i], qh[i] - qh[i - 1], ah[i - 1]);\n    }\n    return ans - N;\n}\n</code></pre> <pre><code># sum floor(k * x) for k in [1, N] and x = [a0; a1, a2, ...]\ndef sum_floor(a, N):\n    N += 1\n    ah, ph, qh = hull(a, N)\n\n    # The number of lattice points within a vertical right trapezoid\n    # on points (0; 0) - (0; y1) - (dx; y2) - (dx; 0) that has\n    # a+1 integer points on the segment (0; y1) - (dx; y2).\n    def picks(y1, y2, dx, a):\n        b = y1 + y2 + a + dx\n        A = (y1 + y2) * dx\n        return (A - b + 2) // 2 + b - (y2 + 1)\n\n    ans = 0\n    for i in range(1, len(qh)):\n        ans += picks(ph[i-1], ph[i], qh[i]-qh[i-1], ah[i-1])\n    return ans - N\n</code></pre> <p>NAIPC 2019 - It's a Mod, Mod, Mod, Mod World</p> <p>Given $p$, $q$ and $n$, compute $\\sum\\limits_{i=1}^n [p \\cdot i \\bmod q]$.</p> Solution <p>This problem reduces to the previous one if you note that $a \\bmod b = a - \\lfloor \\frac{a}{b} \\rfloor b$. With this fact, the sum reduces to</p> $$\\sum\\limits_{i=1}^n \\left(p \\cdot i - \\left\\lfloor \\frac{p \\cdot i}{q} \\right\\rfloor q\\right) = \\frac{pn(n+1)}{2}-q\\sum\\limits_{i=1}^n \\left\\lfloor \\frac{p \\cdot i}{q}\\right\\rfloor.$$ <p>However, summing up $\\lfloor rx \\rfloor$ for $x$ from $1$ to $N$ is something that we're capable of from the previous problem.</p> C++Python <pre><code>void solve(int p, int q, int N) {\n    cout &lt;&lt; p * N * (N + 1) / 2 - q * sum_floor(fraction(p, q), N) &lt;&lt; \"\\n\";\n}\n</code></pre> <pre><code>def solve(p, q, N):\n    return p * N * (N + 1) // 2 - q * sum_floor(fraction(p, q), N)\n</code></pre> <p>Library Checker - Sum of Floor of Linear</p> <p>Given $N$, $M$, $A$ and $B$, compute $\\sum\\limits_{i=0}^{N-1} \\lfloor \\frac{A \\cdot i + B}{M} \\rfloor$.</p> Solution <p>This is the most technically troublesome problem so far.</p> <p>It is possible to use the same approach and construct the full convex hull of points below the line $y = \\frac{Ax+B}{M}$.</p> <p>We already know how to solve it for $B = 0$. Moreover, we already know how to construct this convex hull up to the closest lattice point to this line on $[0, N-1]$ segment (this is done in the \"Crime and Punishment\" problem above.</p> <p>Now we should note that once we reached the closest point to the line, we can just assume that the line in fact passes through the closest point, as there are no other lattice points on $[0, N-1]$ in between the actual line and the line moved slightly below to pass through the closest point.</p> <p>That being said, to construct the full convex hull below the line $y=\\frac{Ax+B}{M}$ on $[0, N-1]$, we can construct it up to the closest point to the line on $[0, N-1]$ and then continue as if the line passes through this point, reusing algorithm for constructing convex hull with $B=0$:</p> Python <pre><code># hull of lattice (x, y) such that C*y &lt;= A*x+B\ndef hull(A, B, C, N):\n    def diff(x, y):\n        return C*y-A*x\n    a = fraction(A, C)\n    p, q = convergents(a)\n    ah = []\n    ph = [B // C]\n    qh = [0]\n\n    def insert(dq, dp):\n        k = (N - qh[-1]) // dq\n        if diff(dq, dp) &gt; 0:\n            k = min(k, (B - diff(qh[-1], ph[-1])) // diff(dq, dp))\n        ah.append(k)\n        qh.append(qh[-1] + k*dq)\n        ph.append(ph[-1] + k*dp)\n\n    for i in range(1, len(q) - 1):\n        if i % 2 == 0:\n            while diff(qh[-1] + q[i+1], ph[-1] + p[i+1]) &lt;= B:\n                t = (B - diff(qh[-1] + q[i+1], ph[-1] + p[i+1])) // abs(diff(q[i], p[i]))\n                dp = p[i+1] - t*p[i]\n                dq = q[i+1] - t*q[i]\n                if dq &lt; 0 or qh[-1] + dq &gt; N:\n                    break\n                insert(dq, dp)\n\n    insert(q[-1], p[-1])\n\n    for i in reversed(range(len(q))):\n        if i % 2 == 1:\n            while qh[-1] + q[i-1] &lt;= N:\n                t = (N - qh[-1] - q[i-1]) // q[i]\n                dp = p[i-1] + t*p[i]\n                dq = q[i-1] + t*q[i]\n                insert(dq, dp)\n    return ah, ph, qh\n</code></pre> <p>OKC 2 - From Modular to Rational</p> <p>There is a rational number $\\frac{p}{q}$ such that $1 \\leq p, q \\leq 10^9$. You may ask the value of $p q^{-1}$ modulo $m \\sim 10^9$ for several prime numbers $m$. Recover $\\frac{p}{q}$.</p> <p>Equivalent formulation: Find $x$ that delivers the minimum of $Ax \\;\\bmod\\; M$ for $1 \\leq x \\leq N$.</p> Solution <p>Due to Chinese remainder theorem, asking the result modulo several prime numbers is the same as asking it modulo their product. Due to this, without loss of generality we'll assume that we know the remainder modulo sufficiently large number $m$.</p> <p>There could be several possible solutions $(p, q)$ to $p \\equiv qr \\pmod m$ for a given remainder $r$. However, if $(p_1, q_1)$ and $(p_2, q_2)$ are both the solutions then it also holds that $p_1 q_2 \\equiv p_2 q_1 \\pmod m$. Assuming that $\\frac{p_1}{q_1} \\neq \\frac{p_2}{q_2}$ it means that $|p_1 q_2 - p_2 q_1|$ is at least $m$.</p> <p>In the statement we were told that $1 \\leq p, q \\leq 10^9$, so if both $p_1, q_1$ and $p_2, q_2$ are at most $10^9$, then the difference is at most $10^{18}$. For $m &gt; 10^{18}$ it means that the solution $\\frac{p}{q}$ with $1 \\leq p, q \\leq 10^9$ is unique, as a rational number.</p> <p>So, the problem boils down, given $r$ modulo $m$, to finding any $q$ such that $1 \\leq q \\leq 10^9$ and $qr \\;\\bmod\\; m \\leq 10^9$.</p> <p>This is effectively the same as finding $q$ that delivers the minimum possible $qr \\bmod m$ for $1 \\leq q \\leq 10^9$.</p> <p>For $qr = km + b$ it means that we need to find a pair $(q, m)$ such that $1 \\leq q \\leq 10^9$ and $qr - km \\geq 0$ is the minimum possible.</p> <p>Since $m$ is constant, we can divide by it and further restate it as find $q$ such that $1 \\leq q \\leq 10^9$ and $\\frac{r}{m} q - k \\geq 0$ is the minimum possible.</p> <p>In terms of continued fractions it means that $\\frac{k}{q}$ is the best diophantine approximation to $\\frac{r}{m}$ and it is sufficient to only check lower semiconvergents of $\\frac{r}{m}$.</p> Python <pre><code># find Q that minimizes Q*r mod m for 1 &lt;= k &lt;= n &lt; m \ndef mod_min(r, n, m):\n    a = fraction(r, m)\n    p, q = convergents(a)\n    for i in range(2, len(q)):\n        if i % 2 == 1 and (i + 1 == len(q) or q[i+1] &gt; n):\n            t = (n - q[i-1]) // q[i]\n            return q[i-1] + t*q[i]\n</code></pre>","tags":["Original"]},{"location":"algebra/continued-fractions.html#practice-problems","title":"Practice problems","text":"<ul> <li>UVa OJ - Continued Fractions</li> <li>ProjectEuler+ #64: Odd period square roots</li> <li>Codeforces Round #184 (Div. 2) - Continued Fractions</li> <li>Codeforces Round #201 (Div. 1) - Doodle Jump</li> <li>Codeforces Round #325 (Div. 1) - Alice, Bob, Oranges and Apples</li> <li>POJ Founder Monthly Contest 2008.03.16 - A Modular Arithmetic Challenge</li> <li>2019 Multi-University Training Contest 5 - fraction</li> <li>SnackDown 2019 Elimination Round - Election Bait</li> <li>Code Jam 2019 round 2 - Continued Fraction</li> </ul>","tags":["Original"]},{"location":"algebra/discrete-log.html","title":"Discrete Logarithm","text":"<p>The discrete logarithm is an integer $x$ satisfying the equation</p> $$a^x \\equiv b \\pmod m$$ <p>for given integers $a$, $b$ and $m$.</p> <p>The discrete logarithm does not always exist, for instance there is no solution to $2^x \\equiv 3 \\pmod 7$. There is no simple condition to determine if the discrete logarithm exists.</p> <p>In this article, we describe the Baby-step giant-step algorithm, an algorithm to compute the discrete logarithm proposed by Shanks in 1971, which has the time complexity $O(\\sqrt{m})$. This is a meet-in-the-middle algorithm because it uses the technique of separating tasks in half.</p>","tags":["Translated"]},{"location":"algebra/discrete-log.html#algorithm","title":"Algorithm","text":"<p>Consider the equation:</p> $$a^x \\equiv b \\pmod m,$$ <p>where $a$ and $m$ are relatively prime.</p> <p>Let $x = np - q$, where $n$ is some pre-selected constant (we will describe how to select $n$ later). $p$ is known as giant step, since increasing it by one increases $x$ by $n$. Similarly, $q$ is known as baby step.</p> <p>Obviously, any number $x$ in the interval $[0; m)$ can be represented in this form, where $p \\in [1; \\lceil \\frac{m}{n} \\rceil ]$ and $q \\in [0; n]$.</p> <p>Then, the equation becomes:</p> $$a^{np - q} \\equiv b \\pmod m.$$ <p>Using the fact that $a$ and $m$ are relatively prime, we obtain:</p> $$a^{np} \\equiv ba^q \\pmod m$$ <p>This new equation can be rewritten in a simplified form:</p> $$f_1(p) = f_2(q).$$ <p>This problem can be solved using the meet-in-the-middle method as follows:</p> <ul> <li>Calculate $f_1$ for all possible arguments $p$. Sort the array of value-argument pairs.</li> <li>For all possible arguments $q$, calculate $f_2$ and look for the corresponding $p$ in the sorted array using binary search.</li> </ul>","tags":["Translated"]},{"location":"algebra/discrete-log.html#complexity","title":"Complexity","text":"<p>We can calculate $f_1(p)$ in $O(\\log m)$ using the binary exponentiation algorithm. Similarly for $f_2(q)$.</p> <p>In the first step of the algorithm, we need to calculate $f_1$ for every possible argument $p$ and then sort the values. Thus, this step has complexity:</p> $$O\\left(\\left\\lceil \\frac{m}{n} \\right\\rceil \\left(\\log m + \\log \\left\\lceil \\frac{m}{n} \\right\\rceil \\right)\\right) = O\\left( \\left\\lceil \\frac {m}{n} \\right\\rceil \\log m\\right)$$ <p>In the second step of the algorithm, we need to calculate $f_2(q)$ for every possible argument $q$ and then do a binary search on the array of values of $f_1$, thus this step has complexity:</p> $$O\\left(n \\left(\\log m + \\log \\frac{m}{n} \\right) \\right) = O\\left(n \\log m\\right).$$ <p>Now, when we add these two complexities, we get $\\log m$ multiplied by the sum of $n$ and $m/n$, which is minimal when $n = m/n$, which means, to achieve optimal performance, $n$ should be chosen such that:</p> $$n = \\sqrt{m}.$$ <p>Then, the complexity of the algorithm becomes:</p> $$O(\\sqrt {m} \\log m).$$","tags":["Translated"]},{"location":"algebra/discrete-log.html#implementation","title":"Implementation","text":"","tags":["Translated"]},{"location":"algebra/discrete-log.html#the-simplest-implementation","title":"The simplest implementation","text":"<p>In the following code, the function <code>powmod</code> calculates $a^b \\pmod m$ and the function <code>solve</code> produces a proper solution to the problem. It returns $-1$ if there is no solution and returns one of the possible solutions otherwise.</p> <pre><code>int powmod(int a, int b, int m) {\n    int res = 1;\n    while (b &gt; 0) {\n        if (b &amp; 1) {\n            res = (res * 1ll * a) % m;\n        }\n        a = (a * 1ll * a) % m;\n        b &gt;&gt;= 1;\n    }\n    return res;\n}\n\nint solve(int a, int b, int m) {\n    a %= m, b %= m;\n    int n = sqrt(m) + 1;\n    map&lt;int, int&gt; vals;\n    for (int p = 1; p &lt;= n; ++p)\n        vals[powmod(a, p * n, m)] = p;\n    for (int q = 0; q &lt;= n; ++q) {\n        int cur = (powmod(a, q, m) * 1ll * b) % m;\n        if (vals.count(cur)) {\n            int ans = vals[cur] * n - q;\n            return ans;\n        }\n    }\n    return -1;\n}\n</code></pre> <p>In this code, we used <code>map</code> from the C++ standard library to store the values of $f_1$. Internally, <code>map</code> uses a red-black tree to store values. Thus this code is a little bit slower than if we had used an array and binary searched, but is much easier to write.</p> <p>Notice that our code assumes $0^0 = 1$, i.e. the code will compute $0$ as solution for the equation $0^x \\equiv 1 \\pmod m$ and also as solution for $0^x \\equiv 0 \\pmod 1$. This is an often used convention in algebra, but it's also not universally accepted in all areas. Sometimes $0^0$ is simply undefined. If you don't like our convention, then you need to handle the case $a=0$ separately:</p> <pre><code>    if (a == 0)\n        return b == 0 ? 1 : -1;\n</code></pre> <p>Another thing to note is that, if there are multiple arguments $p$ that map to the same value of $f_1$, we only store one such argument. This works in this case because we only want to return one possible solution. If we need to return all possible solutions, we need to change <code>map&lt;int, int&gt;</code> to, say, <code>map&lt;int, vector&lt;int&gt;&gt;</code>. We also need to change the second step accordingly.</p>","tags":["Translated"]},{"location":"algebra/discrete-log.html#improved-implementation","title":"Improved implementation","text":"<p>A possible improvement is to get rid of binary exponentiation. This can be done by keeping a variable that is multiplied by $a$ each time we increase $q$ and a variable that is multiplied by $a^n$ each time we increase $p$. With this change, the complexity of the algorithm is still the same, but now the $\\log$ factor is only for the <code>map</code>. Instead of a <code>map</code>, we can also use a hash table (<code>unordered_map</code> in C++) which has the average time complexity $O(1)$ for inserting and searching.</p> <p>Problems often ask for the minimum $x$ which satisfies the solution. It is possible to get all answers and take the minimum, or reduce the first found answer using Euler's theorem, but we can be smart about the order in which we calculate values and ensure the first answer we find is the minimum.</p> <pre><code>// Returns minimum x for which a ^ x % m = b % m, a and m are coprime.\nint solve(int a, int b, int m) {\n    a %= m, b %= m;\n    int n = sqrt(m) + 1;\n\n    int an = 1;\n    for (int i = 0; i &lt; n; ++i)\n        an = (an * 1ll * a) % m;\n\n    unordered_map&lt;int, int&gt; vals;\n    for (int q = 0, cur = b; q &lt;= n; ++q) {\n        vals[cur] = q;\n        cur = (cur * 1ll * a) % m;\n    }\n\n    for (int p = 1, cur = 1; p &lt;= n; ++p) {\n        cur = (cur * 1ll * an) % m;\n        if (vals.count(cur)) {\n            int ans = n * p - vals[cur];\n            return ans;\n        }\n    }\n    return -1;\n}\n</code></pre> <p>The complexity is $O(\\sqrt{m})$ using <code>unordered_map</code>.</p>","tags":["Translated"]},{"location":"algebra/discrete-log.html#when-a-and-m-are-not-coprime","title":"When $a$ and $m$ are not coprime","text":"<p>Let $g = \\gcd(a, m)$, and $g &gt; 1$. Clearly $a^x \\bmod m$ for every $x \\ge 1$ will be divisible by $g$.</p> <p>If $g \\nmid b$, there is no solution for $x$.</p> <p>If $g \\mid b$, let $a = g \\alpha, b = g \\beta, m = g \\nu$.</p> $$ \\begin{aligned} a^x &amp; \\equiv b \\mod m \\\\\\ (g \\alpha) a^{x - 1} &amp; \\equiv g \\beta \\mod g \\nu \\\\\\ \\alpha a^{x-1} &amp; \\equiv \\beta \\mod \\nu \\end{aligned} $$ <p>The baby-step giant-step algorithm can be easily extended to solve $ka^{x} \\equiv b \\pmod m$ for $x$.</p> <pre><code>// Returns minimum x for which a ^ x % m = b % m.\nint solve(int a, int b, int m) {\n    a %= m, b %= m;\n    int k = 1, add = 0, g;\n    while ((g = gcd(a, m)) &gt; 1) {\n        if (b == k)\n            return add;\n        if (b % g)\n            return -1;\n        b /= g, m /= g, ++add;\n        k = (k * 1ll * a / g) % m;\n    }\n\n    int n = sqrt(m) + 1;\n    int an = 1;\n    for (int i = 0; i &lt; n; ++i)\n        an = (an * 1ll * a) % m;\n\n    unordered_map&lt;int, int&gt; vals;\n    for (int q = 0, cur = b; q &lt;= n; ++q) {\n        vals[cur] = q;\n        cur = (cur * 1ll * a) % m;\n    }\n\n    for (int p = 1, cur = k; p &lt;= n; ++p) {\n        cur = (cur * 1ll * an) % m;\n        if (vals.count(cur)) {\n            int ans = n * p - vals[cur] + add;\n            return ans;\n        }\n    }\n    return -1;\n}\n</code></pre> <p>The time complexity remains $O(\\sqrt{m})$ as before since the initial reduction to coprime $a$ and $m$ is done in $O(\\log^2 m)$.</p>","tags":["Translated"]},{"location":"algebra/discrete-log.html#practice-problems","title":"Practice Problems","text":"<ul> <li>Spoj - Power Modulo Inverted</li> <li>Topcoder - SplittingFoxes3</li> <li>CodeChef - Inverse of a Function</li> <li>Hard Equation (assume that $0^0$ is undefined)</li> <li>CodeChef - Chef and Modular Sequence</li> </ul>","tags":["Translated"]},{"location":"algebra/discrete-log.html#references","title":"References","text":"<ul> <li>Wikipedia - Baby-step giant-step</li> <li>Answer by Zander on Mathematics StackExchange</li> </ul>","tags":["Translated"]},{"location":"algebra/discrete-root.html","title":"Discrete Root","text":"<p>The problem of finding a discrete root is defined as follows. Given a prime $n$ and two integers $a$ and $k$, find all $x$ for which:</p> <p>$x^k \\equiv a \\pmod n$</p>","tags":["Translated"]},{"location":"algebra/discrete-root.html#the-algorithm","title":"The algorithm","text":"<p>We will solve this problem by reducing it to the discrete logarithm problem.</p> <p>Let's apply the concept of a primitive root modulo $n$. Let $g$ be a primitive root modulo $n$. Note that since $n$ is prime, it must exist, and it can be found in $O(Ans \\cdot \\log \\phi (n) \\cdot \\log n) = O(Ans \\cdot \\log^2 n)$ plus time of factoring $\\phi (n)$.</p> <p>We can easily discard the case where $a = 0$. In this case, obviously there is only one answer: $x = 0$.</p> <p>Since we know that $n$ is a prime and any number between 1 and $n-1$ can be represented as a power of the primitive root, we can represent the discrete root problem as follows:</p> <p>$(g^y)^k \\equiv a \\pmod n$</p> <p>where</p> <p>$x \\equiv g^y \\pmod n$</p> <p>This, in turn, can be rewritten as</p> <p>$(g^k)^y \\equiv a \\pmod n$</p> <p>Now we have one unknown $y$, which is a discrete logarithm problem. The solution can be found using Shanks' baby-step giant-step algorithm in $O(\\sqrt {n} \\log n)$ (or we can verify that there are no solutions).</p> <p>Having found one solution $y_0$, one of solutions of discrete root problem will be $x_0 = g^{y_0} \\pmod n$.</p>","tags":["Translated"]},{"location":"algebra/discrete-root.html#finding-all-solutions-from-one-known-solution","title":"Finding all solutions from one known solution","text":"<p>To solve the given problem in full, we need to find all solutions knowing one of them: $x_0 = g^{y_0} \\pmod n$.</p> <p>Let's recall the fact that a primitive root always has order of $\\phi (n)$, i.e. the smallest power of $g$ which gives 1 is $\\phi (n)$. Therefore, if we add the term $\\phi (n)$ to the exponential, we still get the same value:</p> <p>$x^k \\equiv g^{ y_0 \\cdot k + l \\cdot \\phi (n)} \\equiv a \\pmod n \\forall l \\in Z$</p> <p>Hence, all the solutions are of the form:</p> <p>$x = g^{y_0 + \\frac {l \\cdot \\phi (n)}{k}} \\pmod n \\forall l \\in Z$.</p> <p>where $l$ is chosen such that the fraction must be an integer. For this to be true, the numerator has to be divisible by the least common multiple of  $\\phi (n)$ and $k$. Remember that least common multiple of two numbers $lcm(a, b) = \\frac{a \\cdot b}{gcd(a, b)}$; we'll get</p> <p>$x = g^{y_0 + i \\frac {\\phi (n)}{gcd(k, \\phi (n))}} \\pmod n \\forall i \\in Z$.</p> <p>This is the final formula for all solutions of the discrete root problem.</p>","tags":["Translated"]},{"location":"algebra/discrete-root.html#implementation","title":"Implementation","text":"<p>Here is a full implementation, including procedures for finding the primitive root, discrete log and finding and printing all solutions.</p> <pre><code>int gcd(int a, int b) {\n    return a ? gcd(b % a, a) : b;\n}\n\nint powmod(int a, int b, int p) {\n    int res = 1;\n    while (b &gt; 0) {\n        if (b &amp; 1) {\n            res = res * a % p;\n        }\n        a = a * a % p;\n        b &gt;&gt;= 1;\n    }\n    return res;\n}\n\n// Finds the primitive root modulo p\nint generator(int p) {\n    vector&lt;int&gt; fact;\n    int phi = p-1, n = phi;\n    for (int i = 2; i * i &lt;= n; ++i) {\n        if (n % i == 0) {\n            fact.push_back(i);\n            while (n % i == 0)\n                n /= i;\n        }\n    }\n    if (n &gt; 1)\n        fact.push_back(n);\n\n    for (int res = 2; res &lt;= p; ++res) {\n        bool ok = true;\n        for (int factor : fact) {\n            if (powmod(res, phi / factor, p) == 1) {\n                ok = false;\n                break;\n            }\n        }\n        if (ok) return res;\n    }\n    return -1;\n}\n\n// This program finds all numbers x such that x^k = a (mod n)\nint main() {\n    int n, k, a;\n    scanf(\"%d %d %d\", &amp;n, &amp;k, &amp;a);\n    if (a == 0) {\n        puts(\"1\\n0\");\n        return 0;\n    }\n\n    int g = generator(n);\n\n    // Baby-step giant-step discrete logarithm algorithm\n    int sq = (int) sqrt (n + .0) + 1;\n    vector&lt;pair&lt;int, int&gt;&gt; dec(sq);\n    for (int i = 1; i &lt;= sq; ++i)\n        dec[i-1] = {powmod(g, i * sq * k % (n - 1), n), i};\n    sort(dec.begin(), dec.end());\n    int any_ans = -1;\n    for (int i = 0; i &lt; sq; ++i) {\n        int my = powmod(g, i * k % (n - 1), n) * a % n;\n        auto it = lower_bound(dec.begin(), dec.end(), make_pair(my, 0));\n        if (it != dec.end() &amp;&amp; it-&gt;first == my) {\n            any_ans = it-&gt;second * sq - i;\n            break;\n        }\n    }\n    if (any_ans == -1) {\n        puts(\"0\");\n        return 0;\n    }\n\n    // Print all possible answers\n    int delta = (n-1) / gcd(k, n-1);\n    vector&lt;int&gt; ans;\n    for (int cur = any_ans % delta; cur &lt; n-1; cur += delta)\n        ans.push_back(powmod(g, cur, n));\n    sort(ans.begin(), ans.end());\n    printf(\"%d\\n\", ans.size());\n    for (int answer : ans)\n        printf(\"%d \", answer);\n}\n</code></pre>","tags":["Translated"]},{"location":"algebra/discrete-root.html#practice-problems","title":"Practice problems","text":"<ul> <li>Codeforces - Lunar New Year and a Recursive Sequence</li> </ul>","tags":["Translated"]},{"location":"algebra/divisors.html","title":"Number of divisors / sum of divisors","text":"<p>In this article we discuss how to compute the number of divisors $d(n)$ and the sum of divisors $\\sigma(n)$ of a given number $n$.</p>","tags":["Original"]},{"location":"algebra/divisors.html#number-of-divisors","title":"Number of divisors","text":"<p>It should be obvious that the prime factorization of a divisor $d$ has to be a subset of the prime factorization of $n$, e.g. $6 = 2 \\cdot 3$ is a divisor of $60 = 2^2 \\cdot 3 \\cdot 5$. So we only need to find all different subsets of the prime factorization of $n$.</p> <p>Usually the number of subsets is $2^x$ for a set with $x$ elements. However this is no longer true, if there are repeated elements in the set. In our case some prime factors may appear multiple times in the prime factorization of $n$.</p> <p>If a prime factor $p$ appears $e$ times in the prime factorization of $n$, then we can use the factor $p$ up to $e$ times in the subset. Which means we have $e+1$ choices.</p> <p>Therefore if the prime factorization of $n$ is $p_1^{e_1} \\cdot p_2^{e_2} \\cdots p_k^{e_k}$, where $p_i$ are distinct prime numbers, then the number of divisors is:</p> $$d(n) = (e_1 + 1) \\cdot (e_2 + 1) \\cdots (e_k + 1)$$ <p>A way of thinking about it is the following:</p> <ul> <li> <p>If there is only one distinct prime divisor $n = p_1^{e_1}$, then there are obviously $e_1 + 1$ divisors ($1, p_1, p_1^2, \\dots, p_1^{e_1}$).</p> </li> <li> <p>If there are two distinct prime divisors $n = p_1^{e_1} \\cdot p_2^{e_2}$, then you can arrange all divisors in form of a tabular.</p> </li> </ul> $$\\begin{array}{c|ccccc} &amp; 1 &amp; p_2 &amp; p_2^2 &amp; \\dots &amp; p_2^{e_2} \\\\\\\\\\hline 1 &amp; 1 &amp; p_2 &amp; p_2^2 &amp; \\dots &amp; p_2^{e_2} \\\\\\\\ p_1 &amp; p_1 &amp; p_1 \\cdot p_2 &amp; p_1 \\cdot p_2^2 &amp; \\dots &amp; p_1 \\cdot p_2^{e_2} \\\\\\\\ p_1^2 &amp; p_1^2 &amp; p_1^2 \\cdot p_2 &amp; p_1^2 \\cdot p_2^2 &amp; \\dots &amp; p_1^2 \\cdot p_2^{e_2} \\\\\\\\ \\vdots &amp; \\vdots &amp; \\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots \\\\\\\\ p_1^{e_1} &amp; p_1^{e_1} &amp; p_1^{e_1} \\cdot p_2 &amp; p_1^{e_1} \\cdot p_2^2 &amp; \\dots &amp; p_1^{e_1} \\cdot p_2^{e_2} \\\\\\\\ \\end{array}$$ <p>So the number of divisors is trivially $(e_1 + 1) \\cdot (e_2 + 1)$.</p> <ul> <li>A similar argument can be made if there are more then two distinct prime factors.</li> </ul> <pre><code>long long numberOfDivisors(long long num) {\n    long long total = 1;\n    for (int i = 2; (long long)i * i &lt;= num; i++) {\n        if (num % i == 0) {\n            int e = 0;\n            do {\n                e++;\n                num /= i;\n            } while (num % i == 0);\n            total *= e + 1;\n        }\n    }\n    if (num &gt; 1) {\n        total *= 2;\n    }\n    return total;\n}\n</code></pre>","tags":["Original"]},{"location":"algebra/divisors.html#sum-of-divisors","title":"Sum of divisors","text":"<p>We can use the same argument of the previous section.</p> <ul> <li>If there is only one distinct prime divisor $n = p_1^{e_1}$, then the sum is:</li> </ul> $$1 + p_1 + p_1^2 + \\dots + p_1^{e_1} = \\frac{p_1^{e_1 + 1} - 1}{p_1 - 1}$$ <ul> <li>If there are two distinct prime divisors $n = p_1^{e_1} \\cdot p_2^{e_2}$, then we can make the same table as before.   The only difference is that now we now want to compute the sum instead of counting the elements.   It is easy to see, that the sum of each combination can be expressed as:</li> </ul> $$\\left(1 + p_1 + p_1^2 + \\dots + p_1^{e_1}\\right) \\cdot \\left(1 + p_2 + p_2^2 + \\dots + p_2^{e_2}\\right)$$ $$ = \\frac{p_1^{e_1 + 1} - 1}{p_1 - 1} \\cdot \\frac{p_2^{e_2 + 1} - 1}{p_2 - 1}$$ <ul> <li>In general, for $n = p_1^{e_1} \\cdot p_2^{e_2} \\cdots p_k^{e_k}$ we receive the formula:</li> </ul> $$\\sigma(n) = \\frac{p_1^{e_1 + 1} - 1}{p_1 - 1} \\cdot \\frac{p_2^{e_2 + 1} - 1}{p_2 - 1} \\cdots \\frac{p_k^{e_k + 1} - 1}{p_k - 1}$$ <pre><code>long long SumOfDivisors(long long num) {\n    long long total = 1;\n\n    for (int i = 2; (long long)i * i &lt;= num; i++) {\n        if (num % i == 0) {\n            int e = 0;\n            do {\n                e++;\n                num /= i;\n            } while (num % i == 0);\n\n            long long sum = 0, pow = 1;\n            do {\n                sum += pow;\n                pow *= i;\n            } while (e-- &gt; 0);\n            total *= sum;\n        }\n    }\n    if (num &gt; 1) {\n        total *= (1 + num);\n    }\n    return total;\n}\n</code></pre>","tags":["Original"]},{"location":"algebra/divisors.html#multiplicative-functions","title":"Multiplicative functions","text":"<p>A multiplicative function is a function $f(x)$ which satisfies</p> $$f(a \\cdot b) = f(a) \\cdot f(b)$$ <p>if $a$ and $b$ are coprime.</p> <p>Both $d(n)$ and $\\sigma(n)$ are multiplicative functions.</p> <p>Multiplicative functions have a huge variety of interesting properties, which can be very useful in number theory problems. For instance the Dirichlet convolution of two multiplicative functions is also multiplicative.</p>","tags":["Original"]},{"location":"algebra/divisors.html#practice-problems","title":"Practice Problems","text":"<ul> <li>SPOJ - COMDIV</li> <li>SPOJ - DIVSUM</li> <li>SPOJ - DIVSUM2</li> </ul>","tags":["Original"]},{"location":"algebra/euclid-algorithm.html","title":"Euclidean algorithm for computing the greatest common divisor","text":"<p>Given two non-negative integers $a$ and $b$, we have to find their GCD (greatest common divisor), i.e. the largest number which is a divisor of both $a$ and $b$. It's commonly denoted by $\\gcd(a, b)$. Mathematically it is defined as:</p> $$\\gcd(a, b) = \\max \\{k &gt; 0 : (k \\mid a) \\text{ and } (k \\mid b) \\}$$ <p>(here the symbol \"$\\mid$\" denotes divisibility, i.e. \"$k \\mid a$\" means \"$k$ divides $a$\")</p> <p>When one of the numbers is zero, while the other is non-zero, their greatest common divisor, by definition, is the second number. When both numbers are zero, their greatest common divisor is undefined (it can be any arbitrarily large number), but it is convenient to define it as zero as well to preserve the associativity of $\\gcd$. Which gives us a simple rule: if one of the numbers is zero, the greatest common divisor is the other number.</p> <p>The Euclidean algorithm, discussed below, allows to find the greatest common divisor of two numbers $a$ and $b$ in $O(\\log \\min(a, b))$. Since the function is associative, to find the GCD of more than two numbers, we can do $\\gcd(a, b, c) = \\gcd(a, \\gcd(b, c))$ and so forth.</p> <p>The algorithm was first described in Euclid's \"Elements\" (circa 300 BC), but it is possible that the algorithm has even earlier origins.</p>","tags":["Translated"]},{"location":"algebra/euclid-algorithm.html#algorithm","title":"Algorithm","text":"<p>Originally, the Euclidean algorithm was formulated as follows: subtract the smaller number from the larger one until one of the numbers is zero. Indeed, if $g$ divides $a$ and $b$, it also divides $a-b$. On the other hand, if $g$ divides $a-b$ and $b$, then it also divides $a = b + (a-b)$, which means that the sets of the common divisors of $\\{a, b\\}$ and $\\{b,a-b\\}$ coincide.</p> <p>Note that $a$ remains the larger number until $b$ is subtracted from it at least $\\left\\lfloor\\frac{a}{b}\\right\\rfloor$ times. Therefore, to speed things up, $a-b$ is substituted with $a-\\left\\lfloor\\frac{a}{b}\\right\\rfloor b = a \\bmod b$. Then the algorithm is formulated in an extremely simple way:</p> $$\\gcd(a, b) = \\begin{cases}a,&amp;\\text{if }b = 0 \\\\ \\gcd(b, a \\bmod b),&amp;\\text{otherwise.}\\end{cases}$$","tags":["Translated"]},{"location":"algebra/euclid-algorithm.html#implementation","title":"Implementation","text":"<pre><code>int gcd (int a, int b) {\n    if (b == 0)\n        return a;\n    else\n        return gcd (b, a % b);\n}\n</code></pre> <p>Using the ternary operator in C++, we can write it as a one-liner.</p> <pre><code>int gcd (int a, int b) {\n    return b ? gcd (b, a % b) : a;\n}\n</code></pre> <p>And finally, here is a non-recursive implementation:</p> <pre><code>int gcd (int a, int b) {\n    while (b) {\n        a %= b;\n        swap(a, b);\n    }\n    return a;\n}\n</code></pre> <p>Note that since C++17, <code>gcd</code> is implemented as a standard function in C++.</p>","tags":["Translated"]},{"location":"algebra/euclid-algorithm.html#time-complexity","title":"Time Complexity","text":"<p>The running time of the algorithm is estimated by Lam\u00e9's theorem, which establishes a surprising connection between the Euclidean algorithm and the Fibonacci sequence:</p> <p>If $a &gt; b \\geq 1$ and $b &lt; F_n$ for some $n$, the Euclidean algorithm performs at most $n-2$ recursive calls.</p> <p>Moreover, it is possible to show that the upper bound of this theorem is optimal. When $a = F_n$ and $b = F_{n-1}$, $gcd(a, b)$ will perform exactly $n-2$ recursive calls. In other words, consecutive Fibonacci numbers are the worst case input for Euclid's algorithm.</p> <p>Given that Fibonacci numbers grow exponentially, we get that the Euclidean algorithm works in $O(\\log \\min(a, b))$.</p> <p>Another way to estimate the complexity is to notice that $a \\bmod b$ for the case $a \\geq b$ is at least $2$ times smaller than $a$, so the larger number is reduced at least in half on each iteration of the algorithm. Applying this reasoning to the case when we compute the GCD of the set of numbers $a_1,\\dots,a_n \\leq C$, this also allows us to estimate the total runtime as $O(n + \\log C)$, rather than $O(n \\log C)$, since every non-trivial iteration of the algorithm reduces the current GCD candidate by at least a factor of $2$.</p>","tags":["Translated"]},{"location":"algebra/euclid-algorithm.html#least-common-multiple","title":"Least common multiple","text":"<p>Calculating the least common multiple (commonly denoted LCM) can be reduced to calculating the GCD with the following simple formula:</p> $$\\text{lcm}(a, b) = \\frac{a \\cdot b}{\\gcd(a, b)}$$ <p>Thus, LCM can be calculated using the Euclidean algorithm with the same time complexity:</p> <p>A possible implementation, that cleverly avoids integer overflows by first dividing $a$ with the GCD, is given here:</p> <pre><code>int lcm (int a, int b) {\n    return a / gcd(a, b) * b;\n}\n</code></pre>","tags":["Translated"]},{"location":"algebra/euclid-algorithm.html#binary-gcd","title":"Binary GCD","text":"<p>The Binary GCD algorithm is an optimization to the normal Euclidean algorithm.</p> <p>The slow part of the normal algorithm are the modulo operations. Modulo operations, although we see them as $O(1)$, are a lot slower than simpler operations like addition, subtraction or bitwise operations. So it would be better to avoid those.</p> <p>It turns out, that you can design a fast GCD algorithm that avoids modulo operations. It's based on a few properties:</p> <ul> <li>If both numbers are even, then we can factor out a two of both and compute the GCD of the remaining numbers: $\\gcd(2a, 2b) = 2 \\gcd(a, b)$.</li> <li>If one of the numbers is even and the other one is odd, then we can remove the factor 2 from the even one: $\\gcd(2a, b) = \\gcd(a, b)$ if $b$ is odd.</li> <li>If both numbers are odd, then subtracting one number of the other one will not change the GCD: $\\gcd(a, b) = \\gcd(b, a-b)$</li> </ul> <p>Using only these properties, and some fast bitwise functions from GCC, we can implement a fast version:</p> <pre><code>int gcd(int a, int b) {\n    if (!a || !b)\n        return a | b;\n    unsigned shift = __builtin_ctz(a | b);\n    a &gt;&gt;= __builtin_ctz(a);\n    do {\n        b &gt;&gt;= __builtin_ctz(b);\n        if (a &gt; b)\n            swap(a, b);\n        b -= a;\n    } while (b);\n    return a &lt;&lt; shift;\n}\n</code></pre> <p>Notice, that such an optimization is usually not necessary, and most programming languages already have a GCD function in their standard libraries. E.g. C++17 has such a function <code>std::gcd</code> in the <code>numeric</code> header.</p>","tags":["Translated"]},{"location":"algebra/euclid-algorithm.html#practice-problems","title":"Practice Problems","text":"<ul> <li>CSAcademy - Greatest Common Divisor</li> <li>Codeforces 1916B - Two Divisors</li> </ul>","tags":["Translated"]},{"location":"algebra/extended-euclid-algorithm.html","title":"Extended Euclidean Algorithm","text":"<p>While the Euclidean algorithm calculates only the greatest common divisor (GCD) of two integers $a$ and $b$, the extended version also finds a way to represent GCD in terms of $a$ and $b$, i.e. coefficients $x$ and $y$ for which:</p> $$a \\cdot x + b \\cdot y = \\gcd(a, b)$$ <p>It's important to note that by B\u00e9zout's identity we can always find such a representation. For instance, $\\gcd(55, 80) = 5$, therefore we can represent $5$ as a linear combination with the terms $55$ and $80$: $55 \\cdot 3 + 80 \\cdot (-2) = 5$ </p> <p>A more general form of that problem is discussed in the article about Linear Diophantine Equations. It will build upon this algorithm.</p>","tags":["Translated"]},{"location":"algebra/extended-euclid-algorithm.html#algorithm","title":"Algorithm","text":"<p>We will denote the GCD of $a$ and $b$ with $g$ in this section.</p> <p>The changes to the original algorithm are very simple. If we recall the algorithm, we can see that the algorithm ends with $b = 0$ and $a = g$. For these parameters we can easily find coefficients, namely $g \\cdot 1 + 0 \\cdot 0 = g$.</p> <p>Starting from these coefficients $(x, y) = (1, 0)$, we can go backwards up the recursive calls. All we need to do is to figure out how the coefficients $x$ and $y$ change during the transition from $(a, b)$ to $(b, a \\bmod b)$.</p> <p>Let us assume we found the coefficients $(x_1, y_1)$ for $(b, a \\bmod b)$:</p> $$b \\cdot x_1 + (a \\bmod b) \\cdot y_1 = g$$ <p>and we want to find the pair $(x, y)$ for $(a, b)$:</p> $$ a \\cdot x + b \\cdot y = g$$ <p>We can represent $a \\bmod b$ as:</p> $$ a \\bmod b = a - \\left\\lfloor \\frac{a}{b} \\right\\rfloor \\cdot b$$ <p>Substituting this expression in the coefficient equation of $(x_1, y_1)$ gives:</p> $$ g = b \\cdot x_1 + (a \\bmod b) \\cdot y_1 = b \\cdot x_1 + \\left(a - \\left\\lfloor \\frac{a}{b} \\right\\rfloor \\cdot b \\right) \\cdot y_1$$ <p>and after rearranging the terms:</p> $$g = a \\cdot y_1 + b \\cdot \\left( x_1 - y_1 \\cdot \\left\\lfloor \\frac{a}{b} \\right\\rfloor \\right)$$ <p>We found the values of $x$ and $y$:</p> $$\\begin{cases} x = y_1 \\\\ y = x_1 - y_1 \\cdot \\left\\lfloor \\frac{a}{b} \\right\\rfloor \\end{cases} $$","tags":["Translated"]},{"location":"algebra/extended-euclid-algorithm.html#implementation","title":"Implementation","text":"<pre><code>int gcd(int a, int b, int&amp; x, int&amp; y) {\n    if (b == 0) {\n        x = 1;\n        y = 0;\n        return a;\n    }\n    int x1, y1;\n    int d = gcd(b, a % b, x1, y1);\n    x = y1;\n    y = x1 - y1 * (a / b);\n    return d;\n}\n</code></pre> <p>The recursive function above returns the GCD and the values of coefficients to <code>x</code> and <code>y</code> (which are passed by reference to the function).</p> <p>This implementation of extended Euclidean algorithm produces correct results for negative integers as well.</p>","tags":["Translated"]},{"location":"algebra/extended-euclid-algorithm.html#iterative-version","title":"Iterative version","text":"<p>It's also possible to write the Extended Euclidean algorithm in an iterative way. Because it avoids recursion, the code will run a little bit faster than the recursive one.</p> <pre><code>int gcd(int a, int b, int&amp; x, int&amp; y) {\n    x = 1, y = 0;\n    int x1 = 0, y1 = 1, a1 = a, b1 = b;\n    while (b1) {\n        int q = a1 / b1;\n        tie(x, x1) = make_tuple(x1, x - q * x1);\n        tie(y, y1) = make_tuple(y1, y - q * y1);\n        tie(a1, b1) = make_tuple(b1, a1 - q * b1);\n    }\n    return a1;\n}\n</code></pre> <p>If you look closely at the variables <code>a1</code> and <code>b1</code>, you can notice that they take exactly the same values as in the iterative version of the normal Euclidean algorithm. So the algorithm will at least compute the correct GCD.</p> <p>To see why the algorithm computes the correct coefficients, consider that the following invariants hold at any given time (before the while loop begins and at the end of each iteration):</p> $$x \\cdot a + y \\cdot b = a_1$$ $$x_1 \\cdot a + y_1 \\cdot b = b_1$$ <p>Let the values at the end of an iteration be denoted by a prime ($'$), and assume $q = \\frac{a_1}{b_1}$. From the Euclidean algorithm, we have:</p> $$a_1' = b_1$$ $$b_1' = a_1 - q \\cdot b_1$$ <p>For the first invariant to hold, the following should be true:</p> $$x' \\cdot a + y' \\cdot b = a_1' = b_1$$ $$x' \\cdot a + y' \\cdot b = x_1 \\cdot a + y_1 \\cdot b$$ <p>Similarly for the second invariant, the following should hold:</p> $$x_1' \\cdot a + y_1' \\cdot b = a_1 - q \\cdot b_1$$ $$x_1' \\cdot a + y_1' \\cdot b = (x - q \\cdot x_1) \\cdot a + (y - q \\cdot y_1) \\cdot b$$ <p>By comparing the coefficients of $a$ and $b$, the update equations for each variable can be derived, ensuring that the invariants are maintained throughout the algorithm.</p> <p>At the end we know that $a_1$ contains the GCD, so $x \\cdot a + y \\cdot b = g$. Which means that we have found the required coefficients.</p> <p>You can even optimize the code more, and remove the variable $a_1$ and $b_1$ from the code, and just reuse $a$ and $b$. However if you do so, you lose the ability to argue about the invariants.</p>","tags":["Translated"]},{"location":"algebra/extended-euclid-algorithm.html#practice-problems","title":"Practice Problems","text":"<ul> <li>UVA - 10104 - Euclid Problem</li> <li>GYM - (J) Once Upon A Time</li> <li>UVA - 12775 - Gift Dilemma</li> </ul>","tags":["Translated"]},{"location":"algebra/factorial-divisors.html","title":"Finding Power of Factorial Divisor","text":"<p>You are given two numbers $n$ and $k$. Find the largest power of $k$ $x$ such that $n!$ is divisible by $k^x$.</p>","tags":["Translated"]},{"location":"algebra/factorial-divisors.html#prime-k","title":"Prime $k$","text":"<p>Let's first consider the case of prime $k$. The explicit expression for factorial</p> $$n! = 1 \\cdot 2 \\cdot 3 \\ldots (n-1) \\cdot n$$ <p>Note that every $k$-th element of the product is divisible by $k$, i.e. adds $+1$ to the answer; the number of such elements is $\\Bigl\\lfloor\\dfrac{n}{k}\\Bigr\\rfloor$.</p> <p>Next, every $k^2$-th element is divisible by $k^2$, i.e. adds another $+1$ to the answer (the first power of $k$ has already been counted in the previous paragraph). The number of such elements is $\\Bigl\\lfloor\\dfrac{n}{k^2}\\Bigr\\rfloor$.</p> <p>And so on, for every $i$ each $k^i$-th element adds another $+1$ to the answer, and there are $\\Bigl\\lfloor\\dfrac{n}{k^i}\\Bigr\\rfloor$ such elements.</p> <p>The final answer is</p> $$\\Bigl\\lfloor\\dfrac{n}{k}\\Bigr\\rfloor + \\Bigl\\lfloor\\dfrac{n}{k^2}\\Bigr\\rfloor + \\ldots + \\Bigl\\lfloor\\dfrac{n}{k^i}\\Bigr\\rfloor + \\ldots$$ <p>This result is also known as Legendre's formula. The sum is of course finite, since only approximately the first $\\log_k n$ elements are not zeros. Thus, the runtime of this algorithm is $O(\\log_k n)$.</p>","tags":["Translated"]},{"location":"algebra/factorial-divisors.html#implementation","title":"Implementation","text":"<pre><code>int fact_pow (int n, int k) {\n    int res = 0;\n    while (n) {\n        n /= k;\n        res += n;\n    }\n    return res;\n}\n</code></pre>","tags":["Translated"]},{"location":"algebra/factorial-divisors.html#composite-k","title":"Composite $k$","text":"<p>The same idea can't be applied directly. Instead we can factor $k$, representing it as $k = k_1^{p_1} \\cdot \\ldots \\cdot k_m^{p_m}$. For each $k_i$, we find the number of times it is present in $n!$ using the algorithm described above - let's call this value $a_i$. The answer for composite $k$ will be</p> $$\\min_ {i=1 \\ldots m} \\dfrac{a_i}{p_i}$$","tags":["Translated"]},{"location":"algebra/factorial-modulo.html","title":"Factorial modulo $p$","text":"<p>In some cases it is necessary to consider complex formulas modulo some prime $p$, containing factorials in both numerator and denominator, like such that you encounter in the formula for Binomial coefficients. We consider the case when $p$ is relatively small. This problem makes only sense when the factorials appear in both numerator and denominator of fractions. Otherwise $p!$ and subsequent terms will reduce to zero. But in fractions the factors of $p$ can cancel, and the resulting expression will be non-zero modulo $p$.</p> <p>Thus, formally the task is: You want to calculate $n! \\bmod p$, without taking all the multiple factors of $p$ into account that appear in the factorial. Imagine you write down the prime factorization of $n!$, remove all factors $p$, and compute the product modulo $p$. We will denote this modified factorial with $n!_{\\%p}$. For instance $7!_{\\%p} \\equiv 1 \\cdot 2 \\cdot \\underbrace{1}_{3} \\cdot 4 \\cdot 5 \\underbrace{2}_{6} \\cdot 7 \\equiv 2 \\bmod 3$.</p> <p>Learning how to effectively calculate this modified factorial allows us to quickly calculate the value of the various combinatorial formulas (for example, Binomial coefficients).</p>","tags":["Translated"]},{"location":"algebra/factorial-modulo.html#algorithm","title":"Algorithm","text":"<p>Let's write this modified factorial explicitly.</p> $$\\begin{eqnarray} n!_{\\%p} &amp;=&amp; 1 \\cdot 2 \\cdot 3 \\cdot \\ldots \\cdot (p-2) \\cdot (p-1) \\cdot \\underbrace{1}_{p} \\cdot (p+1) \\cdot (p+2) \\cdot \\ldots \\cdot (2p-1) \\cdot \\underbrace{2}_{2p} \\\\\\  &amp; &amp;\\quad \\cdot (2p+1) \\cdot \\ldots \\cdot (p^2-1) \\cdot \\underbrace{1}_{p^2} \\cdot (p^2 +1) \\cdot \\ldots \\cdot n \\pmod{p} \\\\\\\\ &amp;=&amp; 1 \\cdot 2 \\cdot 3 \\cdot \\ldots \\cdot (p-2) \\cdot (p-1) \\cdot \\underbrace{1}_{p} \\cdot 1 \\cdot 2 \\cdot \\ldots \\cdot (p-1) \\cdot \\underbrace{2}_{2p} \\cdot 1 \\cdot 2 \\\\\\ &amp; &amp;\\quad \\cdot \\ldots \\cdot (p-1) \\cdot \\underbrace{1}_{p^2} \\cdot 1 \\cdot 2 \\cdot \\ldots \\cdot (n \\bmod p) \\pmod{p} \\end{eqnarray}$$ <p>It can be clearly seen that factorial is divided into several blocks of same length except for the last one.</p> $$\\begin{eqnarray} n!_{\\%p}&amp;=&amp; \\underbrace{1 \\cdot 2 \\cdot 3 \\cdot \\ldots \\cdot (p-2) \\cdot (p-1) \\cdot 1}_{1\\text{st}} \\cdot \\underbrace{1 \\cdot 2 \\cdot 3 \\cdot \\ldots \\cdot (p-2) \\cdot (p-1) \\cdot 2}_{2\\text{nd}} \\cdot \\ldots \\\\\\\\ &amp; &amp; \\cdot \\underbrace{1 \\cdot 2 \\cdot 3 \\cdot \\ldots \\cdot (p-2) \\cdot (p-1) \\cdot 1}_{p\\text{th}} \\cdot \\ldots \\cdot \\quad \\underbrace{1 \\cdot 2 \\cdot \\cdot \\ldots \\cdot (n \\bmod p)}_{\\text{tail}} \\pmod{p}. \\end{eqnarray}$$ <p>The main part of the blocks it is easy to count \u2014 it's just $(p-1)!\\ \\mathrm{mod}\\ p$. We can compute that programmatically or just apply Wilson theorem which states that $(p-1)! \\bmod p = -1$ for any prime $p$.</p> <p>We have exactly $\\lfloor \\frac{n}{p} \\rfloor$ such blocks, therefore we need to raise $-1$ to the power of $\\lfloor \\frac{n}{p} \\rfloor$. This can be done in logarithmic time using Binary Exponentiation; however you can also notice that the result will switch between $-1$ and $1$, so we only need to look at the parity of the exponent and multiply by $-1$ if the parity is odd. And instead of a multiplication, we can also just subtract the current result from $p$.</p> <p>The value of the last partial block can be calculated separately in $O(p)$.</p> <p>This leaves only the last element of each block. If we hide the already handled elements, we can see the following pattern:</p> $$n!_{\\%p} = \\underbrace{ \\ldots \\cdot 1 } \\cdot \\underbrace{ \\ldots \\cdot 2} \\cdot \\ldots \\cdot \\underbrace{ \\ldots \\cdot (p-1)} \\cdot \\underbrace{ \\ldots \\cdot 1 } \\cdot \\underbrace{ \\ldots \\cdot 1} \\cdot \\underbrace{ \\ldots \\cdot 2} \\cdots$$ <p>This again is a modified factorial, only with a much smaller dimension. It's $\\lfloor n / p \\rfloor !_{\\%p}$.</p> <p>Thus, during the calculation of the modified factorial $n\\!_{\\%p}$ we did $O(p)$ operations and are left with the calculation of $\\lfloor n / p \\rfloor !_{\\%p}$. We have a recursive formula. The recursion depth is $O(\\log_p n)$, and therefore the complete asymptotic behavior of the algorithm is $O(p \\log_p n)$.</p> <p>Notice, if you precompute the factorials $0!,~ 1!,~ 2!,~ \\dots,~ (p-1)!$ modulo $p$, then the complexity will just be $O(\\log_p n)$.</p>","tags":["Translated"]},{"location":"algebra/factorial-modulo.html#implementation","title":"Implementation","text":"<p>We don't need recursion because this is a case of tail recursion and thus can be easily implemented using iteration. In the following implementation we precompute the factorials $0!,~ 1!,~ \\dots,~ (p-1)!$, and thus have the runtime $O(p + \\log_p n)$. If you need to call the function multiple times, then you can do the precomputation outside of the function and do the computation of $n!_{\\%p}$ in $O(\\log_p n)$ time.</p> <pre><code>int factmod(int n, int p) {\n    vector&lt;int&gt; f(p);\n    f[0] = 1;\n    for (int i = 1; i &lt; p; i++)\n        f[i] = f[i-1] * i % p;\n\n    int res = 1;\n    while (n &gt; 1) {\n        if ((n/p) % 2)\n            res = p - res;\n        res = res * f[n%p] % p;\n        n /= p;\n    }\n    return res;\n}\n</code></pre> <p>Alternative, if you only have limit memory and can't afford storing all factorials, you can also just remember the factorials that you need, sort them, and then compute them in one sweep by computing the factorials $0!,~ 1!,~ 2!,~ \\dots,~ (p-1)!$ in a loop without storing them explicitly.</p>","tags":["Translated"]},{"location":"algebra/factorial-modulo.html#multiplicity-of-p","title":"Multiplicity of $p$","text":"<p>If we want to compute a Binomial coefficient modulo $p$, then we additionally need the multiplicity of the $p$ in $n$, i.e. the number of times $p$ occurs in the prime factorization of $n$, or number of times we erased $p$ during the computation of the modified factorial.</p> <p>Legendre's formula gives us a way to compute this in $O(\\log_p n)$ time. The formula gives the multiplicity $\\nu_p$ as:</p> $$\\nu_p(n!) = \\sum_{i=1}^{\\infty} \\left\\lfloor \\frac{n}{p^i} \\right\\rfloor$$ <p>Thus we get the implementation:</p> <pre><code>int multiplicity_factorial(int n, int p) {\n    int count = 0;\n    do {\n        n /= p;\n        count += n;\n    } while (n);\n    return count;\n}\n</code></pre> <p>This formula can be proven very easily using the same ideas that we did in the previous sections. Remove all elements that don't contain the factor $p$. This leaves $\\lfloor n/p \\rfloor$ element remaining. If we remove the factor $p$ from each of them, we get the product $1 \\cdot 2 \\cdots \\lfloor n/p \\rfloor = \\lfloor n/p \\rfloor !$, and again we have a recursion.</p>","tags":["Translated"]},{"location":"algebra/factoring-exp.html","title":"Binary Exponentiation by Factoring","text":"<p>Consider a problem of computing $ax^y \\pmod{2^d}$, given integers $a$, $x$, $y$ and $d \\geq 3$, where $x$ is odd.</p> <p>The algorithm below allows to solve this problem with $O(d)$ additions and binary operations and a single multiplication by $y$.</p> <p>Due to the structure of the multiplicative group modulo $2^d$, any number $x$ such that $x \\equiv 1 \\pmod 4$ can be represented as</p> $$ x \\equiv b^{L(x)} \\pmod{2^d}, $$ <p>where $b \\equiv 5 \\pmod 8$. Without loss of generality we assume that $x \\equiv 1 \\pmod 4$, as we can reduce $x \\equiv 3 \\pmod 4$ to $x \\equiv 1 \\pmod 4$ by substituting $x \\mapsto -x$ and $a \\mapsto (-1)^{y} a$. In this notion, $ax^y$ is represented as</p> $$ a x^y \\equiv a b^{yL(x)} \\pmod{2^d}. $$ <p>The core idea of the algorithm is to simplify the computation of $L(x)$ and $b^{y L(x)}$ using the fact that we're working modulo $2^d$. For reasons that will be apparent later on, we'll be working with $4L(x)$ rather than $L(x)$, but taken modulo $2^d$ instead of $2^{d-2}$.</p> <p>In this article, we will cover the implementation for $32$-bit integers. Let</p> <ul> <li><code>mbin_log_32(r, x)</code> be a function that computes $r+4L(x) \\pmod{2^d}$;</li> <li><code>mbin_exp_32(r, x)</code> be a function that computes $r b^{\\frac{x}{4}} \\pmod{2^d}$;</li> <li><code>mbin_power_odd_32(a, x, y)</code> be a function that computes $ax^y \\pmod{2^d}$.</li> </ul> <p>Then <code>mbin_power_odd_32</code> is implemented as follows:</p> <pre><code>uint32_t mbin_power_odd_32(uint32_t rem, uint32_t base, uint32_t exp) {\n    if (base &amp; 2) {\n        /* divider is considered negative */\n        base = -base;\n        /* check if result should be negative */\n        if (exp &amp; 1) {\n            rem = -rem;\n        }\n    }\n    return (mbin_exp_32(rem, mbin_log_32(0, base) * exp));\n}\n</code></pre>","tags":["Original"]},{"location":"algebra/factoring-exp.html#computing-4lx-from-x","title":"Computing 4L(x) from x","text":"<p>Let $x$ be an odd number such that $x \\equiv 1 \\pmod 4$. It can be represented as </p> $$ x \\equiv (2^{a_1}+1)\\dots(2^{a_k}+1) \\pmod{2^d}, $$ <p>where $1 &lt; a_1 &lt; \\dots &lt; a_k &lt; d$. Here $L(\\cdot)$ is well-defined for each multiplier, as they're equal to $1$ modulo $4$. Hence,</p> $$ 4L(x) \\equiv 4L(2^{a_1}+1)+\\dots+4L(2^{a_k}+1) \\pmod{2^{d}}. $$ <p>So, if we precompute $t_k = 4L(2^n+1)$ for all $1 &lt; k &lt; d$, we will be able to compute $4L(x)$ for any number $x$.</p> <p>For 32-bit integers, we can use the following table:</p> <pre><code>const uint32_t mbin_log_32_table[32] = {\n    0x00000000, 0x00000000, 0xd3cfd984, 0x9ee62e18,\n    0xe83d9070, 0xb59e81e0, 0xa17407c0, 0xce601f80,\n    0xf4807f00, 0xe701fe00, 0xbe07fc00, 0xfc1ff800,\n    0xf87ff000, 0xf1ffe000, 0xe7ffc000, 0xdfff8000,\n    0xffff0000, 0xfffe0000, 0xfffc0000, 0xfff80000,\n    0xfff00000, 0xffe00000, 0xffc00000, 0xff800000,\n    0xff000000, 0xfe000000, 0xfc000000, 0xf8000000,\n    0xf0000000, 0xe0000000, 0xc0000000, 0x80000000,\n};\n</code></pre> <p>On practice, a slightly different approach is used than described above. Rather than finding the factorization for $x$, we will consequently multiply $x$ with $2^n+1$ until we turn it into $1$ modulo $2^d$. In this way, we will find the representation of $x^{-1}$, that is</p> $$ x (2^{a_1}+1)\\dots(2^{a_k}+1) \\equiv 1 \\pmod {2^d}. $$ <p>To do this, we iterate over $n$ such that $1 &lt; n &lt; d$. If the current $x$ has $n$-th bit set, we multiply $x$ with $2^n+1$, which is conveniently done in C++ as <code>x = x + (x &lt;&lt; n)</code>. This won't change bits lower than $n$, but will turn the $n$-th bit to zero, because $x$ is odd.</p> <p>With all this in mind, the function <code>mbin_log_32(r, x)</code> is implemented as follows:</p> <pre><code>uint32_t mbin_log_32(uint32_t r, uint32_t x) {\n    uint8_t n;\n\n    for (n = 2; n &lt; 32; n++) {\n        if (x &amp; (1 &lt;&lt; n)) {\n            x = x + (x &lt;&lt; n);\n            r -= mbin_log_32_table[n];\n        }\n    }\n\n    return r;\n}\n</code></pre> <p>Note that $4L(x) = -4L(x^{-1})$, so instead of adding $4L(2^n+1)$, we subtract it from $r$, which initially equates to $0$.</p>","tags":["Original"]},{"location":"algebra/factoring-exp.html#computing-x-from-4lx","title":"Computing x from 4L(x)","text":"<p>Note that for $k \\geq 1$ it holds that</p> $$ (a 2^{k}+1)^2 = a^2 2^{2k} +a 2^{k+1}+1 = b2^{k+1}+1, $$ <p>from which (by repeated squaring) we can deduce that</p> $$ (2^a+1)^{2^b} \\equiv 1 \\pmod{2^{a+b}}. $$ <p>Applying this result to $a=2^n+1$ and $b=d-k$ we deduce that the multiplicative order of $2^n+1$ is a divisor of $2^{d-n}$.</p> <p>This, in turn, means that $L(2^n+1)$ must be divisible by $2^{n}$, as the order of $b$ is $2^{d-2}$ and the order of $b^y$ is $2^{d-2-v}$, where $2^v$ is the highest power of $2$ that divides $y$, so we need</p> $$ 2^{d-k} \\equiv 0 \\pmod{2^{d-2-v}}, $$ <p>thus $v$ must be greater or equal than $k-2$. This is a bit ugly and to mitigate this we said in the beginning that we multiply $L(x)$ by $4$. Now if we know $4L(x)$, we can uniquely decomposing it into a sum of $4L(2^n+1)$ by consequentially checking bits in $4L(x)$. If the $n$-th bit is set to $1$, we will multiply the result with $2^n+1$ and reduce the current $4L(x)$ by $4L(2^n+1)$.</p> <p>Thus, <code>mbin_exp_32</code> is implemented as follows:</p> <pre><code>uint32_t mbin_exp_32(uint32_t r, uint32_t x) {\n    uint8_t n;\n\n    for (n = 2; n &lt; 32; n++) {\n        if (x &amp; (1 &lt;&lt; n)) {\n            r = r + (r &lt;&lt; n);\n            x -= mbin_log_32_table[n];\n        }\n    }\n\n    return r;\n}\n</code></pre>","tags":["Original"]},{"location":"algebra/factoring-exp.html#further-optimizations","title":"Further optimizations","text":"<p>It is possible to halve the number of iterations if you note that $4L(2^{d-1}+1)=2^{d-1}$ and that for $2k \\geq d$ it holds that</p> $$ (2^n+1)^2 \\equiv 2^{2n} + 2^{n+1}+1 \\equiv 2^{n+1}+1 \\pmod{2^d}, $$ <p>which allows to deduce that $4L(2^n+1)=2^n$ for $2n \\geq d$. So, you could simplify the algorithm by only going up to $\\frac{d}{2}$ and then use the fact above to compute the remaining part with bitwise operations:</p> <pre><code>uint32_t mbin_log_32(uint32_t r, uint32_t x) {\n    uint8_t n;\n\n    for (n = 2; n != 16; n++) {\n        if (x &amp; (1 &lt;&lt; n)) {\n            x = x + (x &lt;&lt; n);\n            r -= mbin_log_32_table[n];\n        }\n    }\n\n    r -= (x &amp; 0xFFFF0000);\n\n    return r;\n}\n\nuint32_t mbin_exp_32(uint32_t r, uint32_t x) {\n    uint8_t n;\n\n    for (n = 2; n != 16; n++) {\n        if (x &amp; (1 &lt;&lt; n)) {\n            r = r + (r &lt;&lt; n);\n            x -= mbin_log_32_table[n];\n        }\n    }\n\n    r *= 1 - (x &amp; 0xFFFF0000);\n\n    return r;\n}\n</code></pre>","tags":["Original"]},{"location":"algebra/factoring-exp.html#computing-logarithm-table","title":"Computing logarithm table","text":"<p>To compute log-table, one could modify the Pohlig\u2013Hellman algorithm for the case when modulo is a power of $2$.</p> <p>Our main task here is to compute $x$ such that $g^x \\equiv y \\pmod{2^d}$, where $g=5$ and $y$ is a number of kind $2^n+1$. </p> <p>Squaring both parts $k$ times we arrive to</p> $$ g^{2^k x} \\equiv y^{2^k} \\pmod{2^d}. $$ <p>Note that the order of $g$ is not greater than $2^{d}$ (in fact, than $2^{d-2}$, but we will stick to $2^d$ for convenience), hence using $k=d-1$ we will have either $g^1$ or $g^0$ on the left hand side which allows us to determine the smallest bit of $x$ by comparing $y^{2^k}$ to $g$. Now assume that $x=x_0 + 2^k x_1$, where $x_0$ is a known part and $x_1$ is not yet known. Then</p> $$ g^{x_0+2^k x_1} \\equiv y \\pmod{2^d}. $$ <p>Multiplying both parts with $g^{-x_0}$, we get</p> $$ g^{2^k x_1} \\equiv (g^{-x_0} y) \\pmod{2^d}. $$ <p>Now, squaring both sides $d-k-1$ times we can obtain the next bit of $x$, eventually recovering all its bits.</p>","tags":["Original"]},{"location":"algebra/factoring-exp.html#references","title":"References","text":"<ul> <li>M30, Hans Petter Selasky, 2009</li> </ul>","tags":["Original"]},{"location":"algebra/factorization.html","title":"Integer factorization","text":"<p>In this article we list several algorithms for the factorization of integers, each of which can be either fast or varying levels of slow depending on their input.</p> <p>Notice, if the number that you want to factorize is actually a prime number, most of the algorithms will run very slowly. This is especially true for Fermat's, Pollard's p-1 and Pollard's rho factorization algorithms. Therefore, it makes the most sense to perform a probabilistic (or a fast deterministic) primality test before trying to factorize the number.</p>","tags":["Original"]},{"location":"algebra/factorization.html#trial-division","title":"Trial division","text":"<p>This is the most basic algorithm to find a prime factorization.</p> <p>We divide by each possible divisor $d$. It can be observed that it is impossible for all prime factors of a composite number $n$ to be bigger than $\\sqrt{n}$. Therefore, we only need to test the divisors $2 \\le d \\le \\sqrt{n}$, which gives us the prime factorization in $O(\\sqrt{n})$. (This is pseudo-polynomial time, i.e. polynomial in the value of the input but exponential in the number of bits of the input.)</p> <p>The smallest divisor must be a prime number. We remove the factored number, and continue the process. If we cannot find any divisor in the range $[2; \\sqrt{n}]$, then the number itself has to be prime.</p> <pre><code>vector&lt;long long&gt; trial_division1(long long n) {\n    vector&lt;long long&gt; factorization;\n    for (long long d = 2; d * d &lt;= n; d++) {\n        while (n % d == 0) {\n            factorization.push_back(d);\n            n /= d;\n        }\n    }\n    if (n &gt; 1)\n        factorization.push_back(n);\n    return factorization;\n}\n</code></pre>","tags":["Original"]},{"location":"algebra/factorization.html#wheel-factorization","title":"Wheel factorization","text":"<p>This is an optimization of the trial division. Once we know that the number is not divisible by 2, we don't need to check other even numbers. This leaves us with only $50\\%$ of the numbers to check. After factoring out 2, and getting an odd number, we can simply start with 3 and only count other odd numbers.</p> <pre><code>vector&lt;long long&gt; trial_division2(long long n) {\n    vector&lt;long long&gt; factorization;\n    while (n % 2 == 0) {\n        factorization.push_back(2);\n        n /= 2;\n    }\n    for (long long d = 3; d * d &lt;= n; d += 2) {\n        while (n % d == 0) {\n            factorization.push_back(d);\n            n /= d;\n        }\n    }\n    if (n &gt; 1)\n        factorization.push_back(n);\n    return factorization;\n}\n</code></pre> <p>This method can be extended further. If the number is not divisible by 3, we can also ignore all other multiples of 3 in the future computations. So we only need to check the numbers $5, 7, 11, 13, 17, 19, 23, \\dots$. We can observe a pattern of these remaining numbers. We need to check all numbers with $d \\bmod 6 = 1$ and $d \\bmod 6 = 5$. So this leaves us with only $33.3\\%$ percent of the numbers to check. We can implement this by factoring out the primes 2 and 3 first, after which we start with 5 and only count remainders $1$ and $5$ modulo $6$.</p> <p>Here is an implementation for the prime number 2, 3 and 5. It is convenient to store the skipping strides in an array.</p> <pre><code>vector&lt;long long&gt; trial_division3(long long n) {\n    vector&lt;long long&gt; factorization;\n    for (int d : {2, 3, 5}) {\n        while (n % d == 0) {\n            factorization.push_back(d);\n            n /= d;\n        }\n    }\n    static array&lt;int, 8&gt; increments = {4, 2, 4, 2, 4, 6, 2, 6};\n    int i = 0;\n    for (long long d = 7; d * d &lt;= n; d += increments[i++]) {\n        while (n % d == 0) {\n            factorization.push_back(d);\n            n /= d;\n        }\n        if (i == 8)\n            i = 0;\n    }\n    if (n &gt; 1)\n        factorization.push_back(n);\n    return factorization;\n}\n</code></pre> <p>If we continue exending this method to include even more primes, better percentages can be reached, but the skip lists will become larger. </p>","tags":["Original"]},{"location":"algebra/factorization.html#precomputed-primes","title":"Precomputed primes","text":"<p>Extending the wheel factorization method indefinitely, we will only be left with prime numbers to check.  A good way of checking this is to precompute all prime numbers with the Sieve of Eratosthenes until $\\sqrt{n}$, and test them individually.</p> <pre><code>vector&lt;long long&gt; primes;\n\nvector&lt;long long&gt; trial_division4(long long n) {\n    vector&lt;long long&gt; factorization;\n    for (long long d : primes) {\n        if (d * d &gt; n)\n            break;\n        while (n % d == 0) {\n            factorization.push_back(d);\n            n /= d;\n        }\n    }\n    if (n &gt; 1)\n        factorization.push_back(n);\n    return factorization;\n}\n</code></pre>","tags":["Original"]},{"location":"algebra/factorization.html#fermats-factorization-method","title":"Fermat's factorization method","text":"<p>We can write an odd composite number $n = p \\cdot q$ as the difference of two squares $n = a^2 - b^2$:</p> $$n = \\left(\\frac{p + q}{2}\\right)^2 - \\left(\\frac{p - q}{2}\\right)^2$$ <p>Fermat's factorization method tries to exploit this fact by guessing the first square $a^2$, and checking if the remaining part, $b^2 = a^2 - n$, is also a square number. If it is, then we have found the factors $a - b$ and $a + b$ of $n$.</p> <pre><code>int fermat(int n) {\n    int a = ceil(sqrt(n));\n    int b2 = a*a - n;\n    int b = round(sqrt(b2));\n    while (b * b != b2) {\n        a = a + 1;\n        b2 = a*a - n;\n        b = round(sqrt(b2));\n    }\n    return a - b;\n}\n</code></pre> <p>This factorization method can be very fast if the difference between the two factors $p$ and $q$ is small. The algorithm runs in $O(|p - q|)$ time. In practice though, this method is rarely used. Once factors become further apart, it is extremely slow. </p> <p>However, there are still a large number of optimization options regarding this approach. By looking at the squares $a^2$ modulo a fixed small number, it can be observed that certain values $a$ don't have to be viewed, since they cannot produce a square number $a^2 - n$.</p>","tags":["Original"]},{"location":"algebra/factorization.html#pollards-p-1-method","title":"Pollard's $p - 1$ method","text":"<p>It is very likely that a number $n$ has at least one prime factor $p$ such that $p - 1$ is $\\mathrm{B}$-powersmooth for small $\\mathrm{B}$. An integer $m$ is said to be $\\mathrm{B}$-powersmooth if every prime power dividing $m$ is at most $\\mathrm{B}$. Formally, let $\\mathrm{B} \\geqslant 1$ and let $m$ be any positive integer. Suppose the prime factorization of $m$ is $m = \\prod {q_i}^{e_i}$, where each $q_i$ is a prime and $e_i \\geqslant 1$. Then $m$ is $\\mathrm{B}$-powersmooth if, for all $i$, ${q_i}^{e_i} \\leqslant \\mathrm{B}$.  E.g. the prime factorization of $4817191$ is $1303 \\cdot 3697$. And the values, $1303 - 1$ and $3697 - 1$, are $31$-powersmooth and $16$-powersmooth respectively, because $1303 - 1 = 2 \\cdot 3 \\cdot 7 \\cdot 31$ and $3697 - 1 = 2^4 \\cdot 3 \\cdot 7 \\cdot 11$. In 1974 John Pollard invented a method to extract factors $p$, s.t. $p-1$ is $\\mathrm{B}$-powersmooth, from a composite number.</p> <p>The idea comes from Fermat's little theorem. Let a factorization of $n$ be $n = p \\cdot q$. It says that if $a$ is coprime to $p$, the following statement holds:</p> $$a^{p - 1} \\equiv 1 \\pmod{p}$$ <p>This also means that</p> $${\\left(a^{(p - 1)}\\right)}^k \\equiv a^{k \\cdot (p - 1)} \\equiv 1 \\pmod{p}.$$ <p>So for any $M$ with $p - 1 ~|~ M$ we know that $a^M \\equiv 1$. This means that $a^M - 1 = p \\cdot r$, and because of that also $p ~|~ \\gcd(a^M - 1, n)$.</p> <p>Therefore, if $p - 1$ for a factor $p$ of $n$ divides $M$, we can extract a factor using Euclid's algorithm.</p> <p>It is clear, that the smallest $M$ that is a multiple of every $\\mathrm{B}$-powersmooth number is $\\text{lcm}(1,~2~,3~,4~,~\\dots,~B)$. Or alternatively:</p> $$M = \\prod_{\\text{prime } q \\le B} q^{\\lfloor \\log_q B \\rfloor}$$ <p>Notice, if $p-1$ divides $M$ for all prime factors $p$ of $n$, then $\\gcd(a^M - 1, n)$ will just be $n$. In this case we don't receive a factor. Therefore, we will try to perform the $\\gcd$ multiple times, while we compute $M$.</p> <p>Some composite numbers don't have factors $p$ s.t. $p-1$ is $\\mathrm{B}$-powersmooth for small $\\mathrm{B}$. For example, for the composite number $100~000~000~000~000~493 = 763~013 \\cdot 131~059~365~961$, values $p-1$ are $190~753$-powersmooth and $1~092~161~383$-powersmooth correspondingly. We will have to choose $B \\geq 190~753$ to factorize the number.</p> <p>In the following implementation we start with $\\mathrm{B} = 10$ and increase $\\mathrm{B}$ after each each iteration.</p> <pre><code>long long pollards_p_minus_1(long long n) {\n    int B = 10;\n    long long g = 1;\n    while (B &lt;= 1000000 &amp;&amp; g &lt; n) {\n        long long a = 2 + rand() %  (n - 3);\n        g = gcd(a, n);\n        if (g &gt; 1)\n            return g;\n\n        // compute a^M\n        for (int p : primes) {\n            if (p &gt;= B)\n                continue;\n            long long p_power = 1;\n            while (p_power * p &lt;= B)\n                p_power *= p;\n            a = power(a, p_power, n);\n\n            g = gcd(a - 1, n);\n            if (g &gt; 1 &amp;&amp; g &lt; n)\n                return g;\n        }\n        B *= 2;\n    }\n    return 1;\n}\n</code></pre> <p>Observe that this is a probabilistic algorithm. A consequence of this is that there is a possibility of the algorithm being unable to find a factor at all. </p> <p>The complexity is $O(B \\log B \\log^2 n)$ per iteration.</p>","tags":["Original"]},{"location":"algebra/factorization.html#pollards-rho-algorithm","title":"Pollard's rho algorithm","text":"<p>Pollard's Rho Algorithm is yet another factorization algorithm from John Pollard.</p> <p>Let the prime factorization of a number be $n = p q$. The algorithm looks at a pseudo-random sequence $\\{x_i\\} = \\{x_0,~f(x_0),~f(f(x_0)),~\\dots\\}$ where $f$ is a polynomial function, usually $f(x) = (x^2 + c) \\bmod n$ is chosen with $c = 1$.</p> <p>In this instance, we are not interested in the sequence $\\{x_i\\}$.  We are more interested in the sequence $\\{x_i \\bmod p\\}$. Since $f$ is a polynomial function, and all the values are in the range $[0;~p)$, this sequence will eventually converge into a loop. The birthday paradox actually suggests that the expected number of elements is $O(\\sqrt{p})$ until the repetition starts. If $p$ is smaller than $\\sqrt{n}$, the repetition will likely start in $O(\\sqrt[4]{n})$.</p> <p>Here is a visualization of such a sequence $\\{x_i \\bmod p\\}$ with $n = 2206637$, $p = 317$, $x_0 = 2$ and $f(x) = x^2 + 1$. From the form of the sequence you can see very clearly why the algorithm is called Pollard's $\\rho$ algorithm.</p> <p>Yet, there is still an open question. How can we exploit the properties of the sequence $\\{x_i \\bmod p\\}$ to our advantage without even knowing the number $p$ itself?</p> <p>It's actually quite easy. There is a cycle in the sequence $\\{x_i \\bmod p\\}_{i \\le j}$ if and only if there are two indices $s, t \\le j$ such that $x_s \\equiv x_t \\bmod p$. This equation can be rewritten as $x_s - x_t \\equiv 0 \\bmod p$ which is the same as $p ~|~ \\gcd(x_s - x_t, n)$.</p> <p>Therefore, if we find two indices $s$ and $t$ with $g = \\gcd(x_s - x_t, n) &gt; 1$, we have found a cycle and also a factor $g$ of $n$. It is possible that $g = n$. In this case we haven't found a proper factor, so we must repeat the algorithm with a different parameter (different starting value $x_0$, different constant $c$ in the polynomial function $f$).</p> <p>To find the cycle, we can use any common cycle detection algorithm.</p>","tags":["Original"]},{"location":"algebra/factorization.html#floyds-cycle-finding-algorithm","title":"Floyd's cycle-finding algorithm","text":"<p>This algorithm finds a cycle by using two pointers moving over the sequence at differing speeds. During each iteration, the first pointer will advance one element over, while the second pointer advances to every other element.  Using this idea it is easy to observe that if there is a cycle, at some point the second pointer will come around to meet the first one during the loops.  If the cycle length is $\\lambda$ and the $\\mu$ is the first index at which the cycle starts, then the algorithm will run in $O(\\lambda + \\mu)$ time.</p> <p>This algorithm is also known as the Tortoise and Hare algorithm, based on the tale in which a tortoise (the slow pointer) and a hare (the faster pointer) have a race.</p> <p>It is actually possible to determine the parameter $\\lambda$ and $\\mu$ using this algorithm (also in $O(\\lambda + \\mu)$ time and $O(1)$ space). When a cycle is detected, the algorithm will return 'True'.  If the sequence doesn't have a cycle, then the function will loop endlessly. However, using Pollard's Rho Algorithm, this can be prevented. </p> <pre><code>function floyd(f, x0):\n    tortoise = x0\n    hare = f(x0)\n    while tortoise != hare:\n        tortoise = f(tortoise)\n        hare = f(f(hare))\n    return true\n</code></pre>","tags":["Original"]},{"location":"algebra/factorization.html#implementation","title":"Implementation","text":"<p>First, here is an implementation using the Floyd's cycle-finding algorithm. The algorithm generally runs in $O(\\sqrt[4]{n} \\log(n))$ time.</p> <pre><code>long long mult(long long a, long long b, long long mod) {\n    return (__int128)a * b % mod;\n}\n\nlong long f(long long x, long long c, long long mod) {\n    return (mult(x, x, mod) + c) % mod;\n}\n\nlong long rho(long long n, long long x0=2, long long c=1) {\n    long long x = x0;\n    long long y = x0;\n    long long g = 1;\n    while (g == 1) {\n        x = f(x, c, n);\n        y = f(y, c, n);\n        y = f(y, c, n);\n        g = gcd(abs(x - y), n);\n    }\n    return g;\n}\n</code></pre> <p>The following table shows the values of $x$ and $y$ during the algorithm for $n = 2206637$, $x_0 = 2$ and $c = 1$.</p> $$ \\newcommand\\T{\\Rule{0pt}{1em}{.3em}} \\begin{array}{|l|l|l|l|l|l|} \\hline i &amp; x_i \\bmod n &amp; x_{2i} \\bmod n &amp; x_i \\bmod 317 &amp; x_{2i} \\bmod 317 &amp; \\gcd(x_i - x_{2i}, n) \\\\ \\hline 0   &amp; 2       &amp; 2       &amp; 2       &amp; 2       &amp; -   \\\\ 1   &amp; 5       &amp; 26      &amp; 5       &amp; 26      &amp; 1   \\\\ 2   &amp; 26      &amp; 458330  &amp; 26      &amp; 265     &amp; 1   \\\\ 3   &amp; 677     &amp; 1671573 &amp; 43      &amp; 32      &amp; 1   \\\\ 4   &amp; 458330  &amp; 641379  &amp; 265     &amp; 88      &amp; 1   \\\\ 5   &amp; 1166412 &amp; 351937  &amp; 169     &amp; 67      &amp; 1   \\\\ 6   &amp; 1671573 &amp; 1264682 &amp; 32      &amp; 169     &amp; 1   \\\\ 7   &amp; 2193080 &amp; 2088470 &amp; 74      &amp; 74      &amp; 317 \\\\ \\hline \\end{array}$$ <p>The implementation uses a function <code>mult</code>, that multiplies two integers $\\le 10^{18}$ without overflow by using a GCC's type <code>__int128</code> for 128-bit integer. If GCC is not available, you can using a similar idea as binary exponentiation.</p> <pre><code>long long mult(long long a, long long b, long long mod) {\n    long long result = 0;\n    while (b) {\n        if (b &amp; 1)\n            result = (result + a) % mod;\n        a = (a + a) % mod;\n        b &gt;&gt;= 1;\n    }\n    return result;\n}\n</code></pre> <p>Alternatively you can also implement the Montgomery multiplication.</p> <p>As stated previously, if $n$ is composite and the algorithm returns $n$ as factor, you have to repeat the procedure with different parameters $x_0$ and $c$. E.g. the choice $x_0 = c = 1$ will not factor $25 = 5 \\cdot 5$. The algorithm will return $25$. However, the choice $x_0 = 1$, $c = 2$ will factor it.</p>","tags":["Original"]},{"location":"algebra/factorization.html#brents-algorithm","title":"Brent's algorithm","text":"<p>Brent implements a similar method to Floyd, using two pointers. The difference being that instead of advancing the pointers by one and two places respectively, they are advanced by powers of two.  As soon as $2^i$ is greater than $\\lambda$ and $\\mu$, we will find the cycle.</p> <pre><code>function floyd(f, x0):\n    tortoise = x0\n    hare = f(x0)\n    l = 1\n    while tortoise != hare:\n        tortoise = hare\n        repeat l times:\n            hare = f(hare)\n            if tortoise == hare:\n                return true\n        l *= 2\n    return true\n</code></pre> <p>Brent's algorithm also runs in linear time, but is generally faster than Floyd's, since it uses less evaluations of the function $f$.</p>","tags":["Original"]},{"location":"algebra/factorization.html#implementation_1","title":"Implementation","text":"<p>The straightforward implementation of Brent's algorithm can be sped up by omitting the terms $x_l - x_k$ if $k &lt; \\frac{3 \\cdot l}{2}$. In addition, instead of performing the $\\gcd$ computation at every step, we multiply the terms and only actually check $\\gcd$ every few steps and backtrack if overshot.</p> <pre><code>long long brent(long long n, long long x0=2, long long c=1) {\n    long long x = x0;\n    long long g = 1;\n    long long q = 1;\n    long long xs, y;\n\n    int m = 128;\n    int l = 1;\n    while (g == 1) {\n        y = x;\n        for (int i = 1; i &lt; l; i++)\n            x = f(x, c, n);\n        int k = 0;\n        while (k &lt; l &amp;&amp; g == 1) {\n            xs = x;\n            for (int i = 0; i &lt; m &amp;&amp; i &lt; l - k; i++) {\n                x = f(x, c, n);\n                q = mult(q, abs(y - x), n);\n            }\n            g = gcd(q, n);\n            k += m;\n        }\n        l *= 2;\n    }\n    if (g == n) {\n        do {\n            xs = f(xs, c, n);\n            g = gcd(abs(xs - y), n);\n        } while (g == 1);\n    }\n    return g;\n}\n</code></pre> <p>The combination of a trial division for small prime numbers together with Brent's version of Pollard's rho algorithm makes a very powerful factorization algorithm.</p>","tags":["Original"]},{"location":"algebra/factorization.html#practice-problems","title":"Practice Problems","text":"<ul> <li>SPOJ - FACT0</li> <li>SPOJ - FACT1</li> <li>SPOJ - FACT2</li> <li>GCPC 15 - Divisions</li> </ul>","tags":["Original"]},{"location":"algebra/fft.html","title":"Fast Fourier transform","text":"<p>In this article we will discuss an algorithm that allows us to multiply two polynomials of length $n$ in $O(n \\log n)$ time, which is better than the trivial multiplication which takes $O(n^2)$ time. Obviously also multiplying two long numbers can be reduced to multiplying polynomials, so also two long numbers can be multiplied in $O(n \\log n)$ time (where $n$ is the number of digits in the numbers).</p> <p>The discovery of the Fast Fourier transformation (FFT) is attributed to Cooley and Tukey, who published an algorithm in 1965. But in fact the FFT has been discovered repeatedly before, but the importance of it was not understood before the inventions of modern computers. Some researchers attribute the discovery of the FFT to Runge and K\u00f6nig in 1924. But actually Gauss developed such a method already in 1805, but never published it.</p> <p>Notice, that the FFT algorithm presented here runs in $O(n \\log n)$ time, but it doesn't work for multiplying arbitrary big polynomials with arbitrary large coefficients or for multiplying arbitrary big integers. It can easily handle polynomials of size $10^5$ with small coefficients, or multiplying two numbers of size $10^6$, which is usually enough for solving competitive programming problems. Beyond the scale of multiplying numbers with $10^6$ bits, the range and precision of the floating point numbers used during the computation will not be enough to give accurate final results, though there are more complex variations that can perform arbitrary large polynomial/integer multiplications. E.g. in 1971 Sch\u00f6nhage and Strasser developed a variation for multiplying arbitrary large numbers that applies the FFT recursively in rings structures running in $O(n \\log n \\log \\log n)$. And recently (in 2019) Harvey and van der Hoeven published an algorithm that runs in true $O(n \\log n)$.</p>","tags":["Translated"]},{"location":"algebra/fft.html#discrete-fourier-transform","title":"Discrete Fourier transform","text":"<p>Let there be a polynomial of degree $n - 1$:</p> $$A(x) = a_0 x^0 + a_1 x^1 + \\dots + a_{n-1} x^{n-1}$$ <p>Without loss of generality we assume that $n$ - the number of coefficients - is a power of $2$. If $n$ is not a power of $2$, then we simply add the missing terms $a_i x^i$ and set the coefficients $a_i$ to $0$.</p> <p>The theory of complex numbers tells us that the equation $x^n = 1$ has $n$ complex solutions (called the $n$-th roots of unity), and the solutions are of the form $w_{n, k} = e^{\\frac{2 k \\pi i}{n}}$ with $k = 0 \\dots n-1$. Additionally these complex numbers have some very interesting properties: e.g. the principal $n$-th root $w_n = w_{n, 1} = e^{\\frac{2 \\pi i}{n}}$ can be used to describe all other $n$-th roots: $w_{n, k} = (w_n)^k$.</p> <p>The discrete Fourier transform (DFT) of the polynomial $A(x)$ (or equivalently the vector of coefficients $(a_0, a_1, \\dots, a_{n-1})$ is defined as the values of the polynomial at the points $x = w_{n, k}$, i.e. it is the vector:</p> $$\\begin{align} \\text{DFT}(a_0, a_1, \\dots, a_{n-1}) &amp;= (y_0, y_1, \\dots, y_{n-1}) \\\\ &amp;= (A(w_{n, 0}), A(w_{n, 1}), \\dots, A(w_{n, n-1})) \\\\ &amp;= (A(w_n^0), A(w_n^1), \\dots, A(w_n^{n-1})) \\end{align}$$ <p>Similarly the inverse discrete Fourier transform is defined: The inverse DFT of values of the polynomial $(y_0, y_1, \\dots, y_{n-1})$ are the coefficients of the polynomial $(a_0, a_1, \\dots, a_{n-1})$.</p> $$\\text{InverseDFT}(y_0, y_1, \\dots, y_{n-1}) = (a_0, a_1, \\dots, a_{n-1})$$ <p>Thus, if a direct DFT computes the values of the polynomial at the points at the $n$-th roots, the inverse DFT can restore the coefficients of the polynomial using those values.</p>","tags":["Translated"]},{"location":"algebra/fft.html#application-of-the-dft-fast-multiplication-of-polynomials","title":"Application of the DFT: fast multiplication of polynomials","text":"<p>Let there be two polynomials $A$ and $B$. We compute the DFT for each of them: $\\text{DFT}(A)$ and $\\text{DFT}(B)$.</p> <p>What happens if we multiply these polynomials? Obviously at each point the values are simply multiplied, i.e.</p> $$(A \\cdot B)(x) = A(x) \\cdot B(x).$$ <p>This means that if we multiply the vectors $\\text{DFT}(A)$ and $\\text{DFT}(B)$ - by multiplying each element of one vector by the corresponding element of the other vector - then we get nothing other than the DFT of the polynomial $\\text{DFT}(A \\cdot B)$:</p> $$\\text{DFT}(A \\cdot B) = \\text{DFT}(A) \\cdot \\text{DFT}(B)$$ <p>Finally, applying the inverse DFT, we obtain:</p> $$A \\cdot B = \\text{InverseDFT}(\\text{DFT}(A) \\cdot \\text{DFT}(B))$$ <p>On the right the product of the two DFTs we mean the pairwise product of the vector elements. This can be computed in $O(n)$ time. If we can compute the DFT and the inverse DFT in $O(n \\log n)$, then we can compute the product of the two polynomials (and consequently also two long numbers) with the same time complexity.</p> <p>It should be noted, that the two polynomials should have the same degree. Otherwise the two result vectors of the DFT have different length. We can accomplish this by adding coefficients with the value $0$.</p> <p>And also, since the result of the product of two polynomials is a polynomial of degree $2 (n - 1)$, we have to double the degrees of each polynomial (again by padding $0$s). From a vector with $n$ values we cannot reconstruct the desired polynomial with $2n - 1$ coefficients.</p>","tags":["Translated"]},{"location":"algebra/fft.html#fast-fourier-transform_1","title":"Fast Fourier Transform","text":"<p>The fast Fourier transform is a method that allows computing the DFT in $O(n \\log n)$ time. The basic idea of the FFT is to apply divide and conquer. We divide the coefficient vector of the polynomial into two vectors, recursively compute the DFT for each of them, and combine the results to compute the DFT of the complete polynomial.</p> <p>So let there be a polynomial $A(x)$ with degree $n - 1$, where $n$ is a power of $2$, and $n &gt; 1$:</p> $$A(x) = a_0 x^0 + a_1 x^1 + \\dots + a_{n-1} x^{n-1}$$ <p>We divide it into two smaller polynomials, the one containing only the coefficients of the even positions, and the one containing the coefficients of the odd positions:</p> $$\\begin{align} A_0(x) &amp;= a_0 x^0 + a_2 x^1 + \\dots + a_{n-2} x^{\\frac{n}{2}-1} \\\\ A_1(x) &amp;= a_1 x^0 + a_3 x^1 + \\dots + a_{n-1} x^{\\frac{n}{2}-1} \\end{align}$$ <p>It is easy to see that</p> $$A(x) = A_0(x^2) + x A_1(x^2).$$ <p>The polynomials $A_0$ and $A_1$ have only half as many coefficients as the polynomial $A$. If we can compute the $\\text{DFT}(A)$ in linear time using $\\text{DFT}(A_0)$ and $\\text{DFT}(A_1)$, then we get the recurrence $T_{\\text{DFT}}(n) = 2 T_{\\text{DFT}}\\left(\\frac{n}{2}\\right) + O(n)$ for the time complexity, which results in $T_{\\text{DFT}}(n) = O(n \\log n)$ by the master theorem.</p> <p>Let's learn how we can accomplish that.</p> <p>Suppose we have computed the vectors $\\left(y_k^0\\right)_{k=0}^{n/2-1} = \\text{DFT}(A_0)$ and $\\left(y_k^1\\right)_{k=0}^{n/2-1} = \\text{DFT}(A_1)$. Let us find a expression for $\\left(y_k\\right)_{k=0}^{n-1} = \\text{DFT}(A)$.</p> <p>For the first $\\frac{n}{2}$ values we can just use the previously noted equation $A(x) = A_0(x^2) + x A_1(x^2)$:</p> $$y_k = y_k^0 + w_n^k y_k^1, \\quad k = 0 \\dots \\frac{n}{2} - 1.$$ <p>However for the second $\\frac{n}{2}$ values we need to find a slightly, different expression:</p> $$\\begin{align} y_{k+n/2} &amp;= A\\left(w_n^{k+n/2}\\right) \\\\ &amp;= A_0\\left(w_n^{2k+n}\\right) + w_n^{k + n/2} A_1\\left(w_n^{2k+n}\\right) \\\\ &amp;= A_0\\left(w_n^{2k} w_n^n\\right) + w_n^k w_n^{n/2} A_1\\left(w_n^{2k} w_n^n\\right) \\\\ &amp;= A_0\\left(w_n^{2k}\\right) - w_n^k A_1\\left(w_n^{2k}\\right) \\\\ &amp;= y_k^0 - w_n^k y_k^1 \\end{align}$$ <p>Here we used again $A(x) = A_0(x^2) + x A_1(x^2)$ and the two identities $w_n^n = 1$ and $w_n^{n/2} = -1$.</p> <p>Therefore we get the desired formulas for computing the whole vector $(y_k)$:</p> $$\\begin{align} y_k &amp;= y_k^0 + w_n^k y_k^1, &amp;\\quad k = 0 \\dots \\frac{n}{2} - 1, \\\\ y_{k+n/2} &amp;= y_k^0 - w_n^k y_k^1, &amp;\\quad k = 0 \\dots \\frac{n}{2} - 1. \\end{align}$$ <p>(This pattern $a + b$ and $a - b$ is sometimes called a butterfly.)</p> <p>Thus we learned how to compute the DFT in $O(n \\log n)$ time.</p>","tags":["Translated"]},{"location":"algebra/fft.html#inverse-fft","title":"Inverse FFT","text":"<p>Let the vector $(y_0, y_1, \\dots y_{n-1})$ - the values of polynomial $A$ of degree $n - 1$ in the points $x = w_n^k$ - be given. We want to restore the coefficients $(a_0, a_1, \\dots, a_{n-1})$ of the polynomial. This known problem is called interpolation, and there are general algorithms for solving it. But in this special case (since we know the values of the points at the roots of unity), we can obtains a much simpler algorithm (that is practically the same as the direct FFT).</p> <p>We can write the DFT, according to its definition, in the matrix form:</p> $$ \\begin{pmatrix} w_n^0 &amp; w_n^0 &amp; w_n^0 &amp; w_n^0 &amp; \\cdots &amp; w_n^0 \\\\ w_n^0 &amp; w_n^1 &amp; w_n^2 &amp; w_n^3 &amp; \\cdots &amp; w_n^{n-1} \\\\ w_n^0 &amp; w_n^2 &amp; w_n^4 &amp; w_n^6 &amp; \\cdots &amp; w_n^{2(n-1)} \\\\ w_n^0 &amp; w_n^3 &amp; w_n^6 &amp; w_n^9 &amp; \\cdots &amp; w_n^{3(n-1)} \\\\ \\vdots &amp; \\vdots &amp; \\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots \\\\ w_n^0 &amp; w_n^{n-1} &amp; w_n^{2(n-1)} &amp; w_n^{3(n-1)} &amp; \\cdots &amp; w_n^{(n-1)(n-1)} \\end{pmatrix} \\begin{pmatrix} a_0 \\\\ a_1 \\\\ a_2 \\\\ a_3 \\\\ \\vdots \\\\ a_{n-1} \\end{pmatrix} = \\begin{pmatrix} y_0 \\\\ y_1 \\\\ y_2 \\\\ y_3 \\\\ \\vdots \\\\ y_{n-1} \\end{pmatrix} $$ <p>This matrix is called the Vandermonde matrix.</p> <p>Thus we can compute the vector $(a_0, a_1, \\dots, a_{n-1})$ by multiplying the vector $(y_0, y_1, \\dots y_{n-1})$ from the left with the inverse of the matrix:</p> $$ \\begin{pmatrix} a_0 \\\\ a_1 \\\\ a_2 \\\\ a_3 \\\\ \\vdots \\\\ a_{n-1} \\end{pmatrix} = \\begin{pmatrix} w_n^0 &amp; w_n^0 &amp; w_n^0 &amp; w_n^0 &amp; \\cdots &amp; w_n^0 \\\\ w_n^0 &amp; w_n^1 &amp; w_n^2 &amp; w_n^3 &amp; \\cdots &amp; w_n^{n-1} \\\\ w_n^0 &amp; w_n^2 &amp; w_n^4 &amp; w_n^6 &amp; \\cdots &amp; w_n^{2(n-1)} \\\\ w_n^0 &amp; w_n^3 &amp; w_n^6 &amp; w_n^9 &amp; \\cdots &amp; w_n^{3(n-1)} \\\\ \\vdots &amp; \\vdots &amp; \\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots \\\\ w_n^0 &amp; w_n^{n-1} &amp; w_n^{2(n-1)} &amp; w_n^{3(n-1)} &amp; \\cdots &amp; w_n^{(n-1)(n-1)} \\end{pmatrix}^{-1} \\begin{pmatrix} y_0 \\\\ y_1 \\\\ y_2 \\\\ y_3 \\\\ \\vdots \\\\ y_{n-1} \\end{pmatrix} $$ <p>A quick check can verify that the inverse of the matrix has the following form:</p> $$ \\frac{1}{n} \\begin{pmatrix} w_n^0 &amp; w_n^0 &amp; w_n^0 &amp; w_n^0 &amp; \\cdots &amp; w_n^0 \\\\ w_n^0 &amp; w_n^{-1} &amp; w_n^{-2} &amp; w_n^{-3} &amp; \\cdots &amp; w_n^{-(n-1)} \\\\ w_n^0 &amp; w_n^{-2} &amp; w_n^{-4} &amp; w_n^{-6} &amp; \\cdots &amp; w_n^{-2(n-1)} \\\\ w_n^0 &amp; w_n^{-3} &amp; w_n^{-6} &amp; w_n^{-9} &amp; \\cdots &amp; w_n^{-3(n-1)} \\\\ \\vdots &amp; \\vdots &amp; \\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots \\\\ w_n^0 &amp; w_n^{-(n-1)} &amp; w_n^{-2(n-1)} &amp; w_n^{-3(n-1)} &amp; \\cdots &amp; w_n^{-(n-1)(n-1)} \\end{pmatrix} $$ <p>Thus we obtain the formula:</p> $$a_k = \\frac{1}{n} \\sum_{j=0}^{n-1} y_j w_n^{-k j}$$ <p>Comparing this to the formula for $y_k$</p> $$y_k = \\sum_{j=0}^{n-1} a_j w_n^{k j},$$ <p>we notice that these problems are almost the same, so the coefficients $a_k$ can be found by the same divide and conquer algorithm, as well as the direct FFT, only instead of $w_n^k$ we have to use $w_n^{-k}$, and at the end we need to divide the resulting coefficients by $n$.</p> <p>Thus the computation of the inverse DFT is almost the same as the calculation of the direct DFT, and it also can be performed in $O(n \\log n)$ time.</p>","tags":["Translated"]},{"location":"algebra/fft.html#implementation","title":"Implementation","text":"<p>Here we present a simple recursive implementation of the FFT and the inverse FFT, both in one function, since the difference between the forward and the inverse FFT are so minimal. To store the complex numbers we use the complex type in the C++ STL.</p> <pre><code>using cd = complex&lt;double&gt;;\nconst double PI = acos(-1);\n\nvoid fft(vector&lt;cd&gt; &amp; a, bool invert) {\n    int n = a.size();\n    if (n == 1)\n        return;\n\n    vector&lt;cd&gt; a0(n / 2), a1(n / 2);\n    for (int i = 0; 2 * i &lt; n; i++) {\n        a0[i] = a[2*i];\n        a1[i] = a[2*i+1];\n    }\n    fft(a0, invert);\n    fft(a1, invert);\n\n    double ang = 2 * PI / n * (invert ? -1 : 1);\n    cd w(1), wn(cos(ang), sin(ang));\n    for (int i = 0; 2 * i &lt; n; i++) {\n        a[i] = a0[i] + w * a1[i];\n        a[i + n/2] = a0[i] - w * a1[i];\n        if (invert) {\n            a[i] /= 2;\n            a[i + n/2] /= 2;\n        }\n        w *= wn;\n    }\n}\n</code></pre> <p>The function gets passed a vector of coefficients, and the function will compute the DFT or inverse DFT and store the result again in this vector. The argument $\\text{invert}$ shows whether the direct or the inverse DFT should be computed. Inside the function we first check if the length of the vector is equal to one, if this is the case then we don't have to do anything. Otherwise we divide the vector $a$ into two vectors $a0$ and $a1$ and compute the DFT for both recursively. Then we initialize the value $wn$ and a variable $w$, which will contain the current power of $wn$. Then the values of the resulting DFT are computed using the above formulas.</p> <p>If the flag $\\text{invert}$ is set, then we replace $wn$ with $wn^{-1}$, and each of the values of the result is divided by $2$ (since this will be done in each level of the recursion, this will end up dividing the final values by $n$).</p> <p>Using this function we can create a function for multiplying two polynomials:</p> <pre><code>vector&lt;int&gt; multiply(vector&lt;int&gt; const&amp; a, vector&lt;int&gt; const&amp; b) {\n    vector&lt;cd&gt; fa(a.begin(), a.end()), fb(b.begin(), b.end());\n    int n = 1;\n    while (n &lt; a.size() + b.size()) \n        n &lt;&lt;= 1;\n    fa.resize(n);\n    fb.resize(n);\n\n    fft(fa, false);\n    fft(fb, false);\n    for (int i = 0; i &lt; n; i++)\n        fa[i] *= fb[i];\n    fft(fa, true);\n\n    vector&lt;int&gt; result(n);\n    for (int i = 0; i &lt; n; i++)\n        result[i] = round(fa[i].real());\n    return result;\n}\n</code></pre> <p>This function works with polynomials with integer coefficients, however you can also adjust it to work with other types. Since there is some error when working with complex numbers, we need round the resulting coefficients at the end.</p> <p>Finally the function for multiplying two long numbers practically doesn't differ from the function for multiplying polynomials. The only thing we have to do afterwards, is to normalize the number:</p> <pre><code>    int carry = 0;\n    for (int i = 0; i &lt; n; i++)\n        result[i] += carry;\n        carry = result[i] / 10;\n        result[i] %= 10;\n    }\n</code></pre> <p>Since the length of the product of two numbers never exceed the total length of both numbers, the size of the vector is enough to perform all carry operations.</p>","tags":["Translated"]},{"location":"algebra/fft.html#improved-implementation-in-place-computation","title":"Improved implementation: in-place computation","text":"<p>To increase the efficiency we will switch from the recursive implementation to an iterative one. In the above recursive implementation we explicitly separated the vector $a$ into two vectors - the element on the even positions got assigned to one temporary vector, and the elements on odd positions to another. However if we reorder the elements in a certain way, we don't need to create these temporary vectors (i.e. all the calculations can be done \"in-place\", right in the vector $A$ itself).</p> <p>Note that at the first recursion level, the elements whose lowest bit of the position was zero got assigned to the vector $a_0$, and the ones with a one as the lowest bit of the position got assigned to $a_1$. In the second recursion level the same thing happens, but with the second lowest bit instead, etc. Therefore if we reverse the bits of the position of each coefficient, and sort them by these reversed values, we get the desired order (it is called the bit-reversal permutation).</p> <p>For example the desired order for $n = 8$ has the form:</p> $$a = \\bigg\\{ \\Big[ (a_0, a_4), (a_2, a_6) \\Big], \\Big[ (a_1, a_5), (a_3, a_7) \\Big] \\bigg\\}$$ <p>Indeed in the first recursion level (surrounded by curly braces), the vector gets divided into two parts $[a_0, a_2, a_4, a_6]$ and $[a_1, a_3, a_5, a_7]$. As we see, in the bit-reversal permutation this corresponds to simply dividing the vector into two halves: the first $\\frac{n}{2}$ elements and the last $\\frac{n}{2}$ elements. Then there is a recursive call for each halve. Let the resulting DFT for each of them be returned in place of the elements themselves (i.e. the first half and the second half of the vector $a$ respectively.</p> $$a = \\bigg\\{ \\Big[y_0^0, y_1^0, y_2^0, y_3^0\\Big], \\Big[y_0^1, y_1^1, y_2^1, y_3^1 \\Big] \\bigg\\}$$ <p>Now we want to combine the two DFTs into one for the complete vector. The order of the elements is ideal, and we can also perform the union directly in this vector. We can take the elements $y_0^0$ and $y_0^1$ and perform the butterfly transform. The place of the resulting two values is the same as the place of the two initial values, so we get:</p> $$a = \\bigg\\{ \\Big[y_0^0 + w_n^0 y_0^1, y_1^0, y_2^0, y_3^0\\Big], \\Big[y_0^0 - w_n^0 y_0^1, y_1^1, y_2^1, y_3^1\\Big] \\bigg\\}$$ <p>Similarly we can compute the butterfly transform of $y_1^0$ and $y_1^1$ and put the results in their place, and so on. As a result we get:</p> $$a = \\bigg\\{ \\Big[y_0^0 + w_n^0 y_0^1, y_1^0 + w_n^1 y_1^1, y_2^0 + w_n^2 y_2^1, y_3^0 + w_n^3 y_3^1\\Big], \\Big[y_0^0 - w_n^0 y_0^1, y_1^0 - w_n^1 y_1^1, y_2^0 - w_n^2 y_2^1, y_3^0 - w_n^3 y_3^1\\Big] \\bigg\\}$$ <p>Thus we computed the required DFT from the vector $a$.</p> <p>Here we described the process of computing the DFT only at the first recursion level, but the same works obviously also for all other levels. Thus, after applying the bit-reversal permutation, we can compute the DFT in-place, without any additional memory.</p> <p>This additionally allows us to get rid of the recursion. We just start at the lowest level, i.e. we divide the vector into pairs and apply the butterfly transform to them. This results with the vector $a$ with the work of the last level applied. In the next step we divide the vector into vectors of size $4$, and again apply the butterfly transform, which gives us the DFT for each block of size $4$. And so on. Finally in the last step we obtained the result of the DFTs of both halves of $a$, and by applying the butterfly transform we obtain the DFT for the complete vector $a$.</p> <pre><code>using cd = complex&lt;double&gt;;\nconst double PI = acos(-1);\n\nint reverse(int num, int lg_n) {\n    int res = 0;\n    for (int i = 0; i &lt; lg_n; i++) {\n        if (num &amp; (1 &lt;&lt; i))\n            res |= 1 &lt;&lt; (lg_n - 1 - i);\n    }\n    return res;\n}\n\nvoid fft(vector&lt;cd&gt; &amp; a, bool invert) {\n    int n = a.size();\n    int lg_n = 0;\n    while ((1 &lt;&lt; lg_n) &lt; n)\n        lg_n++;\n\n    for (int i = 0; i &lt; n; i++) {\n        if (i &lt; reverse(i, lg_n))\n            swap(a[i], a[reverse(i, lg_n)]);\n    }\n\n    for (int len = 2; len &lt;= n; len &lt;&lt;= 1) {\n        double ang = 2 * PI / len * (invert ? -1 : 1);\n        cd wlen(cos(ang), sin(ang));\n        for (int i = 0; i &lt; n; i += len) {\n            cd w(1);\n            for (int j = 0; j &lt; len / 2; j++) {\n                cd u = a[i+j], v = a[i+j+len/2] * w;\n                a[i+j] = u + v;\n                a[i+j+len/2] = u - v;\n                w *= wlen;\n            }\n        }\n    }\n\n    if (invert) {\n        for (cd &amp; x : a)\n            x /= n;\n    }\n}\n</code></pre> <p>At first we apply the bit-reversal permutation by swapping the each element with the element of the reversed position. Then the $\\log n - 1$ states of the algorithm we compute the DFT for each block of the corresponding size $\\text{len}$. For all those blocks we have the same root of unity $\\text{wlen}$. We iterate all blocks and perform the butterfly transform on each of them.</p> <p>We can further optimize the reversal of the bits. In the previous implementation we iterated all bits of the index and created the bitwise reversed index. However we can reverse the bits in a different way.</p> <p>Suppose that $j$ already contains the reverse of $i$. Then by to go to $i + 1$, we have to increment $i$, and we also have to increment $j$, but in a \"reversed\" number system. Adding one in the conventional binary system is equivalent to flip all tailing ones into zeros and flipping the zero right before them into a one. Equivalently in the \"reversed\" number system, we flip all leading ones, and the also the next zero.</p> <p>Thus we get the following implementation:</p> <pre><code>using cd = complex&lt;double&gt;;\nconst double PI = acos(-1);\n\nvoid fft(vector&lt;cd&gt; &amp; a, bool invert) {\n    int n = a.size();\n\n    for (int i = 1, j = 0; i &lt; n; i++) {\n        int bit = n &gt;&gt; 1;\n        for (; j &amp; bit; bit &gt;&gt;= 1)\n            j ^= bit;\n        j ^= bit;\n\n        if (i &lt; j)\n            swap(a[i], a[j]);\n    }\n\n    for (int len = 2; len &lt;= n; len &lt;&lt;= 1) {\n        double ang = 2 * PI / len * (invert ? -1 : 1);\n        cd wlen(cos(ang), sin(ang));\n        for (int i = 0; i &lt; n; i += len) {\n            cd w(1);\n            for (int j = 0; j &lt; len / 2; j++) {\n                cd u = a[i+j], v = a[i+j+len/2] * w;\n                a[i+j] = u + v;\n                a[i+j+len/2] = u - v;\n                w *= wlen;\n            }\n        }\n    }\n\n    if (invert) {\n        for (cd &amp; x : a)\n            x /= n;\n    }\n}\n</code></pre> <p>Additionally we can precompute the bit-reversal permutation beforehand. This is especially useful when the size $n$ is the same for all calls. But even when we only have three calls (which are necessary for multiplying two polynomials), the effect is noticeable. Also we can precompute all roots of unity and their powers.</p>","tags":["Translated"]},{"location":"algebra/fft.html#number-theoretic-transform","title":"Number theoretic transform","text":"<p>Now we switch the objective a little bit. We still want to multiply two polynomials in $O(n \\log n)$ time, but this time we want to compute the coefficients modulo some prime number $p$. Of course for this task we can use the normal DFT and apply the modulo operator to the result. However, doing so might lead to rounding errors, especially when dealing with large numbers. The number theoretic transform (NTT) has the advantage, that it only works with integer, and therefore the result are guaranteed to be correct.</p> <p>The discrete Fourier transform is based on complex numbers, and the $n$-th roots of unity. To efficiently compute it, we extensively use properties of the roots (e.g. that there is one root that generates all other roots by exponentiation).</p> <p>But the same properties hold for the $n$-th roots of unity in modular arithmetic. A $n$-th root of unity under a primitive field is such a number $w_n$ that satisfies:</p> $$\\begin{align} (w_n)^n &amp;= 1 \\pmod{p}, \\\\ (w_n)^k &amp;\\ne 1 \\pmod{p}, \\quad 1 \\le k &lt; n. \\end{align}$$ <p>The other $n-1$ roots can be obtained as powers of the root $w_n$.</p> <p>To apply it in the fast Fourier transform algorithm, we need a root to exist for some $n$, which is a power of $2$, and also for all smaller powers. We can notice the following interesting property:</p> $$\\begin{align} (w_n^2)^m = w_n^n &amp;= 1 \\pmod{p}, \\quad \\text{with } m = \\frac{n}{2}\\\\ (w_n^2)^k = w_n^{2k} &amp;\\ne 1 \\pmod{p}, \\quad 1 \\le k &lt; m. \\end{align}$$ <p>Thus if $w_n$ is a $n$-th root of unity, then $w_n^2$ is a $\\frac{n}{2}$-th root of unity. And consequently for all smaller powers of two there exist roots of the required degree, and they can be computed using $w_n$.</p> <p>For computing the inverse DFT, we need the inverse $w_n^{-1}$ of $w_n$. But for a prime modulus the inverse always exists.</p> <p>Thus all the properties that we need from the complex roots are also available in modular arithmetic, provided that we have a large enough module $p$ for which a $n$-th root of unity exists.</p> <p>For example we can take the following values: module $p = 7340033$, $w_{2^{20}} = 5$. If this module is not enough, we need to find a different pair. We can use that fact that for modules of the form $p = c 2^k + 1$ (and $p$ is prime), there always exists the $2^k$-th root of unity. It can be shown that $g^c$ is such a $2^k$-th root of unity, where $g$ is a primitive root of $p$.</p> <pre><code>const int mod = 7340033;\nconst int root = 5;\nconst int root_1 = 4404020;\nconst int root_pw = 1 &lt;&lt; 20;\n\nvoid fft(vector&lt;int&gt; &amp; a, bool invert) {\n    int n = a.size();\n\n    for (int i = 1, j = 0; i &lt; n; i++) {\n        int bit = n &gt;&gt; 1;\n        for (; j &amp; bit; bit &gt;&gt;= 1)\n            j ^= bit;\n        j ^= bit;\n\n        if (i &lt; j)\n            swap(a[i], a[j]);\n    }\n\n    for (int len = 2; len &lt;= n; len &lt;&lt;= 1) {\n        int wlen = invert ? root_1 : root;\n        for (int i = len; i &lt; root_pw; i &lt;&lt;= 1)\n            wlen = (int)(1LL * wlen * wlen % mod);\n\n        for (int i = 0; i &lt; n; i += len) {\n            int w = 1;\n            for (int j = 0; j &lt; len / 2; j++) {\n                int u = a[i+j], v = (int)(1LL * a[i+j+len/2] * w % mod);\n                a[i+j] = u + v &lt; mod ? u + v : u + v - mod;\n                a[i+j+len/2] = u - v &gt;= 0 ? u - v : u - v + mod;\n                w = (int)(1LL * w * wlen % mod);\n            }\n        }\n    }\n\n    if (invert) {\n        int n_1 = inverse(n, mod);\n        for (int &amp; x : a)\n            x = (int)(1LL * x * n_1 % mod);\n    }\n}\n</code></pre> <p>Here the function <code>inverse</code> computes the modular inverse (see Modular Multiplicative Inverse). The constants <code>mod</code>, <code>root</code>, <code>root_pw</code> determine the module and the root, and <code>root_1</code> is the inverse of <code>root</code> modulo <code>mod</code>.</p> <p>In practice this implementation is slower than the implementation using complex numbers (due to the huge number of modulo operations), but it has some advantages such as less memory usage and no rounding errors.</p>","tags":["Translated"]},{"location":"algebra/fft.html#multiplication-with-arbitrary-modulus","title":"Multiplication with arbitrary modulus","text":"<p>Here we want to achieve the same goal as in previous section. Multiplying two polynomial $A(x)$ and $B(x)$, and computing the coefficients modulo some number $M$. The number theoretic transform only works for certain prime numbers. What about the case when the modulus is not of the desired form?</p> <p>One option would be to perform multiple number theoretic transforms with different prime numbers of the form $c 2^k + 1$, then apply the Chinese Remainder Theorem to compute the final coefficients.</p> <p>Another options is to distribute the polynomials $A(x)$ and $B(x)$ into two smaller polynomials each</p> $$\\begin{align} A(x) &amp;= A_1(x) + A_2(x) \\cdot C \\\\ B(x) &amp;= B_1(x) + B_2(x) \\cdot C \\end{align}$$ <p>with $C \\approx \\sqrt{M}$.</p> <p>Then the product of $A(x)$ and $B(x)$ can then be represented as:</p> $$A(x) \\cdot B(x) = A_1(x) \\cdot B_1(x) + \\left(A_1(x) \\cdot B_2(x) + A_2(x) \\cdot B_1(x)\\right)\\cdot C + \\left(A_2(x) \\cdot B_2(x)\\right)\\cdot C^2$$ <p>The polynomials $A_1(x)$, $A_2(x)$, $B_1(x)$ and $B_2(x)$ contain only coefficients smaller than $\\sqrt{M}$, therefore the coefficients of all the appearing products are smaller than $M \\cdot n$, which is usually small enough to handle with typical floating point types.</p> <p>This approach therefore requires computing the products of polynomials with smaller coefficients (by using the normal FFT and inverse FFT), and then the original product can be restored using modular addition and multiplication in $O(n)$ time.</p>","tags":["Translated"]},{"location":"algebra/fft.html#applications","title":"Applications","text":"<p>DFT can be used in a huge variety of other problems, which at the first glance have nothing to do with multiplying polynomials.</p>","tags":["Translated"]},{"location":"algebra/fft.html#all-possible-sums","title":"All possible sums","text":"<p>We are given two arrays $a[]$ and $b[]$. We have to find all possible sums $a[i] + b[j]$, and for each sum count how often it appears.</p> <p>For example for $a = [1,~ 2,~ 3]$ and $b = [2,~ 4]$ we get: then sum $3$ can be obtained in $1$ way, the sum $4$ also in $1$ way, $5$ in $2$, $6$ in $1$, $7$ in $1$.</p> <p>We construct for the arrays $a$ and $b$ two polynomials $A$ and $B$. The numbers of the array will act as the exponents in the polynomial ($a[i] \\Rightarrow x^{a[i]}$); and the coefficients of this term will be how often the number appears in the array.</p> <p>Then, by multiplying these two polynomials in $O(n \\log n)$ time, we get a polynomial $C$, where the exponents will tell us which sums can be obtained, and the coefficients tell us how often. To demonstrate this on the example:</p> $$(1 x^1 + 1 x^2 + 1 x^3) (1 x^2 + 1 x^4) = 1 x^3 + 1 x^4 + 2 x^5 + 1 x^6 + 1 x^7$$","tags":["Translated"]},{"location":"algebra/fft.html#all-possible-scalar-products","title":"All possible scalar products","text":"<p>We are given two arrays $a[]$ and $b[]$ of length $n$. We have to compute the products of $a$ with every cyclic shift of $b$.</p> <p>We generate two new arrays of size $2n$: We reverse $a$ and append $n$ zeros to it. And we just append $b$ to itself. When we multiply these two arrays as polynomials, and look at the coefficients $c[n-1],~ c[n],~ \\dots,~ c[2n-2]$ of the product $c$, we get:</p> $$c[k] = \\sum_{i+j=k} a[i] b[j]$$ <p>And since all the elements $a[i] = 0$ for $i \\ge n$:</p> $$c[k] = \\sum_{i=0}^{n-1} a[i] b[k-i]$$ <p>It is easy to see that this sum is just the scalar product of the vector $a$ with the $(k - (n - 1))$-th cyclic left shift of $b$. Thus these coefficients are the answer to the problem, and we were still able to obtain it in $O(n \\log n)$ time. Note here that $c[2n-1]$ also gives us the $n$-th cyclic shift but that is the same as the $0$-th cyclic shift so we don't need to consider that separately into our answer.</p>","tags":["Translated"]},{"location":"algebra/fft.html#two-stripes","title":"Two stripes","text":"<p>We are given two Boolean stripes (cyclic arrays of values $0$ and $1$) $a$ and $b$. We want to find all ways to attach the first stripe to the second one, such that at no position we have a $1$ of the first stripe next to a $1$ of the second stripe.</p> <p>The problem doesn't actually differ much from the previous problem. Attaching two stripes just means that we perform a cyclic shift on the second array, and we can attach the two stripes, if scalar product of the two arrays is $0$.</p>","tags":["Translated"]},{"location":"algebra/fft.html#string-matching","title":"String matching","text":"<p>We are given two strings, a text $T$ and a pattern $P$, consisting of lowercase letters. We have to compute all the occurrences of the pattern in the text.</p> <p>We create a polynomial for each string ($T[i]$ and $P[I]$ are numbers between $0$ and $25$ corresponding to the $26$ letters of the alphabet):</p> $$A(x) = a_0 x^0 + a_1 x^1 + \\dots + a_{n-1} x^{n-1}, \\quad n = |T|$$ <p>with</p> $$a_i = \\cos(\\alpha_i) + i \\sin(\\alpha_i), \\quad \\alpha_i = \\frac{2 \\pi T[i]}{26}.$$ <p>And</p> $$B(x) = b_0 x^0 + b_1 x^1 + \\dots + b_{m-1} x^{m-1}, \\quad m = |P|$$ <p>with</p> $$b_i = \\cos(\\beta_i) - i \\sin(\\beta_i), \\quad \\beta_i = \\frac{2 \\pi P[m-i-1]}{26}.$$ <p>Notice that with the expression $P[m-i-1]$ explicitly reverses the pattern.</p> <p>The $(m-1+i)$th coefficients of the product of the two polynomials $C(x) = A(x) \\cdot B(x)$ will tell us, if the pattern appears in the text at position $i$.</p> $$c_{m-1+i} = \\sum_{j = 0}^{m-1} a_{i+j} \\cdot b_{m-1-j} = \\sum_{j=0}^{m-1} \\left(\\cos(\\alpha_{i+j}) + i \\sin(\\alpha_{i+j})\\right) \\cdot \\left(\\cos(\\beta_j) - i \\sin(\\beta_j)\\right)$$ <p>with $\\alpha_{i+j} = \\frac{2 \\pi T[i+j]}{26}$ and $\\beta_j = \\frac{2 \\pi P[j]}{26}$</p> <p>If there is a match, than $T[i+j] = P[j]$, and therefore $\\alpha_{i+j} = \\beta_j$. This gives (using the Pythagorean trigonometric identity):</p> $$\\begin{align} c_{m-1+i} &amp;= \\sum_{j = 0}^{m-1}  \\left(\\cos(\\alpha_{i+j}) + i \\sin(\\alpha_{i+j})\\right) \\cdot \\left(\\cos(\\alpha_{i+j}) - i \\sin(\\alpha_{i+j})\\right) \\\\ &amp;= \\sum_{j = 0}^{m-1} \\cos(\\alpha_{i+j})^2 + \\sin(\\alpha_{i+j})^2 = \\sum_{j = 0}^{m-1} 1 = m \\end{align}$$ <p>If there isn't a match, then at least a character is different, which leads that one of the products $a_{i+1} \\cdot b_{m-1-j}$ is not equal to $1$, which leads to the coefficient $c_{m-1+i} \\ne m$.</p>","tags":["Translated"]},{"location":"algebra/fft.html#string-matching-with-wildcards","title":"String matching with wildcards","text":"<p>This is an extension of the previous problem. This time we allow that the pattern contains the wildcard character $\\*$, which can match every possible letter. E.g. the pattern $a*c$ appears in the text $abccaacc$ at exactly three positions, at index $0$, index $4$ and index $5$.</p> <p>We create the exact same polynomials, except that we set $b_i = 0$ if $P[m-i-1] = *$. If $x$ is the number of wildcards in $P$, then we will have a match of $P$ in $T$ at index $i$ if $c_{m-1+i} = m - x$.</p>","tags":["Translated"]},{"location":"algebra/fft.html#practice-problems","title":"Practice problems","text":"<ul> <li>SPOJ - POLYMUL</li> <li>SPOJ - MAXMATCH</li> <li>SPOJ - ADAMATCH</li> <li>Codeforces - Yet Another String Matching Problem</li> <li>Codeforces - Lightsabers (hard)</li> <li>Codeforces - Running Competition</li> <li>Kattis - A+B Problem</li> <li>Kattis - K-Inversions</li> <li>Codeforces - Dasha and cyclic table</li> <li>CodeChef - Expected Number of Customers</li> <li>CodeChef - Power Sum</li> <li>Codeforces - Centroid Probabilities</li> </ul>","tags":["Translated"]},{"location":"algebra/fibonacci-numbers.html","title":"Fibonacci Numbers","text":"<p>The Fibonacci sequence is defined as follows:</p> $$F_0 = 0, F_1 = 1, F_n = F_{n-1} + F_{n-2}$$ <p>The first elements of the sequence (OEIS A000045) are:</p> $$0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...$$","tags":["Translated"]},{"location":"algebra/fibonacci-numbers.html#properties","title":"Properties","text":"<p>Fibonacci numbers possess a lot of interesting properties. Here are a few of them:</p> <ul> <li>Cassini's identity:</li> </ul> $$F_{n-1} F_{n+1} - F_n^2 = (-1)^n$$ <p>This can be proved by induction. A one-line proof by Knuth comes from taking the determinant of the 2x2 matrix form below.</p> <ul> <li>The \"addition\" rule:</li> </ul> $$F_{n+k} = F_k F_{n+1} + F_{k-1} F_n$$ <ul> <li>Applying the previous identity to the case $k = n$, we get:</li> </ul> $$F_{2n} = F_n (F_{n+1} + F_{n-1})$$ <ul> <li> <p>From this we can prove by induction that for any positive integer $k$,  $F_{nk}$ is multiple of $F_n$.</p> </li> <li> <p>The inverse is also true: if $F_m$ is multiple of $F_n$, then $m$ is multiple of $n$.</p> </li> <li> <p>GCD identity:</p> </li> </ul> $$GCD(F_m, F_n) = F_{GCD(m, n)}$$ <ul> <li>Fibonacci numbers are the worst possible inputs for Euclidean algorithm (see Lame's theorem in Euclidean algorithm)</li> </ul>","tags":["Translated"]},{"location":"algebra/fibonacci-numbers.html#fibonacci-coding","title":"Fibonacci Coding","text":"<p>We can use the sequence to encode positive integers into binary code words. According to Zeckendorf's theorem, any natural number $n$ can be uniquely represented as a sum of Fibonacci numbers:</p> $$N = F_{k_1} + F_{k_2} + \\ldots + F_{k_r}$$ <p>such that $k_1 \\ge k_2 + 2,\\ k_2 \\ge k_3 + 2,\\  \\ldots,\\  k_r \\ge 2$ (i.e.: the representation cannot use two consecutive Fibonacci numbers).</p> <p>It follows that any number can be uniquely encoded in the Fibonacci coding. And we can describe this representation with binary codes $d_0 d_1 d_2 \\dots d_s 1$, where $d_i$ is $1$ if $F_{i+2}$ is used in the representation. The code will be appended by a $1$ to indicate the end of the code word. Notice that this is the only occurrence where two consecutive 1-bits appear.</p> $$\\begin{eqnarray} 1 &amp;=&amp; 1 &amp;=&amp; F_2 &amp;=&amp; (11)_F \\\\ 2 &amp;=&amp; 2 &amp;=&amp; F_3 &amp;=&amp; (011)_F \\\\ 6 &amp;=&amp; 5 + 1 &amp;=&amp; F_5 + F_2 &amp;=&amp; (10011)_F \\\\ 8 &amp;=&amp; 8 &amp;=&amp; F_6 &amp;=&amp; (000011)_F \\\\ 9 &amp;=&amp; 8 + 1 &amp;=&amp; F_6 + F_2 &amp;=&amp; (100011)_F \\\\ 19 &amp;=&amp; 13 + 5 + 1 &amp;=&amp; F_7 + F_5 + F_2 &amp;=&amp; (1001011)_F \\end{eqnarray}$$ <p>The encoding of an integer $n$ can be done with a simple greedy algorithm:</p> <ol> <li> <p>Iterate through the Fibonacci numbers from the largest to the smallest until you find one less than or equal to $n$.</p> </li> <li> <p>Suppose this number was $F_i$. Subtract $F_i$ from $n$ and put a $1$ in the $i-2$ position of the code word (indexing from 0 from the leftmost to the rightmost bit).</p> </li> <li> <p>Repeat until there is no remainder.</p> </li> <li> <p>Add a final $1$ to the codeword to indicate its end.</p> </li> </ol> <p>To decode a code word, first remove the final $1$. Then, if the $i$-th bit is set (indexing from 0 from the leftmost to the rightmost bit), sum $F_{i+2}$ to the number.</p>","tags":["Translated"]},{"location":"algebra/fibonacci-numbers.html#formulas-for-the-ntextth-fibonacci-number","title":"Formulas for the $n^{\\text{th}}$ Fibonacci number","text":"","tags":["Translated"]},{"location":"algebra/fibonacci-numbers.html#closed-form-expression","title":"Closed-form expression","text":"<p>There is a formula known as \"Binet's formula\", even though it was already known by Moivre:</p> $$F_n = \\frac{\\left(\\frac{1 + \\sqrt{5}}{2}\\right)^n - \\left(\\frac{1 - \\sqrt{5}}{2}\\right)^n}{\\sqrt{5}}$$ <p>This formula is easy to prove by induction, but it can be deduced with the help of the concept of generating functions or by solving a functional equation.</p> <p>You can immediately notice that the second term's absolute value is always less than $1$, and it also decreases very rapidly (exponentially). Hence the value of the first term alone is \"almost\" $F_n$. This can be written strictly as: </p> $$F_n = \\left[\\frac{\\left(\\frac{1 + \\sqrt{5}}{2}\\right)^n}{\\sqrt{5}}\\right]$$ <p>where the square brackets denote rounding to the nearest integer.</p> <p>As these two formulas would require very high accuracy when working with fractional numbers, they are of little use in practical calculations.</p>","tags":["Translated"]},{"location":"algebra/fibonacci-numbers.html#fibonacci-in-linear-time","title":"Fibonacci in linear time","text":"<p>The $n$-th Fibonacci number can be easily found in $O(n)$ by computing the numbers one by one up to $n$. However, there are also faster ways, as we will see.</p> <p>We can start from an iterative approach, to take advantage of the use of the formula $F_n = F_{n-1} + F_{n-2}$, therefore, we will simply precalculate those values in an array. Taking into account the base cases for $F_0$ and $F_1$.</p> <pre><code>int fib(int n) {\n    int a = 0;\n    int b = 1;\n    for (int i = 0; i &lt; n; i++) {\n        int tmp = a + b;\n        a = b;\n        b = tmp;\n    }\n    return a;\n}\n</code></pre> <p>In this way, we obtain a linear solution, $O(n)$ time, saving all the values prior to $n$ in the sequence.</p>","tags":["Translated"]},{"location":"algebra/fibonacci-numbers.html#matrix-form","title":"Matrix form","text":"<p>To go from $(F_n, F_{n-1})$ to $(F_{n+1}, F_n)$, we can express the linear recurrence as a 2x2 matrix multiplication:</p> $$ \\begin{pmatrix} 1 &amp; 1 \\\\ 1 &amp; 0 \\end{pmatrix} \\begin{pmatrix} F_n \\\\ F_{n-1} \\end{pmatrix} = \\begin{pmatrix} F_n + F_{n-1}  \\\\ F_{n} \\end{pmatrix} = \\begin{pmatrix} F_{n+1}  \\\\ F_{n} \\end{pmatrix} $$ <p>This lets us treat iterating the recurrence as repeated matrix multiplication, which has nice properties. In particular,</p> $$ \\begin{pmatrix} 1 &amp; 1 \\\\ 1 &amp; 0 \\end{pmatrix}^n \\begin{pmatrix} F_1 \\\\ F_0 \\end{pmatrix} = \\begin{pmatrix} F_{n+1}  \\\\ F_{n} \\end{pmatrix} $$ <p>where $F_1 = 1, F_0 = 0$.  In fact, since </p> $$ \\begin{pmatrix} 1 &amp; 1 \\\\ 1 &amp; 0 \\end{pmatrix} = \\begin{pmatrix} F_2 &amp; F_1 \\\\ F_1 &amp; F_0 \\end{pmatrix} $$ <p>we can use the matrix directly:</p> $$ \\begin{pmatrix} 1 &amp; 1 \\\\ 1 &amp; 0 \\end{pmatrix}^n = \\begin{pmatrix} F_{n+1} &amp; F_n \\\\ F_n &amp; F_{n-1} \\end{pmatrix} $$ <p>Thus, in order to find $F_n$ in $O(\\log  n)$ time, we must raise the matrix to n. (See Binary exponentiation)</p> <pre><code>struct matrix {\n    long long mat[2][2];\n    matrix friend operator *(const matrix &amp;a, const matrix &amp;b){\n        matrix c;\n        for (int i = 0; i &lt; 2; i++) {\n          for (int j = 0; j &lt; 2; j++) {\n              c.mat[i][j] = 0;\n              for (int k = 0; k &lt; 2; k++) {\n                  c.mat[i][j] += a.mat[i][k] * b.mat[k][j];\n              }\n          }\n        }\n        return c;\n    }\n};\n\nmatrix matpow(matrix base, long long n) {\n    matrix ans{ {\n      {1, 0},\n      {0, 1}\n    } };\n    while (n) {\n        if(n&amp;1)\n            ans = ans*base;\n        base = base*base;\n        n &gt;&gt;= 1;\n    }\n    return ans;\n}\n\nlong long fib(int n) {\n    matrix base{ {\n      {1, 1},\n      {1, 0}\n    } };\n    return matpow(base, n).mat[0][1];\n}\n</code></pre>","tags":["Translated"]},{"location":"algebra/fibonacci-numbers.html#fast-doubling-method","title":"Fast Doubling Method","text":"<p>By expanding the above matrix expression for $n = 2\\cdot k$</p> $$ \\begin{pmatrix} F_{2k+1} &amp; F_{2k}\\\\ F_{2k} &amp; F_{2k-1} \\end{pmatrix} = \\begin{pmatrix} 1 &amp; 1\\\\ 1 &amp; 0 \\end{pmatrix}^{2k} = \\begin{pmatrix} F_{k+1} &amp; F_{k}\\\\ F_{k} &amp; F_{k-1} \\end{pmatrix} ^2 $$ <p>we can find these simpler equations:</p> $$ \\begin{align} F_{2k+1} &amp;= F_{k+1}^2 + F_{k}^2 \\\\ F_{2k} &amp;= F_k(F_{k+1}+F_{k-1}) = F_k (2F_{k+1} - F_{k})\\\\ \\end{align}.$$ <p>Thus using above two equations Fibonacci numbers can be calculated easily by the following code:</p> <p><pre><code>pair&lt;int, int&gt; fib (int n) {\n    if (n == 0)\n        return {0, 1};\n\n    auto p = fib(n &gt;&gt; 1);\n    int c = p.first * (2 * p.second - p.first);\n    int d = p.first * p.first + p.second * p.second;\n    if (n &amp; 1)\n        return {d, c + d};\n    else\n        return {c, d};\n}\n</code></pre> The above code returns $F_n$ and $F_{n+1}$ as a pair.</p>","tags":["Translated"]},{"location":"algebra/fibonacci-numbers.html#periodicity-modulo-p","title":"Periodicity modulo p","text":"<p>Consider the Fibonacci sequence modulo $p$. We will prove the sequence is periodic.</p> <p>Let us prove this by contradiction. Consider the first $p^2 + 1$ pairs of Fibonacci numbers taken modulo $p$:</p> $$(F_0,\\ F_1),\\ (F_1,\\ F_2),\\ \\ldots,\\ (F_{p^2},\\ F_{p^2 + 1})$$ <p>There can only be $p$ different remainders modulo $p$, and at most $p^2$ different pairs of remainders, so there are at least two identical pairs among them. This is sufficient to prove the sequence is periodic, as a Fibonacci number is only determined by its two predecessors. Hence if two pairs of consecutive numbers repeat, that would also mean the numbers after the pair will repeat in the same fashion.</p> <p>We now choose two pairs of identical remainders with the smallest indices in the sequence. Let the pairs be $(F_a,\\ F_{a + 1})$ and $(F_b,\\ F_{b + 1})$. We will prove that $a = 0$. If this was false, there would be two previous pairs $(F_{a-1},\\ F_a)$ and $(F_{b-1},\\ F_b)$, which, by the property of Fibonacci numbers, would also be equal. However, this contradicts the fact that we had chosen pairs with the smallest indices, completing our proof that there is no pre-period (i.e the numbers are periodic starting from $F_0$).</p>","tags":["Translated"]},{"location":"algebra/fibonacci-numbers.html#practice-problems","title":"Practice Problems","text":"<ul> <li>SPOJ - Euclid Algorithm Revisited</li> <li>SPOJ - Fibonacci Sum</li> <li>HackerRank - Is Fibo</li> <li>Project Euler - Even Fibonacci numbers</li> <li>DMOJ - Fibonacci Sequence</li> <li>DMOJ - Fibonacci Sequence (Harder)</li> <li>DMOJ UCLV - Numbered sequence of pencils</li> <li>DMOJ UCLV - Fibonacci 2D</li> <li>DMOJ UCLV - fibonacci calculation</li> <li>LightOJ -  Number Sequence</li> <li>Codeforces - C. Fibonacci</li> <li>Codeforces - A. Hexadecimal's theorem</li> <li>Codeforces - B. Blackboard Fibonacci</li> <li>Codeforces - E. Fibonacci Number</li> </ul>","tags":["Translated"]},{"location":"algebra/garners-algorithm.html","title":"Garner's algorithm","text":"<p>A consequence of the Chinese Remainder Theorem is, that we can represent big numbers using an array of small integers. For example, let $p$ be the product of the first $1000$ primes. $p$ has around $3000$ digits.</p> <p>Any number $a$ less than $p$ can be represented as an array  $a_1, \\ldots, a_k$, where $a_i \\equiv a \\pmod{p_i}$. But to do this we obviously need to know how to get back the number $a$ from its representation. One way is discussed in the article about the Chinese Remainder Theorem.</p> <p>In this article we discuss an alternative, Garner's Algorithm, which can also be used for this purpose.</p>"},{"location":"algebra/garners-algorithm.html#mixed-radix-representation","title":"Mixed Radix Representation","text":"<p>We can represent the number $a$ in the mixed radix representation:</p> $$a = x_1 + x_2 p_1 + x_3 p_1 p_2 + \\ldots + x_k p_1 \\cdots p_{k-1} \\text{ with }x_i \\in [0, p_i)$$ <p>A mixed radix representation is a positional numeral system, that's a generalization of the typical number systems, like the binary numeral system or the decimal numeral system. For instance, the decimal numeral system is a positional numeral system with the radix (or base) 10. Every number is represented as a string of digits $d_1 d_2 d_3 \\dots d_n$ between $0$ and $9$. For example, the string $415$ represents the number $4 \\cdot 10^2 + 1 \\cdot 10^1 + 5 \\cdot 10^0$. In general the string of digits $d_1 d_2 d_3 \\dots d_n$ represents the number $d_1 b^{n-1} + d_2 b^{n-2} + \\cdots + d_n b^0$ in the positional numeral system with radix $b$.</p> <p>In a mixed radix system, we don't have one radix any more. The base varies from position to position.</p>"},{"location":"algebra/garners-algorithm.html#garners-algorithm_1","title":"Garner's algorithm","text":"<p>Garner's algorithm computes the digits $x_1, \\ldots, x_k$. Notice, that the digits are relatively small. The digit $x_i$ is an integer between $0$ and $p_i - 1$.</p> <p>Let $r_{ij}$ denote the inverse of $p_i$ modulo $p_j$</p> $$r_{ij} = (p_i)^{-1} \\pmod{p_j}$$ <p>which can be found using the algorithm described in Modular Inverse.</p> <p>Substituting $a$ from the mixed radix representation into the first congruence equation we obtain</p> $$a_1 \\equiv x_1 \\pmod{p_1}.$$ <p>Substituting into the second equation yields</p> $$a_2 \\equiv x_1 + x_2 p_1 \\pmod{p_2},$$ <p>which can be rewritten by subtracting $x_1$ and dividing by $p_1$ to get</p> $$\\begin{array}{rclr}     a_2 - x_1 &amp;\\equiv&amp; x_2 p_1 &amp;\\pmod{p_2} \\\\     (a_2 - x_1) r_{12} &amp;\\equiv&amp; x_2 &amp;\\pmod{p_2} \\\\     x_2 &amp;\\equiv&amp; (a_2 - x_1) r_{12} &amp;\\pmod{p_2} \\end{array}$$ <p>Similarly we get that</p> $$x_3 \\equiv ((a_3 - x_1) r_{13} - x_2) r_{23} \\pmod{p_3}.$$ <p>Now, we can clearly see an emerging pattern, which can be expressed by the following code:</p> <pre><code>for (int i = 0; i &lt; k; ++i) {\n    x[i] = a[i];\n    for (int j = 0; j &lt; i; ++j) {\n        x[i] = r[j][i] * (x[i] - x[j]);\n\n        x[i] = x[i] % p[i];\n        if (x[i] &lt; 0)\n            x[i] += p[i];\n    }\n}\n</code></pre> <p>So we learned how to calculate digits $x_i$ in $O(k^2)$ time. The number $a$ can now be calculated using the previously mentioned formula</p> $$a = x_1 + x_2 \\cdot p_1 + x_3 \\cdot p_1 \\cdot p_2 + \\ldots + x_k \\cdot p_1 \\cdots p_{k-1}$$ <p>It is worth noting that in practice, we almost probably need to compute the answer $a$ using Arbitrary-Precision Arithmetic, but the digits $x_i$ (because they are small) can usually be calculated using built-in types, and therefore Garner's algorithm is very efficient.</p>"},{"location":"algebra/garners-algorithm.html#implementation-of-garners-algorithm","title":"Implementation of Garner's Algorithm","text":"<p>It is convenient to implement this algorithm using Java, because it has built-in support for large numbers through the <code>BigInteger</code> class.</p> <p>Here we show an implementation that can store big numbers in the form of a set of congruence equations. It supports addition, subtraction and multiplication. And with Garner's algorithm we can convert the set of equations into the unique integer. In this code, we take 100 prime numbers greater than $10^9$, which allows representing numbers as large as $10^{900}$.</p> <pre><code>final int SZ = 100;\nint pr[] = new int[SZ];\nint r[][] = new int[SZ][SZ];\n\nvoid init() {\n    for (int x = 1000 * 1000 * 1000, i = 0; i &lt; SZ; ++x)\n        if (BigInteger.valueOf(x).isProbablePrime(100))\n            pr[i++] = x;\n\n    for (int i = 0; i &lt; SZ; ++i)\n        for (int j = i + 1; j &lt; SZ; ++j)\n            r[i][j] =\n                BigInteger.valueOf(pr[i]).modInverse(BigInteger.valueOf(pr[j])).intValue();\n}\n\nclass Number {\n    int a[] = new int[SZ];\n\n    public Number() {\n    }\n\n    public Number(int n) {\n        for (int i = 0; i &lt; SZ; ++i)\n            a[i] = n % pr[i];\n    }\n\n    public Number(BigInteger n) {\n        for (int i = 0; i &lt; SZ; ++i)\n            a[i] = n.mod(BigInteger.valueOf(pr[i])).intValue();\n    }\n\n    public Number add(Number n) {\n        Number result = new Number();\n        for (int i = 0; i &lt; SZ; ++i)\n            result.a[i] = (a[i] + n.a[i]) % pr[i];\n        return result;\n    }\n\n    public Number subtract(Number n) {\n        Number result = new Number();\n        for (int i = 0; i &lt; SZ; ++i)\n            result.a[i] = (a[i] - n.a[i] + pr[i]) % pr[i];\n        return result;\n    }\n\n    public Number multiply(Number n) {\n        Number result = new Number();\n        for (int i = 0; i &lt; SZ; ++i)\n            result.a[i] = (int)((a[i] * 1l * n.a[i]) % pr[i]);\n        return result;\n    }\n\n    public BigInteger bigIntegerValue(boolean can_be_negative) {\n        BigInteger result = BigInteger.ZERO, mult = BigInteger.ONE;\n        int x[] = new int[SZ];\n        for (int i = 0; i &lt; SZ; ++i) {\n            x[i] = a[i];\n            for (int j = 0; j &lt; i; ++j) {\n                long cur = (x[i] - x[j]) * 1l * r[j][i];\n                x[i] = (int)((cur % pr[i] + pr[i]) % pr[i]);\n            }\n            result = result.add(mult.multiply(BigInteger.valueOf(x[i])));\n            mult = mult.multiply(BigInteger.valueOf(pr[i]));\n        }\n\n        if (can_be_negative)\n            if (result.compareTo(mult.shiftRight(1)) &gt;= 0)\n                result = result.subtract(mult);\n\n        return result;\n    }\n}\n</code></pre>"},{"location":"algebra/gray-code.html","title":"Gray code","text":"<p>Gray code is a binary numeral system where two successive values differ in only one bit. </p> <p>For example, the sequence of Gray codes for 3-bit numbers is: 000, 001, 011, 010, 110, 111, 101, 100, so $G(4) = 6$.</p> <p>This code was invented by Frank Gray in 1953.</p>","tags":["Translated"]},{"location":"algebra/gray-code.html#finding-gray-code","title":"Finding Gray code","text":"<p>Let's look at the bits of number $n$ and the bits of number $G(n)$. Notice that $i$-th bit of $G(n)$ equals 1 only when $i$-th bit of $n$ equals 1 and $i + 1$-th bit equals 0 or the other way around ($i$-th bit equals 0 and $i + 1$-th bit equals 1). Thus, $G(n) = n \\oplus (n &gt;&gt; 1)$:  </p> <pre><code>int g (int n) {\n    return n ^ (n &gt;&gt; 1);\n}\n</code></pre>","tags":["Translated"]},{"location":"algebra/gray-code.html#finding-inverse-gray-code","title":"Finding inverse Gray code","text":"<p>Given Gray code $g$, restore the original number $n$.</p> <p>We will move from the most significant bits to the least significant ones (the least significant bit has index 1 and the most significant bit has index $k$). The relation between the bits $n_i$ of number $n$ and the bits $g_i$ of number $g$:</p> $$\\begin{align}   n_k &amp;= g_k, \\\\   n_{k-1} &amp;= g_{k-1} \\oplus n_k = g_k \\oplus g_{k-1}, \\\\   n_{k-2} &amp;= g_{k-2} \\oplus n_{k-1} = g_k \\oplus g_{k-1} \\oplus g_{k-2}, \\\\   n_{k-3} &amp;= g_{k-3} \\oplus n_{k-2} = g_k \\oplus g_{k-1} \\oplus g_{k-2} \\oplus g_{k-3},   \\vdots \\end{align}$$ <p>The easiest way to write it in code is:</p> <pre><code>int rev_g (int g) {\n  int n = 0;\n  for (; g; g &gt;&gt;= 1)\n    n ^= g;\n  return n;\n}\n</code></pre>","tags":["Translated"]},{"location":"algebra/gray-code.html#practical-applications","title":"Practical applications","text":"<p>Gray codes have some useful applications, sometimes quite unexpected:</p> <ul> <li> <p>Gray code of $n$ bits forms a Hamiltonian cycle on a hypercube, where each bit corresponds to one dimension. </p> </li> <li> <p>Gray codes are used to minimize the errors in digital-to-analog signals conversion (for example, in sensors). </p> </li> <li> <p>Gray code can be used to solve the Towers of Hanoi problem.     Let $n$ denote number of disks. Start with Gray code of length $n$ which     consists of all zeroes ($G(0)$) and move between consecutive Gray codes (from $G(i)$ to $G(i+1)$).     Let $i$-th bit of current Gray code represent $n$-th disk      (the least significant bit corresponds to the smallest disk and the most significant bit to the biggest disk).      Since exactly one bit changes on each step, we can treat changing $i$-th bit as moving $i$-th disk.     Notice that there is exactly one move option for each disk (except the smallest one) on each step (except start and finish positions).     There are always two move options for the smallest disk but there is a strategy which will always lead to answer:     if $n$ is odd then sequence of the smallest disk moves looks like $f \\to t \\to r \\to f \\to t \\to r \\to ...$     where $f$ is the initial rod, $t$ is the terminal rod and $r$ is the remaining rod), and      if $n$ is even: $f \\to r \\to t \\to f \\to r \\to t \\to ...$.</p> </li> <li> <p>Gray codes are also used in genetic algorithms theory.</p> </li> </ul>","tags":["Translated"]},{"location":"algebra/gray-code.html#practice-problems","title":"Practice Problems","text":"<ul> <li>Gray Code \u00a0\u00a0\u00a0\u00a0 [Difficulty: easy]</li> <li>SGU #249 \"Matrix\" \u00a0\u00a0\u00a0\u00a0 [Difficulty: medium]</li> </ul>","tags":["Translated"]},{"location":"algebra/linear-diophantine-equation.html","title":"Linear Diophantine Equation","text":"<p>A Linear Diophantine Equation (in two variables) is an equation of the general form:</p> $$ax + by = c$$ <p>where $a$, $b$, $c$ are given integers, and $x$, $y$ are unknown integers.</p> <p>In this article, we consider several classical problems on these equations:</p> <ul> <li>finding one solution</li> <li>finding all solutions</li> <li>finding the number of solutions and the solutions themselves in a given interval</li> <li>finding a solution with minimum value of $x + y$</li> </ul>","tags":["Translated"]},{"location":"algebra/linear-diophantine-equation.html#the-degenerate-case","title":"The degenerate case","text":"<p>A degenerate case that needs to be taken care of is when $a = b = 0$. It is easy to see that we either have no solutions or infinitely many solutions, depending on whether $c = 0$ or not. In the rest of this article, we will ignore this case.</p>","tags":["Translated"]},{"location":"algebra/linear-diophantine-equation.html#analytic-solution","title":"Analytic solution","text":"<p>When $a \\neq 0$ and $b \\neq 0$, the equation $ax+by=c$ can be equivalently treated as either of the following:</p> $$\\begin{align} ax &amp;\\equiv c \\pmod b \\\\ by &amp;\\equiv c \\pmod a \\end{align}$$ <p>Without loss of generality, assume that $b \\neq 0$ and consider the first equation. When $a$ and $b$ are co-prime, the solution to it is given as</p> $$x \\equiv ca^{-1} \\pmod b,$$ <p>where $a^{-1}$ is the modular inverse of $a$ modulo $b$.</p> <p>When $a$ and $b$ are not co-prime, values of $ax$ modulo $b$ for all integer $x$ are divisible by $g=\\gcd(a, b)$, so the solution only exists when $c$ is divisible by $g$. In this case, one of solutions can be found by reducing the equation by $g$:</p> $$(a/g) x \\equiv (c/g) \\pmod{b/g}.$$ <p>By the definition of $g$, the numbers $a/g$ and $b/g$ are co-prime, so the solution is given explicitly as</p> $$\\begin{cases} x \\equiv (c/g)(a/g)^{-1}\\pmod{b/g},\\\\ y = \\frac{c-ax}{b}. \\end{cases}$$","tags":["Translated"]},{"location":"algebra/linear-diophantine-equation.html#algorithmic-solution","title":"Algorithmic solution","text":"<p>B\u00e9zout's lemma (also called B\u00e9zout's identity) is a useful result that can be used to understand the following solution. </p> <p>Let $g = \\gcd(a,b)$. Then there exist integers $x,y$ such that $ax + by = g$.</p> <p>Moreover, $g$ is the least such positive integer that can be written as $ax + by$; all integers of the form $ax + by$ are multiples of $g$. </p> <p>To find one solution of the Diophantine equation with 2 unknowns, you can use the Extended Euclidean algorithm. First, assume that $a$ and $b$ are non-negative. When we apply Extended Euclidean algorithm for $a$ and $b$, we can find their greatest common divisor $g$ and 2 numbers $x_g$ and $y_g$ such that:</p> $$a x_g + b y_g = g$$ <p>If $c$ is divisible by $g = \\gcd(a, b)$, then the given Diophantine equation has a solution, otherwise it does not have any solution. The proof is straight-forward: a linear combination of two numbers is divisible by their common divisor.</p> <p>Now suppose that $c$ is divisible by $g$, then we have:</p> $$a \\cdot x_g \\cdot \\frac{c}{g} + b \\cdot y_g \\cdot \\frac{c}{g} = c$$ <p>Therefore one of the solutions of the Diophantine equation is:</p> $$x_0 = x_g \\cdot \\frac{c}{g},$$ $$y_0 = y_g \\cdot \\frac{c}{g}.$$ <p>The above idea still works when $a$ or $b$ or both of them are negative. We only need to change the sign of $x_0$ and $y_0$ when necessary.</p> <p>Finally, we can implement this idea as follows (note that this code does not consider the case $a = b = 0$):</p> <pre><code>int gcd(int a, int b, int&amp; x, int&amp; y) {\n    if (b == 0) {\n        x = 1;\n        y = 0;\n        return a;\n    }\n    int x1, y1;\n    int d = gcd(b, a % b, x1, y1);\n    x = y1;\n    y = x1 - y1 * (a / b);\n    return d;\n}\n\nbool find_any_solution(int a, int b, int c, int &amp;x0, int &amp;y0, int &amp;g) {\n    g = gcd(abs(a), abs(b), x0, y0);\n    if (c % g) {\n        return false;\n    }\n\n    x0 *= c / g;\n    y0 *= c / g;\n    if (a &lt; 0) x0 = -x0;\n    if (b &lt; 0) y0 = -y0;\n    return true;\n}\n</code></pre>","tags":["Translated"]},{"location":"algebra/linear-diophantine-equation.html#getting-all-solutions","title":"Getting all solutions","text":"<p>From one solution $(x_0, y_0)$, we can obtain all the solutions of the given equation.</p> <p>Let $g = \\gcd(a, b)$ and let $x_0, y_0$ be integers which satisfy the following:</p> $$a \\cdot x_0 + b \\cdot y_0 = c$$ <p>Now, we should see that adding $b / g$ to $x_0$, and, at the same time subtracting $a / g$ from $y_0$ will not break the equality:</p> $$a \\cdot \\left(x_0 + \\frac{b}{g}\\right) + b \\cdot \\left(y_0 - \\frac{a}{g}\\right) = a \\cdot x_0 + b \\cdot y_0 + a \\cdot \\frac{b}{g} - b \\cdot \\frac{a}{g} = c$$ <p>Obviously, this process can be repeated again, so all the numbers of the form:</p> $$x = x_0 + k \\cdot \\frac{b}{g}$$ $$y = y_0 - k \\cdot \\frac{a}{g}$$ <p>are solutions of the given Diophantine equation.</p> <p>Since the equation is linear, all solutions lie on the same line, and by the definition of $g$ this is the set of all possible solutions of the given Diophantine equation.</p>","tags":["Translated"]},{"location":"algebra/linear-diophantine-equation.html#finding-the-number-of-solutions-and-the-solutions-in-a-given-interval","title":"Finding the number of solutions and the solutions in a given interval","text":"<p>From previous section, it should be clear that if we don't impose any restrictions on the solutions, there would be infinite number of them. So in this section, we add some restrictions on the interval of $x$ and $y$, and we will try to count and enumerate all the solutions.</p> <p>Let there be two intervals: $[min_x; max_x]$ and $[min_y; max_y]$ and let's say we only want to find the solutions in these two intervals.</p> <p>Note that if $a$ or $b$ is $0$, then the problem only has one solution. We don't consider this case here.</p> <p>First, we can find a solution which has minimum value of $x$, such that $x \\ge min_x$. To do this, we first find any solution of the Diophantine equation. Then, we shift this solution to get $x \\ge min_x$ (using what we know about the set of all solutions in previous section). This can be done in $O(1)$. Denote this minimum value of $x$ by $l_{x1}$.</p> <p>Similarly, we can find the maximum value of $x$ which satisfies $x \\le max_x$. Denote this maximum value of $x$ by $r_{x1}$.</p> <p>Similarly, we can find the minimum value of $y$ $(y \\ge min_y)$ and maximum value of $y$ $(y \\le max_y)$. Denote the corresponding values of $x$ by $l_{x2}$ and $r_{x2}$.</p> <p>The final solution is all solutions with x in intersection of $[l_{x1}, r_{x1}]$ and $[l_{x2}, r_{x2}]$. Let denote this intersection by $[l_x, r_x]$.</p> <p>Following is the code implementing this idea. Notice that we divide $a$ and $b$ at the beginning by $g$. Since the equation $a x + b y = c$ is equivalent to the equation $\\frac{a}{g} x + \\frac{b}{g} y = \\frac{c}{g}$, we can use this one instead and have $\\gcd(\\frac{a}{g}, \\frac{b}{g}) = 1$, which simplifies the formulas.</p> <pre><code>void shift_solution(int &amp; x, int &amp; y, int a, int b, int cnt) {\n    x += cnt * b;\n    y -= cnt * a;\n}\n\nint find_all_solutions(int a, int b, int c, int minx, int maxx, int miny, int maxy) {\n    int x, y, g;\n    if (!find_any_solution(a, b, c, x, y, g))\n        return 0;\n    a /= g;\n    b /= g;\n\n    int sign_a = a &gt; 0 ? +1 : -1;\n    int sign_b = b &gt; 0 ? +1 : -1;\n\n    shift_solution(x, y, a, b, (minx - x) / b);\n    if (x &lt; minx)\n        shift_solution(x, y, a, b, sign_b);\n    if (x &gt; maxx)\n        return 0;\n    int lx1 = x;\n\n    shift_solution(x, y, a, b, (maxx - x) / b);\n    if (x &gt; maxx)\n        shift_solution(x, y, a, b, -sign_b);\n    int rx1 = x;\n\n    shift_solution(x, y, a, b, -(miny - y) / a);\n    if (y &lt; miny)\n        shift_solution(x, y, a, b, -sign_a);\n    if (y &gt; maxy)\n        return 0;\n    int lx2 = x;\n\n    shift_solution(x, y, a, b, -(maxy - y) / a);\n    if (y &gt; maxy)\n        shift_solution(x, y, a, b, sign_a);\n    int rx2 = x;\n\n    if (lx2 &gt; rx2)\n        swap(lx2, rx2);\n    int lx = max(lx1, lx2);\n    int rx = min(rx1, rx2);\n\n    if (lx &gt; rx)\n        return 0;\n    return (rx - lx) / abs(b) + 1;\n}\n</code></pre> <p>Once we have $l_x$ and $r_x$, it is also simple to enumerate through all the solutions. Just need to iterate through $x = l_x + k \\cdot \\frac{b}{g}$ for all $k \\ge 0$ until $x = r_x$, and find the corresponding $y$ values using the equation $a x + b y = c$.</p>","tags":["Translated"]},{"location":"algebra/linear-diophantine-equation.html#find-the-solution-with-minimum-value-of-x-y","title":"Find the solution with minimum value of $x + y$","text":"<p>Here, $x$ and $y$ also need to be given some restriction, otherwise, the answer may become negative infinity.</p> <p>The idea is similar to previous section: We find any solution of the Diophantine equation, and then shift the solution to satisfy some conditions.</p> <p>Finally, use the knowledge of the set of all solutions to find the minimum:</p> $$x' = x + k \\cdot \\frac{b}{g},$$ $$y' = y - k \\cdot \\frac{a}{g}.$$ <p>Note that $x + y$ change as follows:</p> $$x' + y' = x + y + k \\cdot \\left(\\frac{b}{g} - \\frac{a}{g}\\right) = x + y + k \\cdot \\frac{b-a}{g}$$ <p>If $a &lt; b$, we need to select smallest possible value of $k$. If $a &gt; b$, we need to select the largest possible value of $k$. If $a = b$, all solution will have the same sum $x + y$.</p>","tags":["Translated"]},{"location":"algebra/linear-diophantine-equation.html#practice-problems","title":"Practice Problems","text":"<ul> <li>Spoj - Crucial Equation</li> <li>SGU 106</li> <li>Codeforces - Ebony and Ivory</li> <li>Codechef - Get AC in one go</li> <li>LightOj - Solutions to an equation</li> <li>Atcoder - F - S = 1</li> </ul>","tags":["Translated"]},{"location":"algebra/linear_congruence_equation.html","title":"Linear Congruence Equation","text":"<p>This equation is of the form:</p> $$a \\cdot x \\equiv b \\pmod n,$$ <p>where $a$, $b$ and $n$ are given integers and $x$ is an unknown integer.</p> <p>It is required to find the value $x$ from the interval $[0, n-1]$ (clearly, on the entire number line there can be infinitely many solutions that will differ from each other in $n \\cdot k$ , where $k$ is any integer). If the solution is not unique, then we will consider how to get all the solutions.</p>","tags":["Translated"]},{"location":"algebra/linear_congruence_equation.html#solution-by-finding-the-inverse-element","title":"Solution by finding the inverse element","text":"<p>Let us first consider a simpler case where $a$ and $n$ are coprime ($\\gcd(a, n) = 1$). Then one can find the inverse of $a$, and multiplying both sides of the equation with the inverse, and we can get a unique solution.</p> $$x \\equiv b \\cdot a ^ {- 1} \\pmod n$$ <p>Now consider the case where $a$ and $n$ are not coprime ($\\gcd(a, n) \\ne 1$). Then the solution will not always exist (for example $2 \\cdot x \\equiv 1 \\pmod 4$ has no solution).</p> <p>Let $g = \\gcd(a, n)$, i.e. the greatest common divisor of $a$ and $n$ (which in this case is greater than one).</p> <p>Then, if $b$ is not divisible by $g$, there is no solution. In fact, for any $x$ the left side of the equation $a \\cdot x \\pmod n$ , is always divisible by $g$, while the right-hand side is not divisible by it, hence it follows that there are no solutions.</p> <p>If $g$ divides $b$, then by dividing both sides of the equation by $g$ (i.e. dividing $a$, $b$ and $n$ by $g$), we receive a new equation:</p> $$a^\\prime \\cdot x \\equiv b^\\prime \\pmod{n^\\prime}$$ <p>in which $a^\\prime$ and $n^\\prime$ are already relatively prime, and we have already learned how to handle such an equation. We get $x^\\prime$ as solution for $x$.</p> <p>It is clear that this $x^\\prime$ will also be a solution of the original equation. However it will not be the only solution. It can be shown that the original equation has exactly $g$ solutions, and they will look like this:</p> $$x_i \\equiv (x^\\prime + i\\cdot n^\\prime) \\pmod n \\quad \\text{for } i = 0 \\ldots g-1$$ <p>Summarizing, we can say that the number of solutions of the linear congruence equation is equal to either $g = \\gcd(a, n)$ or to zero.</p>","tags":["Translated"]},{"location":"algebra/linear_congruence_equation.html#solution-with-the-extended-euclidean-algorithm","title":"Solution with the Extended Euclidean Algorithm","text":"<p>We can rewrite the linear congruence to the following Diophantine equation:</p> $$a \\cdot x + n \\cdot k = b,$$ <p>where $x$ and $k$ are unknown integers.</p> <p>The method of solving this equation is described in the corresponding article Linear Diophantine equations and it consists of applying the Extended Euclidean Algorithm.</p> <p>It also describes the method of obtaining all solutions of this equation from one found solution, and incidentally this method, when carefully considered, is absolutely equivalent to the method described in the previous section.</p>","tags":["Translated"]},{"location":"algebra/module-inverse.html","title":"Modular Multiplicative Inverse","text":"","tags":["Translated"]},{"location":"algebra/module-inverse.html#definition","title":"Definition","text":"<p>A modular multiplicative inverse of an integer $a$ is an integer $x$ such that $a \\cdot x$ is congruent to $1$ modular some modulus $m$. To write it in a formal way: we want to find an integer $x$ so that </p> $$a \\cdot x \\equiv 1 \\mod m.$$ <p>We will also denote $x$ simply with $a^{-1}$.</p> <p>We should note that the modular inverse does not always exist. For example, let $m = 4$, $a = 2$.  By checking all possible values modulo $m$, it should become clear that we cannot find $a^{-1}$ satisfying the above equation.  It can be proven that the modular inverse exists if and only if $a$ and $m$ are relatively prime (i.e. $\\gcd(a, m) = 1$).</p> <p>In this article, we present two methods for finding the modular inverse in case it exists, and one method for finding the modular inverse for all numbers in linear time.</p>","tags":["Translated"]},{"location":"algebra/module-inverse.html#finding-the-modular-inverse-using-extended-euclidean-algorithm","title":"Finding the Modular Inverse using Extended Euclidean algorithm","text":"<p>Consider the following equation (with unknown $x$ and $y$):</p> $$a \\cdot x + m \\cdot y = 1$$ <p>This is a Linear Diophantine equation in two variables. As shown in the linked article, when $\\gcd(a, m) = 1$, the equation has a solution which can be found using the extended Euclidean algorithm. Note that $\\gcd(a, m) = 1$ is also the condition for the modular inverse to exist.</p> <p>Now, if we take modulo $m$ of both sides, we can get rid of $m \\cdot y$, and the equation becomes:</p> $$a \\cdot x \\equiv 1 \\mod m$$ <p>Thus, the modular inverse of $a$ is $x$.</p> <p>The implementation is as follows:</p> <pre><code>int x, y;\nint g = extended_euclidean(a, m, x, y);\nif (g != 1) {\n    cout &lt;&lt; \"No solution!\";\n}\nelse {\n    x = (x % m + m) % m;\n    cout &lt;&lt; x &lt;&lt; endl;\n}\n</code></pre> <p>Notice that the way we modify <code>x</code>. The resulting <code>x</code> from the extended Euclidean algorithm may be negative, so <code>x % m</code> might also be negative, and we first have to add <code>m</code> to make it positive.</p>","tags":["Translated"]},{"location":"algebra/module-inverse.html#finding-the-modular-inverse-using-binary-exponentiation","title":"Finding the Modular Inverse using Binary Exponentiation","text":"<p>Another method for finding modular inverse is to use Euler's theorem, which states that the following congruence is true if $a$ and $m$ are relatively prime:</p> $$a^{\\phi (m)} \\equiv 1 \\mod m$$ <p>$\\phi$ is Euler's Totient function. Again, note that $a$ and $m$ being relative prime was also the condition for the modular inverse to exist.</p> <p>If $m$ is a prime number, this simplifies to Fermat's little theorem:</p> $$a^{m - 1} \\equiv 1 \\mod m$$ <p>Multiply both sides of the above equations by $a^{-1}$, and we get:</p> <ul> <li>For an arbitrary (but coprime) modulus $m$: $a ^ {\\phi (m) - 1} \\equiv a ^{-1} \\mod m$</li> <li>For a prime modulus $m$: $a ^ {m - 2} \\equiv a ^ {-1} \\mod m$</li> </ul> <p>From these results, we can easily find the modular inverse using the binary exponentiation algorithm, which works in $O(\\log m)$ time.</p> <p>Even though this method is easier to understand than the method described in previous paragraph, in the case when $m$ is not a prime number, we need to calculate Euler phi function, which involves factorization of $m$, which might be very hard. If the prime factorization of $m$ is known, then the complexity of this method is $O(\\log m)$.</p>","tags":["Translated"]},{"location":"algebra/module-inverse.html#finding-the-modular-inverse-for-prime-moduli-using-euclidean-division","title":"Finding the modular inverse for prime moduli using Euclidean Division","text":"<p>Given a prime modulus $m &gt; a$ (or we can apply modulo to make it smaller in 1 step), according to Euclidean Division</p> $$m = k \\cdot a + r$$ <p>where $k = \\left\\lfloor \\frac{m}{a} \\right\\rfloor$ and $r = m \\bmod a$, then</p> $$ \\begin{align*} &amp; \\implies &amp; 0          &amp; \\equiv k \\cdot a + r   &amp; \\mod m \\\\ &amp; \\iff &amp; r              &amp; \\equiv -k \\cdot a      &amp; \\mod m \\\\ &amp; \\iff &amp; r \\cdot a^{-1} &amp; \\equiv -k              &amp; \\mod m \\\\ &amp; \\iff &amp; a^{-1}         &amp; \\equiv -k \\cdot r^{-1} &amp; \\mod m \\end{align*} $$ <p>Note that this reasoning does not hold if $m$ is not prime, since the existence of $a^{-1}$ does not imply the existence of $r^{-1}$ in the general case. To see this, lets try to calculate $5^{-1}$ modulo $12$ with the above formula. We would like to arrive at $5$, since $5 \\cdot 5 \\equiv 1 \\bmod 12$. However, $12 = 2 \\cdot 5 + 2$, and we have $k=2$ and $r=2$, with $2$ being not invertible modulo $12$.</p> <p>If the modulus is prime however, all $a$ with $0 &lt; a &lt; m$ are invertible modulo $m$, and we can have the following recursive function (in C++) for computing the modular inverse for number $a$ with respect to $m$</p> <pre><code>int inv(int a) {\n  return a &lt;= 1 ? a : m - (long long)(m/a) * inv(m % a) % m;\n}\n</code></pre> <p>The exact time complexity of the this recursion is not known. It's is somewhere between $O(\\frac{\\log m}{\\log\\log m})$ and $O(m^{\\frac{1}{3} - \\frac{2}{177} + \\epsilon})$. See On the length of Pierce expansions. In practice this implementation is fast, e.g. for the modulus $10^9 + 7$ it will always finish in less than 50 iterations.</p> <p>Applying this formula, we can also precompute the modular inverse for every number in the range $[1, m-1]$ in $O(m)$.</p> <pre><code>inv[1] = 1;\nfor(int a = 2; a &lt; m; ++a)\n    inv[a] = m - (long long)(m/a) * inv[m%a] % m;\n</code></pre>","tags":["Translated"]},{"location":"algebra/module-inverse.html#finding-the-modular-inverse-for-array-of-numbers-modulo-m","title":"Finding the modular inverse for array of numbers modulo $m$","text":"<p>Suppose we are given an array and we want to find modular inverse for all numbers in it (all of them are invertible). Instead of computing the inverse for every number, we can expand the fraction by the prefix product (excluding itself) and suffix product (excluding itself), and end up only computing a single inverse instead.</p> $$ \\begin{align} x_i^{-1} &amp;= \\frac{1}{x_i} = \\frac{\\overbrace{x_1 \\cdot x_2 \\cdots x_{i-1}}^{\\text{prefix}_{i-1}} \\cdot ~1~ \\cdot \\overbrace{x_{i+1} \\cdot x_{i+2} \\cdots x_n}^{\\text{suffix}_{i+1}}}{x_1 \\cdot x_2 \\cdots x_{i-1} \\cdot x_i \\cdot x_{i+1} \\cdot x_{i+2} \\cdots x_n} \\\\ &amp;= \\text{prefix}_{i-1} \\cdot \\text{suffix}_{i+1} \\cdot \\left(x_1 \\cdot x_2 \\cdots x_n\\right)^{-1} \\end{align} $$ <p>In the code we can just make a prefix product array (exclude itself, start from the identity element), compute the modular inverse for the product of all numbers and than multiply it by the prefix product and suffix product (exclude itself). The suffix product is computed by iterating from the back to the front.</p> <pre><code>std::vector&lt;int&gt; invs(const std::vector&lt;int&gt; &amp;a, int m) {\n    int n = a.size();\n    if (n == 0) return {};\n    std::vector&lt;int&gt; b(n);\n    int v = 1;\n    for (int i = 0; i != n; ++i) {\n        b[i] = v;\n        v = static_cast&lt;long long&gt;(v) * a[i] % m;\n    }\n    int x, y;\n    extended_euclidean(v, m, x, y);\n    x = (x % m + m) % m;\n    for (int i = n - 1; i &gt;= 0; --i) {\n        b[i] = static_cast&lt;long long&gt;(x) * b[i] % m;\n        x = static_cast&lt;long long&gt;(x) * a[i] % m;\n    }\n    return b;\n}\n</code></pre>","tags":["Translated"]},{"location":"algebra/module-inverse.html#practice-problems","title":"Practice Problems","text":"<ul> <li>UVa 11904 - One Unit Machine</li> <li>Hackerrank - Longest Increasing Subsequence Arrays</li> <li>Codeforces 300C - Beautiful Numbers</li> <li>Codeforces 622F - The Sum of the k-th Powers</li> <li>Codeforces 717A - Festival Organization</li> <li>Codeforces 896D - Nephren Runs a Cinema</li> </ul>","tags":["Translated"]},{"location":"algebra/montgomery_multiplication.html","title":"Montgomery Multiplication","text":"<p>Many algorithms in number theory, like prime testing or integer factorization, and in cryptography, like RSA, require lots of operations modulo a large number. A multiplications like $x y \\bmod{n}$ is quite slow to compute with the typical algorithms, since it requires a division to know how many times $n$ has to be subtracted from the product. And division is a really expensive operation, especially with big numbers.</p> <p>The Montgomery (modular) multiplication is a method that allows computing such multiplications faster. Instead of dividing the product and subtracting $n$ multiple times, it adds multiples of $n$ to cancel out the lower bits and then just discards the lower bits.</p>","tags":["Original"]},{"location":"algebra/montgomery_multiplication.html#montgomery-representation","title":"Montgomery representation","text":"<p>However the Montgomery multiplication doesn't come for free. The algorithm works only in the Montgomery space. And we need to transform our numbers into that space, before we can start multiplying.</p> <p>For the space we need a positive integer $r \\ge n$ coprime to $n$, i.e. $\\gcd(n, r) = 1$. In practice we always choose $r$ to be $2^m$ for a positive integer $m$, since multiplications, divisions and modulo $r$ operations can then be efficiently implemented using shifts and other bit operations. $n$ will be an odd number in pretty much all applications, since it is not hard to factorize an even number. So every power of $2$ will be coprime to $n$.</p> <p>The representative $\\bar{x}$ of a number $x$ in the Montgomery space is defined as: </p> $$\\bar{x} := x \\cdot r \\bmod n$$ <p>Notice, the transformation is actually such a multiplication that we want to optimize. So this is still an expensive operation. However you only need to transform a number once into the space. As soon as you are in the Montgomery space, you can perform as many operations as you want efficiently. And at the end you transform the final result back. So as long as you are doing lots of operations modulo $n$, this will be no problem.</p> <p>Inside the Montgomery space you can still perform most operations as usual. You can add two elements ($x \\cdot r + y \\cdot r \\equiv (x + y) \\cdot r \\bmod n$), subtract, check for equality, and even compute the greatest common divisor of a number with $n$ (since $\\gcd(n, r) = 1$). All with the usual algorithms.</p> <p>However this is not the case for multiplication.</p> <p>We expect the result to be:</p> $$\\bar{x} * \\bar{y} = \\overline{x \\cdot y} = (x \\cdot y) \\cdot r \\bmod n.$$ <p>But the normal multiplication will give us:</p> $$\\bar{x} \\cdot \\bar{y} = (x \\cdot y) \\cdot r \\cdot r \\bmod n.$$ <p>Therefore the multiplication in the Montgomery space is defined as:</p> $$\\bar{x} * \\bar{y} := \\bar{x} \\cdot \\bar{y} \\cdot r^{-1} \\bmod n.$$","tags":["Original"]},{"location":"algebra/montgomery_multiplication.html#montgomery-reduction","title":"Montgomery reduction","text":"<p>The multiplication of two numbers in the Montgomery space requires an efficient computation of $x \\cdot r^{-1} \\bmod n$. This operation is called the Montgomery reduction, and is also known as the algorithm REDC.</p> <p>Because $\\gcd(n, r) = 1$, we know that there are two numbers $r^{-1}$ and $n^{\\prime}$ with $0 &lt; r^{-1}, n^{\\prime} &lt; n$ with</p> $$r \\cdot r^{-1} + n \\cdot n^{\\prime} = 1.$$ <p>Both $r^{-1}$ and $n^{\\prime}$ can be computed using the Extended Euclidean algorithm.</p> <p>Using this identity we can write $x \\cdot r^{-1}$ as:</p> $$\\begin{aligned} x \\cdot r^{-1} &amp;= x \\cdot r \\cdot r^{-1} / r = x \\cdot (-n \\cdot n^{\\prime} + 1) / r \\\\ &amp;= (-x \\cdot n \\cdot n^{\\prime} + x) / r \\equiv (-x \\cdot n \\cdot n^{\\prime} + l \\cdot r \\cdot n + x) / r \\bmod n\\\\ &amp;\\equiv ((-x \\cdot n^{\\prime} + l \\cdot r) \\cdot n + x) / r \\bmod n \\end{aligned}$$ <p>The equivalences hold for any arbitrary integer $l$. This means, that we can add or subtract an arbitrary multiple of $r$ to $x \\cdot n^{\\prime}$, or in other words, we can compute $q := x \\cdot n^{\\prime}$ modulo $r$.</p> <p>This gives us the following algorithm to compute $x \\cdot r^{-1} \\bmod n$:</p> <pre><code>function reduce(x):\n    q = (x mod r) * n' mod r\n    a = (x - q * n) / r\n    if a &lt; 0:\n        a += n\n    return a\n</code></pre> <p>Since $x &lt; n \\cdot n &lt; r \\cdot n$ (even if $x$ is the product of a multiplication) and $q \\cdot n &lt; r \\cdot n$ we know that $-n &lt; (x - q \\cdot n) / r &lt; n$. Therefore the final modulo operation is implemented using a single check and one addition.</p> <p>As we see, we can perform the Montgomery reduction without any heavy modulo operations. If we choose $r$ as a power of $2$, the modulo operations and divisions in the algorithm can be computed using bitmasking and shifting.</p> <p>A second application of the Montgomery reduction is to transfer a number back from the Montgomery space into the normal space.</p>","tags":["Original"]},{"location":"algebra/montgomery_multiplication.html#fast-inverse-trick","title":"Fast inverse trick","text":"<p>For computing the inverse $n^{\\prime} := n^{-1} \\bmod r$ efficiently, we can use the following trick (which is inspired from the Newton's method):</p> $$a \\cdot x \\equiv 1 \\bmod 2^k \\Longrightarrow a \\cdot x \\cdot (2 - a \\cdot x) \\equiv 1 \\bmod 2^{2k}$$ <p>This can easily be proven. If we have $a \\cdot x = 1 + m \\cdot 2^k$, then we have:</p> $$\\begin{aligned} a \\cdot x \\cdot (2 - a \\cdot x) &amp;= 2 \\cdot a \\cdot x - (a \\cdot x)^2 \\\\ &amp;= 2 \\cdot (1 + m \\cdot 2^k) - (1 + m \\cdot 2^k)^2 \\\\ &amp;= 2 + 2 \\cdot m \\cdot 2^k - 1 - 2 \\cdot m \\cdot 2^k - m^2 \\cdot 2^{2k} \\\\ &amp;= 1 - m^2 \\cdot 2^{2k} \\\\ &amp;\\equiv 1 \\bmod 2^{2k}. \\end{aligned}$$ <p>This means we can start with $x = 1$ as the inverse of $a$ modulo $2^1$, apply the trick a few times and in each iteration we double the number of correct bits of $x$.</p>","tags":["Original"]},{"location":"algebra/montgomery_multiplication.html#implementation","title":"Implementation","text":"<p>Using the GCC compiler we can compute $x \\cdot y \\bmod n$ still efficiently, when all three numbers are 64 bit integer, since the compiler supports 128 bit integer with the types <code>__int128</code> and <code>__uint128</code>.</p> <pre><code>long long result = (__int128)x * y % n;\n</code></pre> <p>However there is no type for 256 bit integer. Therefore we will here show an implementation for a 128 bit multiplication.</p> <pre><code>using u64 = uint64_t;\nusing u128 = __uint128_t;\nusing i128 = __int128_t;\n\nstruct u256 {\n    u128 high, low;\n\n    static u256 mult(u128 x, u128 y) {\n        u64 a = x &gt;&gt; 64, b = x;\n        u64 c = y &gt;&gt; 64, d = y;\n        // (a*2^64 + b) * (c*2^64 + d) =\n        // (a*c) * 2^128 + (a*d + b*c)*2^64 + (b*d)\n        u128 ac = (u128)a * c;\n        u128 ad = (u128)a * d;\n        u128 bc = (u128)b * c;\n        u128 bd = (u128)b * d;\n        u128 carry = (u128)(u64)ad + (u128)(u64)bc + (bd &gt;&gt; 64u);\n        u128 high = ac + (ad &gt;&gt; 64u) + (bc &gt;&gt; 64u) + (carry &gt;&gt; 64u);\n        u128 low = (ad &lt;&lt; 64u) + (bc &lt;&lt; 64u) + bd;\n        return {high, low};\n    }\n};\n\nstruct Montgomery {\n    Montgomery(u128 n) : mod(n), inv(1) {\n        for (int i = 0; i &lt; 7; i++)\n            inv *= 2 - n * inv;\n    }\n\n    u128 init(u128 x) {\n        x %= mod;\n        for (int i = 0; i &lt; 128; i++) {\n            x &lt;&lt;= 1;\n            if (x &gt;= mod)\n                x -= mod;\n        }\n        return x;\n    }\n\n    u128 reduce(u256 x) {\n        u128 q = x.low * inv;\n        i128 a = x.high - u256::mult(q, mod).high;\n        if (a &lt; 0)\n            a += mod;\n        return a;\n    }\n\n    u128 mult(u128 a, u128 b) {\n        return reduce(u256::mult(a, b));\n    }\n\n    u128 mod, inv;\n};\n</code></pre>","tags":["Original"]},{"location":"algebra/montgomery_multiplication.html#fast-transformation","title":"Fast transformation","text":"<p>The current method of transforming a number into Montgomery space is pretty slow. There are faster ways.</p> <p>You can notice the following relation:</p> $$\\bar{x} := x \\cdot r \\bmod n = x \\cdot r^2 / r = x * r^2$$ <p>Transforming a number into the space is just a multiplication inside the space of the number with $r^2$. Therefore we can precompute $r^2 \\bmod n$ and just perform a multiplication instead of shifting the number 128 times.</p> <p>In the following code we initialize <code>r2</code> with <code>-n % n</code>, which is equivalent to $r - n \\equiv r \\bmod n$, shift it 4 times to get $r \\cdot 2^4 \\bmod n$. This number can be interpreted as $2^4$ in Montgomery space. If we square it $5$ times, we get $(2^4)^{2^5} = (2^4)^{32} = 2^{128} = r$ in Montgomery space, which is exactly $r^2 \\bmod n$.</p> <pre><code>struct Montgomery {\n    Montgomery(u128 n) : mod(n), inv(1), r2(-n % n) {\n        for (int i = 0; i &lt; 7; i++)\n            inv *= 2 - n * inv;\n\n        for (int i = 0; i &lt; 4; i++) {\n            r2 &lt;&lt;= 1;\n            if (r2 &gt;= mod)\n                r2 -= mod;\n        }\n        for (int i = 0; i &lt; 5; i++)\n            r2 = mul(r2, r2);\n    }\n\n    u128 init(u128 x) {\n        return mult(x, r2);\n    }\n\n    u128 mod, inv, r2;\n};\n</code></pre>","tags":["Original"]},{"location":"algebra/phi-function.html","title":"Euler's totient function","text":"<p>Euler's totient function, also known as phi-function $\\phi (n)$, counts the number of integers between 1 and $n$ inclusive, which are coprime to $n$. Two numbers are coprime if their greatest common divisor equals $1$ ($1$ is considered to be coprime to any number).</p> <p>Here are values of $\\phi(n)$ for the first few positive integers:</p> $$\\begin{array}{|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|} \\hline n &amp; 1 &amp; 2 &amp; 3 &amp; 4 &amp; 5 &amp; 6 &amp; 7 &amp; 8 &amp; 9 &amp; 10 &amp; 11 &amp; 12 &amp; 13 &amp; 14 &amp; 15 &amp; 16 &amp; 17 &amp; 18 &amp; 19 &amp; 20 &amp; 21 \\\\\\\\ \\hline \\phi(n) &amp; 1 &amp; 1 &amp; 2 &amp; 2 &amp; 4 &amp; 2 &amp; 6 &amp; 4 &amp; 6 &amp; 4 &amp; 10 &amp; 4 &amp; 12 &amp; 6 &amp; 8 &amp; 8 &amp; 16 &amp; 6 &amp; 18 &amp; 8 &amp; 12 \\\\\\\\ \\hline \\end{array}$$","tags":["Translated"]},{"location":"algebra/phi-function.html#properties","title":"Properties","text":"<p>The following properties of Euler totient function are sufficient to calculate it for any number:</p> <ul> <li>If $p$ is a prime number, then $\\gcd(p, q) = 1$ for all $1 \\le q &lt; p$. Therefore we have:</li> </ul> $$\\phi (p) = p - 1.$$ <ul> <li>If $p$ is a prime number and $k \\ge 1$, then there are exactly $p^k / p$ numbers between $1$ and $p^k$ that are divisible by $p$.     Which gives us:</li> </ul> $$\\phi(p^k) = p^k - p^{k-1}.$$ <ul> <li> <p>If $a$ and $b$ are relatively prime, then:</p> $$\\phi(a b) = \\phi(a) \\cdot \\phi(b).$$ <p>This relation is not trivial to see. It follows from the Chinese remainder theorem. The Chinese remainder theorem guarantees, that for each $0 \\le x &lt; a$ and each $0 \\le y &lt; b$, there exists a unique $0 \\le z &lt; a b$ with $z \\equiv x \\pmod{a}$ and $z \\equiv y \\pmod{b}$. It's not hard to show that $z$ is coprime to $a b$ if and only if $x$ is coprime to $a$ and $y$ is coprime to $b$. Therefore the amount of integers coprime to $a b$ is equal to product of the amounts of $a$ and $b$.</p> </li> <li> <p>In general, for not coprime $a$ and $b$, the equation</p> $$\\phi(ab) = \\phi(a) \\cdot \\phi(b) \\cdot \\dfrac{d}{\\phi(d)}$$ <p>with $d = \\gcd(a, b)$ holds.</p> </li> </ul> <p>Thus, using the first three properties, we can compute $\\phi(n)$ through the factorization of $n$ (decomposition of $n$ into a product of its prime factors). If $n = {p_1}^{a_1} \\cdot {p_2}^{a_2} \\cdots {p_k}^{a_k}$, where $p_i$ are prime factors of $n$,</p> $$\\begin{align} \\phi (n) &amp;= \\phi ({p_1}^{a_1}) \\cdot \\phi ({p_2}^{a_2}) \\cdots  \\phi ({p_k}^{a_k}) \\\\\\\\ &amp;= \\left({p_1}^{a_1} - {p_1}^{a_1 - 1}\\right) \\cdot \\left({p_2}^{a_2} - {p_2}^{a_2 - 1}\\right) \\cdots \\left({p_k}^{a_k} - {p_k}^{a_k - 1}\\right) \\\\\\\\ &amp;= p_1^{a_1} \\cdot \\left(1 - \\frac{1}{p_1}\\right) \\cdot p_2^{a_2} \\cdot \\left(1 - \\frac{1}{p_2}\\right) \\cdots p_k^{a_k} \\cdot \\left(1 - \\frac{1}{p_k}\\right) \\\\\\\\ &amp;= n \\cdot \\left(1 - \\frac{1}{p_1}\\right) \\cdot \\left(1 - \\frac{1}{p_2}\\right) \\cdots \\left(1 - \\frac{1}{p_k}\\right) \\end{align}$$","tags":["Translated"]},{"location":"algebra/phi-function.html#implementation","title":"Implementation","text":"<p>Here is an implementation using factorization in $O(\\sqrt{n})$:</p> <pre><code>int phi(int n) {\n    int result = n;\n    for (int i = 2; i * i &lt;= n; i++) {\n        if (n % i == 0) {\n            while (n % i == 0)\n                n /= i;\n            result -= result / i;\n        }\n    }\n    if (n &gt; 1)\n        result -= result / n;\n    return result;\n}\n</code></pre>","tags":["Translated"]},{"location":"algebra/phi-function.html#etf_1_to_n","title":"Euler totient function from $1$ to $n$ in $O(n \\log\\log{n})$","text":"<p>If we need the totient of all numbers between $1$ and $n$, then factorizing all $n$ numbers is not efficient. We can use the same idea as the Sieve of Eratosthenes. It is still based on the property shown above, but instead of updating the temporary result for each prime factor for each number, we find all prime numbers and for each one update the temporary results of all numbers that are divisible by that prime number.</p> <p>Since this approach is basically identical to the Sieve of Eratosthenes, the complexity will also be the same: $O(n \\log \\log n)$</p> <pre><code>void phi_1_to_n(int n) {\n    vector&lt;int&gt; phi(n + 1);\n    for (int i = 0; i &lt;= n; i++)\n        phi[i] = i;\n\n    for (int i = 2; i &lt;= n; i++) {\n        if (phi[i] == i) {\n            for (int j = i; j &lt;= n; j += i)\n                phi[j] -= phi[j] / i;\n        }\n    }\n}\n</code></pre>","tags":["Translated"]},{"location":"algebra/phi-function.html#divsum","title":"Divisor sum property","text":"<p>This interesting property was established by Gauss:</p> $$ \\sum_{d|n} \\phi{(d)} = n$$ <p>Here the sum is over all positive divisors $d$ of $n$.</p> <p>For instance the divisors of 10 are 1, 2, 5 and 10. Hence $\\phi{(1)} + \\phi{(2)} + \\phi{(5)} + \\phi{(10)} = 1 + 1 + 4 + 4 = 10$.</p>","tags":["Translated"]},{"location":"algebra/phi-function.html#finding-the-totient-from-1-to-n-using-the-divisor-sum-property","title":"Finding the totient from 1 to $n$ using the divisor sum property","text":"<p>The divisor sum property also allows us to compute the totient of all numbers between 1 and $n$. This implementation is a little simpler than the previous implementation based on the Sieve of Eratosthenes, however also has a slightly worse complexity: $O(n \\log n)$</p> <pre><code>void phi_1_to_n(int n) {\n    vector&lt;int&gt; phi(n + 1);\n    phi[0] = 0;\n    phi[1] = 1;\n    for (int i = 2; i &lt;= n; i++)\n        phi[i] = i - 1;\n\n    for (int i = 2; i &lt;= n; i++)\n        for (int j = 2 * i; j &lt;= n; j += i)\n              phi[j] -= phi[i];\n}\n</code></pre>","tags":["Translated"]},{"location":"algebra/phi-function.html#application","title":"Application in Euler's theorem","text":"<p>The most famous and important property of Euler's totient function is expressed in Euler's theorem: </p> $$a^{\\phi(m)} \\equiv 1 \\pmod m \\quad \\text{if } a \\text{ and } m \\text{ are relatively prime.}$$ <p>In the particular case when $m$ is prime, Euler's theorem turns into Fermat's little theorem:</p> $$a^{m - 1} \\equiv 1 \\pmod m$$ <p>Euler's theorem and Euler's totient function occur quite often in practical applications, for example both are used to compute the modular multiplicative inverse.</p> <p>As immediate consequence we also get the equivalence:</p> $$a^n \\equiv a^{n \\bmod \\phi(m)} \\pmod m$$ <p>This allows computing $x^n \\bmod m$ for very big $n$, especially if $n$ is the result of another computation, as it allows to compute $n$ under a modulo.</p>","tags":["Translated"]},{"location":"algebra/phi-function.html#group-theory","title":"Group Theory","text":"<p>$\\phi(n)$ is the order of the multiplicative group mod n $(\\mathbb Z / n\\mathbb Z)^\\times$, that is the group of units (elements with multiplicative inverses). The elements with multiplicative inverses are precisely those coprime to $n$.</p> <p>The multiplicative order of an element $a$ mod $n$, denoted $\\operatorname{ord}_n(a)$, is the smallest $k&gt;0$ such that $a^k \\equiv 1 \\pmod m$. $\\operatorname{ord}_n(a)$ is the size of the subgroup generated by $a$, so by Lagrange's Theorem, the multiplicative order of any $a$ must divide $\\phi(n)$. If the multiplicative order of $a$ is $\\phi(n)$, the largest possible, then $a$ is a primitive root and the group is cyclic by definition. </p>","tags":["Translated"]},{"location":"algebra/phi-function.html#generalization","title":"Generalization","text":"<p>There is a less known version of the last equivalence, that allows computing $x^n \\bmod m$ efficiently for not coprime $x$ and $m$. For arbitrary $x, m$ and $n \\geq \\log_2 m$:</p> $$x^{n}\\equiv x^{\\phi(m)+[n \\bmod \\phi(m)]} \\mod m$$ <p>Proof:</p> <p>Let $p_1, \\dots, p_t$ be common prime divisors of $x$ and $m$, and $k_i$ their exponents in $m$. With those we define $a = p_1^{k_1} \\dots p_t^{k_t}$, which makes $\\frac{m}{a}$ coprime to $x$. And let $k$ be the smallest number such that $a$ divides $x^k$. Assuming $n \\ge k$, we can write:</p> $$\\begin{align}x^n \\bmod m &amp;= \\frac{x^k}{a}ax^{n-k}\\bmod m \\\\ &amp;= \\frac{x^k}{a}\\left(ax^{n-k}\\bmod m\\right) \\bmod m \\\\ &amp;= \\frac{x^k}{a}\\left(ax^{n-k}\\bmod a \\frac{m}{a}\\right) \\bmod m \\\\ &amp;=\\frac{x^k}{a} a \\left(x^{n-k} \\bmod \\frac{m}{a}\\right)\\bmod m \\\\ &amp;= x^k\\left(x^{n-k} \\bmod \\frac{m}{a}\\right)\\bmod m \\end{align}$$ <p>The equivalence between the third and forth line follows from the fact that $ab \\bmod ac = a(b \\bmod c)$. Indeed if $b = cd + r$ with $r &lt; c$, then $ab = acd + ar$ with $ar &lt; ac$.</p> <p>Since $x$ and $\\frac{m}{a}$ are coprime, we can apply Euler's theorem and get the efficient (since $k$ is very small; in fact $k \\le \\log_2 m$) formula:</p> $$x^n \\bmod m = x^k\\left(x^{n-k \\bmod \\phi(\\frac{m}{a})} \\bmod \\frac{m}{a}\\right)\\bmod m.$$ <p>This formula is difficult to apply, but we can use it to analyze the behavior of $x^n \\bmod m$. We can see that the sequence of powers $(x^1 \\bmod m, x^2 \\bmod m, x^3 \\bmod m, \\dots)$ enters a cycle of length $\\phi\\left(\\frac{m}{a}\\right)$ after the first $k$ (or less) elements.  $\\phi\\left(\\frac{m}{a}\\right)$ divides $\\phi(m)$ (because $a$ and $\\frac{m}{a}$ are coprime we have $\\phi(a) \\cdot \\phi\\left(\\frac{m}{a}\\right) = \\phi(m)$), therefore we can also say that the period has length $\\phi(m)$. And since $\\phi(m) \\ge \\log_2 m \\ge k$, we can conclude the desired, much simpler, formula:</p> $$ x^n \\equiv x^{\\phi(m)} x^{(n - \\phi(m)) \\bmod \\phi(m)} \\bmod m \\equiv x^{\\phi(m)+[n \\bmod \\phi(m)]} \\mod m.$$","tags":["Translated"]},{"location":"algebra/phi-function.html#practice-problems","title":"Practice Problems","text":"<ul> <li>SPOJ #4141 \"Euler Totient Function\" [Difficulty: CakeWalk]</li> <li>UVA #10179 \"Irreducible Basic Fractions\" [Difficulty: Easy]</li> <li>UVA #10299 \"Relatives\" [Difficulty: Easy]</li> <li>UVA #11327 \"Enumerating Rational Numbers\" [Difficulty: Medium]</li> <li>TIMUS #1673 \"Admission to Exam\" [Difficulty: High]</li> <li>UVA 10990 - Another New Function</li> <li>Codechef - Golu and Sweetness</li> <li>SPOJ - LCM Sum</li> <li>GYM - Simple Calculations  (F)</li> <li>UVA 13132 - Laser Mirrors</li> <li>SPOJ - GCDEX</li> <li>UVA 12995 - Farey Sequence</li> <li>SPOJ - Totient in Permutation (easy)</li> <li>LOJ - Mathematically Hard</li> <li>SPOJ - Totient Extreme</li> <li>SPOJ - Playing with GCD</li> <li>SPOJ - G Force</li> <li>SPOJ - Smallest Inverse Euler Totient Function</li> <li>Codeforces - Power Tower</li> <li>Kattis - Exponial</li> <li>LeetCode - 372. Super Pow</li> <li>Codeforces - The Holmes Children</li> <li>Codeforces - Small GCD</li> </ul>","tags":["Translated"]},{"location":"algebra/polynomial.html","title":"Operations on polynomials and series","text":"<p>Problems in competitive programming, especially the ones involving enumeration some kind, are often solved by reducing the problem to computing something on polynomials and formal power series.</p> <p>This includes concepts such as polynomial multiplication, interpolation, and more complicated ones, such as polynomial logarithms and exponents. In this article, a brief overview of such operations and common approaches to them is presented.</p>","tags":["Original"]},{"location":"algebra/polynomial.html#basic-notion-and-facts","title":"Basic Notion and facts","text":"<p>In this section, we focus more on the definitions and \"intuitive\" properties of various polynomial operations. The technical details of their implementation and complexities will be covered in later sections.</p>","tags":["Original"]},{"location":"algebra/polynomial.html#polynomial-multiplication","title":"Polynomial multiplication","text":"<p>Definition</p> <p>Univariate polynomial is an expression of form $A(x) = a_0 + a_1 x + \\dots + a_n x^n$.</p> <p>The values $a_0, \\dots, a_n$ are polynomial coefficients, typically taken from some set of numbers or number-like structures. In this article, we assume that the coefficients are taken from some field, meaning that operations of addition, subtraction, multiplication and division are well-defined for them (except for division by $0$) and they generally behave in a similar way to real numbers.</p> <p>Typical example of such field is the field of remainders modulo prime number $p$.</p> <p>For simplicity we will drop the term univariate, as this is the only kind of polynomials we consider in this article. We will also write $A$ instead of $A(x)$ wherever possible, which will be understandable from the context. It is assumed that either $a_n \\neq 0$ or $A(x)=0$.</p> <p>Definition</p> <p>The product of two polynomials is defined by expanding it as an arithmetic expression:</p> $$ A(x) B(x) = \\left(\\sum\\limits_{i=0}^n a_i x^i \\right)\\left(\\sum\\limits_{j=0}^m b_j x^j\\right) = \\sum\\limits_{i,j} a_i b_j x^{i+j} = \\sum\\limits_{k=0}^{n+m} c_k x^k = C(x). $$ <p>The sequence $c_0, c_1, \\dots, c_{n+m}$ of the coefficients of $C(x)$ is called the convolution of $a_0, \\dots, a_n$ and $b_0, \\dots, b_m$.</p> <p>Definition</p> <p>The degree of a polynomial $A$ with $a_n \\neq 0$ is defined as $\\deg A = n$.</p> <p>For consistency, degree of $A(x) = 0$ is defined as $\\deg A = -\\infty$.</p> <p>In this notion, $\\deg AB = \\deg A + \\deg B$ for any polynomials $A$ and $B$.</p> <p>Convolutions are the basis of solving many enumerative problems.</p> <p>Example</p> <p>You have $n$ objects of the first kind and $m$ objects of the second kind.</p> <p>Objects of first kind are valued $a_1, \\dots, a_n$, and objects of the second kind are valued $b_1, \\dots, b_m$.</p> <p>You pick a single object of the first kind and a single object of the second kind. How many ways are there to get the total value $k$?</p> Solution <p>Consider the product $(x^{a_1} + \\dots + x^{a_n})(x^{b_1} + \\dots + x^{b_m})$. If you expand it, each monomial will correspond to the pair $(a_i, b_j)$ and contribute to the coefficient near $x^{a_i+b_j}$. In other words, the answer is the coefficient near $x^k$ in the product.</p> <p>Example</p> <p>You throw a $6$-sided die $n$ times and sum up the results from all throws. What is the probability of getting sum of $k$?</p> Solution <p>The answer is the number of outcomes having the sum $k$, divided by the total number of outcomes, which is $6^n$.</p> <p>What is the number of outcomes having the sum $k$? For $n=1$, it may be represented by a polynomial $A(x) = x^1+x^2+\\dots+x^6$.</p> <p>For $n=2$, using the same approach as in the example above, we conclude that it is represented by the polynomial $(x^1+x^2+\\dots+x^6)^2$.</p> <p>That being said, the answer to the problem is the $k$-th coefficient of $(x^1+x^2+\\dots+x^6)^n$, divided by $6^n$.</p> <p>The coefficient near $x^k$ in the polynomial $A(x)$ is denoted shortly as $[x^k]A$.</p>","tags":["Original"]},{"location":"algebra/polynomial.html#formal-power-series","title":"Formal power series","text":"<p>Definition</p> <p>A formal power series is an infinite sum $A(x) = a_0 + a_1 x + a_2 x^2 + \\dots$, considered regardless of its convergence properties.</p> <p>In other words, when we consider e.g. a sum $1+\\frac{1}{2}+\\frac{1}{4}+\\frac{1}{8}+\\dots=2$, we imply that it converges to $2$ when the number of summands approach infinity. However, formal series are only considered in terms of sequences that make them.</p> <p>Definition</p> <p>The product of formal power series $A(x)$ and $B(x)$, is also defined by expanding it as an arithmetic expression:</p> $$ A(x) B(x) = \\left(\\sum\\limits_{i=0}^\\infty a_i x^i \\right)\\left(\\sum\\limits_{j=0}^\\infty b_j x^j\\right) = \\sum\\limits_{i,j} a_i b_j x^{i+j} = \\sum\\limits_{k=0}^{\\infty} c_k x^k = C(x), $$ <p>where the coefficients $c_0, c_1, \\dots$ are define as finite sums</p> $$ c_k = \\sum\\limits_{i=0}^k a_i b_{k-i}. $$ <p>The sequence $c_0, c_1, \\dots$ is also called a convolution of $a_0, a_1, \\dots$ and $b_0, b_1, \\dots$, generalizing the concept to infinite sequences.</p> <p>Thus, polynomials may be considered formal power series, but with finite number of coefficients.</p> <p>Formal power series play a crucial role in enumerative combinatorics, where they're studied as generating functions for various sequences. Detailed explanation of generating functions and the intuition behind them will, unfortunately, be out of scope for this article, therefore the curious reader is referenced e.g. here for details about their combinatorial meaning.</p> <p>However, we will very briefly mention that if $A(x)$ and $B(x)$ are generating functions for sequences that enumerate some objects by number of \"atoms\" in them (e.g. trees by the number of vertices), then the product $A(x) B(x)$ enumerates objects that can be described as pairs of objects of kinds $A$ and $B$, enumerates by the total number of \"atoms\" in the pair.</p> <p>Example</p> <p>Let $A(x) = \\sum\\limits_{i=0}^\\infty 2^i x^i$ enumerate packs of stones, each stone colored in one of $2$ colors (so, there are $2^i$ such packs of size $i$) and $B(x) = \\sum\\limits_{j=0}^{\\infty} 3^j x^j$ enumerate packs of stones, each stone colored in one of $3$ colors. Then $C(x) = A(x) B(x) = \\sum\\limits_{k=0}^\\infty c_k x^k$ would enumerate objects that may be described as \"two packs of stones, first pack only of stones of type $A$, second pack only of stones of type $B$, with total number of stones being $k$\" for $c_k$.</p> <p>In a similar way, there is an intuitive meaning to some other functions over formal power series.</p>","tags":["Original"]},{"location":"algebra/polynomial.html#long-polynomial-division","title":"Long polynomial division","text":"<p>Similar to integers, it is possible to define long division on polynomials.</p> <p>Definition</p> <p>For any polynomials $A$ and $B \\neq 0$, one may represent $A$ as</p> $$ A = D \\cdot B + R,~ \\deg R &lt; \\deg B, $$ <p>where $R$ is called the remainder of $A$ modulo $B$ and $D$ is called the quotient.</p> <p>Denoting $\\deg A = n$ and $\\deg B = m$, naive way to do it is to use long division, during which you multiply $B$ by the monomial $\\frac{a_n}{b_m} x^{n - m}$ and subtract it from $A$, until the degree of $A$ is smaller than that of $B$. What remains of $A$ in the end will be the remainder (hence the name), and the polynomials with which you multiplied $B$ in the process, summed together, form the quotient.</p> <p>Definition</p> <p>If $A$ and $B$ have the same remainder modulo $C$, they're said to be equivalent modulo $C$, which is denoted as</p> $$ A \\equiv B \\pmod{C}. $$ <p>Polynomial long division is useful because of its many important properties:</p> <ul> <li> <p>$A$ is a multiple of $B$ if and only if $A \\equiv 0 \\pmod B$.</p> </li> <li> <p>It implies that $A \\equiv B \\pmod C$ if and only if $A-B$ is a multiple of $C$.</p> </li> <li> <p>In particular, $A \\equiv B \\pmod{C \\cdot D}$ implies $A \\equiv B \\pmod{C}$.</p> </li> <li> <p>For any linear polynomial $x-r$ it holds that $A(x) \\equiv A(r) \\pmod{x-r}$.</p> </li> <li> <p>It implies that $A$ is a multiple of $x-r$ if and only if $A(r)=0$.</p> </li> <li> <p>For modulo being $x^k$, it holds that $A \\equiv a_0 + a_1 x + \\dots + a_{k-1} x^{k-1} \\pmod{x^k}$.</p> </li> </ul> <p>Note that long division can't be properly defined for formal power series. Instead, for any $A(x)$ such that $a_0 \\neq 0$, it is possible to define an inverse formal power series $A^{-1}(x)$, such that $A(x) A^{-1}(x) = 1$. This fact, in turn, can be used to compute the result of long division for polynomials.</p>","tags":["Original"]},{"location":"algebra/polynomial.html#basic-implementation","title":"Basic implementation","text":"<p>Here you can find the basic implementation of polynomial algebra.</p> <p>It supports all trivial operations and some other useful methods. The main class is <code>poly&lt;T&gt;</code> for polynomials with coefficients of type <code>T</code>.</p> <p>All arithmetic operation <code>+</code>, <code>-</code>, <code>*</code>, <code>%</code> and <code>/</code> are supported, <code>%</code> and <code>/</code> standing for remainder and quotient in Euclidean division.</p> <p>There is also the class <code>modular&lt;m&gt;</code> for performing arithmetic operations on remainders modulo a prime number <code>m</code>.</p> <p>Other useful functions:</p> <ul> <li><code>deriv()</code>: computes the derivative $P'(x)$ of $P(x)$.</li> <li><code>integr()</code>: computes the indefinite integral $Q(x) = \\int P(x)$ of $P(x)$ such that $Q(0)=0$.</li> <li><code>inv(size_t n)</code>: calculate the first $n$ coefficients of $P^{-1}(x)$ in $O(n \\log n)$.</li> <li><code>log(size_t n)</code>: calculate the first $n$ coefficients of $\\ln P(x)$ in $O(n \\log n)$.</li> <li><code>exp(size_t n)</code>: calculate the first $n$ coefficients of $\\exp P(x)$ in $O(n \\log n)$.</li> <li><code>pow(size_t k, size_t n)</code>: calculate the first $n$ coefficients for $P^{k}(x)$ in $O(n \\log nk)$.</li> <li><code>deg()</code>: returns the degree of $P(x)$.</li> <li><code>lead()</code>: returns the coefficient of $x^{\\deg P(x)}$.</li> <li><code>resultant(poly&lt;T&gt; a, poly&lt;T&gt; b)</code>: computes the resultant of $a$ and $b$ in $O(|a| \\cdot |b|)$.</li> <li><code>bpow(T x, size_t n)</code>: computes $x^n$.</li> <li><code>bpow(T x, size_t n, T m)</code>: computes $x^n \\pmod{m}$.</li> <li><code>chirpz(T z, size_t n)</code>: computes $P(1), P(z), P(z^2), \\dots, P(z^{n-1})$ in $O(n \\log n)$.</li> <li><code>vector&lt;T&gt; eval(vector&lt;T&gt; x)</code>: evaluates $P(x_1), \\dots, P(x_n)$ in $O(n \\log^2 n)$.</li> <li><code>poly&lt;T&gt; inter(vector&lt;T&gt; x, vector&lt;T&gt; y)</code>: interpolates a polynomial by a set of pairs $P(x_i) = y_i$ in $O(n \\log^2 n)$.</li> <li>And some more, feel free to explore the code!</li> </ul>","tags":["Original"]},{"location":"algebra/polynomial.html#arithmetic","title":"Arithmetic","text":"","tags":["Original"]},{"location":"algebra/polynomial.html#multiplication","title":"Multiplication","text":"<p>The very core operation is the multiplication of two polynomials. That is, given the polynomials $A$ and $B$:</p> $$A = a_0 + a_1 x + \\dots + a_n x^n$$ $$B = b_0 + b_1 x + \\dots + b_m x^m$$ <p>You have to compute polynomial $C = A \\cdot B$, which is defined as</p> $$\\boxed{C = \\sum\\limits_{i=0}^n \\sum\\limits_{j=0}^m a_i b_j x^{i+j}}  = c_0 + c_1 x + \\dots + c_{n+m} x^{n+m}.$$ <p>It can be computed in $O(n \\log n)$ via the Fast Fourier transform and almost all methods here will use it as subroutine.</p>","tags":["Original"]},{"location":"algebra/polynomial.html#inverse-series","title":"Inverse series","text":"<p>If $A(0) \\neq 0$ there always exists an infinite formal power series $A^{-1}(x) = q_0+q_1 x + q_2 x^2 + \\dots$ such that $A^{-1} A = 1$. It often proves useful to compute first $k$ coefficients of $A^{-1}$ (that is, to compute it modulo $x^k$). There are two major ways to calculate it.</p>","tags":["Original"]},{"location":"algebra/polynomial.html#divide-and-conquer","title":"Divide and conquer","text":"<p>This algorithm was mentioned in Sch\u00f6nhage's article and is inspired by Graeffe's method. It is known that for $B(x)=A(x)A(-x)$ it holds that $B(x)=B(-x)$, that is, $B(x)$ is an even polynomial. It means that it only has non-zero coefficients with even numbers and can be represented as $B(x)=T(x^2)$. Thus, we can do the following transition:</p> $$A^{-1}(x) \\equiv \\frac{1}{A(x)} \\equiv \\frac{A(-x)}{A(x)A(-x)} \\equiv \\frac{A(-x)}{T(x^2)} \\pmod{x^k}$$ <p>Note that $T(x)$ can be computed with a single multiplication, after which we're only interested in the first half of coefficients of its inverse series. This effectively reduces the initial problem of computing $A^{-1} \\pmod{x^k}$ to computing $T^{-1} \\pmod{x^{\\lceil k / 2 \\rceil}}$.</p> <p>The complexity of this method can be estimated as</p> $$T(n) = T(n/2) + O(n \\log n) = O(n \\log n).$$","tags":["Original"]},{"location":"algebra/polynomial.html#sievekingkung-algorithm","title":"Sieveking\u2013Kung algorithm","text":"<p>The generic process described here is known as Hensel lifting, as it follows from Hensel's lemma. We'll cover it in more detail further below, but for now let's focus on ad hoc solution. \"Lifting\" part here means that we start with the approximation $B_0=q_0=a_0^{-1}$, which is $A^{-1} \\pmod x$ and then iteratively lift from $\\bmod x^a$ to $\\bmod x^{2a}$.</p> <p>Let $B_k \\equiv A^{-1} \\pmod{x^a}$. The next approximation needs to follow the equation $A B_{k+1} \\equiv 1 \\pmod{x^{2a}}$ and may be represented as $B_{k+1} = B_k + x^a C$. From this follows the equation</p> $$A(B_k + x^{a}C) \\equiv 1 \\pmod{x^{2a}}.$$ <p>Let $A B_k \\equiv 1 + x^a D \\pmod{x^{2a}}$, then the equation above implies</p> $$x^a(D+AC) \\equiv 0 \\pmod{x^{2a}} \\implies D \\equiv -AC \\pmod{x^a} \\implies C \\equiv -B_k D \\pmod{x^a}.$$ <p>From this, one can obtain the final formula, which is</p> $$x^a C \\equiv -B_k x^a D  \\equiv B_k(1-AB_k) \\pmod{x^{2a}} \\implies \\boxed{B_{k+1} \\equiv B_k(2-AB_k) \\pmod{x^{2a}}}$$ <p>Thus starting with $B_0 \\equiv a_0^{-1} \\pmod x$ we will compute the sequence $B_k$ such that $AB_k \\equiv 1 \\pmod{x^{2^k}}$ with the complexity</p> $$T(n) = T(n/2) + O(n \\log n) = O(n \\log n).$$ <p>The algorithm here might seem a bit more complicated than the first one, but it has a very solid and practical reasoning behind it, as well as a great generalization potential if looked from a different perspective, which would be explained further below.</p>","tags":["Original"]},{"location":"algebra/polynomial.html#euclidean-division","title":"Euclidean division","text":"<p>Consider two polynomials $A(x)$ and $B(x)$ of degrees $n$ and $m$. As it was said earlier you can rewrite $A(x)$ as</p> $$A(x) = B(x) D(x) + R(x), \\deg R &lt; \\deg B.$$ <p>Let $n \\geq m$, it would imply that $\\deg D = n - m$ and the leading $n-m+1$ coefficients of $A$ don't influence $R$. It means that you can recover $D(x)$ from the largest $n-m+1$ coefficients of $A(x)$ and $B(x)$ if you consider it as a system of equations.</p> <p>The system of linear equations we're talking about can be written in the following form:</p> $$\\begin{bmatrix} a_n \\\\ \\vdots \\\\ a_{m+1} \\\\ a_{m} \\end{bmatrix} = \\begin{bmatrix} b_m &amp; \\dots &amp; 0 &amp; 0 \\\\ \\vdots &amp; \\ddots &amp; \\vdots &amp; \\vdots \\\\ \\dots &amp; \\dots &amp; b_m &amp; 0 \\\\ \\dots &amp; \\dots &amp; b_{m-1} &amp; b_m \\end{bmatrix} \\begin{bmatrix}d_{n-m} \\\\ \\vdots \\\\ d_1 \\\\ d_0\\end{bmatrix}$$ <p>From the looks of it, we can conclude that with the introduction of reversed polynomials</p> $$A^R(x) = x^nA(x^{-1})= a_n + a_{n-1} x + \\dots + a_0 x^n$$ $$B^R(x) = x^m B(x^{-1}) = b_m + b_{m-1} x + \\dots + b_0 x^m$$ $$D^R(x) = x^{n-m}D(x^{-1}) = d_{n-m} + d_{n-m-1} x + \\dots + d_0 x^{n-m}$$ <p>the system may be rewritten as</p> $$A^R(x) \\equiv B^R(x) D^R(x) \\pmod{x^{n-m+1}}.$$ <p>From this you can unambiguously recover all coefficients of $D(x)$:</p> $$\\boxed{D^R(x) \\equiv A^R(x) (B^R(x))^{-1} \\pmod{x^{n-m+1}}}$$ <p>And from this, in turn, you can recover $R(x)$ as $R(x) = A(x) - B(x)D(x)$.</p> <p>Note that the matrix above is a so-called triangular Toeplitz matrix and, as we see here, solving system of linear equations with arbitrary Toeplitz matrix is, in fact, equivalent to polynomial inversion. Moreover, inverse matrix of it would also be triangular Toeplitz matrix and its entries, in terms used above, are the coefficients of $(B^R(x))^{-1} \\pmod{x^{n-m+1}}$.</p>","tags":["Original"]},{"location":"algebra/polynomial.html#calculating-functions-of-polynomial","title":"Calculating functions of polynomial","text":"","tags":["Original"]},{"location":"algebra/polynomial.html#newtons-method","title":"Newton's method","text":"<p>Let's generalize the Sieveking\u2013Kung algorithm. Consider equation $F(P) = 0$ where $P(x)$ should be a polynomial and $F(x)$ is some polynomial-valued function defined as</p> $$F(x) = \\sum\\limits_{i=0}^\\infty \\alpha_i (x-\\beta)^i,$$ <p>where $\\beta$ is some constant. It can be proven that if we introduce a new formal variable $y$, we can express $F(x)$ as</p> $$F(x) = F(y) + (x-y)F'(y) + (x-y)^2 G(x,y),$$ <p>where $F'(x)$ is the derivative formal power series defined as</p> $$F'(x) = \\sum\\limits_{i=0}^\\infty (i+1)\\alpha_{i+1}(x-\\beta)^i,$$ <p>and $G(x, y)$ is some formal power series of $x$ and $y$. With this result we can find the solution iteratively.</p> <p>Let $F(Q_k) \\equiv 0 \\pmod{x^{a}}$. We need to find $Q_{k+1} \\equiv Q_k + x^a C \\pmod{x^{2a}}$ such that $F(Q_{k+1}) \\equiv 0 \\pmod{x^{2a}}$.</p> <p>Substituting $x = Q_{k+1}$ and $y=Q_k$ in the formula above, we get</p> $$F(Q_{k+1}) \\equiv F(Q_k) + (Q_{k+1} - Q_k) F'(Q_k) + (Q_{k+1} - Q_k)^2 G(x, y) \\pmod x^{2a}.$$ <p>Since $Q_{k+1} - Q_k \\equiv 0 \\pmod{x^a}$, it also holds that $(Q_{k+1} - Q_k)^2 \\equiv 0 \\pmod{x^{2a}}$, thus</p> $$0 \\equiv F(Q_{k+1}) \\equiv F(Q_k) + (Q_{k+1} - Q_k) F'(Q_k) \\pmod{x^{2a}}.$$ <p>The last formula gives us the value of $Q_{k+1}$:</p> $$\\boxed{Q_{k+1} = Q_k - \\dfrac{F(Q_k)}{F'(Q_k)} \\pmod{x^{2a}}}$$ <p>Thus, knowing how to invert polynomials and how to compute $F(Q_k)$, we can find $n$ coefficients of $P$ with the complexity</p> $$T(n) = T(n/2) + f(n),$$ <p>where $f(n)$ is the time needed to compute $F(Q_k)$ and $F'(Q_k)^{-1}$ which is usually $O(n \\log n)$.</p> <p>The iterative rule above is known in numerical analysis as Newton's method.</p>","tags":["Original"]},{"location":"algebra/polynomial.html#hensels-lemma","title":"Hensel's lemma","text":"<p>As was mentioned earlier, formally and generically this result is known as Hensel's lemma and it may in fact used in even broader sense when we work with a series of nested rings. In this particular case we worked with a sequence of polynomial remainders modulo $x$, $x^2$, $x^3$ and so on.</p> <p>Another example where Hensel's lifting might be helpful are so-called p-adic numbers where we, in fact, work with the sequence of integer remainders modulo $p$, $p^2$, $p^3$ and so on. For example, Newton's method can be used to find all possible automorphic numbers (numbers that end on itself when squared) with a given number base. The problem is left as an exercise to the reader. You might consider this problem to check if your solution works for $10$-based numbers.</p>","tags":["Original"]},{"location":"algebra/polynomial.html#logarithm","title":"Logarithm","text":"<p>For the function $\\ln P(x)$ it's known that: </p> $$ \\boxed{(\\ln P(x))' = \\dfrac{P'(x)}{P(x)}} $$ <p>Thus we can calculate $n$ coefficients of $\\ln P(x)$ in $O(n \\log n)$.</p>","tags":["Original"]},{"location":"algebra/polynomial.html#inverse-series_1","title":"Inverse series","text":"<p>Turns out, we can get the formula for $A^{-1}$ using Newton's method. For this we take the equation $A=Q^{-1}$, thus:</p> $$F(Q) = Q^{-1} - A$$ $$F'(Q) = -Q^{-2}$$ $$\\boxed{Q_{k+1} \\equiv Q_k(2-AQ_k) \\pmod{x^{2^{k+1}}}}$$","tags":["Original"]},{"location":"algebra/polynomial.html#exponent","title":"Exponent","text":"<p>Let's learn to calculate $e^{P(x)}=Q(x)$. It should hold that $\\ln Q = P$, thus:</p> $$F(Q) = \\ln Q - P$$ $$F'(Q) = Q^{-1}$$ $$\\boxed{Q_{k+1} \\equiv Q_k(1 + P - \\ln Q_k) \\pmod{x^{2^{k+1}}}}$$","tags":["Original"]},{"location":"algebra/polynomial.html#k-th-power","title":"$k$-th power","text":"<p>Now we need to calculate $P^k(x)=Q$. This may be done via the following formula:</p> $$Q = \\exp\\left[k \\ln P(x)\\right]$$ <p>Note though, that you can calculate the logarithms and the exponents correctly only if you can find some initial $Q_0$.</p> <p>To find it, you should calculate the logarithm or the exponent of the constant coefficient of the polynomial.</p> <p>But the only reasonable way to do it is if $P(0)=1$ for $Q = \\ln P$ so $Q(0)=0$ and if $P(0)=0$ for $Q = e^P$ so $Q(0)=1$.</p> <p>Thus you can use formula above only if $P(0) = 1$. Otherwise if $P(x) = \\alpha x^t T(x)$ where $T(0)=1$ you can write that:</p> $$\\boxed{P^k(x) = \\alpha^kx^{kt} \\exp[k \\ln T(x)]}$$ <p>Note that you also can calculate some $k$-th root of a polynomial if you can calculate $\\sqrt[k]{\\alpha}$, for example for $\\alpha=1$.</p>","tags":["Original"]},{"location":"algebra/polynomial.html#evaluation-and-interpolation","title":"Evaluation and Interpolation","text":"","tags":["Original"]},{"location":"algebra/polynomial.html#chirp-z-transform","title":"Chirp-z Transform","text":"<p>For the particular case when you need to evaluate a polynomial in the points $x_r = z^{2r}$ you can do the following:</p> $$A(z^{2r}) = \\sum\\limits_{k=0}^n a_k z^{2kr}$$ <p>Let's substitute $2kr = r^2+k^2-(r-k)^2$. Then this sum rewrites as:</p> $$\\boxed{A(z^{2r}) = z^{r^2}\\sum\\limits_{k=0}^n (a_k z^{k^2}) z^{-(r-k)^2}}$$ <p>Which is up to the factor $z^{r^2}$ equal to the convolution of the sequences $u_k = a_k z^{k^2}$ and $v_k = z^{-k^2}$.</p> <p>Note that $u_k$ has indexes from $0$ to $n$ here and $v_k$ has indexes from $-n$ to $m$ where $m$ is the maximum power of $z$ which you need.</p> <p>Now if you need to evaluate a polynomial in the points $x_r = z^{2r+1}$ you can reduce it to the previous task by the transformation $a_k \\to a_k z^k$.</p> <p>It gives us an $O(n \\log n)$ algorithm when you need to compute values in powers of $z$, thus you may compute the DFT for non-powers of two.</p> <p>Another observation is that $kr = \\binom{k+r}{2} - \\binom{k}{2} - \\binom{r}{2}$. Then we have</p> $$\\boxed{A(z^r) = z^{-\\binom{r}{2}}\\sum\\limits_{k=0}^n \\left(a_k z^{-\\binom{k}{2}}\\right)z^{\\binom{k+r}{2}}}$$ <p>The coefficient of $x^{n+r}$ of the product of the polynomials $A_0(x) = \\sum\\limits_{k=0}^n a_{n-k}z^{-\\binom{n-k}{2}}x^k$ and $A_1(x) = \\sum\\limits_{k\\geq 0}z^{\\binom{k}{2}}x^k$ equals $z^{\\binom{r}{2}}A(z^r)$. You can use the formula $z^{\\binom{k+1}{2}}=z^{\\binom{k}{2}+k}$ to calculate the coefficients of $A_0(x)$ and $A_1(x)$.</p>","tags":["Original"]},{"location":"algebra/polynomial.html#multi-point-evaluation","title":"Multi-point Evaluation","text":"<p>Assume you need to calculate $A(x_1), \\dots, A(x_n)$. As mentioned earlier, $A(x) \\equiv A(x_i) \\pmod{x-x_i}$. Thus you may do the following:</p> <ol> <li>Compute a segment tree such that in the segment $[l,r)$ stands the product $P_{l, r}(x) = (x-x_l)(x-x_{l+1})\\dots(x-x_{r-1})$.</li> <li>Starting with $l=1$ and $r=n+1$ at the root node. Let $m=\\lfloor(l+r)/2\\rfloor$. Let's move down to $[l,m)$ with the polynomial $A(x) \\pmod{P_{l,m}(x)}$.</li> <li>This will recursively compute $A(x_l), \\dots, A(x_{m-1})$, now do the same for $[m,r)$ with $A(x) \\pmod{P_{m,r}(x)}$.</li> <li>Concatenate the results from the first and second recursive call and return them.</li> </ol> <p>The whole procedure will run in $O(n \\log^2 n)$.</p>","tags":["Original"]},{"location":"algebra/polynomial.html#interpolation","title":"Interpolation","text":"<p>There's a direct formula by Lagrange to interpolate a polynomial, given set of pairs $(x_i, y_i)$:</p> $$\\boxed{A(x) = \\sum\\limits_{i=1}^n y_i \\prod\\limits_{j \\neq i}\\dfrac{x-x_j}{x_i - x_j}}$$ <p>Computing it directly is a hard thing but turns out, we may compute it in $O(n \\log^2 n)$ with a divide and conquer approach:</p> <p>Consider $P(x) = (x-x_1)\\dots(x-x_n)$. To know the coefficients of the denominators in $A(x)$ we should compute products like: </p> $$ P_i = \\prod\\limits_{j \\neq i} (x_i-x_j) $$ <p>But if you consider the derivative $P'(x)$ you'll find out that $P'(x_i) = P_i$. Thus you can compute $P_i$'s via evaluation in $O(n \\log^2 n)$.</p> <p>Now consider the recursive algorithm done on same segment tree as in the multi-point evaluation. It starts in the leaves with the value $\\dfrac{y_i}{P_i}$ in each leaf.</p> <p>When we return from the recursion we should merge the results from the left and the right vertices as $A_{l,r} = A_{l,m}P_{m,r} + P_{l,m} A_{m,r}$.</p> <p>In this way when you return back to the root you'll have exactly $A(x)$ in it. The total procedure also works in $O(n \\log^2 n)$.</p>","tags":["Original"]},{"location":"algebra/polynomial.html#gcd-and-resultants","title":"GCD and Resultants","text":"<p>Assume you're given polynomials $A(x) = a_0 + a_1 x + \\dots + a_n x^n$ and $B(x) = b_0 + b_1 x + \\dots + b_m x^m$.</p> <p>Let $\\lambda_0, \\dots, \\lambda_n$ be the roots of $A(x)$ and let $\\mu_0, \\dots, \\mu_m$ be the roots of $B(x)$ counted with their multiplicities.</p> <p>You want to know if $A(x)$ and $B(x)$ have any roots in common. There are two interconnected ways to do that.</p>","tags":["Original"]},{"location":"algebra/polynomial.html#euclidean-algorithm","title":"Euclidean algorithm","text":"<p>Well, we already have an article about it. For an arbitrary  domain you can write the Euclidean algorithm as easy as:</p> <pre><code>template&lt;typename T&gt;\nT gcd(const T &amp;a, const T &amp;b) {\n    return b == T(0) ? a : gcd(b, a % b);\n}\n</code></pre> <p>It can be proven that for polynomials $A(x)$ and $B(x)$ it will work in $O(nm)$.</p>","tags":["Original"]},{"location":"algebra/polynomial.html#resultant","title":"Resultant","text":"<p>Let's calculate the product $A(\\mu_0)\\cdots A(\\mu_m)$. It will be equal to zero if and only if some $\\mu_i$ is the root of $A(x)$.</p> <p>For symmetry we can also multiply it with $b_m^n$ and rewrite the whole product in the following form:</p> $$\\boxed{\\mathcal{R}(A, B) = b_m^n\\prod\\limits_{j=0}^m A(\\mu_j) = b_m^n a_m^n \\prod\\limits_{i=0}^n \\prod\\limits_{j=0}^m (\\mu_j - \\lambda_i)= (-1)^{mn}a_n^m \\prod\\limits_{i=0}^n B(\\lambda_i)}$$ <p>The value defined above is called the resultant of the polynomials $A(x)$ and $B(x)$. From the definition you may find the following properties:</p> <ol> <li>$\\mathcal R(A, B) = (-1)^{nm} \\mathcal R(B, A)$.</li> <li>$\\mathcal R(A, B)= a_n^m b_m^n$ when $n=0$ or $m=0$.</li> <li>If $b_m=1$ then $\\mathcal R(A - CB, B) = \\mathcal R(A, B)$ for an arbitrary polynomial $C(x)$ and $n,m \\geq 1$.</li> <li>From this follows $\\mathcal R(A, B) = b_m^{\\deg(A) - \\deg(A-CB)}\\mathcal R(A - CB, B)$ for arbitrary $A(x)$, $B(x)$, $C(x)$.</li> </ol> <p>Miraculously it means that resultant of two polynomials is actually always from the same ring as their coefficients!</p> <p>Also these properties allow us to calculate the resultant alongside the Euclidean algorithm, which works in $O(nm)$.</p> <pre><code>template&lt;typename T&gt;\nT resultant(poly&lt;T&gt; a, poly&lt;T&gt; b) {\n    if(b.is_zero()) {\n        return 0;\n    } else if(b.deg() == 0) {\n        return bpow(b.lead(), a.deg());\n    } else {\n        int pw = a.deg();\n        a %= b;\n        pw -= a.deg();\n        base mul = bpow(b.lead(), pw) * base((b.deg() &amp; a.deg() &amp; 1) ? -1 : 1);\n        base ans = resultant(b, a);\n        return ans * mul;\n    }\n}\n</code></pre>","tags":["Original"]},{"location":"algebra/polynomial.html#half-gcd-algorithm","title":"Half-GCD algorithm","text":"<p>There is a way to calculate the GCD and resultants in $O(n \\log^2 n)$.</p> <p>The procedure to do so implements a $2 \\times 2$ linear transform which maps a pair of polynomials $a(x)$, $b(x)$ into another pair $c(x), d(x)$ such that $\\deg d(x) \\leq \\frac{\\deg a(x)}{2}$. If you're careful enough, you can compute the half-GCD of any pair of polynomials with at most $2$ recursive calls to the polynomials which are at least $2$ times smaller.</p> <p>The specific details of the algorithm are somewhat tedious to explain, however you can find its implementation in the library, as <code>half_gcd</code> function.</p> <p>After half-GCD is implemented, you can repeatedly apply it to polynomials until you're reduced to the pair of $\\gcd(a, b)$ and $0$.</p>","tags":["Original"]},{"location":"algebra/polynomial.html#problems","title":"Problems","text":"<ul> <li>CodeChef - RNG</li> <li>CodeForces - Basis Change</li> <li>CodeForces - Permutant</li> <li>CodeForces - Medium Hadron Collider</li> </ul>","tags":["Original"]},{"location":"algebra/primality_tests.html","title":"Primality tests","text":"<p>This article describes multiple algorithms to determine if a number is prime or not.</p>","tags":["Original"]},{"location":"algebra/primality_tests.html#trial-division","title":"Trial division","text":"<p>By definition a prime number doesn't have any divisors other than $1$ and itself. A composite number has at least one additional divisor, let's call it $d$. Naturally $\\frac{n}{d}$ is also a divisor of $n$. It's easy to see, that either $d \\le \\sqrt{n}$ or $\\frac{n}{d} \\le \\sqrt{n}$, therefore one of the divisors $d$ and $\\frac{n}{d}$ is $\\le \\sqrt{n}$. We can use this information to check for primality.</p> <p>We try to find a non-trivial divisor, by checking if any of the numbers between $2$ and $\\sqrt{n}$ is a divisor of $n$. If it is a divisor, then $n$ is definitely not prime, otherwise it is.</p> <pre><code>bool isPrime(int x) {\n    for (int d = 2; d * d &lt;= x; d++) {\n        if (x % d == 0)\n            return false;\n    }\n    return x &gt;= 2;\n}\n</code></pre> <p>This is the simplest form of a prime check. You can optimize this function quite a bit, for instance by only checking all odd numbers in the loop, since the only even prime number is 2. Multiple such optimizations are described in the article about integer factorization.</p>","tags":["Original"]},{"location":"algebra/primality_tests.html#fermat-primality-test","title":"Fermat primality test","text":"<p>This is a probabilistic test.</p> <p>Fermat's little theorem (see also Euler's totient function) states, that for a prime number $p$ and a coprime integer $a$ the following equation holds:</p> $$a^{p-1} \\equiv 1 \\bmod p$$ <p>In general this theorem doesn't hold for composite numbers.</p> <p>This can be used to create a primality test. We pick an integer $2 \\le a \\le p - 2$, and check if the equation holds or not. If it doesn't hold, e.g. $a^{p-1} \\not\\equiv 1 \\bmod p$, we know that $p$ cannot be a prime number. In this case we call the base $a$ a Fermat witness for the compositeness of $p$.</p> <p>However it is also possible, that the equation holds for a composite number. So if the equation holds, we don't have a proof for primality. We only can say that $p$ is probably prime. If it turns out that the number is actually composite, we call the base $a$ a Fermat liar.</p> <p>By running the test for all possible bases $a$, we can actually prove that a number is prime. However this is not done in practice, since this is a lot more effort that just doing trial division. Instead the test will be repeated multiple times with random choices for $a$. If we find no witness for the compositeness, it is very likely that the number is in fact prime.</p> <pre><code>bool probablyPrimeFermat(int n, int iter=5) {\n    if (n &lt; 4)\n        return n == 2 || n == 3;\n\n    for (int i = 0; i &lt; iter; i++) {\n        int a = 2 + rand() % (n - 3);\n        if (binpower(a, n - 1, n) != 1)\n            return false;\n    }\n    return true;\n}\n</code></pre> <p>We use Binary Exponentiation to efficiently compute the power $a^{p-1}$.</p> <p>There is one bad news though: there exist some composite numbers where $a^{n-1} \\equiv 1 \\bmod n$ holds for all $a$ coprime to $n$, for instance for the number $561 = 3 \\cdot 11 \\cdot 17$. Such numbers are called Carmichael numbers. The Fermat primality test can identify these numbers only, if we have immense luck and choose a base $a$ with $\\gcd(a, n) \\ne 1$.</p> <p>The Fermat test is still being used in practice, as it is very fast and Carmichael numbers are very rare. E.g. there only exist 646 such numbers below $10^9$.</p>","tags":["Original"]},{"location":"algebra/primality_tests.html#miller-rabin-primality-test","title":"Miller-Rabin primality test","text":"<p>The Miller-Rabin test extends the ideas from the Fermat test.</p> <p>For an odd number $n$, $n-1$ is even and we can factor out all powers of 2. We can write:</p> $$n - 1 = 2^s \\cdot d,~\\text{with}~d~\\text{odd}.$$ <p>This allows us to factorize the equation of Fermat's little theorem:</p> $$\\begin{array}{rl} a^{n-1} \\equiv 1 \\bmod n &amp;\\Longleftrightarrow a^{2^s d} - 1 \\equiv 0 \\bmod n \\\\\\\\ &amp;\\Longleftrightarrow (a^{2^{s-1} d} + 1) (a^{2^{s-1} d} - 1) \\equiv 0 \\bmod n \\\\\\\\ &amp;\\Longleftrightarrow (a^{2^{s-1} d} + 1) (a^{2^{s-2} d} + 1) (a^{2^{s-2} d} - 1) \\equiv 0 \\bmod n \\\\\\\\ &amp;\\quad\\vdots \\\\\\\\ &amp;\\Longleftrightarrow (a^{2^{s-1} d} + 1) (a^{2^{s-2} d} + 1) \\cdots (a^{d} + 1) (a^{d} - 1) \\equiv 0 \\bmod n \\\\\\\\ \\end{array}$$ <p>If $n$ is prime, then $n$ has to divide one of these factors. And in the Miller-Rabin primality test we check exactly that statement, which is a more stricter version of the statement of the Fermat test. For a base $2 \\le a \\le n-2$ we check if either</p> $$a^d \\equiv 1 \\bmod n$$ <p>holds or</p> $$a^{2^r d} \\equiv -1 \\bmod n$$ <p>holds for some $0 \\le r \\le s - 1$.</p> <p>If we found a base $a$ which doesn't satisfy any of the above equalities, then we found a witness for the compositeness of $n$. In this case we have proven that $n$ is not a prime number.</p> <p>Similar to the Fermat test, it is also possible that the set of equations is satisfied for a composite number. In that case the base $a$ is called a strong liar. If a base $a$ satisfies the equations (one of them), $n$ is only strong probable prime. However, there are no numbers like the Carmichael numbers, where all non-trivial bases lie. In fact it is possible to show, that at most $\\frac{1}{4}$ of the bases can be strong liars. If $n$ is composite, we have a probability of $\\ge 75\\%$ that a random base will tell us that it is composite. By doing multiple iterations, choosing different random bases, we can tell with very high probability if the number is truly prime or if it is composite.</p> <p>Here is an implementation for 64 bit integer.</p> <pre><code>using u64 = uint64_t;\nusing u128 = __uint128_t;\n\nu64 binpower(u64 base, u64 e, u64 mod) {\n    u64 result = 1;\n    base %= mod;\n    while (e) {\n        if (e &amp; 1)\n            result = (u128)result * base % mod;\n        base = (u128)base * base % mod;\n        e &gt;&gt;= 1;\n    }\n    return result;\n}\n\nbool check_composite(u64 n, u64 a, u64 d, int s) {\n    u64 x = binpower(a, d, n);\n    if (x == 1 || x == n - 1)\n        return false;\n    for (int r = 1; r &lt; s; r++) {\n        x = (u128)x * x % n;\n        if (x == n - 1)\n            return false;\n    }\n    return true;\n};\n\nbool MillerRabin(u64 n, int iter=5) { // returns true if n is probably prime, else returns false.\n    if (n &lt; 4)\n        return n == 2 || n == 3;\n\n    int s = 0;\n    u64 d = n - 1;\n    while ((d &amp; 1) == 0) {\n        d &gt;&gt;= 1;\n        s++;\n    }\n\n    for (int i = 0; i &lt; iter; i++) {\n        int a = 2 + rand() % (n - 3);\n        if (check_composite(n, a, d, s))\n            return false;\n    }\n    return true;\n}\n</code></pre> <p>Before the Miller-Rabin test you can test additionally if one of the first few prime numbers is a divisor. This can speed up the test by a lot, since most composite numbers have very small prime divisors. E.g. $88\\%$ of all numbers have a prime factor smaller than $100$.</p>","tags":["Original"]},{"location":"algebra/primality_tests.html#deterministic-version","title":"Deterministic version","text":"<p>Miller showed that it is possible to make the algorithm deterministic by only checking all bases $\\le O((\\ln n)^2)$. Bach later gave a concrete bound, it is only necessary to test all bases $a \\le 2 \\ln(n)^2$.</p> <p>This is still a pretty large number of bases. So people have invested quite a lot of computation power into finding lower bounds. It turns out, for testing a 32 bit integer it is only necessary to check the first 4 prime bases: 2, 3, 5 and 7. The smallest composite number that fails this test is $3,215,031,751 = 151 \\cdot 751 \\cdot 28351$. And for testing 64 bit integer it is enough to check the first 12 prime bases: 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, and 37.</p> <p>This results in the following deterministic implementation:</p> <pre><code>bool MillerRabin(u64 n) { // returns true if n is prime, else returns false.\n    if (n &lt; 2)\n        return false;\n\n    int r = 0;\n    u64 d = n - 1;\n    while ((d &amp; 1) == 0) {\n        d &gt;&gt;= 1;\n        r++;\n    }\n\n    for (int a : {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37}) {\n        if (n == a)\n            return true;\n        if (check_composite(n, a, d, r))\n            return false;\n    }\n    return true;\n}\n</code></pre> <p>It's also possible to do the check with only 7 bases: 2, 325, 9375, 28178, 450775, 9780504 and 1795265022. However, since these numbers (except 2) are not prime, you need to check additionally if the number you are checking is equal to any prime divisor of those bases: 2, 3, 5, 13, 19, 73, 193, 407521, 299210837.</p>","tags":["Original"]},{"location":"algebra/primality_tests.html#practice-problems","title":"Practice Problems","text":"<ul> <li>SPOJ - Prime or Not</li> <li>Project euler - Investigating a Prime Pattern</li> </ul>","tags":["Original"]},{"location":"algebra/prime-sieve-linear.html","title":"Linear Sieve","text":"<p>Given a number $n$, find all prime numbers in a segment $[2;n]$.</p> <p>The standard way of solving a task is to use the sieve of Eratosthenes. This algorithm is very simple, but it has runtime $O(n \\log \\log n)$.</p> <p>Although there are a lot of known algorithms with sublinear runtime (i.e. $o(n)$), the algorithm described below is interesting by its simplicity: it isn't any more complex than the classic sieve of Eratosthenes.</p> <p>Besides, the algorithm given here calculates factorizations of all numbers in the segment $[2; n]$ as a side effect, and that can be helpful in many practical applications.</p> <p>The weakness of the given algorithm is in using more memory than the classic sieve of Eratosthenes': it requires an array of $n$ numbers, while for the classic sieve of Eratosthenes it is enough to have $n$ bits of memory (which is 32 times less).</p> <p>Thus, it makes sense to use the described algorithm only until for numbers of order $10^7$ and not greater.</p> <p>The algorithm is due to Paul Pritchard. It is a variant of Algorithm 3.3 in (Pritchard, 1987: see references in the end of the article).</p>","tags":["Translated"]},{"location":"algebra/prime-sieve-linear.html#algorithm","title":"Algorithm","text":"<p>Our goal is to calculate minimum prime factor $lp [i]$ for every number $i$ in the segment $[2; n]$.</p> <p>Besides, we need to store the list of all the found prime numbers - let's call it $pr []$.</p> <p>We'll initialize the values $lp [i]$ with zeros, which means that we assume all numbers are prime. During the algorithm execution this array will be filled gradually.</p> <p>Now we'll go through the numbers from 2 to $n$. We have two cases for the current number $i$:</p> <ul> <li> <p>$lp[i] = 0$ - that means that $i$ is prime, i.e. we haven't found any smaller factors for it.   Hence, we assign $lp [i] = i$ and add $i$ to the end of the list $pr[]$.</p> </li> <li> <p>$lp[i] \\neq 0$ - that means that $i$ is composite, and its minimum prime factor is $lp [i]$.</p> </li> </ul> <p>In both cases we update values of $lp []$ for the numbers that are divisible by $i$. However, our goal is to learn to do so as to set a value $lp []$ at most once for every number. We can do it as follows:</p> <p>Let's consider numbers $x_j = i \\cdot p_j$, where $p_j$ are all prime numbers less than or equal to $lp [i]$ (this is why we need to store the list of all prime numbers).</p> <p>We'll set a new value $lp [x_j] = p_j$ for all numbers of this form.</p> <p>The proof of correctness of this algorithm and its runtime can be found after the implementation.</p>","tags":["Translated"]},{"location":"algebra/prime-sieve-linear.html#implementation","title":"Implementation","text":"<pre><code>const int N = 10000000;\nvector&lt;int&gt; lp(N+1);\nvector&lt;int&gt; pr;\n\nfor (int i=2; i &lt;= N; ++i) {\n    if (lp[i] == 0) {\n        lp[i] = i;\n        pr.push_back(i);\n    }\n    for (int j = 0; i * pr[j] &lt;= N; ++j) {\n        lp[i * pr[j]] = pr[j];\n        if (pr[j] == lp[i]) {\n            break;\n        }\n    }\n}\n</code></pre>","tags":["Translated"]},{"location":"algebra/prime-sieve-linear.html#correctness-proof","title":"Correctness Proof","text":"<p>We need to prove that the algorithm sets all values $lp []$ correctly, and that every value will be set exactly once. Hence, the algorithm will have linear runtime, since all the remaining actions of the algorithm, obviously, work for $O (n)$.</p> <p>Notice that every number $i$ has exactly one representation in form:</p> $$i = lp [i] \\cdot x,$$ <p>where $lp [i]$ is the minimal prime factor of $i$, and the number $x$ doesn't have any prime factors less than $lp [i]$, i.e.</p> $$lp [i] \\le lp [x].$$ <p>Now, let's compare this with the actions of our algorithm: in fact, for every $x$ it goes through all prime numbers it could be multiplied by, i.e. all prime numbers up to $lp [x]$ inclusive, in order to get the numbers in the form given above.</p> <p>Hence, the algorithm will go through every composite number exactly once, setting the correct values $lp []$ there. Q.E.D.</p>","tags":["Translated"]},{"location":"algebra/prime-sieve-linear.html#runtime-and-memory","title":"Runtime and Memory","text":"<p>Although the running time of $O(n)$ is better than $O(n \\log \\log n)$ of the classic sieve of Eratosthenes, the difference between them is not so big. In practice the linear sieve runs about as fast as a typical implementation of the sieve of Eratosthenes.</p> <p>In comparison to optimized versions of the sieve of Erathosthenes, e.g. the segmented sieve, it is much slower.</p> <p>Considering the memory requirements of this algorithm - an array $lp []$ of length $n$, and an array of $pr []$ of length  $\\frac n {\\ln n}$, this algorithm seems to be worse than the classic sieve in every way.</p> <p>However, its redeeming quality is that this algorithm calculates an array $lp []$, which allows us to find factorization of any number in the segment $[2; n]$ in the time of the size order of this factorization. Moreover, using just one extra array will allow us to avoid divisions when looking for factorization.</p> <p>Knowing the factorizations of all numbers is very useful for some tasks, and this algorithm is one of the few which allow to find them in linear time.</p>","tags":["Translated"]},{"location":"algebra/prime-sieve-linear.html#references","title":"References","text":"<ul> <li>Paul Pritchard, Linear Prime-Number Sieves: a Family Tree, Science of Computer Programming, vol. 9 (1987), pp.17-35.</li> </ul>","tags":["Translated"]},{"location":"algebra/primitive-root.html","title":"Primitive Root","text":"","tags":["Translated"]},{"location":"algebra/primitive-root.html#definition","title":"Definition","text":"<p>In modular arithmetic, a number $g$ is called a <code>primitive root modulo n</code> if every number coprime to $n$ is congruent to a power of $g$ modulo $n$. Mathematically, $g$ is a <code>primitive root modulo n</code> if and only if for any integer $a$ such that $\\gcd(a, n) = 1$, there exists an integer $k$ such that:</p> <p>$g^k \\equiv a \\pmod n$.</p> <p>$k$ is then called the <code>index</code> or <code>discrete logarithm</code> of $a$ to the base $g$ modulo $n$. $g$ is also called the <code>generator</code> of the multiplicative group of integers modulo $n$.</p> <p>In particular, for the case where $n$ is a prime, the powers of primitive root runs through all numbers from $1$ to $n-1$.</p>","tags":["Translated"]},{"location":"algebra/primitive-root.html#existence","title":"Existence","text":"<p>Primitive root modulo $n$ exists if and only if:</p> <ul> <li>$n$ is 1, 2, 4, or</li> <li>$n$ is power of an odd prime number $(n = p^k)$, or</li> <li>$n$ is twice power of an odd prime number $(n = 2 \\cdot p^k)$.</li> </ul> <p>This theorem was proved by Gauss in 1801.</p>","tags":["Translated"]},{"location":"algebra/primitive-root.html#relation-with-the-euler-function","title":"Relation with the Euler function","text":"<p>Let $g$ be a primitive root modulo $n$. Then we can show that the smallest number $k$ for which $g^k \\equiv 1 \\pmod n$ is equal $\\phi (n)$. Moreover, the reverse is also true, and this fact will be used in this article to find a primitive root.</p> <p>Furthermore, the number of primitive roots modulo $n$, if there are any, is equal to $\\phi (\\phi (n) )$.</p>","tags":["Translated"]},{"location":"algebra/primitive-root.html#algorithm-for-finding-a-primitive-root","title":"Algorithm for finding a primitive root","text":"<p>A naive algorithm is to consider all numbers in range $[1, n-1]$. And then check if each one is a primitive root, by calculating all its power to see if they are all different. This algorithm has complexity $O(g \\cdot n)$, which would be too slow. In this section, we propose a faster algorithm using several well-known theorems.</p> <p>From previous section, we know that if the smallest number $k$ for which $g^k \\equiv 1 \\pmod n$ is $\\phi (n)$, then $g$ is a primitive root. Since for any number $a$ relative prime to $n$, we know from Euler's theorem that $a ^ { \\phi (n) } \\equiv 1 \\pmod n$, then to check if $g$ is primitive root, it is enough to check that for all $d$ less than $\\phi (n)$, $g^d \\not \\equiv 1 \\pmod n$. However, this algorithm is still too slow.</p> <p>From Lagrange's theorem, we know that the index of 1 of any number modulo $n$ must be a divisor of $\\phi (n)$. Thus, it is sufficient to verify for all proper divisor $d \\mid \\phi (n)$ that $g^d \\not \\equiv 1 \\pmod n$. This is already a much faster algorithm, but we can still do better.</p> <p>Factorize $\\phi (n) = p_1 ^ {a_1} \\cdots p_s ^ {a_s}$. We prove that in the previous algorithm, it is sufficient to consider only the values of $d$ which have the form $\\frac { \\phi (n) } {p_j}$. Indeed, let $d$ be any proper divisor of $\\phi (n)$. Then, obviously, there exists such $j$ that $d \\mid \\frac { \\phi (n) } {p_j}$, i.e. $d \\cdot k = \\frac { \\phi (n) } {p_j}$. However, if $g^d \\equiv 1 \\pmod n$, we would get:</p> <p>$g ^ { \\frac { \\phi (n)} {p_j} } \\equiv g ^ {d \\cdot k} \\equiv (g^d) ^k \\equiv 1^k \\equiv 1 \\pmod n$.</p> <p>i.e. among the numbers of the form $\\frac {\\phi (n)} {p_i}$, there would be at least one such that the conditions were not met.</p> <p>Now we have a complete algorithm for finding the primitive root:</p> <ul> <li>First, find $\\phi (n)$ and factorize it.</li> <li> <p>Then iterate through all numbers $g \\in [1, n]$, and for each number, to check if it is primitive root, we do the following:</p> <ul> <li>Calculate all $g ^ { \\frac {\\phi (n)} {p_i}} \\pmod n$.</li> <li>If all the calculated values are different from $1$, then $g$ is a primitive root.</li> </ul> <p>Running time of this algorithm is $O(Ans \\cdot \\log \\phi (n) \\cdot \\log n)$ (assume that $\\phi (n)$ has $\\log \\phi (n)$ divisors).</p> </li> </ul> <p>Shoup (1990, 1992) proved, assuming the generalized Riemann hypothesis, that $g$ is $O(\\log^6 p)$.</p>","tags":["Translated"]},{"location":"algebra/primitive-root.html#implementation","title":"Implementation","text":"<p>The following code assumes that the modulo <code>p</code> is a prime number. To make it works for any value of <code>p</code>, we must add calculation of $\\phi (p)$. </p> <pre><code>int powmod (int a, int b, int p) {\n    int res = 1;\n    while (b)\n        if (b &amp; 1)\n            res = int (res * 1ll * a % p),  --b;\n        else\n            a = int (a * 1ll * a % p),  b &gt;&gt;= 1;\n    return res;\n}\n\nint generator (int p) {\n    vector&lt;int&gt; fact;\n    int phi = p-1,  n = phi;\n    for (int i=2; i*i&lt;=n; ++i)\n        if (n % i == 0) {\n            fact.push_back (i);\n            while (n % i == 0)\n                n /= i;\n        }\n    if (n &gt; 1)\n        fact.push_back (n);\n\n    for (int res=2; res&lt;=p; ++res) {\n        bool ok = true;\n        for (size_t i=0; i&lt;fact.size() &amp;&amp; ok; ++i)\n            ok &amp;= powmod (res, phi / fact[i], p) != 1;\n        if (ok)  return res;\n    }\n    return -1;\n}\n</code></pre>","tags":["Translated"]},{"location":"algebra/sieve-of-eratosthenes.html","title":"Sieve of Eratosthenes","text":"<p>Sieve of Eratosthenes is an algorithm for finding all the prime numbers in a segment $[1;n]$ using $O(n \\log \\log n)$ operations.</p> <p>The algorithm is very simple: at the beginning we write down all numbers between 2 and $n$. We mark all proper multiples of 2 (since 2 is the smallest prime number) as composite. A proper multiple of a number $x$, is a number greater than $x$ and divisible by $x$. Then we find the next number that hasn't been marked as composite, in this case it is 3. Which means 3 is prime, and we mark all proper multiples of 3 as composite. The next unmarked number is 5, which is the next prime number, and we mark all proper multiples of it. And we continue this procedure until we have processed all numbers in the row.</p> <p>In the following image you can see a visualization of the algorithm for computing all prime numbers in the range $[1; 16]$. It can be seen, that quite often we mark numbers as composite multiple times.</p> <p>The idea behind is this: A number is prime, if none of the smaller prime numbers divides it. Since we iterate over the prime numbers in order, we already marked all numbers, which are divisible by at least one of the prime numbers, as divisible. Hence if we reach a cell and it is not marked, then it isn't divisible by any smaller prime number and therefore has to be prime.</p>","tags":["Translated"]},{"location":"algebra/sieve-of-eratosthenes.html#implementation","title":"Implementation","text":"<pre><code>int n;\nvector&lt;bool&gt; is_prime(n+1, true);\nis_prime[0] = is_prime[1] = false;\nfor (int i = 2; i &lt;= n; i++) {\n    if (is_prime[i] &amp;&amp; (long long)i * i &lt;= n) {\n        for (int j = i * i; j &lt;= n; j += i)\n            is_prime[j] = false;\n    }\n}\n</code></pre> <p>This code first marks all numbers except zero and one as potential prime numbers, then it begins the process of sifting composite numbers. For this it iterates over all numbers from $2$ to $n$. If the current number $i$ is a prime number, it marks all numbers that are multiples of $i$ as composite numbers, starting from $i^2$. This is already an optimization over naive way of implementing it, and is allowed as all smaller numbers that are multiples of $i$ necessary also have a prime factor which is less than $i$, so all of them were already sifted earlier. Since $i^2$ can easily overflow the type <code>int</code>, the additional verification is done using type <code>long long</code> before the second nested loop.</p> <p>Using such implementation the algorithm consumes $O(n)$ of the memory (obviously) and performs $O(n \\log \\log n)$ (see next section).</p>","tags":["Translated"]},{"location":"algebra/sieve-of-eratosthenes.html#asymptotic-analysis","title":"Asymptotic analysis","text":"<p>It's simple to prove a running time of $O(n \\log n)$ without knowing anything about the distribution of primes - ignoring the <code>is_prime</code> check, the inner loop runs (at most) $n/i$ times for $i = 2, 3, 4, \\dots$, leading the total number of operations in the inner loop to be a harmonic sum like $n(1/2 + 1/3 + 1/4 + \\cdots)$, which is bounded by $O(n \\log n)$.</p> <p>Let's prove that algorithm's running time is $O(n \\log \\log n)$. The algorithm will perform $\\frac{n}{p}$ operations for every prime $p \\le n$ in the inner loop. Hence, we need to evaluate the next expression:</p> $$\\sum_{\\substack{p \\le n, \\\\\\ p \\text{ prime}}} \\frac n p = n \\cdot \\sum_{\\substack{p \\le n, \\\\\\ p \\text{ prime}}} \\frac 1 p.$$ <p>Let's recall two known facts.</p> <ul> <li>The number of prime numbers less than or equal to $n$ is approximately $\\frac n {\\ln n}$.</li> <li>The $k$-th prime number approximately equals $k \\ln k$ (this follows from the previous fact).</li> </ul> <p>Thus we can write down the sum in the following way:</p> $$\\sum_{\\substack{p \\le n, \\\\\\ p \\text{ prime}}} \\frac 1 p \\approx \\frac 1 2 + \\sum_{k = 2}^{\\frac n {\\ln n}} \\frac 1 {k \\ln k}.$$ <p>Here we extracted the first prime number 2 from the sum, because $k = 1$ in approximation $k \\ln k$  is $0$ and causes a division by zero.</p> <p>Now, let's evaluate this sum using the integral of a same function over $k$ from $2$ to $\\frac n {\\ln n}$ (we can make such approximation because, in fact, the sum is related to the integral as its approximation using the rectangle method):</p> $$\\sum_{k = 2}^{\\frac n {\\ln n}} \\frac 1 {k \\ln k} \\approx \\int_2^{\\frac n {\\ln n}} \\frac 1 {k \\ln k} dk.$$ <p>The antiderivative for the integrand is  $\\ln \\ln k$. Using a substitution and removing terms of lower order, we'll get the result:</p> $$\\int_2^{\\frac n {\\ln n}} \\frac 1 {k \\ln k} dk = \\ln \\ln \\frac n {\\ln n} - \\ln \\ln 2 = \\ln(\\ln n - \\ln \\ln n) - \\ln \\ln 2 \\approx \\ln \\ln n.$$ <p>Now, returning to the original sum, we'll get its approximate evaluation:</p> $$\\sum_{\\substack{p \\le n, \\\\\\ p\\ is\\ prime}} \\frac n p \\approx n \\ln \\ln n + o(n).$$ <p>You can find a more strict proof (that gives more precise evaluation which is accurate within constant multipliers) in the book authored by Hardy &amp; Wright \"An Introduction to the Theory of Numbers\" (p. 349).</p>","tags":["Translated"]},{"location":"algebra/sieve-of-eratosthenes.html#different-optimizations-of-the-sieve-of-eratosthenes","title":"Different optimizations of the Sieve of Eratosthenes","text":"<p>The biggest weakness of the algorithm is, that it \"walks\" along the memory multiple times, only manipulating single elements. This is not very cache friendly. And because of that, the constant which is concealed in $O(n \\log \\log n)$ is comparably big.</p> <p>Besides, the consumed memory is a bottleneck for big $n$.</p> <p>The methods presented below allow us to reduce the quantity of the performed operations, as well as to shorten the consumed memory noticeably.</p>","tags":["Translated"]},{"location":"algebra/sieve-of-eratosthenes.html#sieving-till-root","title":"Sieving till root","text":"<p>Obviously, to find all the prime numbers until $n$, it will be enough just to perform the sifting only by the prime numbers, which do not exceed the root of $n$.</p> <pre><code>int n;\nvector&lt;bool&gt; is_prime(n+1, true);\nis_prime[0] = is_prime[1] = false;\nfor (int i = 2; i * i &lt;= n; i++) {\n    if (is_prime[i]) {\n        for (int j = i * i; j &lt;= n; j += i)\n            is_prime[j] = false;\n    }\n}\n</code></pre> <p>Such optimization doesn't affect the complexity (indeed, by repeating the proof presented above we'll get the evaluation $n \\ln \\ln \\sqrt n + o(n)$, which is asymptotically the same according to the properties of logarithms), though the number of operations will reduce noticeably.</p>","tags":["Translated"]},{"location":"algebra/sieve-of-eratosthenes.html#sieving-by-the-odd-numbers-only","title":"Sieving by the odd numbers only","text":"<p>Since all even numbers (except $2$) are composite, we can stop checking even numbers at all. Instead, we need to operate with odd numbers only.</p> <p>First, it will allow us to halve the needed memory. Second, it will reduce the number of operations performed by algorithm approximately in half.</p>","tags":["Translated"]},{"location":"algebra/sieve-of-eratosthenes.html#memory-consumption-and-speed-of-operations","title":"Memory consumption and speed of operations","text":"<p>We should notice, that these two implementations of the Sieve of Eratosthenes use $n$ bits of memory by using the data structure <code>vector&lt;bool&gt;</code>. <code>vector&lt;bool&gt;</code> is not a regular container that stores a series of <code>bool</code> (as in most computer architectures a <code>bool</code> takes one byte of memory). It's a memory-optimization specialization of <code>vector&lt;T&gt;</code>, that only consumes $\\frac{N}{8}$ bytes of memory.</p> <p>Modern processors architectures work much more efficiently with bytes than with bits as they usually cannot access bits directly. So underneath the <code>vector&lt;bool&gt;</code> stores the bits in a large continuous memory, accesses the memory in blocks of a few bytes, and extracts/sets the bits with bit operations like bit masking and bit shifting.</p> <p>Because of that there is a certain overhead when you read or write bits with a <code>vector&lt;bool&gt;</code>, and quite often using a <code>vector&lt;char&gt;</code> (which uses 1 byte for each entry, so 8x the amount of memory) is faster.</p> <p>However, for the simple implementations of the Sieve of Eratosthenes using a <code>vector&lt;bool&gt;</code> is faster. You are limited by how fast you can load the data into the cache, and therefore using less memory gives a big advantage. A benchmark (link) shows, that using a <code>vector&lt;bool&gt;</code> is between 1.4x and 1.7x faster than using a <code>vector&lt;char&gt;</code>.</p> <p>The same considerations also apply to <code>bitset</code>. It's also an efficient way of storing bits, similar to <code>vector&lt;bool&gt;</code>, so it takes only $\\frac{N}{8}$ bytes of memory, but is a bit slower in accessing the elements. In the benchmark above <code>bitset</code> performs a bit worse than <code>vector&lt;bool&gt;</code>. Another drawback from <code>bitset</code> is that you need to know the size at compile time.</p>","tags":["Translated"]},{"location":"algebra/sieve-of-eratosthenes.html#segmented-sieve","title":"Segmented Sieve","text":"<p>It follows from the optimization \"sieving till root\" that there is no need to keep the whole array <code>is_prime[1...n]</code> at all times. For sieving it is enough to just keep the prime numbers until the root of $n$, i.e. <code>prime[1... sqrt(n)]</code>, split the complete range into blocks, and sieve each block separately.</p> <p>Let $s$ be a constant which determines the size of the block, then we have $\\lceil {\\frac n s} \\rceil$ blocks altogether, and the block $k$ ($k = 0 ... \\lfloor {\\frac n s} \\rfloor$) contains the numbers in a segment $[ks; ks + s - 1]$. We can work on blocks by turns, i.e. for every block $k$ we will go through all the prime numbers (from $1$ to $\\sqrt n$) and perform sieving using them. It is worth noting, that we have to modify the strategy a little bit when handling the first numbers: first, all the prime numbers from $[1; \\sqrt n]$  shouldn't remove themselves; and second, the numbers $0$ and $1$ should be marked as non-prime numbers. While working on the last block it should not be forgotten that the last needed number $n$ is not necessarily located at the end of the block.</p> <p>As discussed previously, the typical implementation of the Sieve of Eratosthenes is limited by the speed how fast you can load data into the CPU caches. By splitting the range of potential prime numbers $[1; n]$ into smaller blocks, we never have to keep multiple blocks in memory at the same time, and all operations are much more cache-friendlier. As we are now no longer limited by the cache speeds, we can replace the <code>vector&lt;bool&gt;</code> with a <code>vector&lt;char&gt;</code>, and gain some additional performance as the processors can handle read and writes with bytes directly and don't need to rely on bit operations for extracting individual bits. The benchmark (link) shows, that using a <code>vector&lt;char&gt;</code> is about 3x faster in this situation than using a <code>vector&lt;bool&gt;</code>. A word of caution: those numbers might differ depending on architecture, compiler, and optimization levels.</p> <p>Here we have an implementation that counts the number of primes smaller than or equal to $n$ using block sieving.</p> <pre><code>int count_primes(int n) {\n    const int S = 10000;\n\n    vector&lt;int&gt; primes;\n    int nsqrt = sqrt(n);\n    vector&lt;char&gt; is_prime(nsqrt + 2, true);\n    for (int i = 2; i &lt;= nsqrt; i++) {\n        if (is_prime[i]) {\n            primes.push_back(i);\n            for (int j = i * i; j &lt;= nsqrt; j += i)\n                is_prime[j] = false;\n        }\n    }\n\n    int result = 0;\n    vector&lt;char&gt; block(S);\n    for (int k = 0; k * S &lt;= n; k++) {\n        fill(block.begin(), block.end(), true);\n        int start = k * S;\n        for (int p : primes) {\n            int start_idx = (start + p - 1) / p;\n            int j = max(start_idx, p) * p - start;\n            for (; j &lt; S; j += p)\n                block[j] = false;\n        }\n        if (k == 0)\n            block[0] = block[1] = false;\n        for (int i = 0; i &lt; S &amp;&amp; start + i &lt;= n; i++) {\n            if (block[i])\n                result++;\n        }\n    }\n    return result;\n}\n</code></pre> <p>The running time of block sieving is the same as for regular sieve of Eratosthenes (unless the size of the blocks is very small), but the needed memory will shorten to $O(\\sqrt{n} + S)$ and we have better caching results. On the other hand, there will be a division for each pair of a block and prime number from $[1; \\sqrt{n}]$, and that will be far worse for smaller block sizes. Hence, it is necessary to keep balance when selecting the constant $S$. We achieved the best results for block sizes between $10^4$ and $10^5$.</p>","tags":["Translated"]},{"location":"algebra/sieve-of-eratosthenes.html#find-primes-in-range","title":"Find primes in range","text":"<p>Sometimes we need to find all prime numbers in a range $[L,R]$ of small size (e.g. $R - L + 1 \\approx 1e7$), where $R$ can be very large (e.g. $1e12$).</p> <p>To solve such a problem, we can use the idea of the Segmented sieve. We pre-generate all prime numbers up to $\\sqrt R$, and use those primes to mark all composite numbers in the segment $[L, R]$.</p> <p><pre><code>vector&lt;char&gt; segmentedSieve(long long L, long long R) {\n    // generate all primes up to sqrt(R)\n    long long lim = sqrt(R);\n    vector&lt;char&gt; mark(lim + 1, false);\n    vector&lt;long long&gt; primes;\n    for (long long i = 2; i &lt;= lim; ++i) {\n        if (!mark[i]) {\n            primes.emplace_back(i);\n            for (long long j = i * i; j &lt;= lim; j += i)\n                mark[j] = true;\n        }\n    }\n\n    vector&lt;char&gt; isPrime(R - L + 1, true);\n    for (long long i : primes)\n        for (long long j = max(i * i, (L + i - 1) / i * i); j &lt;= R; j += i)\n            isPrime[j - L] = false;\n    if (L == 1)\n        isPrime[0] = false;\n    return isPrime;\n}\n</code></pre> Time complexity of this approach is $O((R - L + 1) \\log \\log (R) + \\sqrt R \\log \\log \\sqrt R)$.</p> <p>It's also possible that we don't pre-generate all prime numbers:</p> <pre><code>vector&lt;char&gt; segmentedSieveNoPreGen(long long L, long long R) {\n    vector&lt;char&gt; isPrime(R - L + 1, true);\n    long long lim = sqrt(R);\n    for (long long i = 2; i &lt;= lim; ++i)\n        for (long long j = max(i * i, (L + i - 1) / i * i); j &lt;= R; j += i)\n            isPrime[j - L] = false;\n    if (L == 1)\n        isPrime[0] = false;\n    return isPrime;\n}\n</code></pre> <p>Obviously, the complexity is worse, which is $O((R - L + 1) \\log (R) + \\sqrt R)$. However, it still runs very fast in practice.</p>","tags":["Translated"]},{"location":"algebra/sieve-of-eratosthenes.html#linear-time-modification","title":"Linear time modification","text":"<p>We can modify the algorithm in a such a way, that it only has linear time complexity. This approach is described in the article Linear Sieve. However, this algorithm also has its own weaknesses.</p>","tags":["Translated"]},{"location":"algebra/sieve-of-eratosthenes.html#practice-problems","title":"Practice Problems","text":"<ul> <li>Leetcode - Four Divisors</li> <li>Leetcode - Count Primes</li> <li>SPOJ - Printing Some Primes</li> <li>SPOJ - A Conjecture of Paul Erdos</li> <li>SPOJ - Primal Fear</li> <li>SPOJ - Primes Triangle (I)</li> <li>Codeforces - Almost Prime</li> <li>Codeforces - Sherlock And His Girlfriend</li> <li>SPOJ - Namit in Trouble</li> <li>SPOJ - Bazinga!</li> <li>Project Euler - Prime pair connection</li> <li>SPOJ - N-Factorful</li> <li>SPOJ - Binary Sequence of Prime Numbers</li> <li>UVA 11353 - A Different Kind of Sorting</li> <li>SPOJ - Prime Generator</li> <li>SPOJ - Printing some primes (hard)</li> <li>Codeforces - Nodbach Problem</li> <li>Codeforces - Colliders</li> </ul>","tags":["Translated"]},{"location":"combinatorics/binomial-coefficients.html","title":"Binomial Coefficients","text":"<p>Binomial coefficients $\\binom n k$ are the number of ways to select a set of $k$ elements from $n$ different elements without taking into account the order of arrangement of these elements (i.e., the number of unordered sets).</p> <p>Binomial coefficients are also the coefficients in the expansion of $(a + b) ^ n$ (so-called binomial theorem):</p> $$ (a+b)^n = \\binom n 0 a^n + \\binom n 1 a^{n-1} b + \\binom n 2 a^{n-2} b^2 + \\cdots + \\binom n k a^{n-k} b^k + \\cdots + \\binom n n b^n $$ <p>It is believed that this formula, as well as the triangle which allows efficient calculation of the coefficients, was discovered by Blaise Pascal in the 17th century. Nevertheless, it was known to the Chinese mathematician Yang Hui, who lived in the 13th century. Perhaps it was discovered by a Persian scholar Omar Khayyam. Moreover, Indian mathematician Pingala, who lived  earlier in the 3rd. BC, got similar results. The merit of the Newton is that he generalized this formula for exponents that are not natural.</p>","tags":["Translated"]},{"location":"combinatorics/binomial-coefficients.html#calculation","title":"Calculation","text":"<p>Analytic formula for the calculation:</p> $$ \\binom n k = \\frac {n!} {k!(n-k)!} $$ <p>This formula can be easily deduced from the problem of ordered arrangement (number of ways to select $k$ different elements from $n$ different elements). First, let's count the number of ordered selections of $k$ elements. There are $n$ ways to select the first element, $n-1$ ways to select the second element, $n-2$ ways to select the third element, and so on. As a result, we get the formula of the number of ordered arrangements: $n (n-1) (n-2) \\cdots (n - k + 1) = \\frac {n!} {(n-k)!}$. We can easily move to unordered arrangements, noting that each unordered arrangement corresponds to exactly $k!$ ordered arrangements ($k!$ is the number of possible permutations of $k$ elements). We get the final formula by dividing $\\frac {n!} {(n-k)!}$ by $k!$.</p> <p>Recurrence formula (which is associated with the famous \"Pascal's Triangle\"):</p> $$ \\binom n k = \\binom {n-1} {k-1} + \\binom {n-1} k $$ <p>It is easy to deduce this using the analytic formula.</p> <p>Note that for $n \\lt k$ the value of $\\binom n k$ is assumed to be zero.</p>","tags":["Translated"]},{"location":"combinatorics/binomial-coefficients.html#properties","title":"Properties","text":"<p>Binomial coefficients have many different properties. Here are the simplest of them:</p> <ul> <li> <p>Symmetry rule:</p> $$ \\binom n k = \\binom n {n-k} $$ </li> <li> <p>Factoring in:</p> $$ \\binom n k = \\frac n k \\binom {n-1} {k-1} $$ </li> <li> <p>Sum over $k$:</p> $$ \\sum_{k = 0}^n \\binom n k = 2 ^ n $$ </li> <li> <p>Sum over $n$:</p> $$ \\sum_{m = 0}^n \\binom m k = \\binom {n + 1} {k + 1} $$ </li> <li> <p>Sum over $n$ and $k$:</p> $$ \\sum_{k = 0}^m  \\binom {n + k} k = \\binom {n + m + 1} m $$ </li> <li> <p>Sum of the squares:</p> $$ {\\binom n 0}^2 + {\\binom n 1}^2 + \\cdots + {\\binom n n}^2 = \\binom {2n} n $$ </li> <li> <p>Weighted sum:</p> $$ 1 \\binom n 1 + 2 \\binom n 2 + \\cdots + n \\binom n n = n 2^{n-1} $$ </li> <li> <p>Connection with the Fibonacci numbers:</p> $$ \\binom n 0 + \\binom {n-1} 1 + \\cdots + \\binom {n-k} k + \\cdots + \\binom 0 n = F_{n+1} $$ </li> </ul>","tags":["Translated"]},{"location":"combinatorics/binomial-coefficients.html#calculation_1","title":"Calculation","text":"","tags":["Translated"]},{"location":"combinatorics/binomial-coefficients.html#straightforward-calculation-using-analytical-formula","title":"Straightforward calculation using analytical formula","text":"<p>The first, straightforward formula is very easy to code, but this method is likely to overflow even for relatively small values of $n$ and $k$ (even if the answer completely fit into some datatype, the calculation of the intermediate factorials can lead to overflow). Therefore, this method often can only be used with long arithmetic:</p> <pre><code>int C(int n, int k) {\n    int res = 1;\n    for (int i = n - k + 1; i &lt;= n; ++i)\n        res *= i;\n    for (int i = 2; i &lt;= k; ++i)\n        res /= i;\n    return res;\n}\n</code></pre>","tags":["Translated"]},{"location":"combinatorics/binomial-coefficients.html#improved-implementation","title":"Improved implementation","text":"<p>Note that in the above implementation numerator and denominator have the same number of factors ($k$), each of which is greater than or equal to 1. Therefore, we can replace our fraction with a product $k$ fractions, each of which is real-valued. However, on each step after multiplying current answer by each of the next fractions the answer will still be integer (this follows from the property of factoring in). </p> <p>C++ implementation:</p> <pre><code>int C(int n, int k) {\n    double res = 1;\n    for (int i = 1; i &lt;= k; ++i)\n        res = res * (n - k + i) / i;\n    return (int)(res + 0.01);\n}\n</code></pre> <p>Here we carefully cast the floating point number to an integer, taking into account that due to the accumulated errors, it may be slightly less than the true value (for example, $2.99999$ instead of $3$).</p>","tags":["Translated"]},{"location":"combinatorics/binomial-coefficients.html#pascals-triangle","title":"Pascal's Triangle","text":"<p>By using the recurrence relation we can construct a table of binomial coefficients (Pascal's triangle) and take the result from it. The advantage of this method is that intermediate results never exceed the answer and calculating each new table element requires only one addition. The flaw is slow execution for large $n$ and $k$ if you just need a single value and not the whole table (because in order to calculate $\\binom n k$ you will need to build a table of all $\\binom i j, 1 \\le i \\le n, 1 \\le j \\le n$, or at least to $1 \\le j \\le \\min (i, 2k)$). The time complexity can be considered to be $\\mathcal{O}(n^2)$.</p> <p>C++ implementation:</p> <pre><code>const int maxn = ...;\nint C[maxn + 1][maxn + 1];\nC[0][0] = 1;\nfor (int n = 1; n &lt;= maxn; ++n) {\n    C[n][0] = C[n][n] = 1;\n    for (int k = 1; k &lt; n; ++k)\n        C[n][k] = C[n - 1][k - 1] + C[n - 1][k];\n}\n</code></pre> <p>If the entire table of values is not necessary, storing only two last rows of it is sufficient (current $n$-th row and the previous $n-1$-th).</p>","tags":["Translated"]},{"location":"combinatorics/binomial-coefficients.html#calculation-in-o1","title":"Calculation in $O(1)$","text":"<p>Finally, in some situations it is beneficial to precompute all the factorials in order to produce any necessary binomial coefficient with only two divisions later. This can be advantageous when using long arithmetic, when the memory does not allow precomputation of the whole Pascal's triangle.</p>","tags":["Translated"]},{"location":"combinatorics/binomial-coefficients.html#computing-binomial-coefficients-modulo-m","title":"Computing binomial coefficients modulo $m$","text":"<p>Quite often you come across the problem of computing binomial coefficients modulo some $m$.</p>","tags":["Translated"]},{"location":"combinatorics/binomial-coefficients.html#binomial-coefficient-for-small-n","title":"Binomial coefficient for small $n$","text":"<p>The previously discussed approach of Pascal's triangle can be used to calculate all values of $\\binom{n}{k} \\bmod m$ for reasonably small $n$, since it requires time complexity $\\mathcal{O}(n^2)$. This approach can handle any modulo, since only addition operations are used.</p>","tags":["Translated"]},{"location":"combinatorics/binomial-coefficients.html#binomial-coefficient-modulo-large-prime","title":"Binomial coefficient modulo large prime","text":"<p>The formula for the binomial coefficients is</p> $$\\binom n k = \\frac {n!} {k!(n-k)!},$$ <p>so if we want to compute it modulo some prime $m &gt; n$ we get</p> $$\\binom n k \\equiv n! \\cdot (k!)^{-1} \\cdot ((n-k)!)^{-1} \\mod m.$$ <p>First we precompute all factorials modulo $m$ up to $\\text{MAXN}!$ in $O(\\text{MAXN})$ time.</p> <pre><code>factorial[0] = 1;\nfor (int i = 1; i &lt;= MAXN; i++) {\n    factorial[i] = factorial[i - 1] * i % m;\n}\n</code></pre> <p>And afterwards we can compute the binomial coefficient in $O(\\log m)$ time.</p> <pre><code>long long binomial_coefficient(int n, int k) {\n    return factorial[n] * inverse(factorial[k] * factorial[n - k] % m) % m;\n}\n</code></pre> <p>We even can compute the binomial coefficient in $O(1)$ time if we precompute the inverses of all factorials in $O(\\text{MAXN} \\log m)$ using the regular method for computing the inverse, or even in $O(\\text{MAXN})$ time using the congruence $(x!)^{-1} \\equiv ((x-1)!)^{-1} \\cdot x^{-1}$ and the method for computing all inverses in $O(n)$.</p> <pre><code>long long binomial_coefficient(int n, int k) {\n    return factorial[n] * inverse_factorial[k] % m * inverse_factorial[n - k] % m;\n}\n</code></pre>","tags":["Translated"]},{"location":"combinatorics/binomial-coefficients.html#mod-prime-pow","title":"Binomial coefficient modulo prime power","text":"<p>Here we want to compute the binomial coefficient modulo some prime power, i.e. $m = p^b$ for some prime $p$. If $p &gt; \\max(k, n-k)$, then we can use the same method as described in the previous section. But if $p \\le \\max(k, n-k)$, then at least one of $k!$ and $(n-k)!$ are not coprime with $m$, and therefore we cannot compute the inverses - they don't exist. Nevertheless we can compute the binomial coefficient.</p> <p>The idea is the following: We compute for each $x!$ the biggest exponent $c$ such that $p^c$ divides $x!$, i.e. $p^c ~|~ x!$. Let $c(x)$ be that number. And let $g(x) := \\frac{x!}{p^{c(x)}}$. Then we can write the binomial coefficient as:</p> $$\\binom n k = \\frac {g(n) p^{c(n)}} {g(k) p^{c(k)} g(n-k) p^{c(n-k)}} = \\frac {g(n)} {g(k) g(n-k)}p^{c(n) - c(k) - c(n-k)}$$ <p>The interesting thing is, that $g(x)$ is now free from the prime divisor $p$. Therefore $g(x)$ is coprime to m, and we can compute the modular inverses of $g(k)$ and $g(n-k)$.</p> <p>After precomputing all values for $g$ and $c$, which can be done efficiently using dynamic programming in $\\mathcal{O}(n)$, we can compute the binomial coefficient in $O(\\log m)$ time. Or precompute all inverses and all powers of $p$, and then compute the binomial coefficient in $O(1)$.</p> <p>Notice, if $c(n) - c(k) - c(n-k) \\ge b$, than $p^b ~|~ p^{c(n) - c(k) - c(n-k)}$, and the binomial coefficient is $0$.</p>","tags":["Translated"]},{"location":"combinatorics/binomial-coefficients.html#binomial-coefficient-modulo-an-arbitrary-number","title":"Binomial coefficient modulo an arbitrary number","text":"<p>Now we compute the binomial coefficient modulo some arbitrary modulus $m$.</p> <p>Let the prime factorization of $m$ be $m = p_1^{e_1} p_2^{e_2} \\cdots p_h^{e_h}$. We can compute the binomial coefficient modulo $p_i^{e_i}$ for every $i$. This gives us $h$ different congruences. Since all moduli $p_i^{e_i}$ are coprime, we can apply the Chinese Remainder Theorem to compute the binomial coefficient modulo the product of the moduli, which is the desired binomial coefficient modulo $m$.</p>","tags":["Translated"]},{"location":"combinatorics/binomial-coefficients.html#binomial-coefficient-for-large-n-and-small-modulo","title":"Binomial coefficient for large $n$ and small modulo","text":"<p>When $n$ is too large, the $\\mathcal{O}(n)$ algorithms discussed above become impractical. However, if the modulo $m$ is small there are still ways to calculate $\\binom{n}{k} \\bmod m$.</p> <p>When the modulo $m$ is prime, there are 2 options:</p> <ul> <li>Lucas's theorem can be applied which breaks the problem of computing $\\binom{n}{k} \\bmod m$ into $\\log_m n$ problems of the form $\\binom{x_i}{y_i} \\bmod m$ where $x_i, y_i &lt; m$.  If each reduced coefficient is calculated using precomputed factorials and inverse factorials, the complexity is $\\mathcal{O}(m + \\log_m n)$.</li> <li>The method of computing factorial modulo P can be used to get the required $g$ and $c$ values and use them as described in the section of modulo prime power. This takes $\\mathcal{O}(m \\log_m n)$.</li> </ul> <p>When $m$ is not prime but square-free, the prime factors of $m$ can be obtained and the coefficient modulo each prime factor can be calculated using either of the above methods, and the overall answer can be obtained by the Chinese Remainder Theorem.</p> <p>When $m$ is not square-free, a generalization of Lucas's theorem for prime powers can be applied instead of Lucas's theorem.</p>","tags":["Translated"]},{"location":"combinatorics/binomial-coefficients.html#practice-problems","title":"Practice Problems","text":"<ul> <li>Codechef - Number of ways</li> <li>Codeforces - Curious Array</li> <li>LightOj - Necklaces</li> <li>HACKEREARTH: Binomial Coefficient</li> <li>SPOJ - Ada and Teams</li> <li>SPOJ - Greedy Walking</li> <li>UVa 13214 - The Robot's Grid</li> <li>SPOJ - Good Predictions</li> <li>SPOJ - Card Game</li> <li>SPOJ - Topper Rama Rao</li> <li>UVa 13184 - Counting Edges and Graphs</li> <li>Codeforces - Anton and School 2</li> <li>Codeforces - Bacterial Melee</li> <li>Codeforces - Points, Lines and Ready-made Titles</li> <li>SPOJ - The Ultimate Riddle</li> <li>CodeChef - Long Sandwich</li> <li>Codeforces - Placing Jinas</li> </ul>","tags":["Translated"]},{"location":"combinatorics/binomial-coefficients.html#references","title":"References","text":"<ul> <li>Blog fishi.devtail.io</li> <li>Question on Mathematics StackExchange</li> <li>Question on CodeChef Discuss</li> </ul>","tags":["Translated"]},{"location":"combinatorics/bishops-on-chessboard.html","title":"Placing Bishops on a Chessboard","text":"<p>Find the number of ways to place $K$ bishops on an $N \\times N$ chessboard so that no two bishops attack each other.</p>","tags":["Translated"]},{"location":"combinatorics/bishops-on-chessboard.html#algorithm","title":"Algorithm","text":"<p>This problem can be solved using dynamic programming.</p> <p>Let's enumerate the diagonals of the chessboard as follows: black diagonals have odd indices, white diagonals have even indices, and the diagonals are numbered in non-decreasing order of the number of squares in them. Here is an example for a $5 \\times 5$ chessboard.</p> $$\\begin{matrix} \\bf{1} &amp; 2 &amp; \\bf{5} &amp; 6 &amp; \\bf{9} \\\\\\ 2 &amp; \\bf{5} &amp; 6 &amp; \\bf{9} &amp; 8 \\\\\\ \\bf{5} &amp; 6 &amp; \\bf{9} &amp; 8 &amp; \\bf{7} \\\\\\ 6 &amp; \\bf{9} &amp; 8 &amp; \\bf{7} &amp; 4 \\\\\\ \\bf{9} &amp; 8 &amp; \\bf{7} &amp; 4 &amp; \\bf{3} \\\\\\ \\end{matrix}$$ <p>Let <code>D[i][j]</code> denote the number of ways to place <code>j</code> bishops on diagonals with indices up to <code>i</code> which have the same color as diagonal <code>i</code>. Then <code>i = 1...2N-1</code> and <code>j = 0...K</code>.</p> <p>We can calculate <code>D[i][j]</code> using only values of <code>D[i-2]</code> (we subtract 2 because we only consider diagonals of the same color as $i$). There are two ways to get <code>D[i][j]</code>. Either we place all <code>j</code> bishops on previous diagonals: then there are <code>D[i-2][j]</code> ways to achieve this. Or we place one bishop on diagonal <code>i</code> and <code>j-1</code> bishops on previous diagonals. The number of ways to do this equals the number of squares in diagonal <code>i</code> minus <code>j-1</code>, because each of <code>j-1</code> bishops placed on previous diagonals will block one square on the current diagonal. The number of squares in diagonal <code>i</code> can be calculated as follows:</p> <pre><code>int squares (int i) {\n    if (i &amp; 1)\n        return i / 4 * 2 + 1;\n    else\n        return (i - 1) / 4 * 2 + 2;\n}\n</code></pre> <p>The base case is simple: <code>D[i][0] = 1</code>, <code>D[1][1] = 1</code>.</p> <p>Once we have calculated all values of <code>D[i][j]</code>, the answer can be obtained as follows: consider all possible numbers of bishops placed on black diagonals <code>i=0...K</code>, with corresponding numbers of bishops on white diagonals <code>K-i</code>. The bishops placed on black and white diagonals never attack each other, so the placements can be done independently. The index of the last black diagonal is <code>2N-1</code>, the last white one is <code>2N-2</code>. For each <code>i</code> we add <code>D[2N-1][i] * D[2N-2][K-i]</code> to the answer.</p>","tags":["Translated"]},{"location":"combinatorics/bishops-on-chessboard.html#implementation","title":"Implementation","text":"<pre><code>int bishop_placements(int N, int K)\n{\n    if (K &gt; 2 * N - 1)\n        return 0;\n\n    vector&lt;vector&lt;int&gt;&gt; D(N * 2, vector&lt;int&gt;(K + 1));\n    for (int i = 0; i &lt; N * 2; ++i)\n        D[i][0] = 1;\n    D[1][1] = 1;\n    for (int i = 2; i &lt; N * 2; ++i)\n        for (int j = 1; j &lt;= K; ++j)\n            D[i][j] = D[i-2][j] + D[i-2][j-1] * (squares(i) - j + 1);\n\n    int ans = 0;\n    for (int i = 0; i &lt;= K; ++i)\n        ans += D[N*2-1][i] * D[N*2-2][K-i];\n    return ans;\n}\n</code></pre>","tags":["Translated"]},{"location":"combinatorics/bracket_sequences.html","title":"Balanced bracket sequences","text":"<p>A balanced bracket sequence is a string consisting of only brackets, such that this sequence, when inserted certain numbers and mathematical operations, gives a valid mathematical expression. Formally you can define balanced bracket sequence with:</p> <ul> <li>$e$ (the empty string) is a balanced bracket sequence.</li> <li>if $s$ is a balanced bracket sequence, then so is $(s)$.</li> <li>if $s$ and $t$ are balanced bracket sequences, then so is $s t$.</li> </ul> <p>For instance $(())()$ is a balanced bracket sequence, but $())($ is not.</p> <p>Of course you can define other bracket sequences also with multiple bracket types in a similar fashion.</p> <p>In this article we discuss some classic problems involving balanced bracket sequences (for simplicity we will only call them sequences): validation, number of sequences, finding the lexicographical next sequence, generating all sequences of a certain size, finding the index of sequence, and generating the $k$-th sequences. We will also discuss two variations for the problems, the simpler version when only one type of brackets is allowed, and the harder case when there are multiple types.</p>","tags":["Translated"]},{"location":"combinatorics/bracket_sequences.html#balance-validation","title":"Balance validation","text":"<p>We want to check if a given string is balanced or not.</p> <p>At first suppose there is only one type of bracket. For this case there exists a very simple algorithm. Let $\\text{depth}$ be the current number of open brackets. Initially $\\text{depth} = 0$. We iterate over all character of the string, if the current bracket character is an opening bracket, then we increment $\\text{depth}$, otherwise we decrement it. If at any time the variable $\\text{depth}$ gets negative, or at the end it is different from $0$, then the string is not a balanced sequence. Otherwise it is.</p> <p>If there are several bracket types involved, then the algorithm needs to be changed. Instead of a counter $\\text{depth}$ we create a stack, in which we will store all opening brackets that we meet. If the current bracket character is an opening one, we put it onto the stack. If it is a closing one, then we check if the stack is non-empty, and if the top element of the stack is of the same type as the current closing bracket. If both conditions are fulfilled, then we remove the opening bracket from the stack. If at any time one of the conditions is not fulfilled, or at the end the stack is not empty, then the string is not balanced. Otherwise it is.</p>","tags":["Translated"]},{"location":"combinatorics/bracket_sequences.html#number-of-balanced-sequences","title":"Number of balanced sequences","text":"","tags":["Translated"]},{"location":"combinatorics/bracket_sequences.html#formula","title":"Formula","text":"<p>The number of balanced bracket sequences with only one bracket type can be calculated using the Catalan numbers. The number of balanced bracket sequences of length $2n$ ($n$ pairs of brackets) is:</p> $$\\frac{1}{n+1} \\binom{2n}{n}$$ <p>If we allow $k$ types of brackets, then each pair can be of any of the $k$ types (independently of the others), thus the number of balanced bracket sequences is:</p> $$\\frac{1}{n+1} \\binom{2n}{n} k^n$$","tags":["Translated"]},{"location":"combinatorics/bracket_sequences.html#dynamic-programming","title":"Dynamic programming","text":"<p>On the other hand these numbers can be computed using dynamic programming. Let $d[n]$ be the number of regular bracket sequences with $n$ pairs of bracket. Note that in the first position there is always an opening bracket. And somewhere later is the corresponding closing bracket of the pair. It is clear that inside this pair there is a balanced bracket sequence, and similarly after this pair there is a balanced bracket sequence. So to compute $d[n]$, we will look at how many balanced sequences of $i$ pairs of brackets are inside this first bracket pair, and how many balanced sequences with $n-1-i$ pairs are after this pair. Consequently the formula has the form:</p> $$d[n] = \\sum_{i=0}^{n-1} d[i] \\cdot d[n-1-i]$$ <p>The initial value for this recurrence is $d[0] = 1$.</p>","tags":["Translated"]},{"location":"combinatorics/bracket_sequences.html#finding-the-lexicographical-next-balanced-sequence","title":"Finding the lexicographical next balanced sequence","text":"<p>Here we only consider the case with one valid bracket type.</p> <p>Given a balanced sequence, we have to find the next (in lexicographical order) balanced sequence.</p> <p>It should be obvious, that we have to find the rightmost opening bracket, which we can replace by a closing bracket without violation the condition, that there are more closing brackets than opening brackets up to this position. After replacing this position, we can fill the remaining part of the string with the lexicographically minimal one: i.e. first with as much opening brackets as possible, and then fill up the remaining positions with closing brackets. In other words we try to leave a long as possible prefix unchanged, and the suffix gets replaced by the lexicographically minimal one.</p> <p>To find this position, we can iterate over the character from right to left, and maintain the balance $\\text{depth}$ of open and closing brackets. When we meet an opening brackets, we will decrement $\\text{depth}$, and when we meet a closing bracket, we increase it. If we are at some point meet an opening bracket, and the balance after processing this symbol is positive, then we have found the rightmost position that we can change. We change the symbol, compute the number of opening and closing brackets that we have to add to the right side, and arrange them in the lexicographically minimal way.</p> <p>If we don't find a suitable position, then this sequence is already the maximal possible one, and there is no answer.</p> <pre><code>bool next_balanced_sequence(string &amp; s) {\n    int n = s.size();\n    int depth = 0;\n    for (int i = n - 1; i &gt;= 0; i--) {\n        if (s[i] == '(')\n            depth--;\n        else\n            depth++;\n\n        if (s[i] == '(' &amp;&amp; depth &gt; 0) {\n            depth--;\n            int open = (n - i - 1 - depth) / 2;\n            int close = n - i - 1 - open;\n            string next = s.substr(0, i) + ')' + string(open, '(') + string(close, ')');\n            s.swap(next);\n            return true;\n        }\n    }\n    return false;\n}\n</code></pre> <p>This function computes in $O(n)$ time the next balanced bracket sequence, and returns false if there is no next one.</p>","tags":["Translated"]},{"location":"combinatorics/bracket_sequences.html#finding-all-balanced-sequences","title":"Finding all balanced sequences","text":"<p>Sometimes it is required to find and output all balanced bracket sequences of a specific length $n$.</p> <p>To generate then, we can start with the lexicographically smallest sequence $((\\dots(())\\dots))$, and then continue to find the next lexicographically sequences with the algorithm described in the previous section.</p> <p>However, if the length of the sequence is not very long (e.g. $n$ smaller than $12$), then we can also generate all permutations conveniently with the C++ STL function <code>next_permutation</code>, and check each one for balanceness.</p> <p>Also they can be generated using the ideas we used for counting all sequences with dynamic programming. We will discuss the ideas in the next two sections.</p>","tags":["Translated"]},{"location":"combinatorics/bracket_sequences.html#sequence-index","title":"Sequence index","text":"<p>Given a balanced bracket sequence with $n$ pairs of brackets. We have to find its index in the lexicographically ordered list of all balanced sequences with $n$ bracket pairs.</p> <p>Let's define an auxiliary array $d[i][j]$, where $i$ is the length of the bracket sequence (semi-balanced, each closing bracket has a corresponding opening bracket, but not every opening bracket has necessarily a corresponding closing one), and $j$ is the current balance (difference between opening and closing brackets). $d[i][j]$ is the number of such sequences that fit the parameters. We will calculate these numbers with only one bracket type.</p> <p>For the start value $i = 0$ the answer is obvious: $d[0][0] = 1$, and $d[0][j] = 0$ for $j &gt; 0$. Now let $i &gt; 0$, and we look at the last character in the sequence. If the last character was an opening bracket $($, then the state before was $(i-1, j-1)$, if it was a closing bracket $)$, then the previous state was $(i-1, j+1)$. Thus we obtain the recursion formula:</p> $$d[i][j] = d[i-1][j-1] + d[i-1][j+1]$$ <p>$d[i][j] = 0$ holds obviously for negative $j$. Thus we can compute this array in $O(n^2)$.</p> <p>Now let us generate the index for a given sequence.</p> <p>First let there be only one type of brackets. We will use the counter $\\text{depth}$ which tells us how nested we currently are, and iterate over the characters of the sequence. If the current character $s[i]$ is equal to $($, then we increment $\\text{depth}$. If the current character $s[i]$ is equal to $)$, then we must add $d[2n-i-1][\\text{depth}+1]$ to the answer, taking all possible endings starting with a $($ into account (which are lexicographically smaller sequences), and then decrement $\\text{depth}$.</p> <p>New let there be $k$ different bracket types.</p> <p>Thus, when we look at the current character $s[i]$ before recomputing $\\text{depth}$, we have to go through all bracket types that are smaller than the current character, and try to place this bracket into the current position (obtaining a new balance $\\text{ndepth} = \\text{depth} \\pm 1$), and add the number of ways to finish the sequence (length $2n-i-1$, balance $ndepth$) to the answer:</p> $$d[2n - i - 1][\\text{ndepth}] \\cdot k^{\\frac{2n - i - 1 - ndepth}{2}}$$ <p>This formula can be derived as follows: First we \"forget\" that there are multiple bracket types, and just take the answer $d[2n - i - 1][\\text{ndepth}]$. Now we consider how the answer will change if we have $k$ types of brackets. We have $2n - i - 1$ undefined positions, of which $\\text{ndepth}$ are already predetermined because of the opening brackets. But all the other brackets ($(2n - i - 1 - \\text{ndepth})/2$ pairs) can be of any type, therefore we multiply the number by such a power of $k$.</p>","tags":["Translated"]},{"location":"combinatorics/bracket_sequences.html#finding-the-k-th-sequence","title":"Finding the $k$-th sequence","text":"<p>Let $n$ be the number of bracket pairs in the sequence. We have to find the $k$-th balanced sequence in lexicographically sorted list of all balanced sequences for a given $k$.</p> <p>As in the previous section we compute the auxiliary array $d[i][j]$, the number of semi-balanced bracket sequences of length $i$ with balance $j$.</p> <p>First, we start with only one bracket type.</p> <p>We will iterate over the characters in the string we want to generate. As in the previous problem we store a counter $\\text{depth}$, the current nesting depth. At each position, we have to decide whether to place an opening or a closing bracket. To place an opening bracket, $d[2n - i - 1][\\text{depth}+1] \\ge k$ must be true. If so, we increment the counter $\\text{depth}$, and move on to the next character. Otherwise, we decrement $k$ by $d[2n - i - 1][\\text{depth}+1]$, place a closing bracket, and move on.</p> <pre><code>string kth_balanced(int n, int k) {\n    vector&lt;vector&lt;int&gt;&gt; d(2*n+1, vector&lt;int&gt;(n+1, 0));\n    d[0][0] = 1;\n    for (int i = 1; i &lt;= 2*n; i++) {\n        d[i][0] = d[i-1][1];\n        for (int j = 1; j &lt; n; j++)\n            d[i][j] = d[i-1][j-1] + d[i-1][j+1];\n        d[i][n] = d[i-1][n-1];\n    }\n\n    string ans;\n    int depth = 0;\n    for (int i = 0; i &lt; 2*n; i++) {\n        if (depth + 1 &lt;= n &amp;&amp; d[2*n-i-1][depth+1] &gt;= k) {\n            ans += '(';\n            depth++;\n        } else {\n            ans += ')';\n            if (depth + 1 &lt;= n)\n                k -= d[2*n-i-1][depth+1];\n            depth--;\n        }\n    }\n    return ans;\n}\n</code></pre> <p>Now let there be $k$ types of brackets. The solution will only differ slightly in that we have to multiply the value $d[2n-i-1][\\text{ndepth}]$ by $k^{(2n-i-1-\\text{ndepth})/2}$ and take into account that there can be different bracket types for the next character.</p> <p>Here is an implementation using two types of brackets: round and square:</p> <pre><code>string kth_balanced2(int n, int k) {\n    vector&lt;vector&lt;int&gt;&gt; d(2*n+1, vector&lt;int&gt;(n+1, 0));\n    d[0][0] = 1;\n    for (int i = 1; i &lt;= 2*n; i++) {\n        d[i][0] = d[i-1][1];\n        for (int j = 1; j &lt; n; j++)\n            d[i][j] = d[i-1][j-1] + d[i-1][j+1];\n        d[i][n] = d[i-1][n-1];\n    }\n\n    string ans;\n    int shift, depth = 0;\n\n    stack&lt;char&gt; st;\n    for (int i = 0; i &lt; 2*n; i++) {\n\n        // '('\n        shift = ((2*n-i-1-depth-1) / 2);\n        if (shift &gt;= 0 &amp;&amp; depth + 1 &lt;= n) {\n            int cnt = d[2*n-i-1][depth+1] &lt;&lt; shift;\n            if (cnt &gt;= k) {\n                ans += '(';\n                st.push('(');\n                depth++;\n                continue;\n            }\n            k -= cnt;\n        }\n\n        // ')'\n        shift = ((2*n-i-1-depth+1) / 2);\n        if (shift &gt;= 0 &amp;&amp; depth &amp;&amp; st.top() == '(') {\n            int cnt = d[2*n-i-1][depth-1] &lt;&lt; shift;\n            if (cnt &gt;= k) {\n                ans += ')';\n                st.pop();\n                depth--;\n                continue;\n            }\n            k -= cnt;\n        }\n\n        // '['\n        shift = ((2*n-i-1-depth-1) / 2);\n        if (shift &gt;= 0 &amp;&amp; depth + 1 &lt;= n) {\n            int cnt = d[2*n-i-1][depth+1] &lt;&lt; shift;\n            if (cnt &gt;= k) {\n                ans += '[';\n                st.push('[');\n                depth++;\n                continue;\n            }\n            k -= cnt;\n        }\n\n        // ']'\n        ans += ']';\n        st.pop();\n        depth--;\n    }\n    return ans;\n}\n</code></pre>","tags":["Translated"]},{"location":"combinatorics/burnside.html","title":"Burnside's lemma / P\u00f3lya enumeration theorem","text":"","tags":["Translated"]},{"location":"combinatorics/burnside.html#burnsides-lemma","title":"Burnside's lemma","text":"<p>Burnside's lemma was formulated and proven by Burnside in 1897, but historically it was already discovered in 1887 by Frobenius, and even earlier in 1845 by Cauchy. Therefore it is also sometimes named the Cauchy-Frobenius lemma.</p> <p>Burnside's lemma allows us to count the number of equivalence classes in sets, based on internal symmetry.</p>","tags":["Translated"]},{"location":"combinatorics/burnside.html#objects-and-representations","title":"Objects and representations","text":"<p>We have to clearly distinguish between the number of objects and the number of representations.</p> <p>Different representations can correspond to the same objects, but of course any representation corresponds to exactly one object. Consequently the set of all representations is divided into equivalence classes. Our task is to compute the number of objects, or equivalently, the number of equivalence classes. The following example will make the difference between object and representation clearer.</p>","tags":["Translated"]},{"location":"combinatorics/burnside.html#example-coloring-of-binary-trees","title":"Example: coloring of binary trees","text":"<p>Suppose we have the following problem. We have to count the number of ways to color a rooted binary tree with $n$ vertices with two colors, where at each vertex we do not distinguish between the left and the right children.</p> <p>Here the set of objects is the set of different colorings of the tree.</p> <p>We now define the set of representations. A representation of a coloring is a function $f(v)$, which assigns each vertex a color (here we use the colors $0$ and $1$). The set of representations is the set containing all possible functions of this kind, and its size is obviously equal to $2^n$.</p> <p>At the same time we introduce a partition of this set into equivalence classes.</p> <p>For example, suppose $n = 3$, and the tree consists of the root $1$ and its two children $2$ and $3$. Then the following functions $f_1$ and $f_2$ are considered equivalent.</p> $$\\begin{array}{ll} f_1(1) = 0 &amp; f_2(1) = 0\\\\ f_1(2) = 1 &amp; f_2(2) = 0\\\\ f_1(3) = 0 &amp; f_2(3) = 1 \\end{array}$$","tags":["Translated"]},{"location":"combinatorics/burnside.html#invariant-permutations","title":"Invariant permutations","text":"<p>Why do these two function $f_1$ and $f_2$ belong to the same equivalence class? Intuitively this is understandable - we can rearrange the children of vertex $1$, the vertices $2$ and $3$, and after such a transformation of the function $f_1$ it will coincide with $f_2$.</p> <p>But formally this means that there exists an invariant permutation $\\pi$ (i.e. a permutation which does not change the object itself, but only its representation), such that:</p> $$f_2 \\pi \\equiv f_1$$ <p>So starting from the definition of objects, we can find all the invariant permutations, i.e. all permutations which do not change the object when applying the permutation to the representation. Then we can check whether two functions $f_1$ and $f_2$ are equivalent (i.e. if they correspond to the same object) by checking the condition $f_2 \\pi \\equiv f_1$ for each invariant permutation (or equivalently $f_1 \\pi \\equiv f_2$). If at least one permutation is found for which the condition is satisfied, then $f_1$ and $f_2$ are equivalent, otherwise they are not equivalent.</p> <p>Finding all such invariant permutations with respect to the object definition is a key step for the application of both Burnside's lemma and the P\u00f3lya enumeration theorem. It is clear that these invariant permutations depend on the specific problem, and their finding is a purely heuristic process based on intuitive considerations. However in most cases it is sufficient to manually find several \"basic\" permutations, with which all other permutations can be generated (and this part of the work can be shifted to a computer).</p> <p>It is not difficult to understand that invariant permutations form a group, since the product (composition) of invariant permutations is again an invariant permutation. We denote the group of invariant permutations by $G$.</p>","tags":["Translated"]},{"location":"combinatorics/burnside.html#the-statement-of-the-lemma","title":"The statement of the lemma","text":"<p>For the formulation of the lemma we need one more definition from algebra. A fixed point $f$ for a permutation $\\pi$ is an element that is invariant under this permutation: $f \\equiv f \\pi$. For example in our example the fixed points are those functions $f$, which correspond to colorings that do not change when the permutation $\\pi$ is applied to them (i.e. they do not change in the formal sense of the equality of functions). We denote by $I(\\pi)$ the number of fixed points for the permutation $\\pi$.</p> <p>Then Burnside's lemma goes as follows: the number of equivalence classes is equal to the sum of the numbers of fixed points with respect to all permutations from the group $G$, divided by the size of this group:</p> $$|\\text{Classes}| = \\frac{1}{|G|} \\sum_{\\pi \\in G} I(\\pi)$$ <p>Although Burnside's lemma itself is not so convenient to use in practice (it is unclear how to quickly look for the value $I(\\pi)$, it most clearly reveals the mathematical essence on which the idea of calculating equivalence classes is based.</p>","tags":["Translated"]},{"location":"combinatorics/burnside.html#proof-of-burnsides-lemma","title":"Proof of Burnside's lemma","text":"<p>The proof of Burnside's lemma described here is not important for the practical applications, so it can be skipped on the first reading.</p> <p>The proof here is the simplest known, and does not use group theory. The proof was published by Kenneth P. Bogart in 1991.</p> <p>We need to prove the following statement:</p> $$|\\text{Classes}| \\cdot |G| = \\sum_{\\pi \\in G} I(\\pi)$$ <p>The value on the right side is nothing more than the number of \"invariant pairs\" $(f, \\pi)$, i.e. pairs such that $f \\pi \\equiv f$. It is obvious that we can change the order of summation. We let the sum iterate over all elements $f$ and sum over the values $J(f)$ - the number of permutations for which $f$ is a fixed point.</p> $$|\\text{Classes}| \\cdot |G| = \\sum_{f} J(f)$$ <p>To prove this formula we will compose a table with columns labeled with all functions $f_i$ and rows labeled with all permutations $\\pi_j$. And we fill the cells with $f_i \\pi_j$. If we look at the columns in this table as sets, then some of them will coincide, and this means that the corresponding functions $f$ for these columns are also equivalent. Thus the numbers of different (as sets) columns is equal to the number of classes. Incidentally, from the standpoint of group theory, the column labeled with $f_i$ is the orbit of this element. For equivalent elements the orbits coincides, and the number of orbits gives exactly the number of classes.</p> <p>Thus the columns of the table decompose into equivalence classes. Let us fix a class, and look at the columns in it. First, note that these columns can only contain elements $f_i$ of the equivalence class (otherwise some permutation $\\pi_j$ moved one of the functions into a different equivalence class, which is impossible since we only look at invariant permutations). Secondly each element $f_i$ will occur the same number of times in each column (this also follows from the fact that the columns correspond to equivalent elements). From this we can conclude, that all the columns within the same equivalence class coincide with each other as multisets.</p> <p>Now fix an arbitrary element $f$. On the one hand, it occurs in its column exactly $J(f)$ times (by definition). On the other hand, all columns within the same equivalence class are the same as multisets. Therefore within each column of a given equivalence class any element $g$ occurs exactly $J(g)$ times.</p> <p>Thus if we arbitrarily take one column from each equivalence class, and sum the number of elements in them, we obtain on one hand $|\\text{Classes}| \\cdot |G|$ (simply by multiplying the number of columns by the number of rows), and on the other hand the sum of the quantities $J(f)$ for all $f$ (this follows from all the previous arguments):</p> $$|\\text{Classes}| \\cdot |G| = \\sum_{f} J(f)$$","tags":["Translated"]},{"location":"combinatorics/burnside.html#polya-enumeration-theorem","title":"P\u00f3lya enumeration theorem","text":"<p>The P\u00f3lya enumeration theorem is a generalization of Burnside's lemma, and it also provides a more convenient tool for finding the number of equivalence classes. It should be noted that this theorem was already discovered before P\u00f3lya by Redfield in 1927, but his publication went unnoticed by mathematicians. P\u00f3lya independently came to the same results in 1937, and his publication was more successful.</p> <p>Here we discuss only a special case of the P\u00f3lya enumeration theorem, which will turn out very useful in practice. The general formula of the theorem will not be discussed.</p> <p>We denote by $C(\\pi)$ the number of cycles in the permutation $\\pi$. Then the following formula (a special case of the P\u00f3lya enumeration theorem) holds:</p> $$|\\text{Classes}| = \\frac{1}{|G|} \\sum_{\\pi \\in G} k^{C(\\pi)}$$ <p>$k$ is the number of values that each representation element can take, in the case of the coloring of a binary tree this would be $k = 2$.</p>","tags":["Translated"]},{"location":"combinatorics/burnside.html#evidence","title":"Evidence","text":"<p>This formula is a direct consequence of Burnside's lemma. To get it, we just need to find an explicit expression for $I(\\pi)$, which appears in the lemma. Recall, that $I(\\pi)$ is the number of fixed points in the permutation $\\pi$.</p> <p>Thus we consider a permutation $\\pi$ and some element $f$. During the application of $\\pi$, the elements in $f$ move via the cycles in the permutation. Since the result should obtain $f \\equiv f \\pi$, the elements touched by one cycle must all be equal. At the same time different cycles are independent. Thus for each permutation cycle $\\pi$ we can choose one value (among $k$ possible) and thus we get the number of fixed points:</p> $$I(\\pi) = k^{C(\\pi)}$$","tags":["Translated"]},{"location":"combinatorics/burnside.html#application-coloring-necklaces","title":"Application: Coloring necklaces","text":"<p>The problem \"Necklace\" is one of the classical combinatorial problems. The task is to count the number of different necklaces from $n$ beads, each of which can be painted in one of the $k$ colors. When comparing two necklaces, they can be rotated, but not reversed (i.e. a cyclic shift is permitted).</p> <p>In this problem we can immediately find the group of invariant permutations:</p> $$\\begin{align} \\pi_0 &amp;= 1 2 3 \\dots n\\\\ \\pi_1 &amp;= 2 3 \\dots n 1\\\\ \\pi_2 &amp;= 3 \\dots n 12\\\\ &amp;\\dots\\\\ \\pi_{n-1} &amp;= n 1 2 3\\dots\\end{align}$$ <p>Let us find an explicit formula for calculating $C(\\pi_i)$. First we note, that the permutation $\\pi_i$ has at the $j$-th position the value $i + j$ (taken modulo $n$). If we check the cycle structure for $\\pi_i$. We see that $1$ goes to $1 + i$, $1 + i$ goes to $1 + 2i$, which goes to $1 + 3i$, etc., until we come to a number of the form $1 + k n$. Similar statements can be made for the remaining elements. Hence we see that all cycles have the same length, namely $\\frac{\\text{lcm}(i, n)}{i} = \\frac{n}{\\gcd(i, n)}$. Thus the number of cycles in $\\pi_i$ will be equal to $\\gcd(i, n)$.</p> <p>Substituting these values into the P\u00f3lya enumeration theorem, we obtain the solution:</p> $$\\frac{1}{n} \\sum_{i=1}^n k^{\\gcd(i, n)}$$ <p>You can leave this formula in this form, or you can simplify it even more. Let transfer the sum so that it iterates over all divisors of $n$. In the original sum there will be many equivalent terms: if $i$ is not a divisor of $n$, then such a divisor can be found after computing $\\gcd(i, n)$. Therefore for each divisor $d ~|~ n$ its term $k^{\\gcd(d, n)} = k^d$ will appear in the sum multiple times, i.e. the answer to the problem can be rewritten as</p> $$\\frac{1}{n} \\sum_{d ~|~ n} C_d k^d,$$ <p>where $C_d$ is the number of such numbers $i$ with $\\gcd(i, n) = d$. We can find an explicit expression for this value. Any such number $i$ has the form $i = d j$ with $\\gcd(j, n / d) = 1$ (otherwise $\\gcd(i, n) &gt; d$). So we can count the number of $j$ with this behavior. Euler's phi function gives us the result $C_d = \\phi(n / d)$, and therefore we get the answer:</p> $$\\frac{1}{n} \\sum_{d ~|~ n} \\phi\\left(\\frac{n}{d}\\right) k^d$$","tags":["Translated"]},{"location":"combinatorics/burnside.html#application-coloring-a-torus","title":"Application: Coloring a torus","text":"<p>Quite often we cannot obtain an explicit formula for the number of equivalence classes. In many problems the number of permutations in a group can be too large for manual calculations and it is not possible to compute analytically the number of cycles in them.</p> <p>In that case we should manually find several \"basic\" permutations, so that they can generate the entire group $G$. Next we can write a program that will generate all permutations of the group $G$, count the number of cycles in them, and compute the answer with the formula.</p> <p>Consider the example of the problem for coloring a torus. There is a checkered sheet of paper $n \\times m$ ($n &lt; m$), some of the cells are black. Then a cylinder is obtained from this sheet by gluing together the two sides with lengths $m$. Then a torus is obtained from the cylinder by gluing together the two circles (top and bottom) without twisting. The task is to compute the number of different colored tori, assuming that we cannot see the glued lines, and the torus can be turned and turned.</p> <p>We again start with a piece of $n \\times m$ paper. It is easy to see that the following types of transformations preserve the equivalence class: a cyclic shift of the rows, a cyclic shift of the columns, and a rotation of the sheet by 180 degrees. It is also easy to see, that these transformations can generate the entire group of invariant transformations. If we somehow number the cells of the paper, then we can write three permutations $p_1$, $p_2$, $p_3$ corresponding to these types of transformation.</p> <p>Next it only remains to generate all permutations obtained as a product. It is obvious that all such permutations have the form $p_1^{i_1} p_2^{i_2} p_3^{i_3}$ where $i_1 = 0 \\dots m-1$, $i_2 = 0 \\dots n-1$, $i_3 = 0 \\dots 1$.</p> <p>Thus we can write the implementations to this problem.</p> <pre><code>using Permutation = vector&lt;int&gt;;\n\nvoid operator*=(Permutation&amp; p, Permutation const&amp; q) {\n    Permutation copy = p;\n    for (int i = 0; i &lt; p.size(); i++)\n        p[i] = copy[q[i]];\n}\n\nint count_cycles(Permutation p) {\n    int cnt = 0;\n    for (int i = 0; i &lt; p.size(); i++) {\n        if (p[i] != -1) {\n            cnt++;\n            for (int j = i; p[j] != -1;) {\n                int next = p[j];\n                p[j] = -1;\n                j = next;\n            }\n        }\n    }\n    return cnt;\n}\n\nint solve(int n, int m) {\n    Permutation p(n*m), p1(n*m), p2(n*m), p3(n*m);\n    for (int i = 0; i &lt; n*m; i++) {\n        p[i] = i;\n        p1[i] = (i % n + 1) % n + i / n * n;\n        p2[i] = (i / n + 1) % m * n + i % n;\n        p3[i] = (m - 1 - i / n) * n + (n - 1 - i % n);\n    }\n\n    set&lt;Permutation&gt; s;\n    for (int i1 = 0; i1 &lt; n; i1++) {\n        for (int i2 = 0; i2 &lt; m; i2++) {\n            for (int i3 = 0; i3 &lt; 2; i3++) {\n                s.insert(p);\n                p *= p3;\n            }\n            p *= p2;\n        }\n        p *= p1;\n    }\n\n    int sum = 0;\n    for (Permutation const&amp; p : s) {\n        sum += 1 &lt;&lt; count_cycles(p);\n    }\n    return sum / s.size();\n}\n</code></pre>","tags":["Translated"]},{"location":"combinatorics/burnside.html#practice-problems","title":"Practice Problems","text":"<ul> <li>CSES - Counting Necklaces</li> <li>CSES - Counting Grids</li> <li>Codeforces - Buildings</li> <li>CS Academy - Cube Coloring</li> <li>Codeforces - Side Transmutations</li> <li>LightOJ - Necklace</li> <li>POJ - Necklace of Beads</li> <li>CodeChef - Lucy and Flowers</li> <li>HackerRank - Count the Necklaces</li> <li>POJ - Magic Bracelet</li> <li>SPOJ - Sorting Machine</li> <li>Project Euler - Pizza Toppings</li> <li>ICPC 2011 SERCP - Alphabet Soup</li> <li>GCPC 2017 - Buildings</li> </ul>","tags":["Translated"]},{"location":"combinatorics/catalan-numbers.html","title":"Catalan Numbers","text":"<p>Catalan numbers is a number sequence, which is found useful in a number of combinatorial problems, often involving recursively-defined objects.</p> <p>This sequence was named after the Belgian mathematician Catalan, who lived in the 19th century. (In fact it was known before to Euler, who lived a century before Catalan).</p> <p>The first few Catalan numbers $C_n$ (starting from zero):</p> <p>$1, 1, 2, 5, 14, 42, 132, 429, 1430, \\ldots$</p>","tags":["Translated"]},{"location":"combinatorics/catalan-numbers.html#application-in-some-combinatorial-problems","title":"Application in some combinatorial problems","text":"<p>The Catalan number $C_n$ is the solution for</p> <ul> <li>Number of correct bracket sequence consisting of $n$ opening and $n$ closing brackets.</li> <li>The number of rooted full binary trees with $n + 1$ leaves (vertices are not numbered). A rooted binary tree is full if every vertex has either two children or no children.</li> <li>The number of ways to completely parenthesize $n + 1$ factors.</li> <li>The number of triangulations of a convex polygon with $n + 2$ sides (i.e. the number of partitions of polygon into disjoint triangles by using the diagonals).</li> <li>The number of ways to connect the $2n$ points on a circle to form $n$ disjoint chords.</li> <li>The number of non-isomorphic full binary trees with $n$ internal nodes (i.e. nodes having at least one son).</li> <li>The number of monotonic lattice paths from point $(0, 0)$ to point $(n, n)$ in a square lattice of size $n \\times n$, which do not pass above the main diagonal (i.e. connecting $(0, 0)$ to $(n, n)$).</li> <li>Number of permutations of length $n$ that can be stack sorted (i.e. it can be shown that the rearrangement is stack sorted if and only if there is no such index $i &lt; j &lt; k$, such that $a_k &lt; a_i &lt; a_j$ ).</li> <li>The number of non-crossing partitions of a set of $n$ elements.</li> <li>The number of ways to cover the ladder $1 \\ldots n$ using $n$ rectangles (The ladder consists of $n$ columns, where $i^{th}$ column has a height $i$).</li> </ul>","tags":["Translated"]},{"location":"combinatorics/catalan-numbers.html#calculations","title":"Calculations","text":"<p>There are two formulas for the Catalan numbers: Recursive and Analytical. Since, we believe that all the mentioned above problems are equivalent (have the same solution), for the proof of the formulas below we will choose the task which it is easiest to do.</p>","tags":["Translated"]},{"location":"combinatorics/catalan-numbers.html#recursive-formula","title":"Recursive formula","text":"$$C_0 = C_1 = 1$$ $$C_n = \\sum_{k = 0}^{n-1} C_k C_{n-1-k} , {n} \\geq 2$$ <p>The recurrence formula can be easily deduced from the problem of the correct bracket sequence.</p> <p>The leftmost opening parenthesis $l$ corresponds to certain closing bracket $r$, which divides the sequence into 2 parts which in turn should be a correct sequence of brackets. Thus formula is also divided into 2 parts. If we denote $k = {r - l - 1}$, then for fixed $r$, there will be exactly $C_k C_{n-1-k}$ such bracket sequences. Summing this over all admissible $k's$, we get the recurrence relation on $C_n$.</p> <p>You can also think it in this manner. By definition, $C_n$ denotes number of correct bracket sequences. Now, the sequence may be divided into 2 parts of length $k$ and ${n - k}$, each of which should be a correct bracket sequence. Example :</p> <p>$( ) ( ( ) )$ can be divided into $( )$ and $( ( ) )$, but cannot be divided into $( ) ($ and $( ) )$. Again summing over all admissible $k's$, we get the recurrence relation on $C_n$.</p>","tags":["Translated"]},{"location":"combinatorics/catalan-numbers.html#c-implementation","title":"C++ implementation","text":"<pre><code>const int MOD = ....\nconst int MAX = ....\nint catalan[MAX];\nvoid init() {\n    catalan[0] = catalan[1] = 1;\n    for (int i=2; i&lt;=n; i++) {\n        catalan[i] = 0;\n        for (int j=0; j &lt; i; j++) {\n            catalan[i] += (catalan[j] * catalan[i-j-1]) % MOD;\n            if (catalan[i] &gt;= MOD) {\n                catalan[i] -= MOD;\n            }\n        }\n    }\n}\n</code></pre>","tags":["Translated"]},{"location":"combinatorics/catalan-numbers.html#analytical-formula","title":"Analytical formula","text":"$$C_n = \\frac{1}{n + 1} {\\binom{2n}{n}}$$ <p>(here $\\binom{n}{k}$ denotes the usual binomial coefficient, i.e. number of ways to select $k$ objects from set of $n$ objects).</p> <p>The above formula can be easily concluded from the problem of the monotonic paths in square grid. The total number of  monotonic paths in the lattice size of $n \\times n$ is given by $\\binom{2n}{n}$.</p> <p>Now we count the number of monotonic paths which cross the main diagonal. Consider such paths crossing the main diagonal and find the first edge in it which is above the diagonal. Reflect the path about the diagonal all the way, going after this edge. The result is always a monotonic path in the grid $(n - 1) \\times (n + 1)$. On the other hand, any monotonic path in the lattice $(n - 1) \\times (n + 1)$ must intersect the diagonal. Hence, we enumerated all monotonic paths crossing the main diagonal in the lattice $n \\times n$.</p> <p>The number of monotonic paths in the lattice $(n - 1) \\times (n + 1)$ are $\\binom{2n}{n-1}$ . Let us call such paths as \"bad\" paths. As a result, to obtain the number of monotonic paths which do not cross the main diagonal, we subtract the above \"bad\" paths, obtaining the formula:</p> $$C_n = \\binom{2n}{n} - \\binom{2n}{n-1} = \\frac{1}{n + 1} \\binom{2n}{n} , {n} \\geq 0$$","tags":["Translated"]},{"location":"combinatorics/catalan-numbers.html#reference","title":"Reference","text":"<ul> <li>Catalan Number by Tom Davis</li> </ul>","tags":["Translated"]},{"location":"combinatorics/catalan-numbers.html#practice-problems","title":"Practice Problems","text":"<ul> <li>Codechef - PANSTACK</li> <li>Spoj - Skyline</li> <li>UVA - Safe Salutations</li> <li>Codeforces - How many trees?</li> <li>SPOJ - FUNPROB</li> <li>LOJ - 1170 - Counting Perfect BST</li> <li>UVA - 12887 - The Soldier's Dilemma</li> </ul>","tags":["Translated"]},{"location":"combinatorics/counting_labeled_graphs.html","title":"Counting labeled graphs","text":"","tags":["Translated"]},{"location":"combinatorics/counting_labeled_graphs.html#labeled-graphs","title":"Labeled graphs","text":"<p>Let the number of vertices in a graph be $n$. We have to compute the number $G_n$ of labeled graphs with $n$ vertices (labeled means that the vertices are marked with the numbers from $1$ to $n$). The edges of the graphs are considered undirected, and loops and multiple edges are forbidden.</p> <p>We consider the set of all possible edges of the graph. For each edge $(i, j)$ we can assume that $i &lt; j$ (because the graph is undirected, and there are no loops). Therefore the set of all edges has the cardinality $\\binom{n}{2}$, i.e. $\\frac{n(n-1)}{2}$.</p> <p>Since any labeled graph is uniquely determined by its edges, the number of labeled graphs with $n$ vertices is equal to:</p> $$G_n = 2^{\\frac{n(n-1)}{2}}$$","tags":["Translated"]},{"location":"combinatorics/counting_labeled_graphs.html#connected-labeled-graphs","title":"Connected labeled graphs","text":"<p>Here, we additionally impose the restriction that the graph has to be connected.</p> <p>Let's denote the required number of connected graphs with $n$ vertices as $C_n$.</p> <p>We will first discuss how many disconnected graphs exists. Then the number of connected graphs will be $G_n$ minus the number of disconnected graphs. Even more, we will count the number of disconnected, rooted graphs.A rooted graph is a graph, where we emphasize one vertex by labeling it as root. Obviously we have $n$ possibilities to root a graph with $n$ labeled vertices, therefore we will need to divide the number of disconnected rooted graphs by $n$ at the end to get the number of disconnected graphs.</p> <p>The root vertex will appear in a connected component of size $1, \\dots n-1$. There are $k \\binom{n}{k} C_k G_{n-k}$ graphs such that the root vertex is in a connected component with $k$ vertices (there are $\\binom{n}{k}$ ways to choose $k$ vertices for the component, these are connected in one of $C_k$ ways, the root vertex can be any of the $k$ vertices, and the remainder $n-k$ vertices can be connected/disconnected in any way, which gives a factor of $G_{n-k}$). Therefore the number of disconnected graphs with $n$ vertices is:</p> $$\\frac{1}{n} \\sum_{k=1}^{n-1} k \\binom{n}{k} C_k G_{n-k}$$ <p>And finally the number of connected graphs is:</p> $$C_n = G_n - \\frac{1}{n} \\sum_{k=1}^{n-1} k \\binom{n}{k} C_k G_{n-k}$$","tags":["Translated"]},{"location":"combinatorics/counting_labeled_graphs.html#labeled-graphs-with-k-connected-components","title":"Labeled graphs with $k$ connected components","text":"<p>Based on the formula from the previous section, we will learn how to count the number of labeled graphs with $n$ vertices and $k$ connected components.</p> <p>This number can be computed using dynamic programming. We will compute $D[i][j]$ - the number of labeled graphs with $i$ vertices and $j$ components - for each $i \\le n$ and $j \\le k$.</p> <p>Let's discuss how to compute the next element $D[n][k]$ if we already know the previous values. We use a common approach, we take the last vertex (index $n$). This vertex belongs to some component. If the size of this component be $s$, then there are $\\binom{n-1}{s-1}$ ways to choose such a set of vertices, and $C_s$ ways to connect them.After removing this component from the graph we have $n-s$ remaining vertices with $k-1$ connected components. Therefore we obtain the following recurrence relation:</p> $$D[n][k] = \\sum_{s=1}^{n} \\binom{n-1}{s-1} C_s D[n-s][k-1]$$","tags":["Translated"]},{"location":"combinatorics/generating_combinations.html","title":"Generating all $K$-combinations","text":"<p>In this article we will discuss the problem of generating all $K$-combinations. Given the natural numbers $N$ and $K$, and considering a set of numbers from $1$ to $N$. The task is to derive all subsets of size $K$.</p>","tags":["Translated"]},{"location":"combinatorics/generating_combinations.html#generate-next-lexicographical-k-combination","title":"Generate next lexicographical $K$-combination","text":"<p>First we will generate them in lexicographical order. The algorithm for this is simple. The first combination will be ${1, 2, ..., K}$. Now let's see how to find the combination that immediately follows this, lexicographically. To do so, we consider our current combination, and find the rightmost element that has not yet reached its highest possible value. Once finding this element, we increment it by $1$, and assign the lowest valid value to all subsequent elements.</p> <pre><code>bool next_combination(vector&lt;int&gt;&amp; a, int n) {\n    int k = (int)a.size();\n    for (int i = k - 1; i &gt;= 0; i--) {\n        if (a[i] &lt; n - k + i + 1) {\n            a[i]++;\n            for (int j = i + 1; j &lt; k; j++)\n                a[j] = a[j - 1] + 1;\n            return true;\n        }\n    }\n    return false;\n}\n</code></pre>","tags":["Translated"]},{"location":"combinatorics/generating_combinations.html#generate-all-k-combinations-such-that-adjacent-combinations-differ-by-one-element","title":"Generate all $K$-combinations such that adjacent combinations differ by one element","text":"<p>This time we want to generate all $K$-combinations in such an order, that adjacent combinations differ exactly by one element.</p> <p>This can be solved using the Gray Code: If we assign a bitmask to each subset, then by generating and iterating over these bitmasks with Gray codes, we can obtain our answer.</p> <p>The task of generating $K$-combinations can also be solved using Gray Codes in a different way: Generate Gray Codes for the numbers from $0$ to $2^N - 1$ and leave only those codes containing $K$ $1$s. The surprising fact is that in the resulting sequence of $K$ set bits, any two neighboring masks (including the first and last mask - neighboring in a cyclic sense) - will differ exactly by two bits, which is our objective (remove a number, add a number).</p> <p>Let us prove this:</p> <p>For the proof, we recall the fact that the sequence $G(N)$ (representing the $N$<sup>th</sup> Gray Code) can  be obtained as follows:</p> $$G(N) = 0G(N-1) \\cup 1G(N-1)^\\text{R}$$ <p>That is, consider the Gray Code sequence for $N-1$, and prefix $0$ before every term. And consider the  reversed Gray Code sequence for $N-1$ and prefix a $1$ before every mask, and concatenate these two sequences.</p> <p>Now we may produce our proof.</p> <p>First, we prove that the first and last masks differ exactly in two bits. To do this, it is sufficient to note that the first mask of the sequence $G(N)$, will be of the form $N-K$ $0$s, followed by $K$ $1$s. As the first bit is set as $0$, after which $(N-K-1)$ $0$s follow, after which $K$ set bits follow and the last mask will be of the form $1$, then $(N-K)$ $0$s, then $K-1$ $1$s. Applying the principle of mathematical induction, and using the formula for $G(N)$, concludes the proof.</p> <p>Now our task is to show that any two adjacent codes also differ exactly in two bits, we can do this by considering our recursive equation for the generation of Gray Codes. Let us assume the content of the two halves formed by $G(N-1)$ is true. Now we need to prove that the new consecutive pair formed at the junction (by the concatenation of these two halves) is also valid, i.e. they differ by exactly two bits.</p> <p>This can be done, as we know the last mask of the first half and the first mask of the second half. The last mask of the first half would be $1$, then $(N-K-1)$ $0$s, then $K-1$ $1$s. And the first mask of the second half would be $0$, then $(N-K-2)$ $0$s would follow, and then $K$ $1$s. Thus, comparing the two masks, we find exactly two bits that differ.</p> <p>The following is a naive implementation working by generating all $2^{n}$ possible subsets, and finding subsets of size $K$.</p> <pre><code>int gray_code (int n) {\n    return n ^ (n &gt;&gt; 1);\n}\n\nint count_bits (int n) {\n    int res = 0;\n    for (; n; n &gt;&gt;= 1)\n        res += n &amp; 1;\n    return res;\n}\n\nvoid all_combinations (int n, int k) {\n    for (int i = 0; i &lt; (1 &lt;&lt; n); i++) {\n        int cur = gray_code (i);\n        if (count_bits(cur) == k) {\n            for (int j = 0; j &lt; n; j++) {\n                if (cur &amp; (1 &lt;&lt; j))\n                    cout &lt;&lt; j + 1;\n            }\n            cout &lt;&lt; \"\\n\";\n        }\n    }\n}\n</code></pre> <p>It's worth mentioning that a more efficient implementation exists that only resorts to building valid combinations and thus works in $O\\left(N \\cdot \\binom{N}{K}\\right)$ however it is recursive in nature and for smaller values of $N$ it probably has a larger constant than the previous solution.</p> <p>The implementation is derived from the formula:</p> $$G(N, K) = 0G(N-1, K) \\cup 1G(N-1, K-1)^\\text{R}$$ <p>This formula is obtained by modifying the general equation to determine the Gray code, and works by selecting the subsequence from appropriate elements.</p> <p>Its implementation is as follows:</p> <pre><code>vector&lt;int&gt; ans;\n\nvoid gen(int n, int k, int idx, bool rev) {\n    if (k &gt; n || k &lt; 0)\n        return;\n\n    if (!n) {\n        for (int i = 0; i &lt; idx; ++i) {\n            if (ans[i])\n                cout &lt;&lt; i + 1;\n        }\n        cout &lt;&lt; \"\\n\";\n        return;\n    }\n\n    ans[idx] = rev;\n    gen(n - 1, k - rev, idx + 1, false);\n    ans[idx] = !rev;\n    gen(n - 1, k - !rev, idx + 1, true);\n}\n\nvoid all_combinations(int n, int k) {\n    ans.resize(n);\n    gen(n, k, 0, false);\n}\n</code></pre>","tags":["Translated"]},{"location":"combinatorics/inclusion-exclusion.html","title":"The Inclusion-Exclusion Principle","text":"<p>The inclusion-exclusion principle is an important combinatorial way to compute the size of a set or the probability of complex events. It relates the sizes of individual sets with their union.</p>","tags":["Translated"]},{"location":"combinatorics/inclusion-exclusion.html#statement","title":"Statement","text":"","tags":["Translated"]},{"location":"combinatorics/inclusion-exclusion.html#the-verbal-formula","title":"The verbal formula","text":"<p>The inclusion-exclusion principle can be expressed as follows:</p> <p>To compute the size of a union of multiple sets, it is necessary to sum the sizes of these sets separately, and then subtract the sizes of all pairwise intersections of the sets, then add back the size of the intersections of triples of the sets, subtract the size of quadruples of the sets, and so on, up to the intersection of all sets.</p>","tags":["Translated"]},{"location":"combinatorics/inclusion-exclusion.html#the-formulation-in-terms-of-sets","title":"The formulation in terms of sets","text":"<p>The above definition can be expressed mathematically as follows:</p> $$\\left| \\bigcup_{i=1}^n A_i \\right| = \\sum_{i=1}^n|A_i| - \\sum_{1\\leq i&lt;j\\leq n} |A_i \\cap A_j| + \\sum _{1\\leq i&lt;j&lt;k\\leq n}|A_i \\cap A_j \\cap A_k| - \\cdots + (-1)^{n-1} | A_1 \\cap \\cdots \\cap A_n |$$ <p>And in a more compact way:</p> $$\\left|\\bigcup_{i=1}^n A_i \\right| = \\sum_{\\emptyset \\neq J\\subseteq \\{1,2,\\ldots ,n\\}} (-1)^{|J|-1}{\\Biggl |}\\bigcap_{j\\in J}A_{j}{\\Biggr |}$$","tags":["Translated"]},{"location":"combinatorics/inclusion-exclusion.html#the-formulation-using-venn-diagrams","title":"The formulation using Venn diagrams","text":"<p>Let the diagram show three sets $A$, $B$ and $C$:</p> <p></p> <p>Then the area of their union $A \\cup B \\cup C$ is equal to the sum of the areas $A$, $B$ and $C$ less double-covered areas $A \\cap B$, $A \\cap C$, $B \\cap C$, but with the addition of the area covered by three sets $A \\cap B \\cap C$:</p> $$S(A \\cup B \\cup C) = S(A) + S(B) + S(C) - S(A \\cap B) - S(A \\cap C) - S(B \\cap C) + S(A \\cap B \\cap C)$$ <p>It can also be generalized for an association of $n$ sets.</p>","tags":["Translated"]},{"location":"combinatorics/inclusion-exclusion.html#the-formulation-in-terms-of-probability-theory","title":"The formulation in terms of probability theory","text":"<p>If $A_i$ $(i = 1,2...n)$ are events and ${\\cal P}(A_i)$ the probability of an event from $A_i$ to occur, then the probability of their union (i.e. the probability that at least one of the events occur) is equal to:</p> $$\\begin{eqnarray} {\\cal P} \\left( \\bigcup_{i=1}^n A_i \\right) &amp;=&amp; \\sum_{i=1}^n{\\cal P}(A_i)\\ - \\sum_{1\\leq i&lt;j\\leq n} {\\cal P}(A_i \\cap A_j)\\  + \\\\ &amp;+&amp; \\sum _{1\\leq i&lt;j&lt;k\\leq n}{\\cal P}(A_i \\cap A_j \\cap A_k) - \\cdots + (-1)^{n-1} {\\cal P}( A_1 \\cap \\cdots \\cap A_n ) \\end{eqnarray}$$ <p>And in a more compact way:</p> $${\\cal P} \\left(\\bigcup_{i=1}^n A_i \\right) = \\sum_{\\emptyset \\neq J\\subseteq \\{1,2,\\ldots ,n\\}} (-1)^{|J|-1}\\ {\\cal P}{\\Biggl (}\\bigcap_{j\\in J}A_{j}{\\Biggr )}$$","tags":["Translated"]},{"location":"combinatorics/inclusion-exclusion.html#proof","title":"Proof","text":"<p>For the proof it is convenient to use the mathematical formulation in terms of set theory:</p> $$\\left|\\bigcup_{i=1}^n A_i \\right| = \\sum_{\\emptyset \\neq J\\subseteq \\{1,2,\\ldots ,n\\}} (-1)^{|J|-1}{\\Biggl |}\\bigcap_{j\\in J}A_{j}{\\Biggr |}$$ <p>We want to prove that any element contained in at least one of the sets $A_i$ will occur in the formula only once (note that elements which are not present in any of the sets $A_i$ will never be considered on the right part of the formula).</p> <p>Consider an element $x$ occurring in $k \\geq 1$ sets $A_i$. We will show it is counted only once in the formula. Note that:</p> <ul> <li>in terms which $|J| = 1$, the item $x$ will be counted $+\\ k$ times;</li> <li>in terms which $|J| = 2$, the item $x$ will be counted $-\\ \\binom{k}{2}$ times - because it will be counted in those terms that include two of the $k$ sets containing $x$;</li> <li>in terms which $|J| = 3$, the item $x$ will be counted $+\\ \\binom{k}{3}$ times;</li> <li>$\\cdots$</li> <li>in terms which $|J| = k$, the item $x$ will be counted $(-1)^{k-1}\\cdot \\binom{k}{k}$ times;</li> <li>in terms which $|J| \\gt k$, the item $x$ will be counted zero times;</li> </ul> <p>This leads us to the following sum of binomial coefficients:</p> $$ T = \\binom{k}{1} - \\binom{k}{2} + \\binom{k}{3} - \\cdots + (-1)^{i-1}\\cdot \\binom{k}{i} + \\cdots + (-1)^{k-1}\\cdot \\binom{k}{k}$$ <p>This expression is very similar to the binomial expansion of $(1 - x)^k$:</p> $$ (1 - x)^k = \\binom{k}{0} - \\binom{k}{1} \\cdot x + \\binom{k}{2} \\cdot x^2 - \\binom{k}{3} \\cdot x^3 + \\cdots + (-1)^k\\cdot \\binom{k}{k} \\cdot x^k $$ <p>When $x = 1$, $(1 - x)^k$ looks a lot like $T$. However, the expression has an additional $\\binom{k}{0} = 1$, and it is multiplied by $-1$. That leads us to $(1 - 1)^k = 1 - T$. Therefore $T = 1 - (1 - 1)^k = 1$, what was required to prove. The element is counted only once.</p>","tags":["Translated"]},{"location":"combinatorics/inclusion-exclusion.html#generalization-for-calculating-number-of-elements-in-exactly-r-sets","title":"Generalization for calculating number of elements in exactly $r$ sets","text":"<p>Inclusion-exclusion principle can be rewritten to calculate number of elements which are present in zero sets:</p> $$\\left|\\bigcap_{i=1}^n \\overline{A_i}\\right|=\\sum_{m=0}^n (-1)^m \\sum_{|X|=m} \\left|\\bigcap_{i\\in X} A_{i}\\right|$$ <p>Consider its generalization to calculate number of elements which are present in exactly $r$ sets:</p> $$\\left|\\bigcup_{|B|=r}\\left[\\bigcap_{i \\in B} A_i \\cap \\bigcap_{j \\not\\in B} \\overline{A_j}\\right]\\right|=\\sum_{m=r}^n (-1)^{m-r}\\dbinom{m}{r} \\sum_{|X|=m} \\left|\\bigcap_{i \\in X} A_{i}\\right|$$ <p>To prove this formula, consider some particular $B$. Due to basic inclusion-exclusion principle we can say about it that:</p> $$\\left|\\bigcap_{i \\in B} A_i \\cap \\bigcap_{j \\not \\in B} \\overline{A_j}\\right|=\\sum_{m=r}^{n} (-1)^{m-r} \\sum_{\\substack{|X|=m \\newline B \\subset X}}\\left|\\bigcap_{i\\in X} A_{i}\\right|$$ <p>The sets on the left side do not intersect for different $B$, thus we can sum them up directly. Also one should note that any set $X$ will always have coefficient $(-1)^{m-r}$ if it occurs and it will occur for exactly $\\dbinom{m}{r}$ sets $B$. </p>","tags":["Translated"]},{"location":"combinatorics/inclusion-exclusion.html#usage-when-solving-problems","title":"Usage when solving problems","text":"<p>The inclusion-exclusion principle is hard to understand without studying its applications.</p> <p>First, we will look at three simplest tasks \"at paper\", illustrating applications of the principle, and then consider more practical problems which are difficult to solve without inclusion-exclusion principle.</p> <p>Tasks asking to \"find the number of ways\" are worth of note, as they sometimes lead to polynomial solutions, not necessarily exponential.</p>","tags":["Translated"]},{"location":"combinatorics/inclusion-exclusion.html#a-simple-task-on-permutations","title":"A simple task on permutations","text":"<p>Task: count how many permutations of numbers from $0$ to $9$ exist such that the first element is greater than $1$ and the last one is less than $8$.</p> <p>Let's count the number of \"bad\" permutations, that is, permutations in which the first element is $\\leq 1$ and/or the last is $\\geq 8$.</p> <p>We will denote by $X$ the set of permutations in which the first element is $\\leq 1$ and $Y$ the set of permutations in which the last element is $\\geq 8$. Then the number of \"bad\" permutations, as on the inclusion-exclusion formula, will be:</p> $$ |X \\cup Y| = |X| + |Y| - |X \\cap Y| $$ <p>After a simple combinatorial calculation, we will get to:</p> $$ 2 \\cdot 9! + 2 \\cdot 9! - 2 \\cdot 2 \\cdot 8! $$ <p>The only thing left is to subtract this number from the total of $10!$ to get the number of \"good\" permutations.</p>","tags":["Translated"]},{"location":"combinatorics/inclusion-exclusion.html#a-simple-task-on-0-1-2-sequences","title":"A simple task on (0, 1, 2) sequences","text":"<p>Task: count how many sequences of length $n$ exist consisting only of numbers $0,1,2$ such that each number occurs at least once.</p> <p>Again let us turn to the inverse problem, i.e. we calculate the number of sequences which do not contain at least one of the numbers.</p> <p>Let's denote by $A_i (i = 0,1,2)$ the set of sequences in which the digit $i$ does not occur. The formula of inclusion-exclusion on the number of \"bad\" sequences will be:</p> $$ |A_0 \\cup A_1 \\cup A_2| = |A_0| + |A_1| + |A_2| - |A_0 \\cap A_1| - |A_0 \\cap A_2| - |A_1 \\cap A_2| + |A_0 \\cap A_1 \\cap A_2| $$ <ul> <li>The size of each $A_i$ is $2^n$, as each sequence can only contain two of the digits.</li> <li>The size of each pairwise intersection $A_i \\cap A_j$  is equal to $1$, as there will be only one digit to build the sequence.</li> <li>The size of the intersection of all three sets is equal to $0$, as there will be no digits to build the sequence.</li> </ul> <p>As we solved the inverse problem, we subtract it from the total of $3^n$ sequences:</p> $$3^n - (3 \\cdot 2^n - 3 \\cdot 1 + 0)$$ <p></p>","tags":["Translated"]},{"location":"combinatorics/inclusion-exclusion.html#number-of-upper-bound-integer-sums","title":"Number of upper-bound integer sums","text":"<p>Consider the following equation:</p> $$x_1 + x_2 + x_3 + x_4 + x_5 + x_6 = 20$$ <p>where $0 \\le x_i \\le 8 ~ (i = 1,2,\\ldots 6)$.</p> <p>Task: count the number of solutions to the equation.</p> <p>Forget the restriction on $x_i$ for a moment and just count the number of nonnegative solutions to this equation. This is easily done using Stars and Bars: we want to break a sequence of $20$ units into $6$ groups, which is the same as arranging $5$ bars and $20$ stars:</p> $$N_0 = \\binom{25}{5}$$ <p>We will now calculate the number of \"bad\" solutions with the inclusion-exclusion principle. The \"bad\" solutions will be those in which one or more $x_i$ are greater than or equal to $9$.</p> <p>Denote by $A_k ~ (k = 1,2\\ldots 6)$ the set of solutions where $x_k \\ge 9$, and all other $x_i \\ge 0 ~ (i \\ne k)$ (they may be $\\ge 9$ or not). To calculate the size of $A_k$, note that we have essentially the same combinatorial problem that was solved in the two paragraphs above, but now $9$ of the units are excluded from the slots and definitely belong to the first group. Thus:</p> $$ | A_k | = \\binom{16}{5} $$ <p>Similarly, the size of the intersection between two sets $A_k$ and $A_p$ (for $k \\ne p$) is equal to:</p> $$ \\left| A_k \\cap A_p \\right| = \\binom{7}{5}$$ <p>The size of each intersection of three sets is zero, since $20$ units will not be enough for three or more variables greater than or equal to $9$.</p> <p>Combining all this into the formula of inclusions-exceptions and given that we solved the inverse problem, we finally get the answer:</p> $$\\binom{25}{5} - \\left(\\binom{6}{1} \\cdot \\binom{16}{5} - \\binom{6}{2} \\cdot \\binom{7}{5}\\right) $$ <p>This easily generalizes to $d$ numbers that sum up to $s$ with the restriction $0 \\le x_i \\le b$:</p> $$\\sum_{i=0}^d (-1)^i \\binom{d}{i} \\binom{s+d-1-(b+1)i}{d-1}$$ <p>As above, we treat binomial coefficients with negative upper index as zero. </p> <p>Note this problem could also be solved with dynamic programming or generating functions. The inclusion-exclusion answer is computed in $O(d)$ time (assuming math operations like binomial coefficient are constant time), while a simple DP approach would take $O(ds)$ time. </p>","tags":["Translated"]},{"location":"combinatorics/inclusion-exclusion.html#the-number-of-relative-primes-in-a-given-interval","title":"The number of relative primes in a given interval","text":"<p>Task: given two numbers $n$ and $r$, count the number of integers in the interval $[1;r]$ that are relatively prime to n (their greatest common divisor is $1$).</p> <p>Let's solve the inverse problem - compute the number of not mutually primes with $n$.</p> <p>We will denote the prime factors of $n$ as $p_i (i = 1\\cdots k)$.</p> <p>How many numbers in the interval $[1;r]$ are divisible by $p_i$? The answer to this question is:</p> $$ \\left\\lfloor \\frac{ r }{ p_i } \\right\\rfloor $$ <p>However, if we simply sum these numbers, some numbers will be summarized several times (those that share multiple $p_i$ as their factors). Therefore, it is necessary to use the inclusion-exclusion principle.</p> <p>We will iterate over all $2^k$ subsets of $p_i$s, calculate their product and add or subtract the number of multiples of their product.</p> <p>Here is a C++ implementation:</p> <pre><code>int solve (int n, int r) {\n    vector&lt;int&gt; p;\n    for (int i=2; i*i&lt;=n; ++i)\n        if (n % i == 0) {\n            p.push_back (i);\n            while (n % i == 0)\n                n /= i;\n        }\n    if (n &gt; 1)\n        p.push_back (n);\n\n    int sum = 0;\n    for (int msk=1; msk&lt;(1&lt;&lt;p.size()); ++msk) {\n        int mult = 1,\n            bits = 0;\n        for (int i=0; i&lt;(int)p.size(); ++i)\n            if (msk &amp; (1&lt;&lt;i)) {\n                ++bits;\n                mult *= p[i];\n            }\n\n        int cur = r / mult;\n        if (bits % 2 == 1)\n            sum += cur;\n        else\n            sum -= cur;\n    }\n\n    return r - sum;\n}\n</code></pre> <p>Asymptotics of the solution is $O (\\sqrt{n})$.</p>","tags":["Translated"]},{"location":"combinatorics/inclusion-exclusion.html#the-number-of-integers-in-a-given-interval-which-are-multiple-of-at-least-one-of-the-given-numbers","title":"The number of integers in a given interval which are multiple of at least one of the given numbers","text":"<p>Given $n$ numbers $a_i$ and number $r$. You want to count the number of integers in the interval $[1; r]$ that are multiple of at least one of the $a_i$.</p> <p>The solution algorithm is almost identical to the one for previous task \u2014 construct the formula of inclusion-exclusion on the numbers $a_i$, i.e. each term in this formula is the number of numbers divisible by a given subset of numbers $a_i$ (in other words, divisible by their least common multiple).</p> <p>So we will now iterate over all $2^n$ subsets of integers $a_i$ with $O(n \\log r)$ operations to find their least common multiple, adding or subtracting the number of multiples of it in the interval. Asymptotics is $O (2^n\\cdot n\\cdot \\log r)$.</p>","tags":["Translated"]},{"location":"combinatorics/inclusion-exclusion.html#the-number-of-strings-that-satisfy-a-given-pattern","title":"The number of strings that satisfy a given pattern","text":"<p>Consider $n$ patterns of strings of the same length, consisting only of letters ($a...z$) or question marks. You're also given a number $k$. A string matches a pattern if it has the same length as the pattern, and at each position, either the corresponding characters are equal or the character in the pattern is a question mark. The task is to count the number of strings that match exactly $k$ of the patterns (first problem) and at least $k$ of the patterns (second problem).</p> <p>Notice first that we can easily count the number of strings that satisfy at once all of the specified patterns. To do this, simply \"cross\" patterns: iterate though the positions (\"slots\") and look at a position over all patterns. If all patterns have a question mark in this position, the character can be any letter from $a$ to $z$. Otherwise, the character of this position is uniquely defined by the patterns that do not contain a question mark.</p> <p>Learn now to solve the first version of the problem: when the string must satisfy exactly $k$ of the patterns.</p> <p>To solve it, iterate and fix a specific subset $X$ from the set of patterns consisting of $k$ patterns. Then we have to count the number of strings that satisfy this set of patterns, and only matches it, that is, they don't match any other pattern. We will use the inclusion-exclusion principle in a slightly different manner: we sum on all supersets $Y$ (subsets from the original set of strings that contain $X$), and either add to the current answer or subtract it from the number of strings:</p> $$ ans(X) = \\sum_{Y \\supseteq X} (-1)^{|Y|-k} \\cdot f(Y) $$ <p>Where $f(Y)$ is the number of strings that match $Y$ (at least $Y$).</p> <p>(If you have a hard time figuring out this, you can try drawing Venn Diagrams.)</p> <p>If we sum up on all $ans(X)$, we will get the final answer:</p> $$ ans = \\sum_{X ~ : ~ |X| = k} ans(X) $$ <p>However, asymptotics of this solution is $O(3^k \\cdot k)$. To improve it, notice that different $ans(X)$ computations very often share $Y$ sets.</p> <p>We will reverse the formula of inclusion-exclusion and sum in terms of $Y$ sets. Now it becomes clear that the same set $Y$ would be taken into account in the computation of $ans(X)$ of $\\binom{|Y|}{k}$ sets with the same sign $(-1)^{|Y| - k}$.</p> $$ ans = \\sum_{Y ~ : ~ |Y| \\ge k} (-1)^{|Y|-k} \\cdot \\binom{|Y|}{k} \\cdot f(Y) $$ <p>Now our solution has asymptotics $O(2^k \\cdot k)$.</p> <p>We will now solve the second version of the problem: find the number of strings that match at least $k$ of the patterns.</p> <p>Of course, we can just use the solution to the first version of the problem and add the answers for sets with size greater than $k$. However, you may notice that in this problem, a set |Y| is considered in the formula for all sets with size $\\ge k$ which are contained in $Y$. That said, we can write the part of the expression that is being multiplied by $f(Y)$ as:</p> $$ (-1)^{|Y|-k} \\cdot \\binom{|Y|}{k} + (-1)^{|Y|-k-1} \\cdot \\binom{|Y|}{k+1} + (-1)^{|Y|-k-2} \\cdot \\binom{|Y|}{k+2} + \\cdots + (-1)^{|Y|-|Y|} \\cdot \\binom{|Y|}{|Y|} $$ <p>Looking at Graham's (Graham, Knuth, Patashnik. \"Concrete mathematics\" [1998] ), we see a well-known formula for binomial coefficients:</p> $$ \\sum_{k=0}^m (-1)^k \\cdot \\binom{n}{k} = (-1)^m \\cdot \\binom{n-1}{m} $$ <p>Applying it here, we find that the entire sum of binomial coefficients is minimized:</p> $$ (-1)^{|Y|-k} \\cdot \\binom{|Y|-1}{|Y|-k} $$ <p>Thus, for this task, we also obtained a solution with the asymptotics $O(2^k \\cdot k)$:</p> $$ ans = \\sum_{Y ~ : ~ |Y| \\ge k} (-1)^{|Y|-k} \\cdot \\binom{|Y|-1}{|Y|-k} \\cdot f(Y) $$","tags":["Translated"]},{"location":"combinatorics/inclusion-exclusion.html#the-number-of-ways-of-going-from-a-cell-to-another","title":"The number of ways of going from a cell to another","text":"<p>There is a field $n \\times m$, and $k$ of its cells are impassable walls. A robot is initially at the cell $(1,1)$ (bottom left). The robot can only move right or up, and eventually it needs to get into the cell $(n,m)$, avoiding all obstacles. You need to count the number of ways he can do it.</p> <p>Assume that the sizes $n$ and $m$ are very large (say, $10^9$), and the number $k$ is small (around $100$).</p> <p>For now, sort the obstacles by their coordinate $x$, and in case of equality \u2014 coordinate $y$.</p> <p>Also just learn how to solve a problem without obstacles: i.e. learn how to count the number of ways to get from one cell to another. In one axis, we need to go through $x$ cells, and on the other, $y$ cells. From simple combinatorics, we get a formula using binomial coefficients:</p> $$\\binom{x+y}{x}$$ <p>Now to count the number of ways to get from one cell to another, avoiding all obstacles, you can use inclusion-exclusion to solve the inverse problem: count the number of ways to walk through the board stepping at a subset of obstacles (and subtract it from the total number of ways).</p> <p>When iterating over a subset of the obstacles that we'll step, to count the number of ways to do this simply multiply the number of all paths from starting cell to the first of the selected obstacles, a first obstacle to the second, and so on, and then add or subtract this number from the answer, in accordance with the standard formula of inclusion-exclusion.</p> <p>However, this will again be non-polynomial in complexity $O(2^k \\cdot k)$.</p> <p>Here goes a polynomial solution:</p> <p>We will use dynamic programming. For convenience, push (1,1) to the beginning and (n,m) at the end of the obstacles array. Let's compute the numbers $d[i]$ \u2014 the number of ways to get from the starting point ($0-th$) to $i-th$, without stepping on any other obstacle (except for $i$, of course). We will compute this number for all the obstacle cells, and also for the ending one.</p> <p>Let's forget for a second the obstacles and just count the number of paths from cell $0$ to $i$. We need to consider some \"bad\" paths, the ones that pass through the obstacles, and subtract them from the total number of ways of going from $0$ to $i$.</p> <p>When considering an obstacle $t$ between $0$ and $i$ ($0 &lt; t &lt; i$), on which we can step, we see that the number of paths from $0$ to $i$ that pass through $t$ which have $t$ as the first obstacle between start and $i$. We can compute that as: $d[t]$ multiplied by the number of arbitrary paths from $t$ to $i$. We can count the number of \"bad\" ways summing this for all $t$ between $0$ and $i$.</p> <p>We can compute $d[i]$ in $O(k)$ for $O(k)$ obstacles, so this solution has complexity $O(k^2)$.</p>","tags":["Translated"]},{"location":"combinatorics/inclusion-exclusion.html#the-number-of-coprime-quadruples","title":"The number of coprime quadruples","text":"<p>You're given $n$ numbers: $a_1, a_2, \\ldots, a_n$. You are required to count the number of ways to choose four numbers so that their combined greatest common divisor is equal to one.</p> <p>We will solve the inverse problem \u2014 compute the number of \"bad\" quadruples, i.e. quadruples in which all numbers are divisible by a number $d &gt; 1$.</p> <p>We will use the inclusion-exclusion principle while summing over all possible groups of four numbers divisible by a divisor $d$.</p> $$ans = \\sum_{d \\ge 2} (-1)^{deg(d)-1} \\cdot f(d)$$ <p>where $deg(d)$ is the number of primes in the factorization of the number $d$ and $f(d)$ the number of quadruples divisible by $d$.</p> <p>To calculate the function $f(d)$, you just have to count the number of multiples of $d$ (as mentioned on a previous task) and use binomial coefficients to count the number of ways to choose four of them.</p> <p>Thus, using the formula of inclusions-exclusions we sum the number of groups of four divisible by a prime number, then subtract the number of quadruples which are divisible by the product of two primes, add quadruples divisible by three primes, etc.</p>","tags":["Translated"]},{"location":"combinatorics/inclusion-exclusion.html#the-number-of-harmonic-triplets","title":"The number of harmonic triplets","text":"<p>You are given a number $n \\le 10^6$. You are required to count the number of triples $2 \\le a &lt; b &lt; c \\le n$ that satisfy one of the following conditions:</p> <ul> <li>or ${\\rm gcd}(a,b) = {\\rm gcd}(a,c) = {\\rm gcd}(b,c) = 1$,</li> <li>or ${\\rm gcd}(a,b) &gt; 1, {\\rm gcd}(a,c) &gt; 1, {\\rm gcd}(b,c) &gt; 1$.</li> </ul> <p>First, go straight to the inverse problem \u2014 i.e. count the number of non-harmonic triples.</p> <p>Second, note that any non-harmonic triplet is made of a pair of coprimes and a third number that is not coprime with at least one from the pair.</p> <p>Thus, the number of non-harmonic triples that contain $i$ is equal the number of integers from $2$ to $n$ that are coprimes with $i$ multiplied by the number of integers that are not coprime with $i$.</p> <p>Either $gcd(a,b) = 1 \\wedge gcd(a,c) &gt; 1 \\wedge gcd(b,c) &gt; 1$</p> <p>or $gcd(a,b) = 1 \\wedge gcd(a,c) = 1 \\wedge gcd(b,c) &gt; 1$</p> <p>In both of these cases, it will be counted twice. The first case will be counted when $i = a$ and when $i = b$. The second case will be counted when $i = b$ and when $i = c$. Therefore, to compute the number of non-harmonic triples, we sum this calculation through all $i$ from $2$ to $n$ and divide it by $2$.</p> <p>Now all we have left to solve is to learn to count the number of coprimes to $i$ in the interval $[2;n]$. Although this problem has already been mentioned, the above solution is not suitable here \u2014 it would require the factorization of each of the integers from $2$ to $n$, and then iterating through all subsets of these primes.</p> <p>A faster solution is possible with such modification of the sieve of Eratosthenes:</p> <ol> <li> <p>First, we find all numbers in the interval $[2;n]$ such that its simple factorization does not include a prime factor twice. We will also need to know, for these numbers, how many factors it includes.</p> <ul> <li>To do this we will maintain an array $deg[i]$ to store the number of primes in the factorization of $i$, and an array $good[i]$, to mark either if $i$ contains each factor at most once ($good[i] = 1$) or not ($good[i] = 0$). When iterating from $2$ to $n$, if we reach a number that has $deg$ equal to $0$, then it is a prime and its $deg$ is $1$.</li> <li>During the sieve of Eratosthenes, we will iterate $i$ from $2$ to $n$. When processing a prime number we go through all of its multiples and increase their $deg[]$. If one of these multiples is multiple of the square of $i$, then we can put $good$ as false.</li> </ul> </li> <li> <p>Second, we need to calculate the answer for all $i$ from $2$ to $n$, i.e., the array $cnt[]$ \u2014 the number of integers not coprime with $i$.</p> <ul> <li>To do this, remember how the formula of inclusion-exclusion works \u2014 actually here we implement the same concept, but with inverted logic: we iterate over a component (a product of primes from the factorization) and add or subtract its term on the formula of inclusion-exclusion of each of its multiples.</li> <li>So, let's say we are processing a number $i$ such that $good[i] = true$, i.e., it is involved in the formula of inclusion-exclusion. Iterate through all numbers that are multiples of $i$, and either add or subtract $\\lfloor N/i \\rfloor$ from their $cnt[]$ (the signal depends on $deg[i]$: if $deg[i]$ is odd, then we must add, otherwise subtract).</li> </ul> </li> </ol> <p>Here's a C++ implementation:</p> <pre><code>int n;\nbool good[MAXN];\nint deg[MAXN], cnt[MAXN];\n\nlong long solve() {\n    memset (good, 1, sizeof good);\n    memset (deg, 0, sizeof deg);\n    memset (cnt, 0, sizeof cnt);\n\n    long long ans_bad = 0;\n    for (int i=2; i&lt;=n; ++i) {\n        if (good[i]) {\n            if (deg[i] == 0)  deg[i] = 1;\n            for (int j=1; i*j&lt;=n; ++j) {\n                if (j &gt; 1 &amp;&amp; deg[i] == 1)\n                    if (j % i == 0)\n                        good[i*j] = false;\n                    else\n                        ++deg[i*j];\n                cnt[i*j] += (n / i) * (deg[i]%2==1 ? +1 : -1);\n            }\n        }\n        ans_bad += (cnt[i] - 1) * 1ll * (n-1 - cnt[i]);\n    }\n\n    return (n-1) * 1ll * (n-2) * (n-3) / 6 - ans_bad / 2;\n}\n</code></pre> <p>The asymptotics of our solution is $O(n \\log n)$, as for almost every number up to $n$ we make $n/i$ iterations on the nested loop.</p>","tags":["Translated"]},{"location":"combinatorics/inclusion-exclusion.html#the-number-of-permutations-without-fixed-points-derangements","title":"The number of permutations without fixed points (derangements)","text":"<p>Prove that the number of permutations of length $n$ without fixed points (i.e. no number $i$ is in position $i$ - also called a derangement) is equal to the following number:</p> $$n! - \\binom{n}{1} \\cdot (n-1)! + \\binom{n}{2} \\cdot (n-2)! - \\binom{n}{3} \\cdot (n-3)! + \\cdots \\pm \\binom{n}{n} \\cdot (n-n)! $$ <p>and approximately equal to:</p> $$ \\frac{ n! }{ e } $$ <p>(if you round this expression to the nearest whole number \u2014 you get exactly the number of permutations without fixed points)</p> <p>Denote by $A_k$ the set of permutations of length $n$ with a fixed point at position $k$ ($1 \\le k \\le n$) (i.e. element $k$ is at position $k$).</p> <p>We now use the formula of inclusion-exclusion to count the number of permutations with at least one fixed point. For this we need to learn to count sizes of an intersection of sets $A_i$, as follows:</p> $$\\begin{eqnarray} \\left| A_p \\right| &amp;=&amp; (n-1)!\\ , \\\\ \\left| A_p \\cap A_q \\right| &amp;=&amp; (n-2)!\\ , \\\\ \\left| A_p \\cap A_q \\cap A_r \\right| &amp;=&amp; (n-3)!\\ , \\\\ \\cdots , \\end{eqnarray}$$ <p>because if we know that the number of fixed points is equal $x$, then we know the position of $x$ elements of the permutation, and all other $(n-x)$ elements can be placed anywhere.</p> <p>Substituting this into the formula of inclusion-exclusion, and given that the number of ways to choose a subset of size $x$ from the set of $n$ elements is equal to $\\binom{n}{x}$, we obtain a formula for the number of permutations with at least one fixed point:</p> $$\\binom{n}{1} \\cdot (n-1)! - \\binom{n}{2} \\cdot (n-2)! + \\binom{n}{3} \\cdot (n-3)! - \\cdots \\pm \\binom{n}{n} \\cdot (n-n)! $$ <p>Then the number of permutations without fixed points is equal to:</p> $$n! - \\binom{n}{1} \\cdot (n-1)! + \\binom{n}{2} \\cdot (n-2)! - \\binom{n}{3} \\cdot (n-3)! + \\cdots \\pm \\binom{n}{n} \\cdot (n-n)! $$ <p>Simplifying this expression, we obtain exact and approximate expressions for the number of permutations without fixed points:</p> $$ n! \\left( 1 - \\frac{1}{1!} + \\frac{1}{2!} - \\frac{1}{3!} + \\cdots \\pm \\frac{1}{n!} \\right ) \\approx \\frac{n!}{e} $$ <p>(because the sum in brackets are the first $n+1$ terms of the expansion in Taylor series $e^{-1}$)</p> <p>It is worth noting that a similar problem can be solved this way: when you need the fixed points were not among the $m$ first elements of permutations (and not among all, as we just solved). The formula obtained is as the given above accurate formula, but it will go up to the sum of $k$, instead of $n$.</p>","tags":["Translated"]},{"location":"combinatorics/inclusion-exclusion.html#practice-problems","title":"Practice Problems","text":"<p>A list of tasks that can be solved using the principle of inclusions-exclusions:</p> <ul> <li>UVA #10325 \"The Lottery\" [difficulty: low]</li> <li>UVA #11806 \"Cheerleaders\" [difficulty: low]</li> <li>TopCoder SRM 477 \"CarelessSecretary\" [difficulty: low]</li> <li>TopCoder TCHS 16 \"Divisibility\" [difficulty: low]</li> <li>SPOJ #6285 NGM2 , \"Another Game With Numbers\" [difficulty: low]</li> <li>TopCoder SRM 382 \"CharmingTicketsEasy\" [difficulty: medium]</li> <li>TopCoder SRM 390 \"SetOfPatterns\" [difficulty: medium]</li> <li>TopCoder SRM 176 \"Deranged\" [difficulty: medium]</li> <li>TopCoder SRM 457 \"TheHexagonsDivOne\" [difficulty: medium]</li> <li>SPOJ #4191 MSKYCODE \"Sky Code\" [difficulty: medium]</li> <li>SPOJ #4168 SQFREE \"Square-free integers\" [difficulty: medium]</li> <li>CodeChef \"Count Relations\" [difficulty: medium]</li> <li>SPOJ - Almost Prime Numbers Again</li> <li>SPOJ - Find number of Pair of Friends</li> <li>SPOJ - Balanced Cow Subsets</li> <li>SPOJ - EASY MATH [difficulty: medium]</li> <li>SPOJ - MOMOS - FEASTOFPIGS [difficulty: easy]</li> <li>Atcoder - Grid 2 [difficulty: easy]</li> <li>Codeforces - Count GCD</li> </ul>","tags":["Translated"]},{"location":"combinatorics/stars_and_bars.html","title":"Stars and bars","text":"<p>Stars and bars is a mathematical technique for solving certain combinatorial problems. It occurs whenever you want to count the number of ways to group identical objects.</p>","tags":["Original"]},{"location":"combinatorics/stars_and_bars.html#theorem","title":"Theorem","text":"<p>The number of ways to put $n$ identical objects into $k$ labeled boxes is</p> $$\\binom{n + k - 1}{n}.$$ <p>The proof involves turning the objects into stars and separating the boxes using bars (therefore the name). E.g. we can represent with $\\bigstar | \\bigstar \\bigstar |~| \\bigstar \\bigstar$ the following situation: in the first box is one object, in the second box are two objects, the third one is empty and in the last box are two objects. This is one way of dividing 5 objects into 4 boxes.</p> <p>It should be pretty obvious, that every partition can be represented using $n$ stars and $k - 1$ bars and every stars and bars permutation using $n$ stars and $k - 1$ bars represents one partition. Therefore the number of ways to divide $n$ identical objects into $k$ labeled boxes is the same number as there are permutations of $n$ stars and $k - 1$ bars. The Binomial Coefficient gives us the desired formula.</p>","tags":["Original"]},{"location":"combinatorics/stars_and_bars.html#number-of-non-negative-integer-sums","title":"Number of non-negative integer sums","text":"<p>This problem is a direct application of the theorem.</p> <p>You want to count the number of solution of the equation </p> $$x_1 + x_2 + \\dots + x_k = n$$ <p>with $x_i \\ge 0$.</p> <p>Again we can represent a solution using stars and bars. E.g. the solution $1 + 3 + 0 = 4$ for $n = 4$, $k = 3$ can be represented using $\\bigstar | \\bigstar \\bigstar \\bigstar |$.</p> <p>It is easy to see, that this is exactly the stars and bars theorem. Therefore the solution is $\\binom{n + k - 1}{n}$.</p>","tags":["Original"]},{"location":"combinatorics/stars_and_bars.html#number-of-positive-integer-sums","title":"Number of positive integer sums","text":"<p>A second theorem provides a nice interpretation for positive integers. Consider solutions to </p> $$x_1 + x_2 + \\dots + x_k = n$$ <p>with $x_i \\ge 1$.</p> <p>We can consider $n$ stars, but this time we can put at most one bar between stars, since two bars between stars would represent $x_i=0$, i.e. an empty box.  There are $n-1$ gaps between stars to place $k-1$ bars, so the solution is $\\binom{n-1}{k-1}$. </p>","tags":["Original"]},{"location":"combinatorics/stars_and_bars.html#number-of-lower-bound-integer-sums","title":"Number of lower-bound integer sums","text":"<p>This can easily be extended to integer sums with different lower bounds. I.e. we want to count the number of solutions for  the equation</p> $$x_1 + x_2 + \\dots + x_k = n$$ <p>with $x_i \\ge a_i$.</p> <p>After substituting $x_i' := x_i - a_i$ we receive the modified equation</p> $$(x_1' + a_i) + (x_2' + a_i) + \\dots + (x_k' + a_k) = n$$ $$\\Leftrightarrow ~ ~ x_1' + x_2' + \\dots + x_k' = n - a_1 - a_2 - \\dots - a_k$$ <p>with $x_i' \\ge 0$. So we have reduced the problem to the simpler case with $x_i' \\ge 0$ and again can apply the stars and bars theorem.</p>","tags":["Original"]},{"location":"combinatorics/stars_and_bars.html#number-of-upper-bound-integer-sums","title":"Number of upper-bound integer sums","text":"<p>With some help of the Inclusion-Exclusion Principle, you can also restrict the integers with upper bounds. See the Number of upper-bound integer sums section in the corresponding article.</p>","tags":["Original"]},{"location":"combinatorics/stars_and_bars.html#practice-problems","title":"Practice Problems","text":"<ul> <li>Codeforces - Array</li> <li>Codeforces - Kyoya and Coloured Balls</li> <li>Codeforces - Colorful Bricks</li> <li>Codeforces - Two Arrays</li> <li>Codeforces - One-Dimensional Puzzle</li> </ul>","tags":["Original"]},{"location":"data_structures/deleting_in_log_n.html","title":"Deleting from a data structure in $O(T(n)\\log n)$","text":"<p>Suppose you have a data structure which allows adding elements in true $O(T(n))$. This article will describe a technique that allows deletion in $O(T(n)\\log n)$ offline.</p>","tags":["Original"]},{"location":"data_structures/deleting_in_log_n.html#algorithm","title":"Algorithm","text":"<p>Each element lives in the data structure for some segments of time between additions and deletions. Let's build a segment tree over the queries. Each segment when some element is alive splits into $O(\\log n)$ nodes of the tree. Let's put each query when we want to know something about the structure into the corresponding leaf. Now to process all queries we will run a DFS on the segment tree. When entering the node we will add all the elements that are inside this node. Then we will go further to the children of this node or answer the queries (if the node is a leaf). When leaving the node, we must undo the additions. Note that if we change the structure in $O(T(n))$ we can roll back the changes in $O(T(n))$ by keeping a stack of changes. Note that rollbacks break amortized complexity.</p>","tags":["Original"]},{"location":"data_structures/deleting_in_log_n.html#notes","title":"Notes","text":"<p>The idea of creating a segment tree over segments when something is alive may be used not only for data structure problems. See some problems below.</p>","tags":["Original"]},{"location":"data_structures/deleting_in_log_n.html#implementation","title":"Implementation","text":"<p>This implementation is for the dynamic connectivity problem. It can add edges, remove edges and count the number of connected components.</p> <pre><code>struct dsu_save {\n    int v, rnkv, u, rnku;\n\n    dsu_save() {}\n\n    dsu_save(int _v, int _rnkv, int _u, int _rnku)\n        : v(_v), rnkv(_rnkv), u(_u), rnku(_rnku) {}\n};\n\nstruct dsu_with_rollbacks {\n    vector&lt;int&gt; p, rnk;\n    int comps;\n    stack&lt;dsu_save&gt; op;\n\n    dsu_with_rollbacks() {}\n\n    dsu_with_rollbacks(int n) {\n        p.resize(n);\n        rnk.resize(n);\n        for (int i = 0; i &lt; n; i++) {\n            p[i] = i;\n            rnk[i] = 0;\n        }\n        comps = n;\n    }\n\n    int find_set(int v) {\n        return (v == p[v]) ? v : find_set(p[v]);\n    }\n\n    bool unite(int v, int u) {\n        v = find_set(v);\n        u = find_set(u);\n        if (v == u)\n            return false;\n        comps--;\n        if (rnk[v] &gt; rnk[u])\n            swap(v, u);\n        op.push(dsu_save(v, rnk[v], u, rnk[u]));\n        p[v] = u;\n        if (rnk[u] == rnk[v])\n            rnk[u]++;\n        return true;\n    }\n\n    void rollback() {\n        if (op.empty())\n            return;\n        dsu_save x = op.top();\n        op.pop();\n        comps++;\n        p[x.v] = x.v;\n        rnk[x.v] = x.rnkv;\n        p[x.u] = x.u;\n        rnk[x.u] = x.rnku;\n    }\n};\n\nstruct query {\n    int v, u;\n    bool united;\n    query(int _v, int _u) : v(_v), u(_u) {\n    }\n};\n\nstruct QueryTree {\n    vector&lt;vector&lt;query&gt;&gt; t;\n    dsu_with_rollbacks dsu;\n    int T;\n\n    QueryTree() {}\n\n    QueryTree(int _T, int n) : T(_T) {\n        dsu = dsu_with_rollbacks(n);\n        t.resize(4 * T + 4);\n    }\n\n    void add_to_tree(int v, int l, int r, int ul, int ur, query&amp; q) {\n        if (ul &gt; ur)\n            return;\n        if (l == ul &amp;&amp; r == ur) {\n            t[v].push_back(q);\n            return;\n        }\n        int mid = (l + r) / 2;\n        add_to_tree(2 * v, l, mid, ul, min(ur, mid), q);\n        add_to_tree(2 * v + 1, mid + 1, r, max(ul, mid + 1), ur, q);\n    }\n\n    void add_query(query q, int l, int r) {\n        add_to_tree(1, 0, T - 1, l, r, q);\n    }\n\n    void dfs(int v, int l, int r, vector&lt;int&gt;&amp; ans) {\n        for (query&amp; q : t[v]) {\n            q.united = dsu.unite(q.v, q.u);\n        }\n        if (l == r)\n            ans[l] = dsu.comps;\n        else {\n            int mid = (l + r) / 2;\n            dfs(2 * v, l, mid, ans);\n            dfs(2 * v + 1, mid + 1, r, ans);\n        }\n        for (query q : t[v]) {\n            if (q.united)\n                dsu.rollback();\n        }\n    }\n\n    vector&lt;int&gt; solve() {\n        vector&lt;int&gt; ans(T);\n        dfs(1, 0, T - 1, ans);\n        return ans;\n    }\n};\n</code></pre>","tags":["Original"]},{"location":"data_structures/deleting_in_log_n.html#problems","title":"Problems","text":"<ul> <li>Codeforces - Connect and Disconnect</li> <li>Codeforces - Addition on Segments</li> <li>Codeforces - Extending Set of Points</li> </ul>","tags":["Original"]},{"location":"data_structures/disjoint_set_union.html","title":"Disjoint Set Union","text":"<p>This article discusses the data structure Disjoint Set Union or DSU. Often it is also called Union Find because of its two main operations.</p> <p>This data structure provides the following capabilities. We are given several elements, each of which is a separate set. A DSU will have an operation to combine any two sets, and it will be able to tell in which set a specific element is. The classical version also introduces a third operation, it can create a set from a new element.</p> <p>Thus the basic interface of this data structure consists of only three operations:</p> <ul> <li><code>make_set(v)</code> - creates a new set consisting of the new element <code>v</code></li> <li><code>union_sets(a, b)</code> - merges the two specified sets (the set in which the element <code>a</code> is located, and the set in which the element <code>b</code> is located)</li> <li><code>find_set(v)</code> - returns the representative (also called leader) of the set that contains the element <code>v</code>. This representative is an element of its corresponding set. It is selected in each set by the data structure itself (and can change over time, namely after <code>union_sets</code> calls). This representative can be used to check if two elements are part of the same set or not. <code>a</code> and <code>b</code> are exactly in the same set, if <code>find_set(a) == find_set(b)</code>. Otherwise they are in different sets.</li> </ul> <p>As described in more detail later, the data structure allows you to do each of these operations in almost $O(1)$ time on average.</p> <p>Also in one of the subsections an alternative structure of a DSU is explained, which achieves a slower average complexity of $O(\\log n)$, but can be more powerful than the regular DSU structure.</p>","tags":["Translated"]},{"location":"data_structures/disjoint_set_union.html#build-an-efficient-data-structure","title":"Build an efficient data structure","text":"<p>We will store the sets in the form of trees: each tree will correspond to one set. And the root of the tree will be the representative/leader of the set.</p> <p>In the following image you can see the representation of such trees.</p> <p></p> <p>In the beginning, every element starts as a single set, therefore each vertex is its own tree. Then we combine the set containing the element 1 and the set containing the element 2. Then we combine the set containing the element 3 and the set containing the element 4. And in the last step, we combine the set containing the element 1 and the set containing the element 3.</p> <p>For the implementation this means that we will have to maintain an array <code>parent</code> that stores a reference to its immediate ancestor in the tree.</p>","tags":["Translated"]},{"location":"data_structures/disjoint_set_union.html#naive-implementation","title":"Naive implementation","text":"<p>We can already write the first implementation of the Disjoint Set Union data structure. It will be pretty inefficient at first, but later we can improve it using two optimizations, so that it will take nearly constant time for each function call.</p> <p>As we said, all the information about the sets of elements will be kept in an array <code>parent</code>.</p> <p>To create a new set (operation <code>make_set(v)</code>), we simply create a tree with root in the vertex <code>v</code>, meaning that it is its own ancestor.</p> <p>To combine two sets (operation <code>union_sets(a, b)</code>), we first find the representative of the set in which <code>a</code> is located, and the representative of the set in which <code>b</code> is located. If the representatives are identical, that we have nothing to do, the sets are already merged. Otherwise, we can simply specify that one of the representatives is the parent of the other representative - thereby combining the two trees.</p> <p>Finally the implementation of the find representative function (operation <code>find_set(v)</code>): we simply climb the ancestors of the vertex <code>v</code> until we reach the root, i.e. a vertex such that the reference to the ancestor leads to itself. This operation is easily implemented recursively.</p> <pre><code>void make_set(int v) {\n    parent[v] = v;\n}\n\nint find_set(int v) {\n    if (v == parent[v])\n        return v;\n    return find_set(parent[v]);\n}\n\nvoid union_sets(int a, int b) {\n    a = find_set(a);\n    b = find_set(b);\n    if (a != b)\n        parent[b] = a;\n}\n</code></pre> <p>However this implementation is inefficient. It is easy to construct an example, so that the trees degenerate into long chains. In that case each call <code>find_set(v)</code> can take $O(n)$ time.</p> <p>This is far away from the complexity that we want to have (nearly constant time). Therefore we will consider two optimizations that will allow to significantly accelerate the work.</p>","tags":["Translated"]},{"location":"data_structures/disjoint_set_union.html#path-compression-optimization","title":"Path compression optimization","text":"<p>This optimization is designed for speeding up <code>find_set</code>.</p> <p>If we call <code>find_set(v)</code> for some vertex <code>v</code>, we actually find the representative <code>p</code> for all vertices that we visit on the path between <code>v</code> and the actual representative <code>p</code>. The trick is to make the paths for all those nodes shorter, by setting the parent of each visited vertex directly to <code>p</code>.</p> <p>You can see the operation in the following image. On the left there is a tree, and on the right side there is the compressed tree after calling <code>find_set(7)</code>, which shortens the paths for the visited nodes 7, 5, 3 and 2.</p> <p></p> <p>The new implementation of <code>find_set</code> is as follows:</p> <pre><code>int find_set(int v) {\n    if (v == parent[v])\n        return v;\n    return parent[v] = find_set(parent[v]);\n}\n</code></pre> <p>The simple implementation does what was intended: first find the representative of the set (root vertex), and then in the process of stack unwinding the visited nodes are attached directly to the representative.</p> <p>This simple modification of the operation already achieves the time complexity $O(\\log n)$ per call on average (here without proof). There is a second modification, that will make it even faster.</p>","tags":["Translated"]},{"location":"data_structures/disjoint_set_union.html#union-by-size-rank","title":"Union by size / rank","text":"<p>In this optimization we will change the <code>union_set</code> operation. To be precise, we will change which tree gets attached to the other one. In the naive implementation the second tree always got attached to the first one. In practice that can lead to trees containing chains of length $O(n)$. With this optimization we will avoid this by choosing very carefully which tree gets attached.</p> <p>There are many possible heuristics that can be used. Most popular are the following two approaches: In the first approach we use the size of the trees as rank, and in the second one we use the depth of the tree (more precisely, the upper bound on the tree depth, because the depth will get smaller when applying path compression).</p> <p>In both approaches the essence of the optimization is the same: we attach the tree with the lower rank to the one with the bigger rank.</p> <p>Here is the implementation of union by size:</p> <pre><code>void make_set(int v) {\n    parent[v] = v;\n    size[v] = 1;\n}\n\nvoid union_sets(int a, int b) {\n    a = find_set(a);\n    b = find_set(b);\n    if (a != b) {\n        if (size[a] &lt; size[b])\n            swap(a, b);\n        parent[b] = a;\n        size[a] += size[b];\n    }\n}\n</code></pre> <p>And here is the implementation of union by rank based on the depth of the trees:</p> <p><pre><code>void make_set(int v) {\n    parent[v] = v;\n    rank[v] = 0;\n}\n\nvoid union_sets(int a, int b) {\n    a = find_set(a);\n    b = find_set(b);\n    if (a != b) {\n        if (rank[a] &lt; rank[b])\n            swap(a, b);\n        parent[b] = a;\n        if (rank[a] == rank[b])\n            rank[a]++;\n    }\n}\n</code></pre> Both optimizations are equivalent in terms of time and space complexity. So in practice you can use any of them.</p>","tags":["Translated"]},{"location":"data_structures/disjoint_set_union.html#time-complexity","title":"Time complexity","text":"<p>As mentioned before, if we combine both optimizations - path compression with union by size / rank - we will reach nearly constant time queries. It turns out, that the final amortized time complexity is $O(\\alpha(n))$, where $\\alpha(n)$ is the inverse Ackermann function, which grows very slowly. In fact it grows so slowly, that it doesn't exceed $4$ for all reasonable $n$ (approximately $n &lt; 10^{600}$).</p> <p>Amortized complexity is the total time per operation, evaluated over a sequence of multiple operations. The idea is to guarantee the total time of the entire sequence, while allowing single operations to be much slower then the amortized time. E.g. in our case a single call might take $O(\\log n)$ in the worst case, but if we do $m$ such calls back to back we will end up with an average time of $O(\\alpha(n))$.</p> <p>We will also not present a proof for this time complexity, since it is quite long and complicated.</p> <p>Also, it's worth mentioning that DSU with union by size / rank, but without path compression works in $O(\\log n)$ time per query.</p>","tags":["Translated"]},{"location":"data_structures/disjoint_set_union.html#linking-by-index-coin-flip-linking","title":"Linking by index / coin-flip linking","text":"<p>Both union by rank and union by size require that you store additional data for each set, and maintain these values during each union operation. There exist also a randomized algorithm, that simplifies the union operation a little bit: linking by index.</p> <p>We assign each set a random value called the index, and we attach the set with the smaller index to the one with the larger one. It is likely that a bigger set will have a bigger index than the smaller set, therefore this operation is closely related to union by size. In fact it can be proven, that this operation has the same time complexity as union by size. However in practice it is slightly slower than union by size.</p> <p>You can find a proof of the complexity and even more union techniques here.</p> <pre><code>void make_set(int v) {\n    parent[v] = v;\n    index[v] = rand();\n}\n\nvoid union_sets(int a, int b) {\n    a = find_set(a);\n    b = find_set(b);\n    if (a != b) {\n        if (index[a] &lt; index[b])\n            swap(a, b);\n        parent[b] = a;\n    }\n}\n</code></pre> <p>It's a common misconception that just flipping a coin, to decide which set we attach to the other, has the same complexity. However that's not true. The paper linked above conjectures that coin-flip linking combined with path compression has complexity $\\Omega\\left(n \\frac{\\log n}{\\log \\log n}\\right)$. And in benchmarks it performs a lot worse than union by size/rank or linking by index.</p> <pre><code>void union_sets(int a, int b) {\n    a = find_set(a);\n    b = find_set(b);\n    if (a != b) {\n        if (rand() % 2)\n            swap(a, b);\n        parent[b] = a;\n    }\n}\n</code></pre>","tags":["Translated"]},{"location":"data_structures/disjoint_set_union.html#applications-and-various-improvements","title":"Applications and various improvements","text":"<p>In this section we consider several applications of the data structure, both the trivial uses and some improvements to the data structure.</p>","tags":["Translated"]},{"location":"data_structures/disjoint_set_union.html#connected-components-in-a-graph","title":"Connected components in a graph","text":"<p>This is one of the obvious applications of DSU.</p> <p>Formally the problem is defined in the following way: Initially we have an empty graph. We have to add vertices and undirected edges, and answer queries of the form $(a, b)$ - \"are the vertices $a$ and $b$ in the same connected component of the graph?\"</p> <p>Here we can directly apply the data structure, and get a solution that handles an addition of a vertex or an edge and a query in nearly constant time on average.</p> <p>This application is quite important, because nearly the same problem appears in Kruskal's algorithm for finding a minimum spanning tree. Using DSU we can improve the $O(m \\log n + n^2)$ complexity to $O(m \\log n)$.</p>","tags":["Translated"]},{"location":"data_structures/disjoint_set_union.html#search-for-connected-components-in-an-image","title":"Search for connected components in an image","text":"<p>One of the applications of DSU is the following task: there is an image of $n \\times m$ pixels. Originally all are white, but then a few black pixels are drawn. You want to determine the size of each white connected component in the final image.</p> <p>For the solution we simply iterate over all white pixels in the image, for each cell iterate over its four neighbors, and if the neighbor is white call <code>union_sets</code>. Thus we will have a DSU with $n m$ nodes corresponding to image pixels. The resulting trees in the DSU are the desired connected components.</p> <p>The problem can also be solved by DFS or BFS, but the method described here has an advantage: it can process the matrix row by row (i.e. to process a row we only need the previous and the current row, and only need a DSU built for the elements of one row) in $O(\\min(n, m))$ memory.</p>","tags":["Translated"]},{"location":"data_structures/disjoint_set_union.html#store-additional-information-for-each-set","title":"Store additional information for each set","text":"<p>DSU allows you to easily store additional information in the sets.</p> <p>A simple example is the size of the sets: storing the sizes was already described in the Union by size section (the information was stored by the current representative of the set).</p> <p>In the same way - by storing it at the representative nodes - you can also store any other information about the sets.</p>","tags":["Translated"]},{"location":"data_structures/disjoint_set_union.html#compress-jumps-along-a-segment-painting-subarrays-offline","title":"Compress jumps along a segment / Painting subarrays offline","text":"<p>One common application of the DSU is the following: There is a set of vertices, and each vertex has an outgoing edge to another vertex. With DSU you can find the end point, to which we get after following all edges from a given starting point, in almost constant time.</p> <p>A good example of this application is the problem of painting subarrays. We have a segment of length $L$, each element initially has the color 0. We have to repaint the subarray $[l, r]$ with the color $c$ for each query $(l, r, c)$. At the end we want to find the final color of each cell. We assume that we know all the queries in advance, i.e. the task is offline.</p> <p>For the solution we can make a DSU, which for each cell stores a link to the next unpainted cell. Thus initially each cell points to itself. After painting one requested repaint of a segment, all cells from that segment will point to the cell after the segment.</p> <p>Now to solve this problem, we consider the queries in the reverse order: from last to first. This way when we execute a query, we only have to paint exactly the unpainted cells in the subarray $[l, r]$. All other cells already contain their final color. To quickly iterate over all unpainted cells, we use the DSU. We find the left-most unpainted cell inside of a segment, repaint it, and with the pointer we move to the next empty cell to the right.</p> <p>Here we can use the DSU with path compression, but we cannot use union by rank / size (because it is important who becomes the leader after the merge). Therefore the complexity will be $O(\\log n)$ per union (which is also quite fast).</p> <p>Implementation:</p> <pre><code>for (int i = 0; i &lt;= L; i++) {\n    make_set(i);\n}\n\nfor (int i = m-1; i &gt;= 0; i--) {\n    int l = query[i].l;\n    int r = query[i].r;\n    int c = query[i].c;\n    for (int v = find_set(l); v &lt;= r; v = find_set(v)) {\n        answer[v] = c;\n        parent[v] = v + 1;\n    }\n}\n</code></pre> <p>There is one optimization: We can use union by rank, if we store the next unpainted cell in an additional array <code>end[]</code>. Then we can merge two sets into one ranked according to their heuristics, and we obtain the solution in $O(\\alpha(n))$.</p>","tags":["Translated"]},{"location":"data_structures/disjoint_set_union.html#support-distances-up-to-representative","title":"Support distances up to representative","text":"<p>Sometimes in specific applications of the DSU you need to maintain the distance between a vertex and the representative of its set (i.e. the path length in the tree from the current node to the root of the tree).</p> <p>If we don't use path compression, the distance is just the number of recursive calls. But this will be inefficient.</p> <p>However it is possible to do path compression, if we store the distance to the parent as additional information for each node.</p> <p>In the implementation it is convenient to use an array of pairs for <code>parent[]</code> and the function <code>find_set</code> now returns two numbers: the representative of the set, and the distance to it.</p> <pre><code>void make_set(int v) {\n    parent[v] = make_pair(v, 0);\n    rank[v] = 0;\n}\n\npair&lt;int, int&gt; find_set(int v) {\n    if (v != parent[v].first) {\n        int len = parent[v].second;\n        parent[v] = find_set(parent[v].first);\n        parent[v].second += len;\n    }\n    return parent[v];\n}\n\nvoid union_sets(int a, int b) {\n    a = find_set(a).first;\n    b = find_set(b).first;\n    if (a != b) {\n        if (rank[a] &lt; rank[b])\n            swap(a, b);\n        parent[b] = make_pair(a, 1);\n        if (rank[a] == rank[b])\n            rank[a]++;\n    }\n}\n</code></pre>","tags":["Translated"]},{"location":"data_structures/disjoint_set_union.html#support-the-parity-of-the-path-length-checking-bipartiteness-online","title":"Support the parity of the path length / Checking bipartiteness online","text":"<p>In the same way as computing the path length to the leader, it is possible to maintain the parity of the length of the path before him. Why is this application in a separate paragraph?</p> <p>The unusual requirement of storing the parity of the path comes up in the following task: initially we are given an empty graph, it can be added edges, and we have to answer queries of the form \"is the connected component containing this vertex bipartite?\".</p> <p>To solve this problem, we make a DSU for storing of the components and store the parity of the path up to the representative for each vertex. Thus we can quickly check if adding an edge leads to a violation of the bipartiteness or not: namely if the ends of the edge lie in the same connected component and have the same parity length to the leader, then adding this edge will produce a cycle of odd length, and the component will lose the bipartiteness property.</p> <p>The only difficulty that we face is to compute the parity in the <code>union_find</code> method.</p> <p>If we add an edge $(a, b)$ that connects two connected components into one, then when you attach one tree to another we need to adjust the parity.</p> <p>Let's derive a formula, which computes the parity issued to the leader of the set that will get attached to another set. Let $x$ be the parity of the path length from vertex $a$ up to its leader $A$, and $y$ as the parity of the path length from vertex $b$ up to its leader $B$, and $t$ the desired parity that we have to assign to $B$ after the merge. The path consists of the three parts: from $B$ to $b$, from $b$ to $a$, which is connected by one edge and therefore has parity $1$, and from $a$ to $A$. Therefore we receive the formula ($\\oplus$ denotes the XOR operation):</p> $$t = x \\oplus y \\oplus 1$$ <p>Thus regardless of how many joins we perform, the parity of the edges is carried from one leader to another.</p> <p>We give the implementation of the DSU that supports parity. As in the previous section we use a pair to store the ancestor and the parity. In addition for each set we store in the array <code>bipartite[]</code> whether it is still bipartite or not.</p> <pre><code>void make_set(int v) {\n    parent[v] = make_pair(v, 0);\n    rank[v] = 0;\n    bipartite[v] = true;\n}\n\npair&lt;int, int&gt; find_set(int v) {\n    if (v != parent[v].first) {\n        int parity = parent[v].second;\n        parent[v] = find_set(parent[v].first);\n        parent[v].second ^= parity;\n    }\n    return parent[v];\n}\n\nvoid add_edge(int a, int b) {\n    pair&lt;int, int&gt; pa = find_set(a);\n    a = pa.first;\n    int x = pa.second;\n\n    pair&lt;int, int&gt; pb = find_set(b);\n    b = pb.first;\n    int y = pb.second;\n\n    if (a == b) {\n        if (x == y)\n            bipartite[a] = false;\n    } else {\n        if (rank[a] &lt; rank[b])\n            swap (a, b);\n        parent[b] = make_pair(a, x^y^1);\n        bipartite[a] &amp;= bipartite[b];\n        if (rank[a] == rank[b])\n            ++rank[a];\n    }\n}\n\nbool is_bipartite(int v) {\n    return bipartite[find_set(v).first];\n}\n</code></pre>","tags":["Translated"]},{"location":"data_structures/disjoint_set_union.html#arpa","title":"Offline RMQ (range minimum query) in $O(\\alpha(n))$ on average / Arpa's trick","text":"<p>We are given an array <code>a[]</code> and we have to compute some minima in given segments of the array.</p> <p>The idea to solve this problem with DSU is the following: We will iterate over the array and when we are at the <code>i</code>th element we will answer all queries <code>(L, R)</code> with <code>R == i</code>. To do this efficiently we will keep a DSU using the first <code>i</code> elements with the following structure: the parent of an element is the next smaller element to the right of it. Then using this structure the answer to a query will be the <code>a[find_set(L)]</code>, the smallest number to the right of <code>L</code>.</p> <p>This approach obviously only works offline, i.e. if we know all queries beforehand.</p> <p>It is easy to see that we can apply path compression. And we can also use Union by rank, if we store the actual leader in an separate array.</p> <pre><code>struct Query {\n    int L, R, idx;\n};\n\nvector&lt;int&gt; answer;\nvector&lt;vector&lt;Query&gt;&gt; container;\n</code></pre> <p><code>container[i]</code> contains all queries with <code>R == i</code>.</p> <pre><code>stack&lt;int&gt; s;\nfor (int i = 0; i &lt; n; i++) {\n    while (!s.empty() &amp;&amp; a[s.top()] &gt; a[i]) {\n        parent[s.top()] = i;\n        s.pop();\n    }\n    s.push(i);\n    for (Query q : container[i]) {\n        answer[q.idx] = a[find_set(q.L)];\n    }\n}\n</code></pre> <p>Nowadays this algorithm is known as Arpa's trick. It is named after AmirReza Poorakhavan, who independently discovered and popularized this technique. Although this algorithm existed already before his discovery.</p>","tags":["Translated"]},{"location":"data_structures/disjoint_set_union.html#offline-lca-lowest-common-ancestor-in-a-tree-in-oalphan-on-average","title":"Offline LCA (lowest common ancestor in a tree) in $O(\\alpha(n))$ on average","text":"<p>The algorithm for finding the LCA is discussed in the article Lowest Common Ancestor - Tarjan's off-line algorithm. This algorithm compares favorable with other algorithms for finding the LCA due to its simplicity (especially compared to an optimal algorithm like the one from Farach-Colton and Bender).</p>","tags":["Translated"]},{"location":"data_structures/disjoint_set_union.html#storing-the-dsu-explicitly-in-a-set-list-applications-of-this-idea-when-merging-various-data-structures","title":"Storing the DSU explicitly in a set list / Applications of this idea when merging various data structures","text":"<p>One of the alternative ways of storing the DSU is the preservation of each set in the form of an explicitly stored list of its elements. At the same time each element also stores the reference to the representative of his set.</p> <p>At first glance this looks like an inefficient data structure: by combining two sets we will have to add one list to the end of another and have to update the leadership in all elements of one of the lists.</p> <p>However it turns out, the use of a weighting heuristic (similar to Union by size) can significantly reduce the asymptotic complexity: $O(m + n \\log n)$ to perform $m$ queries on the $n$ elements.</p> <p>Under weighting heuristic we mean, that we will always add the smaller of the two sets to the bigger set. Adding one set to another is easy to implement in <code>union_sets</code> and will take time proportional to the size of the added set. And the search for the leader in <code>find_set</code> will take $O(1)$ with this method of storing.</p> <p>Let us prove the time complexity $O(m + n \\log n)$ for the execution of $m$ queries. We will fix an arbitrary element $x$ and count how often it was touched in the merge operation <code>union_sets</code>. When the element $x$ gets touched the first time, the size of the new set will be at least $2$. When it gets touched the second time, the resulting set will have size of at least $4$, because the smaller set gets added to the bigger one. And so on. This means, that $x$ can only be moved in at most $\\log n$ merge operations. Thus the sum over all vertices gives $O(n \\log n)$ plus $O(1)$ for each request.</p> <p>Here is an implementation:</p> <pre><code>vector&lt;int&gt; lst[MAXN];\nint parent[MAXN];\n\nvoid make_set(int v) {\n    lst[v] = vector&lt;int&gt;(1, v);\n    parent[v] = v;\n}\n\nint find_set(int v) {\n    return parent[v];\n}\n\nvoid union_sets(int a, int b) {\n    a = find_set(a);\n    b = find_set(b);\n    if (a != b) {\n        if (lst[a].size() &lt; lst[b].size())\n            swap(a, b);\n        while (!lst[b].empty()) {\n            int v = lst[b].back();\n            lst[b].pop_back();\n            parent[v] = a;\n            lst[a].push_back (v);\n        }\n    }\n}\n</code></pre> <p>This idea of adding the smaller part to a bigger part can also be used in a lot of solutions that have nothing to do with DSU.</p> <p>For example consider the following problem: we are given a tree, each leaf has a number assigned (same number can appear multiple times on different leaves). We want to compute the number of different numbers in the subtree for every node of the tree.</p> <p>Applying to this task the same idea it is possible to obtain this solution: we can implement a DFS, which will return a pointer to a set of integers - the list of numbers in that subtree. Then to get the answer for the current node (unless of course it is a leaf), we call DFS for all children of that node, and merge all the received sets together. The size of the resulting set will be the answer for the current node. To efficiently combine multiple sets we just apply the above-described recipe: we merge the sets by simply adding smaller ones to larger. In the end we get a $O(n \\log^2 n)$ solution, because one number will only added to a set at most $O(\\log n)$ times.</p>","tags":["Translated"]},{"location":"data_structures/disjoint_set_union.html#storing-the-dsu-by-maintaining-a-clear-tree-structure-online-bridge-finding-in-oalphan-on-average","title":"Storing the DSU by maintaining a clear tree structure / Online bridge finding in $O(\\alpha(n))$ on average","text":"<p>One of the most powerful applications of DSU is that it allows you to store both as compressed and uncompressed trees. The compressed form can be used for merging of trees and for the verification if two vertices are in the same tree, and the uncompressed form can be used - for example - to search for paths between two given vertices, or other traversals of the tree structure.</p> <p>In the implementation this means that in addition to the compressed ancestor array <code>parent[]</code> we will need to keep the array of uncompressed ancestors <code>real_parent[]</code>. It is trivial that maintaining this additional array will not worsen the complexity: changes in it only occur when we merge two trees, and only in one element.</p> <p>On the other hand when applied in practice, we often need to connect trees using a specified edge other that using the two root nodes. This means that we have no other choice but to re-root one of the trees (make the ends of the edge the new root of the tree).</p> <p>At first glance it seems that this re-rooting is very costly and will greatly worsen the time complexity. Indeed, for rooting a tree at vertex $v$ we must go from the vertex to the old root and change directions in <code>parent[]</code> and <code>real_parent[]</code> for all nodes on that path.</p> <p>However in reality it isn't so bad, we can just re-root the smaller of the two trees similar to the ideas in the previous sections, and get $O(\\log n)$ on average.</p> <p>More details (including proof of the time complexity) can be found in the article Finding Bridges Online.</p>","tags":["Translated"]},{"location":"data_structures/disjoint_set_union.html#historical-retrospective","title":"Historical retrospective","text":"<p>The data structure DSU has been known for a long time.</p> <p>This way of storing this structure in the form of a forest of trees was apparently first described by Galler and Fisher in 1964 (Galler, Fisher, \"An Improved Equivalence Algorithm), however the complete analysis of the time complexity was conducted much later.</p> <p>The optimizations path compression and Union by rank has been developed by McIlroy and Morris, and independently of them also by Tritter.</p> <p>Hopcroft and Ullman showed in 1973 the time complexity $O(\\log^\\star n)$ (Hopcroft, Ullman \"Set-merging algorithms\") - here $\\log^\\star$ is the iterated logarithm (this is a slow-growing function, but still not as slow as the inverse Ackermann function).</p> <p>For the first time the evaluation of $O(\\alpha(n))$ was shown in 1975 (Tarjan \"Efficiency of a Good But Not Linear Set Union Algorithm\"). Later in 1985 he, along with Leeuwen, published multiple complexity analyses for several different rank heuristics and ways of compressing the path (Tarjan, Leeuwen \"Worst-case Analysis of Set Union Algorithms\").</p> <p>Finally in 1989 Fredman and Sachs proved that in the adopted model of computation any algorithm for the disjoint set union problem has to work in at least $O(\\alpha(n))$ time on average (Fredman, Saks, \"The cell probe complexity of dynamic data structures\").</p>","tags":["Translated"]},{"location":"data_structures/disjoint_set_union.html#problems","title":"Problems","text":"<ul> <li>TIMUS - Anansi's Cobweb</li> <li>Codeforces - Roads not only in Berland</li> <li>TIMUS - Parity</li> <li>SPOJ - Strange Food Chain</li> <li>SPOJ - COLORFUL ARRAY</li> <li>SPOJ - Consecutive Letters</li> <li>Toph - Unbelievable Array</li> <li>HackerEarth - Lexicographically minimal string</li> <li>HackerEarth - Fight in Ninja World</li> </ul>","tags":["Translated"]},{"location":"data_structures/fenwick.html","title":"Fenwick Tree","text":"<p>Let $f$ be some group operation (a binary associative function over a set with an identity element and inverse elements) and $A$ be an array of integers of length $N$. Denote $f$'s infix notation as $*$; that is, $f(x,y) = x*y$ for arbitrary integers $x,y$. (Since this is associative, we will omit parentheses for order of application of $f$ when using infix notation.)</p> <p>The Fenwick tree is a data structure which:</p> <ul> <li>calculates the value of function $f$ in the given range $[l, r]$ (i.e. $A_l * A_{l+1} * \\dots * A_r$) in $O(\\log N)$ time</li> <li>updates the value of an element of $A$ in $O(\\log N)$ time</li> <li>requires $O(N)$ memory (the same amount required for $A$)</li> <li>is easy to use and code, especially in the case of multidimensional arrays</li> </ul> <p>The most common application of a Fenwick tree is calculating the sum of a range. For example, using addition over the set of integers as the group operation, i.e. $f(x,y) = x + y$: the binary operation, $*$, is $+$ in this case, so $A_l * A_{l+1} * \\dots * A_r = A_l + A_{l+1} + \\dots + A_{r}$.</p> <p>The Fenwick tree is also called a Binary Indexed Tree (BIT). It was first described in a paper titled \"A new data structure for cumulative frequency tables\" (Peter M. Fenwick, 1994).</p>","tags":["Translated"]},{"location":"data_structures/fenwick.html#description","title":"Description","text":"","tags":["Translated"]},{"location":"data_structures/fenwick.html#overview","title":"Overview","text":"<p>For the sake of simplicity, we will assume that function $f$ is defined as $f(x,y) = x + y$ over the integers.</p> <p>Suppose we are given an array of integers, $A[0 \\dots N-1]$. (Note that we are using zero-based indexing.) A Fenwick tree is just an array, $T[0 \\dots N-1]$, where each element is equal to the sum of elements of $A$ in some range, $[g(i), i]$:</p> $$T_i = \\sum_{j = g(i)}^{i}{A_j}$$ <p>where $g$ is some function that satisfies $0 \\le g(i) \\le i$. We will define $g$ in the next few paragraphs.</p> <p>The data structure is called a tree because there is a nice representation of it in the form of a tree, although we don't need to model an actual tree with nodes and edges. We only need to maintain the array $T$ to handle all queries.</p> <p>Note: The Fenwick tree presented here uses zero-based indexing. Many people use a version of the Fenwick tree that uses one-based indexing. As such, you will also find an alternative implementation which uses one-based indexing in the implementation section. Both versions are equivalent in terms of time and memory complexity.</p> <p>Now we can write some pseudo-code for the two operations mentioned above. Below, we get the sum of elements of $A$ in the range $[0, r]$ and update (increase) some element $A_i$:</p> <pre><code>def sum(int r):\n    res = 0\n    while (r &gt;= 0):\n        res += t[r]\n        r = g(r) - 1\n    return res\n\ndef increase(int i, int delta):\n    for all j with g(j) &lt;= i &lt;= j:\n        t[j] += delta\n</code></pre> <p>The function <code>sum</code> works as follows:</p> <ol> <li>First, it adds the sum of the range $[g(r), r]$ (i.e. $T[r]$) to the <code>result</code>.</li> <li>Then, it \"jumps\" to the range $[g(g(r)-1), g(r)-1]$ and adds this range's sum to the <code>result</code>.</li> <li>This continues until it \"jumps\" from $[0, g(g( \\dots g(r)-1 \\dots -1)-1)]$ to $[g(-1), -1]$; this is where the <code>sum</code> function stops jumping.</li> </ol> <p>The function <code>increase</code> works with the same analogy, but it \"jumps\" in the direction of increasing indices:</p> <ol> <li>The sum for each range of the form $[g(j), j]$ which satisfies the condition $g(j) \\le i \\le j$ is increased by <code>delta</code>; that is, <code>t[j] += delta</code>. Therefore, it updates all elements in $T$ that correspond to ranges in which $A_i$ lies.</li> </ol> <p>The complexity of both <code>sum</code> and <code>increase</code> depend on the function $g$. There are many ways to choose the function $g$ such that $0 \\le g(i) \\le i$ for all $i$. For instance, the function $g(i) = i$ works, which yields $T = A$ (in which case, the summation queries are slow). We could also take the function $g(i) = 0$. This would correspond to prefix sum arrays (in which case, finding the sum of the range $[0, i]$ will only take constant time; however, updates are slow). The clever part of the algorithm for Fenwick trees is how it uses a special definition of the function $g$ which can handle both operations in $O(\\log N)$ time.</p>","tags":["Translated"]},{"location":"data_structures/fenwick.html#definition-of-gi","title":"Definition of $g(i)$","text":"<p>The computation of $g(i)$ is defined using the following simple operation: we replace all trailing $1$ bits in the binary representation of $i$ with $0$ bits.</p> <p>In other words, if the least significant digit of $i$ in binary is $0$, then $g(i) = i$. And otherwise the least significant digit is a $1$, and we take this $1$ and all other trailing $1$s and flip them.</p> <p>For instance we get</p> $$\\begin{align} g(11) = g(1011_2) = 1000_2 &amp;= 8 \\\\\\\\ g(12) = g(1100_2) = 1100_2 &amp;= 12 \\\\\\\\ g(13) = g(1101_2) = 1100_2 &amp;= 12 \\\\\\\\ g(14) = g(1110_2) = 1110_2 &amp;= 14 \\\\\\\\ g(15) = g(1111_2) = 0000_2 &amp;= 0 \\\\\\\\ \\end{align}$$ <p>There exists a simple implementation using bitwise operations for the non-trivial operation described above:</p> $$g(i) = i ~\\&amp;~ (i+1),$$ <p>where $\\&amp;$ is the bitwise AND operator. It is not hard to convince yourself that this solution does the same thing as the operation described above.</p> <p>Now, we just need to find a way to iterate over all $j$'s, such that $g(j) \\le i \\le j$.</p> <p>It is easy to see that we can find all such $j$'s by starting with $i$ and flipping the last unset bit. We will call this operation $h(j)$. For example, for $i = 10$ we have:</p> $$\\begin{align} 10 &amp;= 0001010_2 \\\\\\\\ h(10) = 11 &amp;= 0001011_2 \\\\\\\\ h(11) = 15 &amp;= 0001111_2 \\\\\\\\ h(15) = 31 &amp;= 0011111_2 \\\\\\\\ h(31) = 63 &amp;= 0111111_2 \\\\\\\\ \\vdots &amp; \\end{align}$$ <p>Unsurprisingly, there also exists a simple way to perform $h$ using bitwise operations:</p> $$h(j) = j ~|~ (j+1),$$ <p>where $|$ is the bitwise OR operator.</p> <p>The following image shows a possible interpretation of the Fenwick tree as tree. The nodes of the tree show the ranges they cover.</p>","tags":["Translated"]},{"location":"data_structures/fenwick.html#implementation","title":"Implementation","text":"","tags":["Translated"]},{"location":"data_structures/fenwick.html#finding-sum-in-one-dimensional-array","title":"Finding sum in one-dimensional array","text":"<p>Here we present an implementation of the Fenwick tree for sum queries and single updates.</p> <p>The normal Fenwick tree can only answer sum queries of the type $[0, r]$ using <code>sum(int r)</code>, however we can also answer other queries of the type $[l, r]$ by computing two sums $[0, r]$ and $[0, l-1]$ and subtract them. This is handled in the <code>sum(int l, int r)</code> method.</p> <p>Also this implementation supports two constructors. You can create a Fenwick tree initialized with zeros, or you can convert an existing array into the Fenwick form.</p> <pre><code>struct FenwickTree {\n    vector&lt;int&gt; bit;  // binary indexed tree\n    int n;\n\n    FenwickTree(int n) {\n        this-&gt;n = n;\n        bit.assign(n, 0);\n    }\n\n    FenwickTree(vector&lt;int&gt; const &amp;a) : FenwickTree(a.size()) {\n        for (size_t i = 0; i &lt; a.size(); i++)\n            add(i, a[i]);\n    }\n\n    int sum(int r) {\n        int ret = 0;\n        for (; r &gt;= 0; r = (r &amp; (r + 1)) - 1)\n            ret += bit[r];\n        return ret;\n    }\n\n    int sum(int l, int r) {\n        return sum(r) - sum(l - 1);\n    }\n\n    void add(int idx, int delta) {\n        for (; idx &lt; n; idx = idx | (idx + 1))\n            bit[idx] += delta;\n    }\n};\n</code></pre>","tags":["Translated"]},{"location":"data_structures/fenwick.html#linear-construction","title":"Linear construction","text":"<p>The above implementation requires $O(N \\log N)$ time. It's possible to improve that to $O(N)$ time.</p> <p>The idea is, that the number $a[i]$ at index $i$ will contribute to the range stored in $bit[i]$, and to all ranges that the index $i | (i + 1)$ contributes to. So by adding the numbers in order, you only have to push the current sum further to the next range, where it will then get pushed further to the next range, and so on.</p> <pre><code>FenwickTree(vector&lt;int&gt; const &amp;a) : FenwickTree(a.size()){\n    for (int i = 0; i &lt; n; i++) {\n        bit[i] += a[i];\n        int r = i | (i + 1);\n        if (r &lt; n) bit[r] += bit[i];\n    }\n}\n</code></pre>","tags":["Translated"]},{"location":"data_structures/fenwick.html#finding-minimum-of-0-r-in-one-dimensional-array","title":"Finding minimum of $[0, r]$ in one-dimensional array","text":"<p>It is obvious that there is no easy way of finding minimum of range $[l, r]$ using Fenwick tree, as Fenwick tree can only answer queries of type $[0, r]$. Additionally, each time a value is <code>update</code>'d, the new value has to be smaller than the current value. Both significant limitations are because the $min$ operation together with the set of integers doesn't form a group, as there are no inverse elements.</p> <pre><code>struct FenwickTreeMin {\n    vector&lt;int&gt; bit;\n    int n;\n    const int INF = (int)1e9;\n\n    FenwickTreeMin(int n) {\n        this-&gt;n = n;\n        bit.assign(n, INF);\n    }\n\n    FenwickTreeMin(vector&lt;int&gt; a) : FenwickTreeMin(a.size()) {\n        for (size_t i = 0; i &lt; a.size(); i++)\n            update(i, a[i]);\n    }\n\n    int getmin(int r) {\n        int ret = INF;\n        for (; r &gt;= 0; r = (r &amp; (r + 1)) - 1)\n            ret = min(ret, bit[r]);\n        return ret;\n    }\n\n    void update(int idx, int val) {\n        for (; idx &lt; n; idx = idx | (idx + 1))\n            bit[idx] = min(bit[idx], val);\n    }\n};\n</code></pre> <p>Note: it is possible to implement a Fenwick tree that can handle arbitrary minimum range queries and arbitrary updates. The paper Efficient Range Minimum Queries using Binary Indexed Trees describes such an approach. However with that approach you need to maintain a second binary indexed tree over the data, with a slightly different structure, since one tree is not enough to store the values of all elements in the array. The implementation is also a lot harder compared to the normal implementation for sums.</p>","tags":["Translated"]},{"location":"data_structures/fenwick.html#finding-sum-in-two-dimensional-array","title":"Finding sum in two-dimensional array","text":"<p>As claimed before, it is very easy to implement Fenwick Tree for multidimensional array.</p> <pre><code>struct FenwickTree2D {\n    vector&lt;vector&lt;int&gt;&gt; bit;\n    int n, m;\n\n    // init(...) { ... }\n\n    int sum(int x, int y) {\n        int ret = 0;\n        for (int i = x; i &gt;= 0; i = (i &amp; (i + 1)) - 1)\n            for (int j = y; j &gt;= 0; j = (j &amp; (j + 1)) - 1)\n                ret += bit[i][j];\n        return ret;\n    }\n\n    void add(int x, int y, int delta) {\n        for (int i = x; i &lt; n; i = i | (i + 1))\n            for (int j = y; j &lt; m; j = j | (j + 1))\n                bit[i][j] += delta;\n    }\n};\n</code></pre>","tags":["Translated"]},{"location":"data_structures/fenwick.html#one-based-indexing-approach","title":"One-based indexing approach","text":"<p>For this approach we change the requirements and definition for $T[]$ and $g()$ a little bit. We want $T[i]$ to store the sum of $[g(i)+1; i]$. This changes the implementation a little bit, and allows for a similar nice definition for $g(i)$:</p> <pre><code>def sum(int r):\n    res = 0\n    while (r &gt; 0):\n        res += t[r]\n        r = g(r)\n    return res\n\ndef increase(int i, int delta):\n    for all j with g(j) &lt; i &lt;= j:\n        t[j] += delta\n</code></pre> <p>The computation of $g(i)$ is defined as: toggling of the last set $1$ bit in the binary representation of $i$.</p> $$\\begin{align} g(7) = g(111_2) = 110_2 &amp;= 6 \\\\\\\\ g(6) = g(110_2) = 100_2 &amp;= 4 \\\\\\\\ g(4) = g(100_2) = 000_2 &amp;= 0 \\\\\\\\ \\end{align}$$ <p>The last set bit can be extracted using $i ~\\&amp;~ (-i)$, so the operation can be expressed as:</p> $$g(i) = i - (i ~\\&amp;~ (-i)).$$ <p>And it's not hard to see, that you need to change all values $T[j]$ in the sequence $i,~ h(i),~ h(h(i)),~ \\dots$ when you want to update $A[j]$, where $h(i)$ is defined as:</p> $$h(i) = i + (i ~\\&amp;~ (-i)).$$ <p>As you can see, the main benefit of this approach is that the binary operations complement each other very nicely.</p> <p>The following implementation can be used like the other implementations, however it uses one-based indexing internally.</p> <pre><code>struct FenwickTreeOneBasedIndexing {\n    vector&lt;int&gt; bit;  // binary indexed tree\n    int n;\n\n    FenwickTreeOneBasedIndexing(int n) {\n        this-&gt;n = n + 1;\n        bit.assign(n + 1, 0);\n    }\n\n    FenwickTreeOneBasedIndexing(vector&lt;int&gt; a)\n        : FenwickTreeOneBasedIndexing(a.size()) {\n        for (size_t i = 0; i &lt; a.size(); i++)\n            add(i, a[i]);\n    }\n\n    int sum(int idx) {\n        int ret = 0;\n        for (++idx; idx &gt; 0; idx -= idx &amp; -idx)\n            ret += bit[idx];\n        return ret;\n    }\n\n    int sum(int l, int r) {\n        return sum(r) - sum(l - 1);\n    }\n\n    void add(int idx, int delta) {\n        for (++idx; idx &lt; n; idx += idx &amp; -idx)\n            bit[idx] += delta;\n    }\n};\n</code></pre>","tags":["Translated"]},{"location":"data_structures/fenwick.html#range-operations","title":"Range operations","text":"<p>A Fenwick tree can support the following range operations:</p> <ol> <li>Point Update and Range Query</li> <li>Range Update and Point Query</li> <li>Range Update and Range Query</li> </ol>","tags":["Translated"]},{"location":"data_structures/fenwick.html#1-point-update-and-range-query","title":"1. Point Update and Range Query","text":"<p>This is just the ordinary Fenwick tree as explained above.</p>","tags":["Translated"]},{"location":"data_structures/fenwick.html#2-range-update-and-point-query","title":"2. Range Update and Point Query","text":"<p>Using simple tricks we can also do the reverse operations: increasing ranges and querying for single values.</p> <p>Let the Fenwick tree be initialized with zeros. Suppose that we want to increment the interval $[l, r]$ by $x$. We make two point update operations on Fenwick tree which are <code>add(l, x)</code> and <code>add(r+1, -x)</code>.</p> <p>If we want to get the value of $A[i]$, we just need to take the prefix sum using the ordinary range sum method. To see why this is true, we can just focus on the previous increment operation again. If $i &lt; l$, then the two update operations have no effect on the query and we get the sum $0$. If $i \\in [l, r]$, then we get the answer $x$ because of the first update operation. And if $i &gt; r$, then the second update operation will cancel the effect of first one.</p> <p>The following implementation uses one-based indexing.</p> <pre><code>void add(int idx, int val) {\n    for (++idx; idx &lt; n; idx += idx &amp; -idx)\n        bit[idx] += val;\n}\n\nvoid range_add(int l, int r, int val) {\n    add(l, val);\n    add(r + 1, -val);\n}\n\nint point_query(int idx) {\n    int ret = 0;\n    for (++idx; idx &gt; 0; idx -= idx &amp; -idx)\n        ret += bit[idx];\n    return ret;\n}\n</code></pre> <p>Note: of course it is also possible to increase a single point $A[i]$ with <code>range_add(i, i, val)</code>.</p>","tags":["Translated"]},{"location":"data_structures/fenwick.html#3-range-update-and-range-query","title":"3. Range Update and Range Query","text":"<p>To support both range updates and range queries we will use two BITs namely $B_1[]$ and $B_2[]$, initialized with zeros.</p> <p>Suppose that we want to increment the interval $[l, r]$ by the value $x$. Similarly as in the previous method, we perform two point updates on $B_1$: <code>add(B1, l, x)</code> and <code>add(B1, r+1, -x)</code>. And we also update $B_2$. The details will be explained later.</p> <p><pre><code>def range_add(l, r, x):\n    add(B1, l, x)\n    add(B1, r+1, -x)\n    add(B2, l, x*(l-1))\n    add(B2, r+1, -x*r))\n</code></pre> After the range update $(l, r, x)$ the range sum query should return the following values:</p> $$ sum[0, i]= \\begin{cases} 0 &amp; i &lt; l \\\\\\\\ x \\cdot (i-(l-1)) &amp; l \\le i \\le r \\\\\\\\ x \\cdot (r-l+1) &amp; i &gt; r \\\\\\\\ \\end{cases} $$ <p>We can write the range sum as difference of two terms, where we use $B_1$ for first term and $B_2$ for second term. The difference of the queries will give us prefix sum over $[0, i]$.</p> $$\\begin{align} sum[0, i] &amp;= sum(B_1, i) \\cdot i - sum(B_2, i) \\\\\\\\ &amp;= \\begin{cases} 0 \\cdot i - 0 &amp; i &lt; l\\\\\\\\ x \\cdot i - x \\cdot (l-1) &amp; l \\le i \\le r \\\\\\\\ 0 \\cdot i - (x \\cdot (l-1) - x \\cdot r) &amp; i &gt; r \\\\\\\\ \\end{cases} \\end{align} $$ <p>The last expression is exactly equal to the required terms. Thus we can use $B_2$ for shaving off extra terms when we multiply $B_1[i]\\times i$.</p> <p>We can find arbitrary range sums by computing the prefix sums for $l-1$ and $r$ and taking the difference of them again.</p> <pre><code>def add(b, idx, x):\n    while idx &lt;= N:\n        b[idx] += x\n        idx += idx &amp; -idx\n\ndef range_add(l,r,x):\n    add(B1, l, x)\n    add(B1, r+1, -x)\n    add(B2, l, x*(l-1))\n    add(B2, r+1, -x*r)\n\ndef sum(b, idx):\n    total = 0\n    while idx &gt; 0:\n        total += b[idx]\n        idx -= idx &amp; -idx\n    return total\n\ndef prefix_sum(idx):\n    return sum(B1, idx)*idx -  sum(B2, idx)\n\ndef range_sum(l, r):\n    return prefix_sum(r) - prefix_sum(l-1)\n</code></pre>","tags":["Translated"]},{"location":"data_structures/fenwick.html#practice-problems","title":"Practice Problems","text":"<ul> <li>UVA 12086 - Potentiometers</li> <li>LOJ 1112 - Curious Robin Hood</li> <li>LOJ 1266 - Points in Rectangle</li> <li>Codechef - SPREAD</li> <li>SPOJ - CTRICK</li> <li>SPOJ - MATSUM</li> <li>SPOJ - DQUERY</li> <li>SPOJ - NKTEAM</li> <li>SPOJ - YODANESS</li> <li>SRM 310 - FloatingMedian</li> <li>SPOJ - Ada and Behives</li> <li>Hackerearth - Counting in Byteland</li> <li>DevSkill - Shan and String (archived)</li> <li>Codeforces - Little Artem and Time Machine</li> <li>Codeforces - Hanoi Factory</li> <li>SPOJ - Tulip and Numbers</li> <li>SPOJ - SUMSUM</li> <li>SPOJ - Sabir and Gifts</li> <li>SPOJ - The Permutation Game Again</li> <li>SPOJ - Zig when you Zag</li> <li>SPOJ - Cryon</li> <li>SPOJ - Weird Points</li> <li>SPOJ - Its a Murder</li> <li>SPOJ - Bored of Suffixes and Prefixes</li> <li>SPOJ - Mega Inversions</li> <li>Codeforces - Subsequences</li> <li>Codeforces - Ball</li> <li>GYM - The Kamphaeng Phet's Chedis</li> <li>Codeforces - Garlands</li> <li>Codeforces - Inversions after Shuffle</li> <li>GYM - Cairo Market</li> <li>Codeforces - Goodbye Souvenir</li> <li>SPOJ - Ada and Species</li> <li>Codeforces - Thor</li> <li>CSES - Forest Queries II</li> <li>Latin American Regionals 2017 - Fundraising</li> </ul>","tags":["Translated"]},{"location":"data_structures/fenwick.html#other-sources","title":"Other sources","text":"<ul> <li>Fenwick tree on Wikipedia</li> <li>Binary indexed trees tutorial on TopCoder</li> <li>Range updates and queries </li> </ul>","tags":["Translated"]},{"location":"data_structures/randomized_heap.html","title":"Randomized Heap","text":"<p>A randomized heap is a heap that, through using randomization, allows to perform all operations in expected logarithmic time.</p> <p>A min heap is a binary tree in which the value of each vertex is less than or equal to the values of its children. Thus the minimum of the tree is always in the root vertex.</p> <p>A max heap can be defined in a similar way: by replacing less with greater.</p> <p>The default operations of a heap are:</p> <ul> <li>Adding a value</li> <li>Extracting the minimum</li> <li>Removing the minimum</li> <li>Merging two heaps (without deleting duplicates)</li> <li>Removing an arbitrary element (if its position in the tree is known)</li> </ul> <p>A randomized heap can perform all these operations in expected $O(\\log n)$ time with a very simple implementation.</p>","tags":["Translated"]},{"location":"data_structures/randomized_heap.html#data-structure","title":"Data structure","text":"<p>We can immediately describe the structure of the binary heap:</p> <pre><code>struct Tree {\n    int value;\n    Tree * l = nullptr;\n    Tree * r = nullptr;\n};\n</code></pre> <p>In the vertex we store a value. In addition we have pointers to the left and right children, which are point to null if the corresponding child doesn't exist.</p>","tags":["Translated"]},{"location":"data_structures/randomized_heap.html#operations","title":"Operations","text":"<p>It is not difficult to see, that all operations can be reduced to a single one: merging two heaps into one. Indeed, adding a new value to the heap is equivalent to merging the heap with a heap consisting of a single vertex with that value.  Finding a minimum doesn't require any operation at all - the minimum is simply the value at the root. Removing the minimum is equivalent to the result of merging the left and right children of the root vertex. And removing an arbitrary element is similar. We merge the children of the vertex and replace the vertex with the result of the merge.</p> <p>So we actually only need to implement the operation of merging two heaps. All other operations are trivially reduced to this operation.</p> <p>Let two heaps $T_1$ and $T_2$ be given. It is clear that the root of each of these heaps contains its minimum. So the root of the resulting heap will be the minimum of these two values. So we compare both values, and use the smaller one as the new root. Now we have to combine the children of the selected vertex with the remaining heap. For this we select one of the children, and merge it with the remaining heap. Thus we again have the operation of merging two heaps. Sooner of later this process will end (the number of such steps is limited by the sum of the heights of the two heaps)</p> <p>To achieve logarithmic complexity on average, we need to specify a method for choosing one of the two children so that the average path length is logarithmic. It is not difficult to guess, that we will make this decision randomly. Thus the implementation of the merging operation is as follows:</p> <pre><code>Tree* merge(Tree* t1, Tree* t2) {\n    if (!t1 || !t2)\n        return t1 ? t1 : t2;\n    if (t2-&gt;value &lt; t1-&gt;value)\n        swap(t1, t2);\n    if (rand() &amp; 1)\n        swap(t1-&gt;l, t1-&gt;r);\n    t1-&gt;l = merge(t1-&gt;l, t2);\n    return t1;\n}\n</code></pre> <p>Here first we check if one of the heaps is empty, then we don't need to perform any merge action at all. Otherwise we make the heap <code>t1</code> the one with the smaller value (by swapping <code>t1</code> and <code>t2</code> if necessary). We want to merge the left child of <code>t1</code> with <code>t2</code>, therefore we randomly swap the children of <code>t1</code>, and then perform the merge.</p>","tags":["Translated"]},{"location":"data_structures/randomized_heap.html#complexity","title":"Complexity","text":"<p>We introduce the random variable $h(T)$ which will denote the length of the random path from the root to the leaf (the length in the number of edges). It is clear that the algorithm <code>merge</code> performs $O(h(T_1) + h(T_2))$ steps. Therefore to understand the complexity of the operations, we must look into the random variable $h(T)$.</p>","tags":["Translated"]},{"location":"data_structures/randomized_heap.html#expected-value","title":"Expected value","text":"<p>We assume that the expectation $h(T)$ can be estimated from above by the logarithm of the number of vertices in the heap:</p> $$\\mathbf{E} h(T) \\le \\log(n+1)$$ <p>This can be easily proven by induction. Let $L$ and $R$ be the left and the right subtrees of the root $T$, and $n_L$ and $n_R$ the number of vertices in them ($n = n_L + n_R + 1$).</p> <p>The following shows the induction step:</p> $$\\begin{align} \\mathbf{E} h(T) &amp;= 1 + \\frac{\\mathbf{E} h(L) + \\mathbf{E} h(R)}{2}  \\le 1 + \\frac{\\log(n_L + 1) \\log(n_R + 1)}{2} \\\\\\\\ &amp;= 1 + \\log\\sqrt{(n_L + 1)(n_R + 1)} = \\log 2\\sqrt{(n_L + 1)(n_R + 1)} \\\\\\\\ &amp;\\le \\log \\frac{2\\left((n_L + 1) + (n_R + 1)\\right)}{2} = \\log(n_L + n_R + 2) = \\log(n+1) \\end{align}$$","tags":["Translated"]},{"location":"data_structures/randomized_heap.html#exceeding-the-expected-value","title":"Exceeding the expected value","text":"<p>Of course we are still not happy. The expected value of $h(T)$ doesn't say anything about the worst case. It is still possible that the paths from the root to the vertices is on average much greater than $\\log(n + 1)$ for a specific tree.</p> <p>Let us prove that exceeding the expected value is indeed very small:</p> $$P\\{h(T) &gt; (c+1) \\log n\\} &lt; \\frac{1}{n^c}$$ <p>for any positive constant $c$.</p> <p>Here we denote by $P$ the set of paths from the root of the heap to the leaves where the length exceeds $(c+1) \\log n$. Note that for any path $p$ of length $|p|$ the probability that it will be chosen as random path is $2^{-|p|}$. Therefore we get:</p> $$P\\{h(T) &gt; (c+1) \\log n\\} = \\sum_{p \\in P} 2^{-|p|} &lt; \\sum_{p \\in P} 2^{-(c+1) \\log n} = |P| n^{-(c+1)} \\le n^{-c}$$","tags":["Translated"]},{"location":"data_structures/randomized_heap.html#complexity-of-the-algorithm","title":"Complexity of the algorithm","text":"<p>Thus the algorithm <code>merge</code>, and hence all other operations expressed with it, can be performed in $O(\\log n)$ on average.</p> <p>Moreover for any positive constant $\\epsilon$ there is a positive constant $c$, such that the probability that the operation will require more than $c \\log n$ steps is less than $n^{-\\epsilon}$ (in some sense this describes the worst case behavior of the algorithm).</p>","tags":["Translated"]},{"location":"data_structures/segment_tree.html","title":"Segment Tree","text":"<p>A Segment Tree is a data structure that stores information about array intervals as a tree. This allows answering range queries over an array efficiently, while still being flexible enough to allow quick modification of the array. This includes finding the sum of consecutive array elements $a[l \\dots r]$, or finding the minimum element in a such a range in $O(\\log n)$ time.  Between answering such queries, the Segment Tree allows modifying the array by replacing one element, or even changing the elements of a whole subsegment (e.g. assigning all elements $a[l \\dots r]$ to any value, or adding a value to all element in the subsegment). </p> <p>In general, a Segment Tree is a very flexible data structure, and a huge number of problems can be solved with it.  Additionally, it is also possible to apply more complex operations and answer more complex queries (see Advanced versions of Segment Trees). In particular the Segment Tree can be easily generalized to larger dimensions.  For instance, with a two-dimensional Segment Tree you can answer sum or minimum queries over some subrectangle of a given matrix in only $O(\\log^2 n)$ time. </p> <p>One important property of Segment Trees is that they require only a linear amount of memory. The standard Segment Tree requires $4n$ vertices for working on an array of size $n$. </p>","tags":["Translated"]},{"location":"data_structures/segment_tree.html#simplest-form-of-a-segment-tree","title":"Simplest form of a Segment Tree","text":"<p>To start easy, we consider the simplest form of a Segment Tree.  We want to answer sum queries efficiently.  The formal definition of our task is: Given an array $a[0 \\dots n-1]$, the Segment Tree must be able to find the sum of elements between the indices $l$ and $r$ (i.e. computing the sum $\\sum_{i=l}^r a[i]$), and also handle changing values of the elements in the array (i.e. perform assignments of the form $a[i] = x$). The Segment Tree should be able to process both queries in $O(\\log n)$ time.</p> <p>This is an improvement over the simpler approaches. A naive array implementation - just using a simple array - can update elements in $O(1)$, but requires $O(n)$ to compute each sum query. And precomputed prefix sums can compute sum queries in $O(1)$, but updating an array element requires $O(n)$ changes to the prefix sums.</p>","tags":["Translated"]},{"location":"data_structures/segment_tree.html#structure-of-the-segment-tree","title":"Structure of the Segment Tree","text":"<p>We can take a divide-and-conquer approach when it comes to array segments.  We compute and store the sum of the elements of the whole array, i.e. the sum of the segment $a[0 \\dots n-1]$.  We then split the array into two halves $a[0 \\dots n/2-1]$ and $a[n/2 \\dots n-1]$ and compute the sum of each halve and store them.  Each of these two halves in turn are split in half, and so on until all segments reach size $1$. </p> <p>We can view these segments as forming a binary tree:  the root of this tree is the segment $a[0 \\dots n-1]$, and each vertex (except leaf vertices) has exactly two child vertices.  This is why the data structure is called \"Segment Tree\", even though in most implementations the tree is not constructed explicitly (see Implementation).</p> <p>Here is a visual representation of such a Segment Tree over the array $a = [1, 3, -2, 8, -7]$:</p> <p></p> <p>From this short description of the data structure, we can already conclude that a Segment Tree only requires a linear number of vertices.  The first level of the tree contains a single node (the root), the second level will contain two vertices, in the third it will contain four vertices, until the number of vertices reaches $n$.  Thus the number of vertices in the worst case can be estimated by the sum $1 + 2 + 4 + \\dots + 2^{\\lceil\\log_2 n\\rceil} \\lt 2^{\\lceil\\log_2 n\\rceil + 1} \\lt 4n$.</p> <p>It is worth noting that whenever $n$ is not a power of two, not all levels of the Segment Tree will be completely filled.  We can see that behavior in the image. For now we can forget about this fact, but it will become important later during the implementation.</p> <p>The height of the Segment Tree is $O(\\log n)$, because when going down from the root to the leaves the size of the segments decreases approximately by half. </p>","tags":["Translated"]},{"location":"data_structures/segment_tree.html#construction","title":"Construction","text":"<p>Before constructing the segment tree, we need to decide:</p> <ol> <li>the value that gets stored at each node of the segment tree.    For example, in a sum segment tree, a node would store the sum of the elements in its range $[l, r]$.</li> <li>the merge operation that merges two siblings in a segment tree.    For example, in a sum segment tree, the two nodes corresponding to the ranges $a[l_1 \\dots r_1]$ and $a[l_2 \\dots r_2]$ would be merged into a node corresponding to the range $a[l_1 \\dots r_2]$ by adding the values of the two nodes.</li> </ol> <p>Note that a vertex is a \"leaf vertex\", if its corresponding segment covers only one value in the original array. It is present at the lowermost level of a segment tree. Its value would be equal to the (corresponding) element $a[i]$. </p> <p>Now, for construction of the segment tree, we start at the bottom level (the leaf vertices) and assign them their respective values. On the basis of these values, we can compute the values of the previous level, using the <code>merge</code> function. And on the basis of those, we can compute the values of the previous, and repeat the procedure until we reach the root vertex. </p> <p>It is convenient to describe this operation recursively in the other direction, i.e., from the root vertex to the leaf vertices. The construction procedure, if called on a non-leaf vertex, does the following:</p> <ol> <li>recursively construct the values of the two child vertices</li> <li>merge the computed values of these children.</li> </ol> <p>We start the construction at the root vertex, and hence, we are able to compute the entire segment tree.</p> <p>The time complexity of this construction is $O(n)$, assuming that the merge operation is constant time (the merge operation gets called $n$ times, which is equal to the number of internal nodes in the segment tree).</p>","tags":["Translated"]},{"location":"data_structures/segment_tree.html#sum-queries","title":"Sum queries","text":"<p>For now we are going to answer sum queries. As an input we receive two integers $l$ and $r$, and we have to compute the sum of the segment $a[l \\dots r]$ in $O(\\log n)$ time. </p> <p>To do this, we will traverse the Segment Tree and use the precomputed sums of the segments. Let's assume that we are currently at the vertex that covers the segment $a[tl \\dots tr]$. There are three possible cases. </p> <p>The easiest case is when the segment $a[l \\dots r]$ is equal to the corresponding segment of the current vertex (i.e. $a[l \\dots r] = a[tl \\dots tr]$), then we are finished and can return the precomputed sum that is stored in the vertex.</p> <p>Alternatively the segment of the query can fall completely into the domain of either the left or the right child. Recall that the left child covers the segment $a[tl \\dots tm]$ and the right vertex covers the segment $a[tm + 1 \\dots tr]$ with $tm = (tl + tr) / 2$.  In this case we can simply go to the child vertex, which corresponding segment covers the query segment, and execute the algorithm described here with that vertex. </p> <p>And then there is the last case, the query segment intersects with both children.  In this case we have no other option as to make two recursive calls, one for each child. First we go to the left child, compute a partial answer for this vertex (i.e. the sum of values of the intersection between the segment of the query and the segment of the left child), then go to the right child, compute the partial answer using that vertex, and then combine the answers by adding them.  In other words, since the left child represents the segment $a[tl \\dots tm]$ and the right child the segment $a[tm+1 \\dots tr]$, we compute the sum query $a[l \\dots tm]$ using the left child, and the sum query $a[tm+1 \\dots r]$ using the right child. </p> <p>So processing a sum query is a function that recursively calls itself once with either the left or the right child (without changing the query boundaries), or twice, once for the left and once for the right child (by splitting the query into two subqueries).  And the recursion ends, whenever the boundaries of the current query segment coincides with the boundaries of the segment of the current vertex.  In that case the answer will be the precomputed value of the sum of this segment, which is stored in the tree.</p> <p>In other words, the calculation of the query is a traversal of the tree, which spreads through all necessary branches of the tree, and uses the precomputed sum values of the segments in the tree. </p> <p>Obviously we will start the traversal from the root vertex of the Segment Tree.</p> <p>The procedure is illustrated in the following image. Again the array $a = [1, 3, -2, 8, -7]$ is used, and here we want to compute the sum $\\sum_{i=2}^4 a[i]$. The colored vertices will be visited, and we will use the precomputed values of the green vertices. This gives us the result $-2 + 1 = -1$.</p> <p></p> <p>Why is the complexity of this algorithm $O(\\log n)$? To show this complexity we look at each level of the tree.  It turns out, that for each level we only visit not more than four vertices.  And since the height of the tree is $O(\\log n)$, we receive the desired running time. </p> <p>We can show that this proposition (at most four vertices each level) is true by induction. At the first level, we only visit one vertex, the root vertex, so here we visit less than four vertices.  Now let's look at an arbitrary level. By induction hypothesis, we visit at most four vertices.  If we only visit at most two vertices, the next level has at most four vertices. That is trivial, because each vertex can only cause at most two recursive calls.  So let's assume that we visit three or four vertices in the current level.  From those vertices, we will analyze the vertices in the middle more carefully.  Since the sum query asks for the sum of a continuous subarray, we know that segments corresponding to the visited vertices in the middle will be completely covered by the segment of the sum query.  Therefore these vertices will not make any recursive calls.  So only the most left, and the most right vertex will have the potential to make recursive calls.  And those will only create at most four recursive calls, so also the next level will satisfy the assertion. We can say that one branch approaches the left boundary of the query, and the second branch approaches the right one. </p> <p>Therefore we visit at most $4 \\log n$ vertices in total, and that is equal to a running time of $O(\\log n)$. </p> <p>In conclusion the query works by dividing the input segment into several sub-segments for which all the sums are already precomputed and stored in the tree.  And if we stop partitioning whenever the query segment coincides with the vertex segment, then we only need $O(\\log n)$ such segments, which gives the effectiveness of the Segment Tree. </p>","tags":["Translated"]},{"location":"data_structures/segment_tree.html#update-queries","title":"Update queries","text":"<p>Now we want to modify a specific element in the array, let's say we want to do the assignment $a[i] = x$.  And we have to rebuild the Segment Tree, such that it corresponds to the new, modified array. </p> <p>This query is easier than the sum query.  Each level of a Segment Tree forms a partition of the array.  Therefore an element $a[i]$ only contributes to one segment from each level.  Thus only $O(\\log n)$ vertices need to be updated. </p> <p>It is easy to see, that the update request can be implemented using a recursive function.  The function gets passed the current tree vertex, and it recursively calls itself with one of the two child vertices (the one that contains $a[i]$ in its segment), and after that recomputes its sum value, similar how it is done in the build method (that is as the sum of its two children). </p> <p>Again here is a visualization using the same array. Here we perform the update $a[2] = 3$. The green vertices are the vertices that we visit and update.</p> <p></p>","tags":["Translated"]},{"location":"data_structures/segment_tree.html#implementation","title":"Implementation","text":"<p>The main consideration is how to store the Segment Tree. Of course we can define a $\\text{Vertex}$ struct and create objects, that store the boundaries of the segment, its sum and additionally also pointers to its child vertices. However, this requires storing a lot of redundant information in the form of pointers. We will use a simple trick to make this a lot more efficient by using an implicit data structure: Only storing the sums in an array. (A similar method is used for binary heaps). The sum of the root vertex at index 1, the sums of its two child vertices at indices 2 and 3, the sums of the children of those two vertices at indices 4 to 7, and so on.  With 1-indexing, conveniently the left child of a vertex at index $i$ is stored at index $2i$, and the right one at index $2i + 1$.  Equivalently, the parent of a vertex at index $i$ is stored at $i/2$ (integer division).</p> <p>This simplifies the implementation a lot.  We don't need to store the structure of the tree in memory.  It is defined implicitly.  We only need one array which contains the sums of all segments. </p> <p>As noted before, we need to store at most $4n$ vertices. It might be less, but for convenience we always allocate an array of size $4n$. There will be some elements in the sum array, that will not correspond to any vertices in the actual tree, but this doesn't complicate the implementation.</p> <p>So, we store the Segment Tree simply as an array $t[]$ with a size of four times the input size $n$:</p> <pre><code>int n, t[4*MAXN];\n</code></pre> <p>The procedure for constructing the Segment Tree from a given array $a[]$ looks like this:  it is a recursive function with the parameters $a[]$ (the input array), $v$ (the index of the current vertex), and the boundaries $tl$ and $tr$ of the current segment.  In the main program this function will be called with the parameters of the root vertex: $v = 1$, $tl = 0$, and $tr = n - 1$. </p> <pre><code>void build(int a[], int v, int tl, int tr) {\n    if (tl == tr) {\n        t[v] = a[tl];\n    } else {\n        int tm = (tl + tr) / 2;\n        build(a, v*2, tl, tm);\n        build(a, v*2+1, tm+1, tr);\n        t[v] = t[v*2] + t[v*2+1];\n    }\n}\n</code></pre> <p>Further the function for answering sum queries is also a recursive function, which receives as parameters information about the current vertex/segment (i.e. the index $v$ and the boundaries $tl$ and $tr$) and also the information about the boundaries of the query, $l$ and $r$.  In order to simplify the code, this function always does two recursive calls, even if only one is necessary - in that case the superfluous recursive call will have $l &gt; r$, and this can easily be caught using an additional check at the beginning of the function.</p> <pre><code>int sum(int v, int tl, int tr, int l, int r) {\n    if (l &gt; r) \n        return 0;\n    if (l == tl &amp;&amp; r == tr) {\n        return t[v];\n    }\n    int tm = (tl + tr) / 2;\n    return sum(v*2, tl, tm, l, min(r, tm))\n           + sum(v*2+1, tm+1, tr, max(l, tm+1), r);\n}\n</code></pre> <p>Finally the update query. The function will also receive information about the current vertex/segment, and additionally also the parameter of the update query (i.e. the position of the element and its new value).</p> <pre><code>void update(int v, int tl, int tr, int pos, int new_val) {\n    if (tl == tr) {\n        t[v] = new_val;\n    } else {\n        int tm = (tl + tr) / 2;\n        if (pos &lt;= tm)\n            update(v*2, tl, tm, pos, new_val);\n        else\n            update(v*2+1, tm+1, tr, pos, new_val);\n        t[v] = t[v*2] + t[v*2+1];\n    }\n}\n</code></pre>","tags":["Translated"]},{"location":"data_structures/segment_tree.html#memory-efficient-implementation","title":"Memory efficient implementation","text":"<p>Most people use the implementation from the previous section. If you look at the array <code>t</code> you can see that it follows the numbering of the tree nodes in the order of a BFS traversal (level-order traversal).  Using this traversal the children of vertex $v$ are $2v$ and $2v + 1$ respectively. However if $n$ is not a power of two, this method will skip some indices and leave some parts of the array <code>t</code> unused. The memory consumption is limited by $4n$, even though a Segment Tree of an array of $n$ elements requires only $2n - 1$ vertices.</p> <p>However it can be reduced.  We renumber the vertices of the tree in the order of an Euler tour traversal (pre-order traversal), and we write all these vertices next to each other.</p> <p>Let's look at a vertex at index $v$, and let it be responsible for the segment $[l, r]$, and let $mid = \\dfrac{l + r}{2}$. It is obvious that the left child will have the index $v + 1$. The left child is responsible for the segment $[l, mid]$, i.e. in total there will be $2 * (mid - l + 1) - 1$ vertices in the left child's subtree. Thus we can compute the index of the right child of $v$. The index will be $v + 2 * (mid - l + 1)$. By this numbering we achieve a reduction of the necessary memory to $2n$.</p>","tags":["Translated"]},{"location":"data_structures/segment_tree.html#advanced-versions-of-segment-trees","title":"Advanced versions of Segment Trees","text":"<p>A Segment Tree is a very flexible data structure, and allows variations and extensions in many different directions.  Let's try to categorize them below. </p>","tags":["Translated"]},{"location":"data_structures/segment_tree.html#more-complex-queries","title":"More complex queries","text":"<p>It can be quite easy to change the Segment Tree in a direction, such that it computes different queries (e.g. computing the minimum / maximum instead of the sum), but it also can be very nontrivial. </p>","tags":["Translated"]},{"location":"data_structures/segment_tree.html#finding-the-maximum","title":"Finding the maximum","text":"<p>Let us slightly change the condition of the problem described above: instead of querying the sum, we will now make maximum queries.</p> <p>The tree will have exactly the same structure as the tree described above.  We only need to change the way $t[v]$ is computed in the $\\text{build}$ and $\\text{update}$ functions. $t[v]$ will now store the maximum of the corresponding segment.  And we also need to change the calculation of the returned value of the $\\text{sum}$ function (replacing the summation by the maximum).</p> <p>Of course this problem can be easily changed into computing the minimum instead of the maximum.</p> <p>Instead of showing an implementation to this problem, the implementation will be given to a more complex version of this problem in the next section.</p>","tags":["Translated"]},{"location":"data_structures/segment_tree.html#finding-the-maximum-and-the-number-of-times-it-appears","title":"Finding the maximum and the number of times it appears","text":"<p>This task is very similar to the previous one. In addition of finding the maximum, we also have to find the number of occurrences of the maximum. </p> <p>To solve this problem, we store a pair of numbers at each vertex in the tree:  In addition to the maximum we also store the number of occurrences of it in the corresponding segment.  Determining the correct pair to store at $t[v]$ can still be done in constant time using the information of the pairs stored at the child vertices.  Combining two such pairs should be done in a separate function, since this will be an operation that we will do while building the tree, while answering maximum queries and while performing modifications.</p> <pre><code>pair&lt;int, int&gt; t[4*MAXN];\n\npair&lt;int, int&gt; combine(pair&lt;int, int&gt; a, pair&lt;int, int&gt; b) {\n    if (a.first &gt; b.first) \n        return a;\n    if (b.first &gt; a.first)\n        return b;\n    return make_pair(a.first, a.second + b.second);\n}\n\nvoid build(int a[], int v, int tl, int tr) {\n    if (tl == tr) {\n        t[v] = make_pair(a[tl], 1);\n    } else {\n        int tm = (tl + tr) / 2;\n        build(a, v*2, tl, tm);\n        build(a, v*2+1, tm+1, tr);\n        t[v] = combine(t[v*2], t[v*2+1]);\n    }\n}\n\npair&lt;int, int&gt; get_max(int v, int tl, int tr, int l, int r) {\n    if (l &gt; r)\n        return make_pair(-INF, 0);\n    if (l == tl &amp;&amp; r == tr)\n        return t[v];\n    int tm = (tl + tr) / 2;\n    return combine(get_max(v*2, tl, tm, l, min(r, tm)), \n                   get_max(v*2+1, tm+1, tr, max(l, tm+1), r));\n}\n\nvoid update(int v, int tl, int tr, int pos, int new_val) {\n    if (tl == tr) {\n        t[v] = make_pair(new_val, 1);\n    } else {\n        int tm = (tl + tr) / 2;\n        if (pos &lt;= tm)\n            update(v*2, tl, tm, pos, new_val);\n        else\n            update(v*2+1, tm+1, tr, pos, new_val);\n        t[v] = combine(t[v*2], t[v*2+1]);\n    }\n}\n</code></pre>","tags":["Translated"]},{"location":"data_structures/segment_tree.html#compute-the-greatest-common-divisor-least-common-multiple","title":"Compute the greatest common divisor / least common multiple","text":"<p>In this problem we want to compute the GCD / LCM of all numbers of given ranges of the array. </p> <p>This interesting variation of the Segment Tree can be solved in exactly the same way as the Segment Trees we derived for sum / minimum / maximum queries: it is enough to store the GCD / LCM of the corresponding vertex in each vertex of the tree.  Combining two vertices can be done by computing the GCD / LCM of both vertices.</p>","tags":["Translated"]},{"location":"data_structures/segment_tree.html#counting-zero-search-kth","title":"Counting the number of zeros, searching for the $k$-th zero","text":"<p>In this problem we want to find the number of zeros in a given range, and additionally find the index of the $k$-th zero using a second function.</p> <p>Again we have to change the store values of the tree a bit: This time we will store the number of zeros in each segment in $t[]$.  It is pretty clear, how to implement the $\\text{build}$, $\\text{update}$ and $\\text{count_zero}$ functions, we can simply use the ideas from the sum query problem. Thus we solved the first part of the problem.</p> <p>Now we learn how to solve the problem of finding the $k$-th zero in the array $a[]$.  To do this task, we will descend the Segment Tree, starting at the root vertex, and moving each time to either the left or the right child, depending on which segment contains the $k$-th zero. In order to decide to which child we need to go, it is enough to look at the number of zeros appearing in the segment corresponding to the left vertex. If this precomputed count is greater or equal to $k$, it is necessary to descend to the left child, and otherwise descent to the right child. Notice, if we chose the right child, we have to subtract the number of zeros of the left child from $k$.</p> <p>In the implementation we can handle the special case, $a[]$ containing less than $k$ zeros, by returning -1.</p> <pre><code>int find_kth(int v, int tl, int tr, int k) {\n    if (k &gt; t[v])\n        return -1;\n    if (tl == tr)\n        return tl;\n    int tm = (tl + tr) / 2;\n    if (t[v*2] &gt;= k)\n        return find_kth(v*2, tl, tm, k);\n    else \n        return find_kth(v*2+1, tm+1, tr, k - t[v*2]);\n}\n</code></pre>","tags":["Translated"]},{"location":"data_structures/segment_tree.html#searching-for-an-array-prefix-with-a-given-amount","title":"Searching for an array prefix with a given amount","text":"<p>The task is as follows:  for a given value $x$ we have to quickly find smallest index $i$ such that the sum of the first $i$ elements of the array $a[]$ is greater or equal to $x$ (assuming that the array $a[]$ only contains non-negative values).</p> <p>This task can be solved using binary search, computing the sum of the prefixes with the Segment Tree. However this will lead to a $O(\\log^2 n)$ solution.</p> <p>Instead we can use the same idea as in the previous section, and find the position by descending the tree: by moving each time to the left or the right, depending on the sum of the left child. Thus finding the answer in $O(\\log n)$ time.</p>","tags":["Translated"]},{"location":"data_structures/segment_tree.html#searching-for-the-first-element-greater-than-a-given-amount","title":"Searching for the first element greater than a given amount","text":"<p>The task is as follows:  for a given value $x$ and a range $a[l \\dots r]$ find the smallest $i$  in the range $a[l \\dots r]$, such that $a[i]$ is greater than $x$.</p> <p>This task can be solved using binary search over max prefix queries with the Segment Tree. However, this will lead to a $O(\\log^2 n)$ solution.</p> <p>Instead, we can use the same idea as in the previous sections, and find the position by descending the tree: by moving each time to the left or the right, depending on the maximum value of the left child. Thus finding the answer in $O(\\log n)$ time. </p> <pre><code>int get_first(int v, int tl, int tr, int l, int r, int x) {\n    if(tl &gt; r || tr &lt; l) return -1;\n    if(t[v] &lt;= x) return -1;\n\n    if (tl== tr) return tl;\n\n    int tm = tl + (tr-tl)/2;\n    int left = get_first(2*v, tl, tm, l, r, x);\n    if(left != -1) return left;\n    return get_first(2*v+1, tm+1, tr, l ,r, x);\n}\n</code></pre>","tags":["Translated"]},{"location":"data_structures/segment_tree.html#finding-subsegments-with-the-maximal-sum","title":"Finding subsegments with the maximal sum","text":"<p>Here again we receive a range $a[l \\dots r]$ for each query, this time we have to find a subsegment $a[l^\\prime \\dots r^\\prime]$ such that $l \\le l^\\prime$ and $r^\\prime \\le r$ and the sum of the elements of this segment is maximal.  As before we also want to be able to modify individual elements of the array.  The elements of the array can be negative, and the optimal subsegment can be empty (e.g. if all elements are negative).</p> <p>This problem is a non-trivial usage of a Segment Tree. This time we will store four values for each vertex:  the sum of the segment, the maximum prefix sum, the maximum suffix sum, and the sum of the maximal subsegment in it. In other words for each segment of the Segment Tree the answer is already precomputed as well as the answers for segments touching the left and the right boundaries of the segment.</p> <p>How to build a tree with such data? Again we compute it in a recursive fashion:  we first compute all four values for the left and the right child, and then combine those to archive the four values for the current vertex. Note the answer for the current vertex is either:</p> <ul> <li>the answer of the left child, which means that the optimal subsegment is entirely placed in the segment of the left child</li> <li>the answer of the right child, which means that the optimal subsegment is entirely placed in the segment of the right child</li> <li>the sum of the maximum suffix sum of the left child and the maximum prefix sum of the right child, which means that the optimal subsegment intersects with both children.</li> </ul> <p>Hence the answer to the current vertex is the maximum of these three values.  Computing the maximum prefix / suffix sum is even easier.  Here is the implementation of the $\\text{combine}$ function, which receives only data from the left and right child, and returns the data of the current vertex. </p> <pre><code>struct data {\n    int sum, pref, suff, ans;\n};\n\ndata combine(data l, data r) {\n    data res;\n    res.sum = l.sum + r.sum;\n    res.pref = max(l.pref, l.sum + r.pref);\n    res.suff = max(r.suff, r.sum + l.suff);\n    res.ans = max(max(l.ans, r.ans), l.suff + r.pref);\n    return res;\n}\n</code></pre> <p>Using the $\\text{combine}$ function it is easy to build the Segment Tree.  We can implement it in exactly the same way as in the previous implementations. To initialize the leaf vertices, we additionally create the auxiliary function $\\text{make_data}$, which will return a $\\text{data}$ object holding the information of a single value.</p> <pre><code>data make_data(int val) {\n    data res;\n    res.sum = val;\n    res.pref = res.suff = res.ans = max(0, val);\n    return res;\n}\n\nvoid build(int a[], int v, int tl, int tr) {\n    if (tl == tr) {\n        t[v] = make_data(a[tl]);\n    } else {\n        int tm = (tl + tr) / 2;\n        build(a, v*2, tl, tm);\n        build(a, v*2+1, tm+1, tr);\n        t[v] = combine(t[v*2], t[v*2+1]);\n    }\n}\n\nvoid update(int v, int tl, int tr, int pos, int new_val) {\n    if (tl == tr) {\n        t[v] = make_data(new_val);\n    } else {\n        int tm = (tl + tr) / 2;\n        if (pos &lt;= tm)\n            update(v*2, tl, tm, pos, new_val);\n        else\n            update(v*2+1, tm+1, tr, pos, new_val);\n        t[v] = combine(t[v*2], t[v*2+1]);\n    }\n}\n</code></pre> <p>It only remains, how to compute the answer to a query.  To answer it, we go down the tree as before, breaking the query into several subsegments that coincide with the segments of the Segment Tree, and combine the answers in them into a single answer for the query. Then it should be clear, that the work is exactly the same as in the simple Segment Tree, but instead of summing / minimizing / maximizing the values, we use the $\\text{combine}$ function.</p> <pre><code>data query(int v, int tl, int tr, int l, int r) {\n    if (l &gt; r) \n        return make_data(0);\n    if (l == tl &amp;&amp; r == tr) \n        return t[v];\n    int tm = (tl + tr) / 2;\n    return combine(query(v*2, tl, tm, l, min(r, tm)), \n                   query(v*2+1, tm+1, tr, max(l, tm+1), r));\n}\n</code></pre>","tags":["Translated"]},{"location":"data_structures/segment_tree.html#saving-the-entire-subarrays-in-each-vertex","title":"Saving the entire subarrays in each vertex","text":"<p>This is a separate subsection that stands apart from the others, because at each vertex of the Segment Tree we don't store information about the corresponding segment in compressed form (sum, minimum, maximum, ...), but store all elements of the segment. Thus the root of the Segment Tree will store all elements of the array, the left child vertex will store the first half of the array, the right vertex the second half, and so on.</p> <p>In its simplest application of this technique we store the elements in sorted order. In more complex versions the elements are not stored in lists, but more advanced data structures (sets, maps, ...).  But all these methods have the common factor, that each vertex requires linear memory (i.e. proportional to the length of the corresponding segment).</p> <p>The first natural question, when considering these Segment Trees, is about memory consumption. Intuitively this might look like $O(n^2)$ memory, but it turns out that the complete tree will only need $O(n \\log n)$ memory. Why is this so? Quite simply, because each element of the array falls into $O(\\log n)$ segments (remember the height of the tree is $O(\\log n)$). </p> <p>So in spite of the apparent extravagance of such a Segment Tree, it consumes only slightly more memory than the usual Segment Tree. </p> <p>Several typical applications of this data structure are described below. It is worth noting the similarity of these Segment Trees with 2D data structures (in fact this is a 2D data structure, but with rather limited capabilities).</p>","tags":["Translated"]},{"location":"data_structures/segment_tree.html#find-the-smallest-number-greater-or-equal-to-a-specified-number-no-modification-queries","title":"Find the smallest number greater or equal to a specified number. No modification queries.","text":"<p>We want to answer queries of the following form:  for three given numbers $(l, r, x)$ we have to find the minimal number in the segment $a[l \\dots r]$ which is greater than or equal to $x$.</p> <p>We construct a Segment Tree.  In each vertex we store a sorted list of all numbers occurring in the corresponding segment, like described above.  How to build such a Segment Tree as effectively as possible? As always we approach this problem recursively: let the lists of the left and right children already be constructed, and we want to build the list for the current vertex. From this view the operation is now trivial and can be accomplished in linear time: We only need to combine the two sorted lists into one, which can be done by iterating over them using two pointers.  The C++ STL already has an implementation of this algorithm.</p> <p>Because this structure of the Segment Tree and the similarities to the merge sort algorithm, the data structure is also often called \"Merge Sort Tree\".</p> <pre><code>vector&lt;int&gt; t[4*MAXN];\n\nvoid build(int a[], int v, int tl, int tr) {\n    if (tl == tr) {\n        t[v] = vector&lt;int&gt;(1, a[tl]);\n    } else { \n        int tm = (tl + tr) / 2;\n        build(a, v*2, tl, tm);\n        build(a, v*2+1, tm+1, tr);\n        merge(t[v*2].begin(), t[v*2].end(), t[v*2+1].begin(), t[v*2+1].end(),\n              back_inserter(t[v]));\n    }\n}\n</code></pre> <p>We already know that the Segment Tree constructed in this way will require $O(n \\log n)$ memory. And thanks to this implementation its construction also takes $O(n \\log n)$ time, after all each list is constructed in linear time in respect to its size. </p> <p>Now consider the answer to the query.  We will go down the tree, like in the regular Segment Tree, breaking our segment $a[l \\dots r]$ into several subsegments (into at most $O(\\log n)$ pieces).  It is clear that the answer of the whole answer is the minimum of each of the subqueries. So now we only need to understand, how to respond to a query on one such subsegment that corresponds with some vertex of the tree.</p> <p>We are at some vertex of the Segment Tree and we want to compute the answer to the query, i.e. find the minimum number greater that or equal to a given number $x$.  Since the vertex contains the list of elements in sorted order, we can simply perform a binary search on this list and return the first number, greater than or equal to $x$.</p> <p>Thus the answer to the query in one segment of the tree takes $O(\\log n)$ time, and the entire query is processed in $O(\\log^2 n)$.</p> <pre><code>int query(int v, int tl, int tr, int l, int r, int x) {\n    if (l &gt; r)\n        return INF;\n    if (l == tl &amp;&amp; r == tr) {\n        vector&lt;int&gt;::iterator pos = lower_bound(t[v].begin(), t[v].end(), x);\n        if (pos != t[v].end())\n            return *pos;\n        return INF;\n    }\n    int tm = (tl + tr) / 2;\n    return min(query(v*2, tl, tm, l, min(r, tm), x), \n               query(v*2+1, tm+1, tr, max(l, tm+1), r, x));\n}\n</code></pre> <p>The constant $\\text{INF}$ is equal to some large number that is bigger than all numbers in the array.  Its usage means, that there is no number greater than or equal to $x$ in the segment.  It has the meaning of \"there is no answer in the given interval\".</p>","tags":["Translated"]},{"location":"data_structures/segment_tree.html#find-the-smallest-number-greater-or-equal-to-a-specified-number-with-modification-queries","title":"Find the smallest number greater or equal to a specified number. With modification queries.","text":"<p>This task is similar to the previous. The last approach has a disadvantage, it was not possible to modify the array between answering queries. Now we want to do exactly this: a modification query will do the assignment $a[i] = y$.</p> <p>The solution is similar to the solution of the previous problem, but instead of lists at each vertex of the Segment Tree, we will store a balanced list that allows you to quickly search for numbers, delete numbers, and insert new numbers.  Since the array can contain a number repeated, the optimal choice is the data structure $\\text{multiset}$. </p> <p>The construction of such a Segment Tree is done in pretty much the same way as in the previous problem, only now we need to combine $\\text{multiset}$s and not sorted lists. This leads to a construction time of $O(n \\log^2 n)$ (in general merging two red-black trees can be done in linear time, but the C++ STL doesn't guarantee this time complexity).</p> <p>The $\\text{query}$ function is also almost equivalent, only now the $\\text{lower_bound}$ function of the $\\text{multiset}$ function should be called instead ($\\text{std::lower_bound}$ only works in $O(\\log n)$ time if used with random-access iterators).</p> <p>Finally the modification request.  To process it, we must go down the tree, and modify all $\\text{multiset}$ from the corresponding segments that contain the affected element. We simply delete the old value of this element (but only one occurrence), and insert the new value.</p> <pre><code>void update(int v, int tl, int tr, int pos, int new_val) {\n    t[v].erase(t[v].find(a[pos]));\n    t[v].insert(new_val);\n    if (tl != tr) {\n        int tm = (tl + tr) / 2;\n        if (pos &lt;= tm)\n            update(v*2, tl, tm, pos, new_val);\n        else\n            update(v*2+1, tm+1, tr, pos, new_val);\n    } else {\n        a[pos] = new_val;\n    }\n}\n</code></pre> <p>Processing of this modification query also takes $O(\\log^2 n)$ time.</p>","tags":["Translated"]},{"location":"data_structures/segment_tree.html#find-the-smallest-number-greater-or-equal-to-a-specified-number-acceleration-with-fractional-cascading","title":"Find the smallest number greater or equal to a specified number. Acceleration with \"fractional cascading\".","text":"<p>We have the same problem statement, we want to find the minimal number greater than or equal to $x$ in a segment, but this time in $O(\\log n)$ time. We will improve the time complexity using the technique \"fractional cascading\".</p> <p>Fractional cascading is a simple technique that allows you to improve the running time of multiple binary searches, which are conducted at the same time.  Our previous approach to the search query was, that we divide the task into several subtasks, each of which is solved with a binary search.  Fractional cascading allows you to replace all of these binary searches with a single one.</p> <p>The simplest and most obvious example of fractional cascading is the following problem: there are $k$ sorted lists of numbers, and we must find in each list the first number greater than or equal to the given number.</p> <p>Instead of performing a binary search for each list, we could merge all lists into one big sorted list. Additionally for each element $y$ we store a list of results of searching for $y$ in each of the $k$ lists. Therefore if we want to find the smallest number greater than or equal to $x$, we just need to perform one single binary search, and from the list of indices we can determine the smallest number in each list. This approach however requires $O(n \\cdot k)$ ($n$ is the length of the combined lists), which can be quite inefficient. </p> <p>Fractional cascading reduces this memory complexity to $O(n)$ memory, by creating from the $k$ input lists $k$ new lists, in which each list contains the corresponding list and additionally also every second element of the following new list. Using this structure it is only necessary to store two indices, the index of the element in the original list, and the index of the element in the following new list. So this approach only uses $O(n)$ memory, and still can answer the queries using a single binary search. </p> <p>But for our application we do not need the full power of fractional cascading. In our Segment Tree a vertex will contain the sorted list of all elements that occur in either the left or the right subtrees (like in the Merge Sort Tree).  Additionally to this sorted list, we store two positions for each element. For an element $y$ we store the smallest index $i$, such that the $i$th element in the sorted list of the left child is greater or equal to $y$. And we store the smallest index $j$, such that the $j$th element in the sorted list of the right child is greater or equal to $y$. These values can be computed in parallel to the merging step when we build the tree.</p> <p>How does this speed up the queries?</p> <p>Remember, in the normal solution we did a binary search in every node. But with this modification, we can avoid all except one.</p> <p>To answer a query, we simply do a binary search in the root node. This gives us the smallest element $y \\ge x$ in the complete array, but it also gives us two positions. The index of the smallest element greater or equal $x$ in the left subtree, and the index of the smallest element $y$ in the right subtree. Notice that $\\ge y$ is the same as $\\ge x$, since our array doesn't contain any elements between $x$ and $y$. In the normal Merge Sort Tree solution we would compute these indices via binary search, but with the help of the precomputed values we can just look them up in $O(1)$. And we can repeat that until we visited all nodes that cover our query interval.</p> <p>To summarize, as usual we touch $O(\\log n)$ nodes during a query. In the root node we do a binary search, and in all other nodes we only do constant work. This means the complexity for answering a query is $O(\\log n)$.</p> <p>But notice, that this uses three times more memory than a normal Merge Sort Tree, which already uses a lot of memory ($O(n \\log n)$).</p> <p>It is straightforward to apply this technique to a problem, that doesn't require any modification queries. The two positions are just integers and can easily be computed by counting when merging the two sorted sequences.</p> <p>It it still possible to also allow modification queries, but that complicates the entire code. Instead of integers, you need to store the sorted array as <code>multiset</code>, and instead of indices you need to store iterators. And you need to work very carefully, so that you increment or decrement the correct iterators during a modification query.</p>","tags":["Translated"]},{"location":"data_structures/segment_tree.html#other-possible-variations","title":"Other possible variations","text":"<p>This technique implies a whole new class of possible applications.  Instead of storing a $\\text{vector}$ or a $\\text{multiset}$ in each vertex, other data structures can be used: other Segment Trees (somewhat discussed in Generalization to higher dimensions), Fenwick Trees, Cartesian trees, etc.</p>","tags":["Translated"]},{"location":"data_structures/segment_tree.html#range-updates-lazy-propagation","title":"Range updates (Lazy Propagation)","text":"<p>All problems in the above sections discussed modification queries that only affected a single element of the array each. However the Segment Tree allows applying modification queries to an entire segment of contiguous elements, and perform the query in the same time $O(\\log n)$. </p>","tags":["Translated"]},{"location":"data_structures/segment_tree.html#addition-on-segments","title":"Addition on segments","text":"<p>We begin by considering problems of the simplest form: the modification query should add a number $x$ to all numbers in the segment $a[l \\dots r]$. The second query, that we are supposed to answer, asked simply for the value of $a[i]$.</p> <p>To make the addition query efficient, we store at each vertex in the Segment Tree how many we should add to all numbers in the corresponding segment.  For example, if the query \"add 3 to the whole array $a[0 \\dots n-1]$\" comes, then we place the number 3 in the root of the tree. In general we have to place this number to multiple segments, which form a partition of the query segment.  Thus we don't have to change all $O(n)$ values, but only $O(\\log n)$ many.</p> <p>If now there comes a query that asks the current value of a particular array entry, it is enough to go down the tree and add up all values found along the way.</p> <pre><code>void build(int a[], int v, int tl, int tr) {\n    if (tl == tr) {\n        t[v] = a[tl];\n    } else {\n        int tm = (tl + tr) / 2;\n        build(a, v*2, tl, tm);\n        build(a, v*2+1, tm+1, tr);\n        t[v] = 0;\n    }\n}\n\nvoid update(int v, int tl, int tr, int l, int r, int add) {\n    if (l &gt; r)\n        return;\n    if (l == tl &amp;&amp; r == tr) {\n        t[v] += add;\n    } else {\n        int tm = (tl + tr) / 2;\n        update(v*2, tl, tm, l, min(r, tm), add);\n        update(v*2+1, tm+1, tr, max(l, tm+1), r, add);\n    }\n}\n\nint get(int v, int tl, int tr, int pos) {\n    if (tl == tr)\n        return t[v];\n    int tm = (tl + tr) / 2;\n    if (pos &lt;= tm)\n        return t[v] + get(v*2, tl, tm, pos);\n    else\n        return t[v] + get(v*2+1, tm+1, tr, pos);\n}\n</code></pre>","tags":["Translated"]},{"location":"data_structures/segment_tree.html#assignment-on-segments","title":"Assignment on segments","text":"<p>Suppose now that the modification query asks to assign each element of a certain segment $a[l \\dots r]$ to some value $p$. As a second query we will again consider reading the value of the array $a[i]$.</p> <p>To perform this modification query on a whole segment, you have to store at each vertex of the Segment Tree whether the corresponding segment is covered entirely with the same value or not. This allows us to make a \"lazy\" update:  instead of changing all segments in the tree that cover the query segment, we only change some, and leave others unchanged. A marked vertex will mean, that every element of the corresponding segment is assigned to that value, and actually also the complete subtree should only contain this value. In a sense we are lazy and delay writing the new value to all those vertices. We can do this tedious task later, if this is necessary.</p> <p>So after the modification query is executed, some parts of the tree become irrelevant - some modifications remain unfulfilled in it.</p> <p>For example if a modification query \"assign a number to the whole array $a[0 \\dots n-1]$\" gets executed, in the Segment Tree only a single change is made - the number is placed in the root of the tree and this vertex gets marked. The remaining segments remain unchanged, although in fact the number should be placed in the whole tree.</p> <p>Suppose now that the second modification query says, that the first half of the array $a[0 \\dots n/2]$ should be assigned with some other number.  To process this query we must assign each element in the whole left child of the root vertex with that number.  But before we do this, we must first sort out the root vertex first.  The subtlety here is that the right half of the array should still be assigned to the value of the first query, and at the moment there is no information for the right half stored.</p> <p>The way to solve this is to push the information of the root to its children, i.e. if the root of the tree was assigned with any number, then we assign the left and the right child vertices with this number and remove the mark of the root. After that, we can assign the left child with the new value, without losing any necessary information.</p> <p>Summarizing we get: for any queries (a modification or reading query) during the descent along the tree we should always push information from the current vertex into both of its children.  We can understand this in such a way, that when we descent the tree we apply delayed modifications, but exactly as much as necessary (so not to degrade the complexity of $O(\\log n)$). </p> <p>For the implementation we need to make a $\\text{push}$ function, which will receive the current vertex, and it will push the information for its vertex to both its children.  We will call this function at the beginning of the query functions (but we will not call it from the leaves, because there is no need to push information from them any further).</p> <pre><code>void push(int v) {\n    if (marked[v]) {\n        t[v*2] = t[v*2+1] = t[v];\n        marked[v*2] = marked[v*2+1] = true;\n        marked[v] = false;\n    }\n}\n\nvoid update(int v, int tl, int tr, int l, int r, int new_val) {\n    if (l &gt; r) \n        return;\n    if (l == tl &amp;&amp; tr == r) {\n        t[v] = new_val;\n        marked[v] = true;\n    } else {\n        push(v);\n        int tm = (tl + tr) / 2;\n        update(v*2, tl, tm, l, min(r, tm), new_val);\n        update(v*2+1, tm+1, tr, max(l, tm+1), r, new_val);\n    }\n}\n\nint get(int v, int tl, int tr, int pos) {\n    if (tl == tr) {\n        return t[v];\n    }\n    push(v);\n    int tm = (tl + tr) / 2;\n    if (pos &lt;= tm) \n        return get(v*2, tl, tm, pos);\n    else\n        return get(v*2+1, tm+1, tr, pos);\n}\n</code></pre> <p>Notice: the function $\\text{get}$ can also be implemented in a different way:  do not make delayed updates, but immediately return the value $t[v]$ if $marked[v]$ is true.</p>","tags":["Translated"]},{"location":"data_structures/segment_tree.html#adding-on-segments-querying-for-maximum","title":"Adding on segments, querying for maximum","text":"<p>Now the modification query is to add a number to all elements in a range, and the reading query is to find the maximum in a range.</p> <p>So for each vertex of the Segment Tree we have to store the maximum of the corresponding subsegment.  The interesting part is how to recompute these values during a modification request.</p> <p>For this purpose we keep store an additional value for each vertex.  In this value we store the addends we haven't propagated to the child vertices. Before traversing to a child vertex, we call $\\text{push}$ and propagate the value to both children. We have to do this in both the $\\text{update}$ function and the $\\text{query}$ function.</p> <pre><code>void build(int a[], int v, int tl, int tr) {\n    if (tl == tr) {\n        t[v] = a[tl];\n    } else {\n        int tm = (tl + tr) / 2;\n        build(a, v*2, tl, tm);\n        build(a, v*2+1, tm+1, tr);\n        t[v] = max(t[v*2], t[v*2 + 1]);\n    }\n}\n\nvoid push(int v) {\n    t[v*2] += lazy[v];\n    lazy[v*2] += lazy[v];\n    t[v*2+1] += lazy[v];\n    lazy[v*2+1] += lazy[v];\n    lazy[v] = 0;\n}\n\nvoid update(int v, int tl, int tr, int l, int r, int addend) {\n    if (l &gt; r) \n        return;\n    if (l == tl &amp;&amp; tr == r) {\n        t[v] += addend;\n        lazy[v] += addend;\n    } else {\n        push(v);\n        int tm = (tl + tr) / 2;\n        update(v*2, tl, tm, l, min(r, tm), addend);\n        update(v*2+1, tm+1, tr, max(l, tm+1), r, addend);\n        t[v] = max(t[v*2], t[v*2+1]);\n    }\n}\n\nint query(int v, int tl, int tr, int l, int r) {\n    if (l &gt; r)\n        return -INF;\n    if (l == tl &amp;&amp; tr == r)\n        return t[v];\n    push(v);\n    int tm = (tl + tr) / 2;\n    return max(query(v*2, tl, tm, l, min(r, tm)), \n               query(v*2+1, tm+1, tr, max(l, tm+1), r));\n}\n</code></pre>","tags":["Translated"]},{"location":"data_structures/segment_tree.html#generalization-to-higher-dimensions","title":"Generalization to higher dimensions","text":"<p>A Segment Tree can be generalized quite natural to higher dimensions. If in the one-dimensional case we split the indices of the array into segments, then in the two-dimensional we make an ordinary Segment Tree with respect to the first indices, and for each segment we build an ordinary Segment Tree with respect to the second indices.</p>","tags":["Translated"]},{"location":"data_structures/segment_tree.html#simple-2d-segment-tree","title":"Simple 2D Segment Tree","text":"<p>A matrix $a[0 \\dots n-1, 0 \\dots m-1]$ is given, and we have to find the sum (or minimum/maximum) on some submatrix $a[x_1 \\dots x_2, y_1 \\dots y_2]$, as well as perform modifications of individual matrix elements (i.e. queries of the form $a[x][y] = p$).</p> <p>So we build a 2D Segment Tree: first the Segment Tree using the first coordinate ($x$), then the second ($y$).</p> <p>To make the construction process more understandable, you can forget for a while that the matrix is two-dimensional, and only leave the first coordinate. We will construct an ordinary one-dimensional Segment Tree using only the first coordinate. But instead of storing a number in a segment, we store an entire Segment Tree:  i.e. at this moment we remember that we also have a second coordinate; but because at this moment the first coordinate is already fixed to some interval $[l \\dots r]$, we actually work with such a strip $a[l \\dots r, 0 \\dots m-1]$ and for it we build a Segment Tree.</p> <p>Here is the implementation of the construction of a 2D Segment Tree. It actually represents two separate blocks:  the construction of a Segment Tree along the $x$ coordinate ($\\text{build}_x$), and the $y$ coordinate ($\\text{build}_y$). For the leaf nodes in $\\text{build}_y$ we have to separate two cases:  when the current segment of the first coordinate $[tlx \\dots trx]$ has length 1, and when it has a length greater than one. In the first case, we just take the corresponding value from the matrix, and in the second case we can combine the values of two Segment Trees from the left and the right son in the coordinate $x$.</p> <pre><code>void build_y(int vx, int lx, int rx, int vy, int ly, int ry) {\n    if (ly == ry) {\n        if (lx == rx)\n            t[vx][vy] = a[lx][ly];\n        else\n            t[vx][vy] = t[vx*2][vy] + t[vx*2+1][vy];\n    } else {\n        int my = (ly + ry) / 2;\n        build_y(vx, lx, rx, vy*2, ly, my);\n        build_y(vx, lx, rx, vy*2+1, my+1, ry);\n        t[vx][vy] = t[vx][vy*2] + t[vx][vy*2+1];\n    }\n}\n\nvoid build_x(int vx, int lx, int rx) {\n    if (lx != rx) {\n        int mx = (lx + rx) / 2;\n        build_x(vx*2, lx, mx);\n        build_x(vx*2+1, mx+1, rx);\n    }\n    build_y(vx, lx, rx, 1, 0, m-1);\n}\n</code></pre> <p>Such a Segment Tree still uses a linear amount of memory, but with a larger constant: $16 n m$. It is clear that the described procedure $\\text{build}_x$ also works in linear time. </p> <p>Now we turn to processing of queries. We will answer to the two-dimensional query using the same principle:  first break the query on the first coordinate, and then for every reached vertex, we call the corresponding Segment Tree of the second coordinate.</p> <pre><code>int sum_y(int vx, int vy, int tly, int try_, int ly, int ry) {\n    if (ly &gt; ry) \n        return 0;\n    if (ly == tly &amp;&amp; try_ == ry)\n        return t[vx][vy];\n    int tmy = (tly + try_) / 2;\n    return sum_y(vx, vy*2, tly, tmy, ly, min(ry, tmy))\n         + sum_y(vx, vy*2+1, tmy+1, try_, max(ly, tmy+1), ry);\n}\n\nint sum_x(int vx, int tlx, int trx, int lx, int rx, int ly, int ry) {\n    if (lx &gt; rx)\n        return 0;\n    if (lx == tlx &amp;&amp; trx == rx)\n        return sum_y(vx, 1, 0, m-1, ly, ry);\n    int tmx = (tlx + trx) / 2;\n    return sum_x(vx*2, tlx, tmx, lx, min(rx, tmx), ly, ry)\n         + sum_x(vx*2+1, tmx+1, trx, max(lx, tmx+1), rx, ly, ry);\n}\n</code></pre> <p>This function works in $O(\\log n \\log m)$ time, since it first descends the tree in the first coordinate, and for each traversed vertex in the tree it makes a query in the corresponding Segment Tree along the second coordinate.</p> <p>Finally we consider the modification query.  We want to learn how to modify the Segment Tree in accordance with the change in the value of some element $a[x][y] = p$. It is clear, that the changes will occur only in those vertices of the first Segment Tree that cover the coordinate $x$ (and such will be $O(\\log n)$), and for Segment Trees corresponding to them the changes will only occurs at those vertices that covers the coordinate $y$ (and such will be $O(\\log m)$). Therefore the implementation will be not very different form the one-dimensional case, only now we first descend the first coordinate, and then the second.</p> <pre><code>void update_y(int vx, int lx, int rx, int vy, int ly, int ry, int x, int y, int new_val) {\n    if (ly == ry) {\n        if (lx == rx)\n            t[vx][vy] = new_val;\n        else\n            t[vx][vy] = t[vx*2][vy] + t[vx*2+1][vy];\n    } else {\n        int my = (ly + ry) / 2;\n        if (y &lt;= my)\n            update_y(vx, lx, rx, vy*2, ly, my, x, y, new_val);\n        else\n            update_y(vx, lx, rx, vy*2+1, my+1, ry, x, y, new_val);\n        t[vx][vy] = t[vx][vy*2] + t[vx][vy*2+1];\n    }\n}\n\nvoid update_x(int vx, int lx, int rx, int x, int y, int new_val) {\n    if (lx != rx) {\n        int mx = (lx + rx) / 2;\n        if (x &lt;= mx)\n            update_x(vx*2, lx, mx, x, y, new_val);\n        else\n            update_x(vx*2+1, mx+1, rx, x, y, new_val);\n    }\n    update_y(vx, lx, rx, 1, 0, m-1, x, y, new_val);\n}\n</code></pre>","tags":["Translated"]},{"location":"data_structures/segment_tree.html#compression-of-2d-segment-tree","title":"Compression of 2D Segment Tree","text":"<p>Let the problem be the following: there are $n$ points on the plane given by their coordinates $(x_i, y_i)$ and queries of the form \"count the number of points lying in the rectangle $((x_1, y_1), (x_2, y_2))$\". It is clear that in the case of such a problem it becomes unreasonably wasteful to construct a two-dimensional Segment Tree with $O(n^2)$ elements. Most on this memory will be wasted, since each single point can only get into $O(\\log n)$ segments of the tree along the first coordinate, and therefore the total \"useful\" size of all tree segments on the second coordinate is $O(n \\log n)$.</p> <p>So we proceed as follows: at each vertex of the Segment Tree with respect to the first coordinate we store a Segment Tree constructed only by those second coordinates that occur in the current segment of the first coordinates.  In other words, when constructing a Segment Tree inside some vertex with index $vx$ and the boundaries $tlx$ and $trx$, we only consider those points that fall into this interval $x \\in [tlx, trx]$, and build a Segment Tree just using them.</p> <p>Thus we will achieve that each Segment Tree on the second coordinate will occupy exactly as much memory as it should. As a result, the total amount of memory will decrease to $O(n \\log n)$. We still can answer the queries in $O(\\log^2 n)$ time, we just have to make a binary search on the second coordinate, but this will not worsen the complexity.</p> <p>But modification queries will be impossible with this structure: in fact if a new point appears, we have to add a new element in the middle of some Segment Tree along the second coordinate, which cannot be effectively done.</p> <p>In conclusion we note that the two-dimensional Segment Tree contracted in the described way becomes practically equivalent to the modification of the one-dimensional Segment Tree (see Saving the entire subarrays in each vertex). In particular the two-dimensional Segment Tree is just a special case of storing a subarray in each vertex of the tree. It follows, that if you gave to abandon a two-dimensional Segment Tree due to the impossibility of executing a query, it makes sense to try to replace the nested Segment Tree with some more powerful data structure, for example a Cartesian tree.</p>","tags":["Translated"]},{"location":"data_structures/segment_tree.html#preserving-the-history-of-its-values-persistent-segment-tree","title":"Preserving the history of its values (Persistent Segment Tree)","text":"<p>A persistent data structure is a data structure that remembers it previous state for each modification. This allows to access any version of this data structure that interest us and execute a query on it.</p> <p>Segment Tree is a data structure that can be turned into a persistent data structure efficiently (both in time and memory consumption). We want to avoid copying the complete tree before each modification, and we don't want to loose the $O(\\log n)$ time behavior for answering range queries.</p> <p>In fact, any change request in the Segment Tree leads to a change in the data of only $O(\\log n)$ vertices along the path starting from the root.  So if we store the Segment Tree using pointers (i.e. a vertex stores pointers to the left and the right child vertices), then when performing the modification query, we simply need to create new vertices instead of changing the available vertices. Vertices that are not affected by the modification query can still be used by pointing the pointers to the old vertices. Thus for a modification query $O(\\log n)$ new vertices will be created, including a new root vertex of the Segment Tree, and the entire previous version of the tree rooted at the old root vertex will remain unchanged.</p> <p>Let's give an example implementation for the simplest Segment Tree: when there is only a query asking for sums, and modification queries of single elements. </p> <pre><code>struct Vertex {\n    Vertex *l, *r;\n    int sum;\n\n    Vertex(int val) : l(nullptr), r(nullptr), sum(val) {}\n    Vertex(Vertex *l, Vertex *r) : l(l), r(r), sum(0) {\n        if (l) sum += l-&gt;sum;\n        if (r) sum += r-&gt;sum;\n    }\n};\n\nVertex* build(int a[], int tl, int tr) {\n    if (tl == tr)\n        return new Vertex(a[tl]);\n    int tm = (tl + tr) / 2;\n    return new Vertex(build(a, tl, tm), build(a, tm+1, tr));\n}\n\nint get_sum(Vertex* v, int tl, int tr, int l, int r) {\n    if (l &gt; r)\n        return 0;\n    if (l == tl &amp;&amp; tr == r)\n        return v-&gt;sum;\n    int tm = (tl + tr) / 2;\n    return get_sum(v-&gt;l, tl, tm, l, min(r, tm))\n         + get_sum(v-&gt;r, tm+1, tr, max(l, tm+1), r);\n}\n\nVertex* update(Vertex* v, int tl, int tr, int pos, int new_val) {\n    if (tl == tr)\n        return new Vertex(new_val);\n    int tm = (tl + tr) / 2;\n    if (pos &lt;= tm)\n        return new Vertex(update(v-&gt;l, tl, tm, pos, new_val), v-&gt;r);\n    else\n        return new Vertex(v-&gt;l, update(v-&gt;r, tm+1, tr, pos, new_val));\n}\n</code></pre> <p>For each modification of the Segment Tree we will receive a new root vertex. To quickly jump between two different versions of the Segment Tree, we need to store this roots in an array. To use a specific version of the Segment Tree we simply call the query using the appropriate root vertex.</p> <p>With the approach described above almost any Segment Tree can be turned into a persistent data structure.</p>","tags":["Translated"]},{"location":"data_structures/segment_tree.html#finding-the-k-th-smallest-number-in-a-range","title":"Finding the $k$-th smallest number in a range","text":"<p>This time we have to answer queries of the form \"What is the $k$-th smallest element in the range $a[l \\dots r]$.  This query can be answered using a binary search and a Merge Sort Tree, but the time complexity for a single query would be $O(\\log^3 n)$. We will accomplish the same task using a persistent Segment Tree in $O(\\log n)$.</p> <p>First we will discuss a solution for a simpler problem: We will only consider arrays in which the elements are bound by $0 \\le a[i] \\lt n$. And we only want to find the $k$-th smallest element in some prefix of the array $a$. It will be very easy to extent the developed ideas later for not restricted arrays and not restricted range queries. Note that we will be using 1 based indexing for $a$.</p> <p>We will use a Segment Tree that counts all appearing numbers, i.e. in the Segment Tree we will store the histogram of the array. So the leaf vertices will store how often the values $0$, $1$, $\\dots$, $n-1$ will appear in the array, and the other vertices store how many numbers in some range are in the array.  In other words we create a regular Segment Tree with sum queries over the histogram of the array. But instead of creating all $n$ Segment Trees for every possible prefix, we will create one persistent one, that will contain the same information. We will start with an empty Segment Tree (all counts will be $0$) pointed to by $root_0$, and add the elements $a[1]$, $a[2]$, $\\dots$, $a[n]$ one after another. For each modification we will receive a new root vertex, let's call $root_i$ the root of the Segment Tree after inserting the first $i$ elements of the array $a$. The Segment Tree rooted at $root_i$ will contain the histogram of the prefix $a[1 \\dots i]$. Using this Segment Tree we can find in $O(\\log n)$ time the position of the $k$-th element using the same technique discussed in Counting the number of zeros, searching for the $k$-th zero.</p> <p>Now to the not-restricted version of the problem.</p> <p>First for the restriction on the queries:  Instead of only performing these queries over a prefix of $a$, we want to use any arbitrary segments $a[l \\dots r]$. Here we need a Segment Tree that represents the histogram of the elements in the range $a[l \\dots r]$.  It is easy to see that such a Segment Tree is just the difference between the Segment Tree rooted at $root_{r}$ and the Segment Tree rooted at $root_{l-1}$, i.e. every vertex in the $[l \\dots r]$ Segment Tree can be computed with the vertex of the $root_{r}$ tree minus the vertex of the $root_{l-1}$ tree.</p> <p>In the implementation of the $\\text{find_kth}$ function this can be handled by passing two vertex pointer and computing the count/sum of the current segment as difference of the two counts/sums of the vertices.</p> <p>Here are the modified $\\text{build}$, $\\text{update}$  and $\\text{find_kth}$ functions</p> <pre><code>Vertex* build(int tl, int tr) {\n    if (tl == tr)\n        return new Vertex(0);\n    int tm = (tl + tr) / 2;\n    return new Vertex(build(tl, tm), build(tm+1, tr));\n}\n\nVertex* update(Vertex* v, int tl, int tr, int pos) {\n    if (tl == tr)\n        return new Vertex(v-&gt;sum+1);\n    int tm = (tl + tr) / 2;\n    if (pos &lt;= tm)\n        return new Vertex(update(v-&gt;l, tl, tm, pos), v-&gt;r);\n    else\n        return new Vertex(v-&gt;l, update(v-&gt;r, tm+1, tr, pos));\n}\n\nint find_kth(Vertex* vl, Vertex *vr, int tl, int tr, int k) {\n    if (tl == tr)\n        return tl;\n    int tm = (tl + tr) / 2, left_count = vr-&gt;l-&gt;sum - vl-&gt;l-&gt;sum;\n    if (left_count &gt;= k)\n        return find_kth(vl-&gt;l, vr-&gt;l, tl, tm, k);\n    return find_kth(vl-&gt;r, vr-&gt;r, tm+1, tr, k-left_count);\n}\n</code></pre> <p>As already written above, we need to store the root of the initial Segment Tree, and also all the roots after each update. Here is the code for building a persistent Segment Tree over an vector <code>a</code> with elements in the range <code>[0, MAX_VALUE]</code>.</p> <pre><code>int tl = 0, tr = MAX_VALUE + 1;\nstd::vector&lt;Vertex*&gt; roots;\nroots.push_back(build(tl, tr));\nfor (int i = 0; i &lt; a.size(); i++) {\n    roots.push_back(update(roots.back(), tl, tr, a[i]));\n}\n\n// find the 5th smallest number from the subarray [a[2], a[3], ..., a[19]]\nint result = find_kth(roots[2], roots[20], tl, tr, 5);\n</code></pre> <p>Now to the restrictions on the array elements: We can actually transform any array to such an array by index compression. The smallest element in the array will gets assigned the value 0, the second smallest the value 1, and so forth. It is easy to generate lookup tables (e.g. using $\\text{map}$), that convert a value to its index and vice versa in $O(\\log n)$ time.</p>","tags":["Translated"]},{"location":"data_structures/segment_tree.html#dynamic-segment-tree","title":"Dynamic segment tree","text":"<p>(Called so because its shape is dynamic and the nodes are usually dynamically allocated. Also known as implicit segment tree or sparse segment tree.)</p> <p>Previously, we considered cases when we have the ability to build the original segment tree. But what to do if the original size is filled with some default element, but its size does not allow you to completely build up to it in advance?</p> <p>We can solve this problem by creating a segment tree lazily (incrementally). Initially, we will create only the root, and we will create the other vertexes only when we need them. In this case, we will use the implementation on pointers(before going to the vertex children, check whether they are created, and if not, create them). Each query has still only the complexity $O(\\log n)$, which is small enough for most use-cases (e.g. $\\log_2 10^9 \\approx 30$).</p> <p>In this implementation we have two queries, adding a value to a position (initially all values  are $0$), and computing the sum of all values in a range. <code>Vertex(0, n)</code> will be the root vertex of the implicit tree.</p> <pre><code>struct Vertex {\n    int left, right;\n    int sum = 0;\n    Vertex *left_child = nullptr, *right_child = nullptr;\n\n    Vertex(int lb, int rb) {\n        left = lb;\n        right = rb;\n    }\n\n    void extend() {\n        if (!left_child &amp;&amp; left + 1 &lt; right) {\n            int t = (left + right) / 2;\n            left_child = new Vertex(left, t);\n            right_child = new Vertex(t, right);\n        }\n    }\n\n    void add(int k, int x) {\n        extend();\n        sum += x;\n        if (left_child) {\n            if (k &lt; left_child-&gt;right)\n                left_child-&gt;add(k, x);\n            else\n                right_child-&gt;add(k, x);\n        }\n    }\n\n    int get_sum(int lq, int rq) {\n        if (lq &lt;= left &amp;&amp; right &lt;= rq)\n            return sum;\n        if (max(left, lq) &gt;= min(right, rq))\n            return 0;\n        extend();\n        return left_child-&gt;get_sum(lq, rq) + right_child-&gt;get_sum(lq, rq);\n    }\n};\n</code></pre> <p>Obviously this idea can be extended in lots of different ways. E.g. by adding support for range updates via lazy propagation.</p>","tags":["Translated"]},{"location":"data_structures/segment_tree.html#practice-problems","title":"Practice Problems","text":"<ul> <li>SPOJ - KQUERY [Persistent segment tree / Merge sort tree]</li> <li>Codeforces - Xenia and Bit Operations</li> <li>UVA 11402 - Ahoy, Pirates!</li> <li>SPOJ - GSS3</li> <li>Codeforces - Distinct Characters Queries</li> <li>Codeforces - Knight Tournament [For beginners]</li> <li>Codeforces - Ant colony</li> <li>Codeforces - Drazil and Park</li> <li>Codeforces - Circular RMQ</li> <li>Codeforces - Lucky Array</li> <li>Codeforces - The Child and Sequence</li> <li>Codeforces - DZY Loves Fibonacci Numbers [Lazy propagation]</li> <li>Codeforces - Alphabet Permutations</li> <li>Codeforces - Eyes Closed</li> <li>Codeforces - Kefa and Watch</li> <li>Codeforces - A Simple Task</li> <li>Codeforces - SUM and REPLACE</li> <li>Codeforces - XOR on Segment [Lazy propagation]</li> <li>Codeforces - Please, another Queries on Array? [Lazy propagation]</li> <li>COCI - Deda [Last element smaller or equal to x / Binary search]</li> <li>Codeforces - The Untended Antiquity [2D]</li> <li>CSES - Hotel Queries</li> <li>CSES - Polynomial Queries</li> <li>CSES - Range Updates and Sums</li> </ul>","tags":["Translated"]},{"location":"data_structures/sparse-table.html","title":"Sparse Table","text":"<p>Sparse Table is a data structure, that allows answering range queries. It can answer most range queries in $O(\\log n)$, but its true power is answering range minimum queries (or equivalent range maximum queries). For those queries it can compute the answer in $O(1)$ time.</p> <p>The only drawback of this data structure is, that it can only be used on immutable arrays. This means, that the array cannot be changed between two queries. If any element in the array changes, the complete data structure has to be recomputed.</p>","tags":["Original"]},{"location":"data_structures/sparse-table.html#intuition","title":"Intuition","text":"<p>Any non-negative number can be uniquely represented as a sum of decreasing powers of two. This is just a variant of the binary representation of a number. E.g. $13 = (1101)_2 = 8 + 4 + 1$. For a number $x$ there can be at most $\\lceil \\log_2 x \\rceil$ summands.</p> <p>By the same reasoning any interval can be uniquely represented as a union of intervals with lengths that are decreasing powers of two. E.g. $[2, 14] = [2, 9] \\cup [10, 13] \\cup [14, 14]$, where the complete interval has length 13, and the individual intervals have the lengths 8, 4 and 1 respectively. And also here the union consists of at most $\\lceil \\log_2(\\text{length of interval}) \\rceil$ many intervals.</p> <p>The main idea behind Sparse Tables is to precompute all answers for range queries with power of two length. Afterwards a different range query can be answered by splitting the range into ranges with power of two lengths, looking up the precomputed answers, and combining them to receive a complete answer.</p>","tags":["Original"]},{"location":"data_structures/sparse-table.html#precomputation","title":"Precomputation","text":"<p>We will use a 2-dimensional array for storing the answers to the precomputed queries. $\\text{st}[i][j]$ will store the answer for the range $[j, j + 2^i - 1]$ of length $2^i$. The size of the 2-dimensional array will be $(K + 1) \\times \\text{MAXN}$, where $\\text{MAXN}$ is the biggest possible array length. $\\text{K}$ has to satisfy $\\text{K} \\ge \\lfloor \\log_2 \\text{MAXN} \\rfloor$, because $2^{\\lfloor \\log_2 \\text{MAXN} \\rfloor}$ is the biggest power of two range, that we have to support. For arrays with reasonable length ($\\le 10^7$ elements), $K = 25$ is a good value.</p> <p>The $\\text{MAXN}$ dimension is second to allow (cache friendly) consecutive memory accesses.</p> <pre><code>int st[K + 1][MAXN];\n</code></pre> <p>Because the range $[j, j + 2^i - 1]$ of length $2^i$ splits nicely into the ranges $[j, j + 2^{i - 1} - 1]$ and $[j + 2^{i - 1}, j + 2^i - 1]$, both of length $2^{i - 1}$, we can generate the table efficiently using dynamic programming:</p> <pre><code>std::copy(array.begin(), array.end(), st[0]);\n\nfor (int i = 1; i &lt;= K; i++)\n    for (int j = 0; j + (1 &lt;&lt; i) &lt;= N; j++)\n        st[i][j] = f(st[i - 1][j], st[i - 1][j + (1 &lt;&lt; (i - 1))]);\n</code></pre> <p>The function $f$ will depend on the type of query. For range sum queries it will compute the sum, for range minimum queries it will compute the minimum.</p> <p>The time complexity of the precomputation is $O(\\text{N} \\log \\text{N})$.</p>","tags":["Original"]},{"location":"data_structures/sparse-table.html#range-sum-queries","title":"Range Sum Queries","text":"<p>For this type of queries, we want to find the sum of all values in a range. Therefore the natural definition of the function $f$ is $f(x, y) = x + y$. We can construct the data structure with:</p> <pre><code>long long st[K + 1][MAXN];\n\nstd::copy(array.begin(), array.end(), st[0]);\n\nfor (int i = 1; i &lt;= K; i++)\n    for (int j = 0; j + (1 &lt;&lt; i) &lt;= N; j++)\n        st[i][j] = st[i - 1][j] + st[i - 1][j + (1 &lt;&lt; (i - 1))];\n</code></pre> <p>To answer the sum query for the range $[L, R]$, we iterate over all powers of two, starting from the biggest one. As soon as a power of two $2^i$ is smaller or equal to the length of the range ($= R - L + 1$), we process the first part of range $[L, L + 2^i - 1]$, and continue with the remaining range $[L + 2^i, R]$.</p> <pre><code>long long sum = 0;\nfor (int i = K; i &gt;= 0; i--) {\n    if ((1 &lt;&lt; i) &lt;= R - L + 1) {\n        sum += st[i][L];\n        L += 1 &lt;&lt; i;\n    }\n}\n</code></pre> <p>Time complexity for a Range Sum Query is $O(K) = O(\\log \\text{MAXN})$.</p>","tags":["Original"]},{"location":"data_structures/sparse-table.html#range-minimum-queries-rmq","title":"Range Minimum Queries (RMQ)","text":"<p>These are the queries where the Sparse Table shines. When computing the minimum of a range, it doesn't matter if we process a value in the range once or twice. Therefore instead of splitting a range into multiple ranges, we can also split the range into only two overlapping ranges with power of two length. E.g. we can split the range $[1, 6]$ into the ranges $[1, 4]$ and $[3, 6]$. The range minimum of $[1, 6]$ is clearly the same as the minimum of the range minimum of $[1, 4]$ and the range minimum of $[3, 6]$. So we can compute the minimum of the range $[L, R]$ with:</p> $$\\min(\\text{st}[i][L], \\text{st}[i][R - 2^i + 1]) \\quad \\text{ where } i = \\log_2(R - L + 1)$$ <p>This requires that we are able to compute $\\log_2(R - L + 1)$ fast. You can accomplish that by precomputing all logarithms:</p> <p><pre><code>int lg[MAXN+1];\nlg[1] = 0;\nfor (int i = 2; i &lt;= MAXN; i++)\n    lg[i] = lg[i/2] + 1;\n</code></pre> Alternatively, log can be computed on the fly in constant space and time: <pre><code>// C++20\n#include &lt;bit&gt;\nint log2_floor(unsigned long i) {\n    return std::bit_width(i) - 1;\n}\n\n// pre C++20\nint log2_floor(unsigned long long i) {\n    return i ? __builtin_clzll(1) - __builtin_clzll(i) : -1;\n}\n</code></pre> This benchmark shows that using <code>lg</code> array is slower because of cache misses.</p> <p>Afterwards we need to precompute the Sparse Table structure. This time we define $f$ with $f(x, y) = \\min(x, y)$.</p> <pre><code>int st[K + 1][MAXN];\n\nstd::copy(array.begin(), array.end(), st[0]);\n\nfor (int i = 1; i &lt;= K; i++)\n    for (int j = 0; j + (1 &lt;&lt; i) &lt;= N; j++)\n        st[i][j] = min(st[i - 1][j], st[i - 1][j + (1 &lt;&lt; (i - 1))]);\n</code></pre> <p>And the minimum of a range $[L, R]$ can be computed with:</p> <pre><code>int i = lg[R - L + 1];\nint minimum = min(st[i][L], st[i][R - (1 &lt;&lt; i) + 1]);\n</code></pre> <p>Time complexity for a Range Minimum Query is $O(1)$.</p>","tags":["Original"]},{"location":"data_structures/sparse-table.html#similar-data-structures-supporting-more-types-of-queries","title":"Similar data structures supporting more types of queries","text":"<p>One of the main weakness of the $O(1)$ approach discussed in the previous section is, that this approach only supports queries of idempotent functions. I.e. it works great for range minimum queries, but it is not possible to answer range sum queries using this approach.</p> <p>There are similar data structures that can handle any type of associative functions and answer range queries in $O(1)$. One of them is called Disjoint Sparse Table. Another one would be the Sqrt Tree.</p>","tags":["Original"]},{"location":"data_structures/sparse-table.html#practice-problems","title":"Practice Problems","text":"<ul> <li>SPOJ - RMQSQ</li> <li>SPOJ - THRBL</li> <li>Codechef - MSTICK</li> <li>Codechef - SEAD</li> <li>Codeforces - CGCDSSQ</li> <li>Codeforces - R2D2 and Droid Army</li> <li>Codeforces - Maximum of Maximums of Minimums</li> <li>SPOJ - Miraculous</li> <li>DevSkill - Multiplication Interval (archived)</li> <li>Codeforces - Animals and Puzzles</li> <li>Codeforces - Trains and Statistics</li> <li>SPOJ - Postering</li> <li>SPOJ - Negative Score</li> <li>SPOJ - A Famous City</li> <li>SPOJ - Diferencija</li> <li>Codeforces - Turn off the TV</li> <li>Codeforces - Map</li> <li>Codeforces - Awards for Contestants</li> <li>Codeforces - Longest Regular Bracket Sequence</li> <li>CSES - Static Range Minimum Queries</li> <li>Codeforces - Array Stabilization (GCD version)</li> </ul>","tags":["Original"]},{"location":"data_structures/sqrt-tree.html","title":"Sqrt Tree","text":"<p>Given an array $a$ that contains $n$ elements and the operation $\\circ$ that satisfies associative property: $(x \\circ y) \\circ z = x \\circ (y \\circ z)$ is true for any $x$, $y$, $z$.</p> <p>So, such operations as $\\gcd$, $\\min$, $\\max$, $+$, $\\text{and}$, $\\text{or}$, $\\text{xor}$, etc. satisfy these conditions.</p> <p>Also we have some queries $q(l, r)$. For each query, we need to compute $a_l \\circ a_{l+1} \\circ \\dots \\circ a_r$.</p> <p>Sqrt Tree can process such queries in $O(1)$ time with $O(n \\cdot \\log \\log n)$ preprocessing time and $O(n \\cdot \\log \\log n)$ memory.</p>","tags":["Original"]},{"location":"data_structures/sqrt-tree.html#description","title":"Description","text":"","tags":["Original"]},{"location":"data_structures/sqrt-tree.html#building-sqrt-decomposition","title":"Building sqrt decomposition","text":"<p>Let's make a sqrt decomposition. We divide our array in $\\sqrt{n}$ blocks, each block has size $\\sqrt{n}$. For each block, we compute:</p> <ol> <li>Answers to the queries that lie in the block and begin at the beginning of the block ($\\text{prefixOp}$)</li> <li>Answers to the queries that lie in the block and end at the end of the block ($\\text{suffixOp}$)</li> </ol> <p>And we'll compute an additional array:</p> <ol> <li>$\\text{between}_{i, j}$ (for $i \\le j$) - answer to the query that begins at the start of block $i$ and ends at the end of block $j$. Note that we have $\\sqrt{n}$ blocks, so the size of this array will be $O(\\sqrt{n}^2) = O(n)$.</li> </ol> <p>Let's see the example.</p> <p>Let $\\circ$ be $+$ (we calculate sum on a segment) and we have the following array $a$:</p> <p><code>{1, 2, 3, 4, 5, 6, 7, 8, 9}</code></p> <p>It will be divided onto three blocks: <code>{1, 2, 3}</code>, <code>{4, 5, 6}</code> and <code>{7, 8, 9}</code>.</p> <p>For first block $\\text{prefixOp}$ is <code>{1, 3, 6}</code> and $\\text{suffixOp}$ is <code>{6, 5, 3}</code>.</p> <p>For second block $\\text{prefixOp}$ is <code>{4, 9, 15}</code> and $\\text{suffixOp}$ is <code>{15, 11, 6}</code>.</p> <p>For third block $\\text{prefixOp}$ is <code>{7, 15, 24}</code> and $\\text{suffixOp}$ is <code>{24, 17, 9}</code>.</p> <p>$\\text{between}$ array is:</p> <pre><code>{\n    {6, 21, 45},\n    {0, 15, 39},\n    {0, 0,  24}\n}\n</code></pre> <p>(we assume that invalid elements where $i &gt; j$ are filled with zeroes)</p> <p>It's obvious to see that these arrays can be easily calculated in $O(n)$ time and memory.</p> <p>We already can answer some queries using these arrays. If the query doesn't fit into one block, we can divide it onto three parts: suffix of a block, then some segment of contiguous blocks and then prefix of some block. We can answer a query by dividing it into three parts and taking our operation of some value from $\\text{suffixOp}$, then some value from $\\text{between}$, then some value from $\\text{prefixOp}$.</p> <p>But if we have queries that entirely fit into one block, we cannot process them using these three arrays. So, we need to do something.</p>","tags":["Original"]},{"location":"data_structures/sqrt-tree.html#making-a-tree","title":"Making a tree","text":"<p>We cannot answer only the queries that entirely fit in one block. But what if we build the same structure as described above for each block? Yes, we can do it. And we do it recursively, until we reach the block size of $1$ or $2$. Answers for such blocks can be calculated easily in $O(1)$.</p> <p>So, we get a tree. Each node of the tree represents some segment of the array. Node that represents array segment with size $k$ has $\\sqrt{k}$ children -- for each block. Also each node contains the three arrays described above for the segment it contains. The root of the tree represents the entire array. Nodes with segment lengths $1$ or $2$ are leaves.</p> <p>Also it's obvious that the height of this tree is $O(\\log \\log n)$, because if some vertex of the tree represents an array with length $k$, then its children have length $\\sqrt{k}$. $\\log(\\sqrt{k}) = \\frac{\\log{k}}{2}$, so $\\log k$ decreases two times every layer of the tree and so its height is $O(\\log \\log n)$. The time for building and memory usage will be $O(n \\cdot \\log \\log n)$, because every element of the array appears exactly once on each layer of the tree.</p> <p>Now we can answer the queries in $O(\\log \\log n)$. We can go down on the tree until we meet a segment with length $1$ or $2$ (answer for it can be calculated in $O(1)$ time) or meet the first segment in which our query doesn't fit entirely into one block. See the first section on how to answer the query in this case.</p> <p>OK, now we can do $O(\\log \\log n)$ per query. Can it be done faster?</p>","tags":["Original"]},{"location":"data_structures/sqrt-tree.html#optimizing-the-query-complexity","title":"Optimizing the query complexity","text":"<p>One of the most obvious optimization is to binary search the tree node we need. Using binary search, we can reach the $O(\\log \\log \\log n)$ complexity per query. Can we do it even faster?</p> <p>The answer is yes. Let's assume the following two things:</p> <ol> <li>Each block size is a power of two.</li> <li>All the blocks are equal on each layer.</li> </ol> <p>To reach this, we can add some zero elements to our array so that its size becomes a power of two.</p> <p>When we use this, some block sizes may become twice larger to be a power of two, but it still be $O(\\sqrt{k})$ in size and we keep linear complexity for building the arrays in a segment.</p> <p>Now, we can easily check if the query fits entirely into a block with size $2^k$. Let's write the ranges of the query, $l$ and $r$ (we use 0-indexation) in binary form. For instance, let's assume $k=4, l=39, r=46$. The binary representation of $l$ and $r$ is:</p> <p>$l = 39_{10} = 100111_2$</p> <p>$r = 46_{10} = 101110_2$</p> <p>Remember that one layer contains segments of the equal size, and the block on one layer have also equal size (in our case, their size is $2^k = 2^4 = 16$. The blocks cover the array entirely, so the first block covers elements $(0 - 15)$ ($(000000_2 - 001111_2)$ in binary), the second one covers elements $(16 - 31)$ ($(010000_2 - 011111_2)$ in binary) and so on. We see that the indices of the positions covered by one block may differ only in $k$ (in our case, $4$) last bits. In our case $l$ and $r$ have equal bits except four lowest, so they lie in one block.</p> <p>So, we need to check if nothing more that $k$ smallest bits differ (or $l\\ \\text{xor}\\ r$ doesn't exceed $2^k-1$).</p> <p>Using this observation, we can find a layer that is suitable to answer the query quickly. How to do this:</p> <ol> <li> <p>For each $i$ that doesn't exceed the array size, we find the highest bit that is equal to $1$. To do this quickly, we use DP and a precalculated array.</p> </li> <li> <p>Now, for each $q(l, r)$ we find the highest bit of $l\\ \\text{xor}\\ r$ and, using this information, it's easy to choose the layer on which we can process the query easily. We can also use a precalculated array here.</p> </li> </ol> <p>For more details, see the code below.</p> <p>So, using this, we can answer the queries in $O(1)$ each. Hooray! :)</p>","tags":["Original"]},{"location":"data_structures/sqrt-tree.html#updating-elements","title":"Updating elements","text":"<p>We can also update elements in Sqrt Tree. Both single element updates and updates on a segment are supported.</p>","tags":["Original"]},{"location":"data_structures/sqrt-tree.html#updating-a-single-element","title":"Updating a single element","text":"<p>Consider a query $\\text{update}(x, val)$ that does the assignment $a_x = val$. We need to perform this query fast enough.</p>","tags":["Original"]},{"location":"data_structures/sqrt-tree.html#naive-approach","title":"Naive approach","text":"<p>First, let's take a look of what is changed in the tree when a single element changes. Consider a tree node with length $l$ and its arrays: $\\text{prefixOp}$, $\\text{suffixOp}$ and $\\text{between}$. It is easy to see that only $O(\\sqrt{l})$ elements from $\\text{prefixOp}$ and $\\text{suffixOp}$ change (only inside the block with the changed element). $O(l)$ elements are changed in $\\text{between}$. Therefore, $O(l)$ elements in the tree node are updated.</p> <p>We remember that any element $x$ is present in exactly one tree node at each layer. Root node (layer $0$) has length $O(n)$, nodes on layer $1$ have length $O(\\sqrt{n})$, nodes on layer $2$ have length $O(\\sqrt{\\sqrt{n}})$, etc. So the time complexity per update is $O(n + \\sqrt{n} + \\sqrt{\\sqrt{n}} + \\dots) = O(n)$.</p> <p>But it's too slow. Can it be done faster?</p>","tags":["Original"]},{"location":"data_structures/sqrt-tree.html#an-sqrt-tree-inside-the-sqrt-tree","title":"An sqrt-tree inside the sqrt-tree","text":"<p>Note that the bottleneck of updating is rebuilding $\\text{between}$ of the root node. To optimize the tree, let's get rid of this array! Instead of $\\text{between}$ array, we store another sqrt-tree for the root node. Let's call it $\\text{index}$. It plays the same role as $\\text{between}$\u2014 answers the queries on segments of blocks. Note that the rest of the tree nodes don't have $\\text{index}$, they keep their $\\text{between}$ arrays.</p> <p>A sqrt-tree is indexed, if its root node has $\\text{index}$. A sqrt-tree with $\\text{between}$ array in its root node is unindexed. Note that $\\text{index}$ is unindexed itself.</p> <p>So, we have the following algorithm for updating an indexed tree:</p> <ul> <li> <p>Update $\\text{prefixOp}$ and $\\text{suffixOp}$ in $O(\\sqrt{n})$.</p> </li> <li> <p>Update $\\text{index}$. It has length $O(\\sqrt{n})$ and we need to update only one item in it (that represents the changed block). So, the time complexity for this step is $O(\\sqrt{n})$. We can use the algorithm described in the beginning of this section (the \"slow\" one) to do it.</p> </li> <li> <p>Go into the child node that represents the changed block and update it in $O(\\sqrt{n})$ with the \"slow\" algorithm.</p> </li> </ul> <p>Note that the query complexity is still $O(1)$: we need to use $\\text{index}$ in query no more than once, and this will take $O(1)$ time.</p> <p>So, total time complexity for updating a single element is $O(\\sqrt{n})$. Hooray! :)</p>","tags":["Original"]},{"location":"data_structures/sqrt-tree.html#updating-a-segment","title":"Updating a segment","text":"<p>Sqrt-tree also can do things like assigning an element on a segment. $\\text{massUpdate}(x, l, r)$ means $a_i = x$ for all $l \\le i \\le r$.</p> <p>There are two approaches to do this: one of them does $\\text{massUpdate}$ in $O(\\sqrt{n}\\cdot \\log \\log n)$, keeping $O(1)$ per query. The second one does $\\text{massUpdate}$ in $O(\\sqrt{n})$, but the query complexity becomes $O(\\log \\log n)$.</p> <p>We will do lazy propagation in the same way as it is done in segment trees: we mark some nodes as lazy, meaning that we'll push them when it's necessary. But one thing is different from segment trees: pushing a node is expensive, so it cannot be done in queries. On the layer $0$, pushing a node takes $O(\\sqrt{n})$ time. So, we don't push nodes inside queries, we only look if the current node or its parent are lazy, and just take it into account while performing queries.</p>","tags":["Original"]},{"location":"data_structures/sqrt-tree.html#first-approach","title":"First approach","text":"<p>In the first approach, we say that only nodes on layer $1$ (with length $O(\\sqrt{n}$) can be lazy. When pushing such node, it updates all its subtree including itself in $O(\\sqrt{n}\\cdot \\log \\log n)$. The $\\text{massUpdate}$ process is done as follows:</p> <ul> <li> <p>Consider the nodes on layer $1$ and blocks corresponding to them.</p> </li> <li> <p>Some blocks are entirely covered by $\\text{massUpdate}$. Mark them as lazy in $O(\\sqrt{n})$.</p> </li> <li> <p>Some blocks are partially covered. Note there are no more than two blocks of this kind. Rebuild them in $O(\\sqrt{n}\\cdot \\log \\log n)$. If they were lazy, take it into account.</p> </li> <li> <p>Update $\\text{prefixOp}$ and $\\text{suffixOp}$ for partially covered blocks in $O(\\sqrt{n})$ (because there are only two such blocks).</p> </li> <li> <p>Rebuild the $\\text{index}$ in $O(\\sqrt{n}\\cdot \\log \\log n)$.</p> </li> </ul> <p>So we can do $\\text{massUpdate}$ fast. But how lazy propagation affects queries? They will have the following modifications:</p> <ul> <li> <p>If our query entirely lies in a lazy block, calculate it and take lazy into account. $O(1)$.</p> </li> <li> <p>If our query consists of many blocks, some of which are lazy, we need to take care of lazy only on the leftmost and the rightmost block. The rest of the blocks are calculated using $\\text{index}$, which already knows the answer on lazy block (because it's rebuilt after each modification). $O(1)$.</p> </li> </ul> <p>The query complexity still remains $O(1)$.</p>","tags":["Original"]},{"location":"data_structures/sqrt-tree.html#second-approach","title":"Second approach","text":"<p>In this approach, each node can be lazy (except root). Even nodes in $\\text{index}$ can be lazy. So, while processing a query, we have to look for lazy tags in all the parent nodes, i. e. query complexity will be $O(\\log \\log n)$.</p> <p>But $\\text{massUpdate}$ becomes faster. It looks in the following way:</p> <ul> <li> <p>Some blocks are fully covered with $\\text{massUpdate}$. So, lazy tags are added to them. It is $O(\\sqrt{n})$.</p> </li> <li> <p>Update $\\text{prefixOp}$ and $\\text{suffixOp}$ for partially covered blocks in $O(\\sqrt{n})$ (because there are only two such blocks).</p> </li> <li> <p>Do not forget to update the index. It is $O(\\sqrt{n})$ (we use the same $\\text{massUpdate}$ algorithm).</p> </li> <li> <p>Update $\\text{between}$ array for unindexed subtrees. </p> </li> <li> <p>Go into the nodes representing partially covered blocks and call $\\text{massUpdate}$ recursively.</p> </li> </ul> <p>Note that when we do the recursive call, we do prefix or suffix $\\text{massUpdate}$. But for prefix and suffix updates we can have no more than one partially covered child. So, we visit one node on layer $1$, two nodes on layer $2$ and two nodes on any deeper level. So, the time complexity is $O(\\sqrt{n} + \\sqrt{\\sqrt{n}} + \\dots) = O(\\sqrt{n})$. The approach here is similar to the segment tree mass update.</p>","tags":["Original"]},{"location":"data_structures/sqrt-tree.html#implementation","title":"Implementation","text":"<p>The following implementation of Sqrt Tree can perform the following operations: build in $O(n \\cdot \\log \\log n)$, answer queries in $O(1)$ and update an element in $O(\\sqrt{n})$.</p> <pre><code>SqrtTreeItem op(const SqrtTreeItem &amp;a, const SqrtTreeItem &amp;b);\n\ninline int log2Up(int n) {\n    int res = 0;\n    while ((1 &lt;&lt; res) &lt; n) {\n        res++;\n    }\n    return res;\n}\n\nclass SqrtTree {\nprivate:\n    int n, lg, indexSz;\n    vector&lt;SqrtTreeItem&gt; v;\n    vector&lt;int&gt; clz, layers, onLayer;\n    vector&lt; vector&lt;SqrtTreeItem&gt; &gt; pref, suf, between;\n\n    inline void buildBlock(int layer, int l, int r) {\n        pref[layer][l] = v[l];\n        for (int i = l+1; i &lt; r; i++) {\n            pref[layer][i] = op(pref[layer][i-1], v[i]);\n        }\n        suf[layer][r-1] = v[r-1];\n        for (int i = r-2; i &gt;= l; i--) {\n            suf[layer][i] = op(v[i], suf[layer][i+1]);\n        }\n    }\n\n    inline void buildBetween(int layer, int lBound, int rBound, int betweenOffs) {\n        int bSzLog = (layers[layer]+1) &gt;&gt; 1;\n        int bCntLog = layers[layer] &gt;&gt; 1;\n        int bSz = 1 &lt;&lt; bSzLog;\n        int bCnt = (rBound - lBound + bSz - 1) &gt;&gt; bSzLog;\n        for (int i = 0; i &lt; bCnt; i++) {\n            SqrtTreeItem ans;\n            for (int j = i; j &lt; bCnt; j++) {\n                SqrtTreeItem add = suf[layer][lBound + (j &lt;&lt; bSzLog)];\n                ans = (i == j) ? add : op(ans, add);\n                between[layer-1][betweenOffs + lBound + (i &lt;&lt; bCntLog) + j] = ans;\n            }\n        }\n    }\n\n    inline void buildBetweenZero() {\n        int bSzLog = (lg+1) &gt;&gt; 1;\n        for (int i = 0; i &lt; indexSz; i++) {\n            v[n+i] = suf[0][i &lt;&lt; bSzLog];\n        }\n        build(1, n, n + indexSz, (1 &lt;&lt; lg) - n);\n    }\n\n    inline void updateBetweenZero(int bid) {\n        int bSzLog = (lg+1) &gt;&gt; 1;\n        v[n+bid] = suf[0][bid &lt;&lt; bSzLog];\n        update(1, n, n + indexSz, (1 &lt;&lt; lg) - n, n+bid);\n    }\n\n    void build(int layer, int lBound, int rBound, int betweenOffs) {\n        if (layer &gt;= (int)layers.size()) {\n            return;\n        }\n        int bSz = 1 &lt;&lt; ((layers[layer]+1) &gt;&gt; 1);\n        for (int l = lBound; l &lt; rBound; l += bSz) {\n            int r = min(l + bSz, rBound);\n            buildBlock(layer, l, r);\n            build(layer+1, l, r, betweenOffs);\n        }\n        if (layer == 0) {\n            buildBetweenZero();\n        } else {\n            buildBetween(layer, lBound, rBound, betweenOffs);\n        }\n    }\n\n    void update(int layer, int lBound, int rBound, int betweenOffs, int x) {\n        if (layer &gt;= (int)layers.size()) {\n            return;\n        }\n        int bSzLog = (layers[layer]+1) &gt;&gt; 1;\n        int bSz = 1 &lt;&lt; bSzLog;\n        int blockIdx = (x - lBound) &gt;&gt; bSzLog;\n        int l = lBound + (blockIdx &lt;&lt; bSzLog);\n        int r = min(l + bSz, rBound);\n        buildBlock(layer, l, r);\n        if (layer == 0) {\n            updateBetweenZero(blockIdx);\n        } else {\n            buildBetween(layer, lBound, rBound, betweenOffs);\n        }\n        update(layer+1, l, r, betweenOffs, x);\n    }\n\n    inline SqrtTreeItem query(int l, int r, int betweenOffs, int base) {\n        if (l == r) {\n            return v[l];\n        }\n        if (l + 1 == r) {\n            return op(v[l], v[r]);\n        }\n        int layer = onLayer[clz[(l - base) ^ (r - base)]];\n        int bSzLog = (layers[layer]+1) &gt;&gt; 1;\n        int bCntLog = layers[layer] &gt;&gt; 1;\n        int lBound = (((l - base) &gt;&gt; layers[layer]) &lt;&lt; layers[layer]) + base;\n        int lBlock = ((l - lBound) &gt;&gt; bSzLog) + 1;\n        int rBlock = ((r - lBound) &gt;&gt; bSzLog) - 1;\n        SqrtTreeItem ans = suf[layer][l];\n        if (lBlock &lt;= rBlock) {\n            SqrtTreeItem add = (layer == 0) ? (\n                query(n + lBlock, n + rBlock, (1 &lt;&lt; lg) - n, n)\n            ) : (\n                between[layer-1][betweenOffs + lBound + (lBlock &lt;&lt; bCntLog) + rBlock]\n            );\n            ans = op(ans, add);\n        }\n        ans = op(ans, pref[layer][r]);\n        return ans;\n    }\npublic:\n    inline SqrtTreeItem query(int l, int r) {\n        return query(l, r, 0, 0);\n    }\n\n    inline void update(int x, const SqrtTreeItem &amp;item) {\n        v[x] = item;\n        update(0, 0, n, 0, x);\n    }\n\n    SqrtTree(const vector&lt;SqrtTreeItem&gt;&amp; a)\n        : n((int)a.size()), lg(log2Up(n)), v(a), clz(1 &lt;&lt; lg), onLayer(lg+1) {\n        clz[0] = 0;\n        for (int i = 1; i &lt; (int)clz.size(); i++) {\n            clz[i] = clz[i &gt;&gt; 1] + 1;\n        }\n        int tlg = lg;\n        while (tlg &gt; 1) {\n            onLayer[tlg] = (int)layers.size();\n            layers.push_back(tlg);\n            tlg = (tlg+1) &gt;&gt; 1;\n        }\n        for (int i = lg-1; i &gt;= 0; i--) {\n            onLayer[i] = max(onLayer[i], onLayer[i+1]);\n        }\n        int betweenLayers = max(0, (int)layers.size() - 1);\n        int bSzLog = (lg+1) &gt;&gt; 1;\n        int bSz = 1 &lt;&lt; bSzLog;\n        indexSz = (n + bSz - 1) &gt;&gt; bSzLog;\n        v.resize(n + indexSz);\n        pref.assign(layers.size(), vector&lt;SqrtTreeItem&gt;(n + indexSz));\n        suf.assign(layers.size(), vector&lt;SqrtTreeItem&gt;(n + indexSz));\n        between.assign(betweenLayers, vector&lt;SqrtTreeItem&gt;((1 &lt;&lt; lg) + bSz));\n        build(0, 0, n, 0);\n    }\n};\n</code></pre>","tags":["Original"]},{"location":"data_structures/sqrt-tree.html#problems","title":"Problems","text":"<p>CodeChef - SEGPROD</p>","tags":["Original"]},{"location":"data_structures/sqrt_decomposition.html","title":"Sqrt Decomposition","text":"<p>Sqrt Decomposition is a method (or a data structure) that allows you to perform some common operations (finding sum of the elements of the sub-array, finding the minimal/maximal element, etc.) in $O(\\sqrt n)$ operations, which is much faster than $O(n)$ for the trivial algorithm.</p> <p>First we describe the data structure for one of the simplest applications of this idea, then show how to generalize it to solve some other problems, and finally look at a slightly different use of this idea: splitting the input requests into sqrt blocks.</p>","tags":["Translated"]},{"location":"data_structures/sqrt_decomposition.html#sqrt-decomposition-based-data-structure","title":"Sqrt-decomposition based data structure","text":"<p>Given an array $a[0 \\dots n-1]$, implement a data structure that allows to find the sum of the elements $a[l \\dots r]$ for arbitrary $l$ and $r$ in $O(\\sqrt n)$ operations.</p>","tags":["Translated"]},{"location":"data_structures/sqrt_decomposition.html#description","title":"Description","text":"<p>The basic idea of sqrt decomposition is preprocessing. We'll divide the array $a$ into blocks of length approximately $\\sqrt n$, and for each block $i$ we'll precalculate the sum of elements in it $b[i]$.</p> <p>We can assume that both the size of the block and the number of blocks are equal to $\\sqrt n$ rounded up:</p> $$ s = \\lceil \\sqrt n \\rceil $$ <p>Then the array $a$ is divided into blocks in the following way:</p> $$ \\underbrace{a[0], a[1], \\dots, a[s-1]}_{\\text{b[0]}}, \\underbrace{a[s], \\dots, a[2s-1]}_{\\text{b[1]}}, \\dots, \\underbrace{a[(s-1) \\cdot s], \\dots, a[n-1]}_{\\text{b[s-1]}} $$ <p>The last block may have fewer elements than the others (if $n$ not a multiple of $s$), it is not important to the discussion (as it can be handled easily). Thus, for each block $k$, we know the sum of elements on it $b[k]$:</p> $$ b[k] = \\sum\\limits_{i=k\\cdot s}^{\\min {(n-1,(k+1)\\cdot s - 1})} a[i] $$ <p>So, we have calculated the values of $b[k]$ (this required $O(n)$ operations). How can they help us to answer each query $[l, r]$ ? Notice that if the interval $[l, r]$ is long enough, it will contain several whole blocks, and for those blocks we can find the sum of elements in them in a single operation. As a result, the interval $[l, r]$ will contain parts of only two blocks, and we'll have to calculate the sum of elements in these parts trivially.</p> <p>Thus, in order to calculate the sum of elements on the interval $[l, r]$ we only need to sum the elements of the two \"tails\": $[l\\dots (k + 1)\\cdot s-1]$ and $[p\\cdot s\\dots r]$ , and sum the values $b[i]$ in all the blocks from $k + 1$ to $p-1$:</p> $$ \\sum\\limits_{i=l}^r a[i] = \\sum\\limits_{i=l}^{(k+1) \\cdot s-1} a[i] + \\sum\\limits_{i=k+1}^{p-1} b[i] + \\sum\\limits_{i=p\\cdot s}^r a[i] $$ <p>Note: When $k = p$, i.e. $l$ and $r$ belong to the same block, the formula can't be applied, and the sum should be calculated trivially.</p> <p>This approach allows us to significantly reduce the number of operations. Indeed, the size of each \"tail\" does not exceed the block length $s$, and the number of blocks in the sum does not exceed $s$. Since we have chosen $s \\approx \\sqrt n$, the total number of operations required to find the sum of elements on the interval $[l, r]$ is $O(\\sqrt n)$.</p>","tags":["Translated"]},{"location":"data_structures/sqrt_decomposition.html#implementation","title":"Implementation","text":"<p>Let's start with the simplest implementation:</p> <pre><code>// input data\nint n;\nvector&lt;int&gt; a (n);\n\n// preprocessing\nint len = (int) sqrt (n + .0) + 1; // size of the block and the number of blocks\nvector&lt;int&gt; b (len);\nfor (int i=0; i&lt;n; ++i)\n    b[i / len] += a[i];\n\n// answering the queries\nfor (;;) {\n    int l, r;\n  // read input data for the next query\n    int sum = 0;\n    for (int i=l; i&lt;=r; )\n        if (i % len == 0 &amp;&amp; i + len - 1 &lt;= r) {\n            // if the whole block starting at i belongs to [l, r]\n            sum += b[i / len];\n            i += len;\n        }\n        else {\n            sum += a[i];\n            ++i;\n        }\n}\n</code></pre> <p>This implementation has unreasonably many division operations (which are much slower than other arithmetical operations). Instead, we can calculate the indices of the blocks $c_l$ and $c_r$ which contain indices $l$ and $r$, and loop through blocks $c_l+1 \\dots c_r-1$ with separate processing of the \"tails\" in blocks $c_l$ and $c_r$. This approach corresponds to the last formula in the description, and makes the case $c_l = c_r$ a special case.</p> <pre><code>int sum = 0;\nint c_l = l / len,   c_r = r / len;\nif (c_l == c_r)\n    for (int i=l; i&lt;=r; ++i)\n        sum += a[i];\nelse {\n    for (int i=l, end=(c_l+1)*len-1; i&lt;=end; ++i)\n        sum += a[i];\n    for (int i=c_l+1; i&lt;=c_r-1; ++i)\n        sum += b[i];\n    for (int i=c_r*len; i&lt;=r; ++i)\n        sum += a[i];\n}\n</code></pre>","tags":["Translated"]},{"location":"data_structures/sqrt_decomposition.html#other-problems","title":"Other problems","text":"<p>So far we were discussing the problem of finding the sum of elements of a continuous subarray. This problem can be extended to allow to update individual array elements. If an element $a[i]$ changes, it's sufficient to update the value of $b[k]$ for the block to which this element belongs ($k = i / s$) in one operation:</p> $$ b[k] += a_{new}[i] - a_{old}[i] $$ <p>On the other hand, the task of finding the sum of elements can be replaced with the task of finding minimal/maximal element of a subarray. If this problem has to address individual elements' updates as well, updating the value of $b[k]$ is also possible, but it will require iterating through all values of block $k$ in $O(s) = O(\\sqrt{n})$ operations.</p> <p>Sqrt decomposition can be applied in a similar way to a whole class of other problems: finding the number of zero elements, finding the first non-zero element, counting elements which satisfy a certain property etc.</p> <p>Another class of problems appears when we need to update array elements on intervals: increment existing elements or replace them with a given value.</p> <p>For example, let's say we can do two types of operations on an array: add a given value $\\delta$ to all array elements on interval $[l, r]$ or query the value of element $a[i]$. Let's store the value which has to be added to all elements of block $k$ in $b[k]$ (initially all $b[k] = 0$). During each \"add\" operation we need to add $\\delta$ to $b[k]$ for all blocks which belong to interval $[l, r]$ and to add $\\delta$ to $a[i]$ for all elements which belong to the \"tails\" of the interval. The answer to query $i$ is simply $a[i] + b[i/s]$. This way \"add\" operation has $O(\\sqrt{n})$ complexity, and answering a query has $O(1)$ complexity.</p> <p>Finally, those two classes of problems can be combined if the task requires doing both element updates on an interval and queries on an interval. Both operations can be done with $O(\\sqrt{n})$ complexity. This will require two block arrays $b$ and $c$: one to keep track of element updates and another to keep track of answers to the query.</p> <p>There exist other problems which can be solved using sqrt decomposition, for example, a problem about maintaining a set of numbers which would allow adding/deleting numbers, checking whether a number belongs to the set and finding $k$-th largest number. To solve it one has to store numbers in increasing order, split into several blocks with $\\sqrt{n}$ numbers in each. Every time a number is added/deleted, the blocks have to be rebalanced by moving numbers between beginnings and ends of adjacent blocks.</p>","tags":["Translated"]},{"location":"data_structures/sqrt_decomposition.html#mos-algorithm","title":"Mo's algorithm","text":"<p>A similar idea, based on sqrt decomposition, can be used to answer range queries ($Q$) offline in $O((N+Q)\\sqrt{N})$. This might sound like a lot worse than the methods in the previous section, since this is a slightly worse complexity than we had earlier and cannot update values between two queries. But in a lot of situations this method has advantages. During a normal sqrt decomposition, we have to precompute the answers for each block, and merge them during answering queries. In some problems this merging step can be quite problematic. E.g. when each queries asks to find the mode of its range (the number that appears the most often). For this each block would have to store the count of each number in it in some sort of data structure, and we can no longer perform the merge step fast enough any more. Mo's algorithm uses a completely different approach, that can answer these kind of queries fast, because it only keeps track of one data structure, and the only operations with it are easy and fast.</p> <p>The idea is to answer the queries in a special order based on the indices. We will first answer all queries which have the left index in block 0, then answer all queries which have left index in block 1 and so on. And also we will have to answer the queries of a block is a special order, namely sorted by the right index of the queries.</p> <p>As already said we will use a single data structure. This data structure will store information about the range. At the beginning this range will be empty. When we want to answer the next query (in the special order), we simply extend or reduce the range, by adding/removing elements on both sides of the current range, until we transformed it into the query range. This way, we only need to add or remove a single element once at a time, which should be pretty easy operations in our data structure.</p> <p>Since we change the order of answering the queries, this is only possible when we are allowed to answer the queries in offline mode.</p>","tags":["Translated"]},{"location":"data_structures/sqrt_decomposition.html#implementation_1","title":"Implementation","text":"<p>In Mo's algorithm we use two functions for adding an index and for removing an index from the range which we are currently maintaining.</p> <pre><code>void remove(idx);  // TODO: remove value at idx from data structure\nvoid add(idx);     // TODO: add value at idx from data structure\nint get_answer();  // TODO: extract the current answer of the data structure\n\nint block_size;\n\nstruct Query {\n    int l, r, idx;\n    bool operator&lt;(Query other) const\n    {\n        return make_pair(l / block_size, r) &lt;\n               make_pair(other.l / block_size, other.r);\n    }\n};\n\nvector&lt;int&gt; mo_s_algorithm(vector&lt;Query&gt; queries) {\n    vector&lt;int&gt; answers(queries.size());\n    sort(queries.begin(), queries.end());\n\n    // TODO: initialize data structure\n\n    int cur_l = 0;\n    int cur_r = -1;\n    // invariant: data structure will always reflect the range [cur_l, cur_r]\n    for (Query q : queries) {\n        while (cur_l &gt; q.l) {\n            cur_l--;\n            add(cur_l);\n        }\n        while (cur_r &lt; q.r) {\n            cur_r++;\n            add(cur_r);\n        }\n        while (cur_l &lt; q.l) {\n            remove(cur_l);\n            cur_l++;\n        }\n        while (cur_r &gt; q.r) {\n            remove(cur_r);\n            cur_r--;\n        }\n        answers[q.idx] = get_answer();\n    }\n    return answers;\n}\n</code></pre> <p>Based on the problem we can use a different data structure and modify the <code>add</code>/<code>remove</code>/<code>get_answer</code> functions accordingly. For example if we are asked to find range sum queries then we use a simple integer as data structure, which is $0$ at the beginning. The <code>add</code> function will simply add the value of the position and subsequently update the answer variable. On the other hand <code>remove</code> function will subtract the value at position and subsequently update the answer variable. And <code>get_answer</code> just returns the integer.</p> <p>For answering mode-queries, we can use a binary search tree (e.g. <code>map&lt;int, int&gt;</code>) for storing how often each number appears in the current range, and a second binary search tree (e.g. <code>set&lt;pair&lt;int, int&gt;&gt;</code>) for keeping counts of the numbers (e.g. as count-number pairs) in order. The <code>add</code> method removes the current number from the second BST, increases the count in the first one, and inserts the number back into the second one. <code>remove</code> does the same thing, it only decreases the count. And <code>get_answer</code> just looks at second tree and returns the best value in $O(1)$.</p>","tags":["Translated"]},{"location":"data_structures/sqrt_decomposition.html#complexity","title":"Complexity","text":"<p>Sorting all queries will take $O(Q \\log Q)$.</p> <p>How about the other operations? How many times will the <code>add</code> and <code>remove</code> be called?</p> <p>Let's say the block size is $S$.</p> <p>If we only look at all queries having the left index in the same block, the queries are sorted by the right index. Therefore we will call <code>add(cur_r)</code> and <code>remove(cur_r)</code> only $O(N)$ times for all these queries combined. This gives $O(\\frac{N}{S} N)$ calls for all blocks.</p> <p>The value of <code>cur_l</code> can change by at most $O(S)$ during between two queries. Therefore we have an additional $O(S Q)$ calls of <code>add(cur_l)</code> and <code>remove(cur_l)</code>.</p> <p>For $S \\approx \\sqrt{N}$ this gives $O((N + Q) \\sqrt{N})$ operations in total. Thus the complexity is $O((N+Q)F\\sqrt{N})$ where $O(F)$  is the complexity of <code>add</code> and <code>remove</code> function.</p>","tags":["Translated"]},{"location":"data_structures/sqrt_decomposition.html#tips-for-improving-runtime","title":"Tips for improving runtime","text":"<ul> <li>Block size of precisely $\\sqrt{N}$ doesn't always offer the best runtime.  For example, if $\\sqrt{N}=750$ then it may happen that block size of $700$ or $800$ may run better. More importantly, don't compute the block size at runtime - make it <code>const</code>. Division by constants is well optimized by compilers.</li> <li>In odd blocks sort the right index in ascending order and in even blocks sort it in descending order. This will minimize the movement of right pointer, as the normal sorting will move the right pointer from the end back to the beginning at the start of every block. With the improved version this resetting is no more necessary.</li> </ul> <pre><code>bool cmp(pair&lt;int, int&gt; p, pair&lt;int, int&gt; q) {\n    if (p.first / BLOCK_SIZE != q.first / BLOCK_SIZE)\n        return p &lt; q;\n    return (p.first / BLOCK_SIZE &amp; 1) ? (p.second &lt; q.second) : (p.second &gt; q.second);\n}\n</code></pre> <p>You can read about even faster sorting approach here.</p>","tags":["Translated"]},{"location":"data_structures/sqrt_decomposition.html#practice-problems","title":"Practice Problems","text":"<ul> <li>Codeforces - Kuriyama Mirai's Stones</li> <li>UVA - 12003 - Array Transformer</li> <li>UVA - 11990 Dynamic Inversion</li> <li>SPOJ - Give Away</li> <li>Codeforces - Till I Collapse</li> <li>Codeforces - Destiny</li> <li>Codeforces - Holes</li> <li>Codeforces - XOR and Favorite Number</li> <li>Codeforces - Powerful array</li> <li>SPOJ - DQUERY</li> <li>Codeforces - Robin Hood Archery</li> </ul>","tags":["Translated"]},{"location":"data_structures/stack_queue_modification.html","title":"Minimum stack / Minimum queue","text":"<p>In this article we will consider three problems:  first we will modify a stack in a way that allows us to find the smallest element of the stack in $O(1)$, then we will do the same thing with a queue, and finally we will use these data structures to find the minimum in all subarrays of a fixed length in an array in $O(n)$</p>","tags":["Translated"]},{"location":"data_structures/stack_queue_modification.html#stack-modification","title":"Stack modification","text":"<p>We want to modify the stack data structure in such a way, that it is possible to find the smallest element in the stack in $O(1)$ time, while maintaining the same asymptotic behavior for adding and removing elements from the stack. Quick reminder, on a stack we only add and remove elements on one end.</p> <p>To do this, we will not only store the elements in the stack, but we will store them in pairs: the element itself and the minimum in the stack starting from this element and below.</p> <pre><code>stack&lt;pair&lt;int, int&gt;&gt; st;\n</code></pre> <p>It is clear that finding the minimum in the whole stack consists only of looking at the value <code>stack.top().second</code>.</p> <p>It is also obvious that adding or removing a new element to the stack can be done in constant time.</p> <p>Implementation:</p> <ul> <li> <p>Adding an element: <pre><code>int new_min = st.empty() ? new_elem : min(new_elem, st.top().second);\nst.push({new_elem, new_min});\n</code></pre></p> </li> <li> <p>Removing an element: <pre><code>int removed_element = st.top().first;\nst.pop();\n</code></pre></p> </li> <li> <p>Finding the minimum: <pre><code>int minimum = st.top().second;\n</code></pre></p> </li> </ul>","tags":["Translated"]},{"location":"data_structures/stack_queue_modification.html#queue-modification-method-1","title":"Queue modification (method 1)","text":"<p>Now we want to achieve the same operations with a queue, i.e. we want to add elements at the end and remove them from the front.</p> <p>Here we consider a simple method for modifying a queue. It has a big disadvantage though, because the modified queue will actually not store all elements.</p> <p>The key idea is to only store the items in the queue that are needed to determine the minimum. Namely we will keep the queue in nondecreasing order (i.e. the smallest value will be stored in the head), and of course not in any arbitrary way, the actual minimum has to be always contained in the queue. This way the smallest element will always be in the head of the queue. Before adding a new element to the queue, it is enough to make a \"cut\": we will remove all trailing elements of the queue that are larger than the new element, and afterwards add the new element to the queue.  This way we don't break the order of the queue, and we will also not loose the current element if it is at any subsequent step the minimum.  All the elements that we removed can never be a minimum itself, so this operation is allowed. When we want to extract an element from the head, it actually might not be there (because we removed it previously while adding a smaller element).  Therefore when deleting an element from a queue we need to know the value of the element. If the head of the queue has the same value, we can safely remove it, otherwise we do nothing.</p> <p>Consider the implementations of the above operations:</p> <pre><code>deque&lt;int&gt; q;\n</code></pre> <ul> <li> <p>Finding the minimum: <pre><code>int minimum = q.front();\n</code></pre></p> </li> <li> <p>Adding an element: <pre><code>while (!q.empty() &amp;&amp; q.back() &gt; new_element)\n    q.pop_back();\nq.push_back(new_element);\n</code></pre></p> </li> <li> <p>Removing an element: <pre><code>if (!q.empty() &amp;&amp; q.front() == remove_element)\n    q.pop_front();\n</code></pre></p> </li> </ul> <p>It is clear that on average all these operation only take $O(1)$ time (because every element can only be pushed and popped once).</p>","tags":["Translated"]},{"location":"data_structures/stack_queue_modification.html#queue-modification-method-2","title":"Queue modification (method 2)","text":"<p>This is a modification of method 1. We want to be able to remove elements without knowing which element we have to remove. We can accomplish that by storing the index for each element in the queue. And we also remember how many elements we already have added and removed.</p> <pre><code>deque&lt;pair&lt;int, int&gt;&gt; q;\nint cnt_added = 0;\nint cnt_removed = 0;\n</code></pre> <ul> <li> <p>Finding the minimum: <pre><code>int minimum = q.front().first;\n</code></pre></p> </li> <li> <p>Adding an element: <pre><code>while (!q.empty() &amp;&amp; q.back().first &gt; new_element)\n    q.pop_back();\nq.push_back({new_element, cnt_added});\ncnt_added++;\n</code></pre></p> </li> <li> <p>Removing an element: <pre><code>if (!q.empty() &amp;&amp; q.front().second == cnt_removed) \n    q.pop_front();\ncnt_removed++;\n</code></pre></p> </li> </ul>","tags":["Translated"]},{"location":"data_structures/stack_queue_modification.html#queue-modification-method-3","title":"Queue modification (method 3)","text":"<p>Here we consider another way of modifying a queue to find the minimum in $O(1)$. This way is somewhat more complicated to implement, but this time we actually store all elements. And we also can remove an element from the front without knowing its value.</p> <p>The idea is to reduce the problem to the problem of stacks, which was already solved by us. So we only need to learn how to simulate a queue using two stacks.</p> <p>We make two stacks, <code>s1</code> and <code>s2</code>.  Of course these stack will be of the modified form, so that we can find the minimum in $O(1)$.  We will add new elements to the stack <code>s1</code>, and remove elements from the stack <code>s2</code>. If at any time the stack <code>s2</code> is empty, we move all elements from <code>s1</code> to <code>s2</code> (which essentially reverses the order of those elements). Finally finding the minimum in a queue involves just finding the minimum of both stacks.</p> <p>Thus we perform all operations in $O(1)$ on average (each element will be once added to stack <code>s1</code>, once transferred to <code>s2</code>, and once popped from <code>s2</code>)</p> <p>Implementation:</p> <pre><code>stack&lt;pair&lt;int, int&gt;&gt; s1, s2;\n</code></pre> <ul> <li> <p>Finding the minimum: <pre><code>if (s1.empty() || s2.empty()) \n    minimum = s1.empty() ? s2.top().second : s1.top().second;\nelse\n    minimum = min(s1.top().second, s2.top().second);\n</code></pre></p> </li> <li> <p>Add element: <pre><code>int minimum = s1.empty() ? new_element : min(new_element, s1.top().second);\ns1.push({new_element, minimum});\n</code></pre></p> </li> <li> <p>Removing an element: <pre><code>if (s2.empty()) {\n    while (!s1.empty()) {\n        int element = s1.top().first;\n        s1.pop();\n        int minimum = s2.empty() ? element : min(element, s2.top().second);\n        s2.push({element, minimum});\n    }\n}\nint remove_element = s2.top().first;\ns2.pop();\n</code></pre></p> </li> </ul>","tags":["Translated"]},{"location":"data_structures/stack_queue_modification.html#finding-the-minimum-for-all-subarrays-of-fixed-length","title":"Finding the minimum for all subarrays of fixed length","text":"<p>Suppose we are given an array $A$ of length $N$ and a given $M \\le N$. We have to find the minimum of each subarray of length $M$ in this array, i.e. we have to find:</p> $$\\min_{0 \\le i \\le M-1} A[i], \\min_{1 \\le i \\le M} A[i], \\min_{2 \\le i \\le M+1} A[i],~\\dots~, \\min_{N-M \\le i \\le N-1} A[i]$$ <p>We have to solve this problem in linear time, i.e. $O(n)$.</p> <p>We can use any of the three modified queues to solve the problem. The solutions should be clear: we add the first $M$ element of the array, find and output its minimum, then add the next element to the queue and remove the first element of the array, find and output its minimum, etc.  Since all operations with the queue are performed in constant time on average, the complexity of the whole algorithm will be $O(n)$.</p>","tags":["Translated"]},{"location":"data_structures/stack_queue_modification.html#practice-problems","title":"Practice Problems","text":"<ul> <li>Queries with Fixed Length</li> <li>Sliding Window Minimum</li> <li>Binary Land</li> </ul>","tags":["Translated"]},{"location":"data_structures/treap.html","title":"Treap (Cartesian tree)","text":"<p>A treap is a data structure which combines binary tree and binary heap (hence the name: tree + heap $\\Rightarrow$ Treap).</p> <p>More specifically, treap is a data structure that stores pairs $(X, Y)$ in a binary tree in such a way that it is a binary search tree by $X$ and a binary heap by $Y$. If some node of the tree contains values $(X_0, Y_0)$, all nodes in the left subtree have $X \\leq X_0$, all nodes in the right subtree have $X_0 \\leq X$, and all nodes in both left and right subtrees have $Y \\leq Y_0$.</p> <p>A treap is also often referred to as a \"cartesian tree\", as it is easy to embed it in a Cartesian plane:</p> <p>Treaps have been proposed by Raimund Siedel and Cecilia Aragon in 1989.</p>","tags":["Translated"]},{"location":"data_structures/treap.html#advantages-of-such-data-organisation","title":"Advantages of such data organisation","text":"<p>In such implementation, $X$ values are the keys (and at same time the values stored in the treap), and $Y$ values are called priorities. Without priorities, the treap would be a regular binary search tree by $X$, and one set of $X$ values could correspond to a lot of different trees, some of them degenerate (for example, in the form of a linked list), and therefore extremely slow (the main operations would have $O(N)$ complexity).</p> <p>At the same time, priorities (when they're unique) allow to uniquely specify the tree that will be constructed (of course, it does not depend on the order in which values are added), which can be proven using corresponding theorem. Obviously, if you choose the priorities randomly, you will get non-degenerate trees on average, which will ensure $O(\\log N)$ complexity for the main operations. Hence another name of this data structure - randomized binary search tree.</p>","tags":["Translated"]},{"location":"data_structures/treap.html#operations","title":"Operations","text":"<p>A treap provides the following operations:</p> <ul> <li>Insert (X,Y) in $O(\\log N)$.   Adds a new node to the tree. One possible variant is to pass only $X$ and generate $Y$ randomly inside the operation.</li> <li>Search (X) in $O(\\log N)$.   Looks for a node with the specified key value $X$. The implementation is the same as for an ordinary binary search tree.</li> <li>Erase (X) in $O(\\log N)$.   Looks for a node with the specified key value $X$ and removes it from the tree.</li> <li>Build ($X_1$, ..., $X_N$) in $O(N)$.   Builds a tree from a list of values. This can be done in linear time (assuming that $X_1, ..., X_N$ are sorted).</li> <li>Union ($T_1$, $T_2$) in $O(M \\log (N/M))$.   Merges two trees, assuming that all the elements are different. It is possible to achieve the same complexity if duplicate elements should be removed during merge.</li> <li>Intersect ($T_1$, $T_2$) in $O(M \\log (N/M))$.   Finds the intersection of two trees (i.e. their common elements). We will not consider the implementation of this operation here.</li> </ul> <p>In addition, due to the fact that a treap is a binary search tree, it can implement other operations, such as finding the $K$-th largest element or finding the index of an element.</p>","tags":["Translated"]},{"location":"data_structures/treap.html#implementation-description","title":"Implementation Description","text":"<p>In terms of implementation, each node contains $X$, $Y$ and pointers to the left ($L$) and right ($R$) children.</p> <p>We will implement all the required operations using just two auxiliary operations: Split and Merge.</p>","tags":["Translated"]},{"location":"data_structures/treap.html#split","title":"Split","text":"<p>Split ($T$, $X$) separates tree $T$ in 2 subtrees $L$ and $R$ trees (which are the return values of split) so that $L$ contains all elements with key $X_L \\le X$, and $R$ contains all elements with key $X_R &gt; X$. This operation has $O (\\log N)$ complexity and is implemented using a clean recursion:</p> <ol> <li>If the value of the root node (R) is $\\le X$, then <code>L</code> would at least consist of <code>R-&gt;L</code> and <code>R</code>. We then call split on <code>R-&gt;R</code>, and note its split result as <code>L'</code> and <code>R'</code>. Finally, <code>L</code> would also contain <code>L'</code>, whereas <code>R = R'</code>.</li> <li>If the value of the root node (R) is $&gt; X$, then <code>R</code> would at least consist of <code>R</code> and <code>R-&gt;R</code>. We then call split on <code>R-&gt;L</code>, and note its split result as <code>L'</code> and <code>R'</code>. Finally, <code>L=L'</code>, whereas <code>R</code> would also contain <code>R'</code>.</li> </ol> <p>Thus, the split algorithm is:</p> <ol> <li>decide which subtree the root node would belong to (left or right)</li> <li>recursively call split on one of its children</li> <li>create the final result by reusing the recursive split call.</li> </ol>","tags":["Translated"]},{"location":"data_structures/treap.html#merge","title":"Merge","text":"<p>Merge ($T_1$, $T_2$) combines two subtrees $T_1$ and $T_2$ and returns the new tree. This operation also has $O (\\log N)$ complexity. It works under the assumption that $T_1$ and $T_2$ are ordered (all keys $X$ in $T_1$ are smaller than keys in $T_2$). Thus, we need to combine these trees without violating the order of priorities $Y$. To do this, we choose as the root the tree which has higher priority $Y$ in the root node, and recursively call Merge for the other tree and the corresponding subtree of the selected root node.</p>","tags":["Translated"]},{"location":"data_structures/treap.html#insert","title":"Insert","text":"<p>Now implementation of Insert ($X$, $Y$) becomes obvious. First we descend in the tree (as in a regular binary search tree by X), and stop at the first node in which the priority value is less than $Y$. We have found the place where we will insert the new element. Next, we call Split (T, X) on the subtree starting at the found node, and use returned subtrees $L$ and $R$ as left and right children of the new node.</p> <p>Alternatively, insert can be done by splitting the initial treap on $X$ and doing $2$ merges with the new node (see the picture).</p>","tags":["Translated"]},{"location":"data_structures/treap.html#erase","title":"Erase","text":"<p>Implementation of Erase ($X$) is also clear. First we descend in the tree (as in a regular binary search tree by $X$), looking for the element we want to delete. Once the node is found, we call Merge on its children and put the return value of the operation in the place of the element we're deleting.</p> <p>Alternatively, we can factor out the subtree holding $X$ with $2$ split operations and merge the remaining treaps (see the picture).</p>","tags":["Translated"]},{"location":"data_structures/treap.html#build","title":"Build","text":"<p>We implement Build operation with $O (N \\log N)$ complexity using $N$ Insert calls.</p>","tags":["Translated"]},{"location":"data_structures/treap.html#union","title":"Union","text":"<p>Union ($T_1$, $T_2$) has theoretical complexity $O (M \\log (N / M))$, but in practice it works very well, probably with a very small hidden constant. Let's assume without loss of generality that $T_1 \\rightarrow Y &gt; T_2 \\rightarrow Y$, i. e. root of $T_1$ will be the root of the result. To get the result, we need to merge trees $T_1 \\rightarrow L$, $T_1 \\rightarrow R$ and $T_2$ in two trees which could be children of $T_1$ root. To do this, we call Split ($T_2$, $T_1\\rightarrow X$), thus splitting $T_2$ in two parts L and R, which we then recursively combine with children of $T_1$: Union ($T_1 \\rightarrow L$, $L$) and Union ($T_1 \\rightarrow R$, $R$), thus getting left and right subtrees of the result.</p>","tags":["Translated"]},{"location":"data_structures/treap.html#implementation","title":"Implementation","text":"<pre><code>struct item {\n    int key, prior;\n    item *l, *r;\n    item () { }\n    item (int key) : key(key), prior(rand()), l(NULL), r(NULL) { }\n    item (int key, int prior) : key(key), prior(prior), l(NULL), r(NULL) { }\n};\ntypedef item* pitem;\n</code></pre> <p>This is our item defintion. Note there are two child pointers, and an integer key (for the BST) and an integer priority (for the heap). The priority is assigned using a random number generator.</p> <pre><code>void split (pitem t, int key, pitem &amp; l, pitem &amp; r) {\n    if (!t)\n        l = r = NULL;\n    else if (t-&gt;key &lt;= key)\n        split (t-&gt;r, key, t-&gt;r, r),  l = t;\n    else\n        split (t-&gt;l, key, l, t-&gt;l),  r = t;\n}\n</code></pre> <p><code>t</code> is the treap to split, and <code>key</code> is the BST value by which to split. Note that we do not <code>return</code> the result values anywhere, instead, we just use them like so:</p> <pre><code>pitem l = nullptr, r = nullptr;\nsplit(t, 5, l, r);\nif (l) cout &lt;&lt; \"Left subtree size: \" &lt;&lt; (l-&gt;size) &lt;&lt; endl;\nif (r) cout &lt;&lt; \"Right subtree size: \" &lt;&lt; (r-&gt;size) &lt;&lt; endl;\n</code></pre> <p>This <code>split</code> function can be tricky to understand, as it has both pointers (<code>pitem</code>) as well as reference to those pointers (<code>pitem &amp;l</code>). Let us understand in words what the function call <code>split(t, k, l, r)</code> intends: \"split treap <code>t</code> by value <code>k</code> into two treaps, and store the left treaps in <code>l</code> and right treap in <code>r</code>\". Great! Now, let us apply this definition to the two recursive calls, using the case work we analyzed in the previous section: (The first if condition is a trivial base case for an empty treap)</p> <ol> <li>When the root node value is $\\le$ key, we call <code>split (t-&gt;r, key, t-&gt;r, r)</code>, which means: \"split treap <code>t-&gt;r</code> (right subtree of <code>t</code>) by value <code>key</code> and store the left subtree in <code>t-&gt;r</code> and right subtree in <code>r</code>\". After that, we set <code>l = t</code>. Note now that the <code>l</code> result value contains <code>t-&gt;l</code>, <code>t</code> as well as <code>t-&gt;r</code> (which is the result of the recursive call we made) all already merged in the correct order! You should pause to ensure that this result of <code>l</code> and <code>r</code> corresponds exactly with what we discussed earlier in Implementation Description.</li> <li>When the root node value is greater than key, we call <code>split (t-&gt;l, key, l, t-&gt;l)</code>, which means: \"split treap <code>t-&gt;l</code> (left subtree of <code>t</code>) by value <code>key</code> and store the left subtree in <code>l</code> and right subtree in <code>t-&gt;l</code>\". After that, we set <code>r = t</code>. Note now that the <code>r</code> result value contains <code>t-&gt;l</code> (which is the result of the recursive call we made), <code>t</code> as well as <code>t-&gt;r</code>, all already merged in the correct order! You should pause to ensure that this result of <code>l</code> and <code>r</code> corresponds exactly with what we discussed earlier in Implementation Description.</li> </ol> <p>If you're still having trouble understanding the implementation, you should look at it inductively, that is: do not try to break down the recursive calls over and over again. Assume the split implementation works correct on empty treap, then try to run it for a single node treap, then a two node treap, and so on, each time reusing your knowledge that split on smaller treaps works.</p> <pre><code>void insert (pitem &amp; t, pitem it) {\n    if (!t)\n        t = it;\n    else if (it-&gt;prior &gt; t-&gt;prior)\n        split (t, it-&gt;key, it-&gt;l, it-&gt;r),  t = it;\n    else\n        insert (t-&gt;key &lt;= it-&gt;key ? t-&gt;r : t-&gt;l, it);\n}\n\nvoid merge (pitem &amp; t, pitem l, pitem r) {\n    if (!l || !r)\n        t = l ? l : r;\n    else if (l-&gt;prior &gt; r-&gt;prior)\n        merge (l-&gt;r, l-&gt;r, r),  t = l;\n    else\n        merge (r-&gt;l, l, r-&gt;l),  t = r;\n}\n\nvoid erase (pitem &amp; t, int key) {\n    if (t-&gt;key == key) {\n        pitem th = t;\n        merge (t, t-&gt;l, t-&gt;r);\n        delete th;\n    }\n    else\n        erase (key &lt; t-&gt;key ? t-&gt;l : t-&gt;r, key);\n}\n\npitem unite (pitem l, pitem r) {\n    if (!l || !r)  return l ? l : r;\n    if (l-&gt;prior &lt; r-&gt;prior)  swap (l, r);\n    pitem lt, rt;\n    split (r, l-&gt;key, lt, rt);\n    l-&gt;l = unite (l-&gt;l, lt);\n    l-&gt;r = unite (l-&gt;r, rt);\n    return l;\n}\n</code></pre>","tags":["Translated"]},{"location":"data_structures/treap.html#maintaining-the-sizes-of-subtrees","title":"Maintaining the sizes of subtrees","text":"<p>To extend the functionality of the treap, it is often necessary to store the number of nodes in subtree of each node - field <code>int cnt</code> in the <code>item</code> structure. For example, it can be used to find K-th largest element of tree in $O (\\log N)$, or to find the index of the element in the sorted list with the same complexity. The implementation of these operations will be the same as for the regular binary search tree.</p> <p>When a tree changes (nodes are added or removed etc.), <code>cnt</code> of some nodes should be updated accordingly. We'll create two functions: <code>cnt()</code> will return the current value of <code>cnt</code> or 0 if the node does not exist, and <code>upd_cnt()</code> will update the value of <code>cnt</code> for this node assuming that for its children L and R the values of <code>cnt</code> have already been updated. Evidently it's sufficient to add calls of <code>upd_cnt()</code> to the end of <code>insert</code>, <code>erase</code>, <code>split</code> and <code>merge</code> to keep <code>cnt</code> values up-to-date.</p> <pre><code>int cnt (pitem t) {\n    return t ? t-&gt;cnt : 0;\n}\n\nvoid upd_cnt (pitem t) {\n    if (t)\n        t-&gt;cnt = 1 + cnt(t-&gt;l) + cnt (t-&gt;r);\n}\n</code></pre>","tags":["Translated"]},{"location":"data_structures/treap.html#building-a-treap-in-o-n-in-offline-mode","title":"Building a Treap in $O (N)$ in offline mode","text":"<p>Given a sorted list of keys, it is possible to construct a treap faster than by inserting the keys one at a time which takes $O(N \\log N)$. Since the keys are sorted, a balanced binary search tree can be easily constructed in linear time. The heap values $Y$ are initialized randomly and then can be heapified independent of the keys $X$ to build the heap in $O(N)$.</p> <pre><code>void heapify (pitem t) {\n    if (!t) return;\n    pitem max = t;\n    if (t-&gt;l != NULL &amp;&amp; t-&gt;l-&gt;prior &gt; max-&gt;prior)\n        max = t-&gt;l;\n    if (t-&gt;r != NULL &amp;&amp; t-&gt;r-&gt;prior &gt; max-&gt;prior)\n        max = t-&gt;r;\n    if (max != t) {\n        swap (t-&gt;prior, max-&gt;prior);\n        heapify (max);\n    }\n}\n\npitem build (int * a, int n) {\n    // Construct a treap on values {a[0], a[1], ..., a[n - 1]}\n    if (n == 0) return NULL;\n    int mid = n / 2;\n    pitem t = new item (a[mid], rand ());\n    t-&gt;l = build (a, mid);\n    t-&gt;r = build (a + mid + 1, n - mid - 1);\n    heapify (t);\n    upd_cnt(t)\n    return t;\n}\n</code></pre> <p>Note: calling <code>upd_cnt(t)</code> is only necessary if you need the subtree sizes.</p> <p>The approach above always provides a perfectly balanced tree, which is generally good for practical purposes, but at the cost of not preserving the priorities that were initially assigned to each node. Thus, this approach is not feasible to solve the following problem:</p> <p>acmsguru - Cartesian Tree</p> <p>Given a sequence of pairs $(x_i, y_i)$, construct a cartesian tree on them. All $x_i$ and all $y_i$ are unique.</p> <p>Note that in this problem priorities are not random, hence just inserting vertices one by one could provide a quadratic solution.</p> <p>One of possible solutions here is to find for each element the closest elements to the left and to the right which have a smaller priority than this element. Among these two elements, the one with the larger priority must be the parent of the current element.</p> <p>This problem is solvable with a minimum stack modification in linear time:</p> <pre><code>void connect(auto from, auto to) {\n    vector&lt;pitem&gt; st;\n    for(auto it: ranges::subrange(from, to)) {\n        while(!st.empty() &amp;&amp; st.back()-&gt;prior &gt; it-&gt;prior) {\n            st.pop_back();\n        }\n        if(!st.empty()) {\n            if(!it-&gt;p || it-&gt;p-&gt;prior &lt; st.back()-&gt;prior) {\n                it-&gt;p = st.back();\n            }\n        }\n        st.push_back(it);\n    }\n}\n\npitem build(int *x, int *y, int n) {\n    vector&lt;pitem&gt; nodes(n);\n    for(int i = 0; i &lt; n; i++) {\n        nodes[i] = new item(x[i], y[i]);\n    }\n    connect(nodes.begin(), nodes.end());\n    connect(nodes.rbegin(), nodes.rend());\n    for(int i = 0; i &lt; n; i++) {\n        if(nodes[i]-&gt;p) {\n            if(nodes[i]-&gt;p-&gt;key &lt; nodes[i]-&gt;key) {\n                nodes[i]-&gt;p-&gt;r = nodes[i];\n            } else {\n                nodes[i]-&gt;p-&gt;l = nodes[i];\n            }\n        }\n    }\n    return nodes[min_element(y, y + n) - y];\n}\n</code></pre>","tags":["Translated"]},{"location":"data_structures/treap.html#implicit-treaps","title":"Implicit Treaps","text":"<p>Implicit treap is a simple modification of the regular treap which is a very powerful data structure. In fact, implicit treap can be considered as an array with the following procedures implemented (all in $O (\\log N)$ in the online mode):</p> <ul> <li>Inserting an element in the array in any location</li> <li>Removal of an arbitrary element</li> <li>Finding sum, minimum / maximum element etc. on an arbitrary interval</li> <li>Addition, painting on an arbitrary interval</li> <li>Reversing elements on an arbitrary interval</li> </ul> <p>The idea is that the keys should be null-based indices of the elements in the array. But we will not store these values explicitly (otherwise, for example, inserting an element would cause changes of the key in $O (N)$ nodes of the tree).</p> <p>Note that the key of a node is the number of nodes less than it (such nodes can be present not only in its left subtree but also in left subtrees of its ancestors).  More specifically, the implicit key for some node T is the number of vertices $cnt (T \\rightarrow L)$ in the left subtree of this node plus similar values $cnt (P \\rightarrow L) + 1$ for each ancestor P of the node T, if T is in the right subtree of P.</p> <p>Now it's clear how to calculate the implicit key of current node quickly. Since in all operations we arrive to any node by descending in the tree, we can just accumulate this sum and pass it to the function. If we go to the left subtree, the accumulated sum does not change, if we go to the right subtree it increases by $cnt (T \\rightarrow L) +1$.</p> <p>Here are the new implementations of Split and Merge:</p> <pre><code>void merge (pitem &amp; t, pitem l, pitem r) {\n    if (!l || !r)\n        t = l ? l : r;\n    else if (l-&gt;prior &gt; r-&gt;prior)\n        merge (l-&gt;r, l-&gt;r, r),  t = l;\n    else\n        merge (r-&gt;l, l, r-&gt;l),  t = r;\n    upd_cnt (t);\n}\n\nvoid split (pitem t, pitem &amp; l, pitem &amp; r, int key, int add = 0) {\n    if (!t)\n        return void( l = r = 0 );\n    int cur_key = add + cnt(t-&gt;l); //implicit key\n    if (key &lt;= cur_key)\n        split (t-&gt;l, l, t-&gt;l, key, add),  r = t;\n    else\n        split (t-&gt;r, t-&gt;r, r, key, add + 1 + cnt(t-&gt;l)),  l = t;\n    upd_cnt (t);\n}\n</code></pre> <p>In the implementation above, after the call of $split(T, T_1, T_2, k)$, the tree $T_1$ will consist of first $k$ elements of $T$ (that is, of elements having their implicit key less than $k$) and $T_2$ will consist of all the rest.</p> <p>Now let's consider the implementation of various operations on implicit treaps:</p> <ul> <li>Insert element.   Suppose we need to insert an element at position $pos$. We divide the treap into two parts, which correspond to arrays $[0..pos-1]$ and $[pos..sz]$; to do this we call $split(T, T_1, T_2, pos)$. Then we can combine tree $T_1$ with the new vertex by calling $merge(T_1, T_1, \\text{new item})$ (it is easy to see that all preconditions are met). Finally, we combine trees $T_1$ and $T_2$ back into $T$ by calling $merge(T, T_1, T_2)$.</li> <li>Delete element.  This operation is even easier: find the element to be deleted $T$, perform merge of its children $L$ and $R$, and replace the element $T$ with the result of merge. In fact, element deletion in the implicit treap is exactly the same as in the regular treap.</li> <li>Find sum / minimum, etc. on the interval.  First, create an additional field $F$ in the <code>item</code> structure to store the value of the target function for this node's subtree. This field is easy to maintain similarly to maintaining sizes of subtrees: create a function which calculates this value for a node based on values for its children and add calls of this function in the end of all functions which modify the tree.  Second, we need to know how to process a query for an arbitrary interval $[A; B]$.  To get a part of tree which corresponds to the interval $[A; B]$, we need to call $split(T, T_2, T_3, B+1)$, and then $split(T_2, T_1, T_2, A)$: after this $T_2$ will consist of all the elements in the interval $[A; B]$, and only of them. Therefore, the response to the query will be stored in the field $F$ of the root of $T_2$. After the query is answered, the tree has to be restored by calling $merge(T, T_1, T_2)$ and $merge(T, T, T_3)$.</li> <li>Addition / painting on the interval.  We act similarly to the previous paragraph, but instead of the field F we will store a field <code>add</code> which will contain the added value for the subtree (or the value to which the subtree is painted). Before performing any operation we have to \"push\" this value correctly - i.e. change $T \\rightarrow L \\rightarrow add$ and $T \\rightarrow R \\rightarrow add$, and to clean up <code>add</code> in the parent node. This way after any changes to the tree the information will not be lost.</li> <li>Reverse on the interval.  This is again similar to the previous operation: we have to add boolean flag <code>rev</code> and set it to true when the subtree of the current node has to be reversed. \"Pushing\" this value is a bit complicated - we swap children of this node and set this flag to true for them.</li> </ul> <p>Here is an example implementation of the implicit treap with reverse on the interval. For each node we store field called <code>value</code> which is the actual value of the array element at current position. We also provide implementation of the function <code>output()</code>, which outputs an array that corresponds to the current state of the implicit treap.</p> <pre><code>typedef struct item * pitem;\nstruct item {\n    int prior, value, cnt;\n    bool rev;\n    pitem l, r;\n};\n\nint cnt (pitem it) {\n    return it ? it-&gt;cnt : 0;\n}\n\nvoid upd_cnt (pitem it) {\n    if (it)\n        it-&gt;cnt = cnt(it-&gt;l) + cnt(it-&gt;r) + 1;\n}\n\nvoid push (pitem it) {\n    if (it &amp;&amp; it-&gt;rev) {\n        it-&gt;rev = false;\n        swap (it-&gt;l, it-&gt;r);\n        if (it-&gt;l)  it-&gt;l-&gt;rev ^= true;\n        if (it-&gt;r)  it-&gt;r-&gt;rev ^= true;\n    }\n}\n\nvoid merge (pitem &amp; t, pitem l, pitem r) {\n    push (l);\n    push (r);\n    if (!l || !r)\n        t = l ? l : r;\n    else if (l-&gt;prior &gt; r-&gt;prior)\n        merge (l-&gt;r, l-&gt;r, r),  t = l;\n    else\n        merge (r-&gt;l, l, r-&gt;l),  t = r;\n    upd_cnt (t);\n}\n\nvoid split (pitem t, pitem &amp; l, pitem &amp; r, int key, int add = 0) {\n    if (!t)\n        return void( l = r = 0 );\n    push (t);\n    int cur_key = add + cnt(t-&gt;l);\n    if (key &lt;= cur_key)\n        split (t-&gt;l, l, t-&gt;l, key, add),  r = t;\n    else\n        split (t-&gt;r, t-&gt;r, r, key, add + 1 + cnt(t-&gt;l)),  l = t;\n    upd_cnt (t);\n}\n\nvoid reverse (pitem t, int l, int r) {\n    pitem t1, t2, t3;\n    split (t, t1, t2, l);\n    split (t2, t2, t3, r-l+1);\n    t2-&gt;rev ^= true;\n    merge (t, t1, t2);\n    merge (t, t, t3);\n}\n\nvoid output (pitem t) {\n    if (!t)  return;\n    push (t);\n    output (t-&gt;l);\n    printf (\"%d \", t-&gt;value);\n    output (t-&gt;r);\n}\n</code></pre>","tags":["Translated"]},{"location":"data_structures/treap.html#literature","title":"Literature","text":"<ul> <li>Blelloch, Reid-Miller \"Fast Set Operations Using Treaps\"</li> </ul>","tags":["Translated"]},{"location":"data_structures/treap.html#practice-problems","title":"Practice Problems","text":"<ul> <li>SPOJ - Ada and Aphids</li> <li>SPOJ - Ada and Harvest</li> <li>Codeforces - Radio Stations</li> <li>SPOJ - Ghost Town</li> <li>SPOJ - Arrangement Validity</li> <li>SPOJ - All in One</li> <li>Codeforces - Dog Show</li> <li>Codeforces - Yet Another Array Queries Problem</li> <li>SPOJ - Mean of Array</li> <li>SPOJ - TWIST</li> <li>SPOJ - KOILINE</li> <li>CodeChef - The Prestige</li> <li>Codeforces - T-Shirts</li> <li>Codeforces - Wizards and Roads</li> <li>Codeforces - Yaroslav and Points</li> </ul>","tags":["Translated"]},{"location":"dynamic_programming/divide-and-conquer-dp.html","title":"Divide and Conquer DP","text":"<p>Divide and Conquer is a dynamic programming optimization.</p>","tags":["Original"]},{"location":"dynamic_programming/divide-and-conquer-dp.html#preconditions","title":"Preconditions","text":"<p>Some dynamic programming problems have a recurrence of this form: </p> $$ dp(i, j) = \\min_{0 \\leq k \\leq j} \\\\{ dp(i - 1, k - 1) + C(k, j) \\\\} $$ <p>where $C(k, j)$ is a cost function and $dp(i, j) = 0$ when $j \\lt 0$. </p> <p>Say $0 \\leq i \\lt m$ and $0 \\leq j \\lt n$, and evaluating $C$ takes $O(1)$ time. Then the straightforward evaluation of the above recurrence is $O(m n^2)$. There are $m \\times n$ states, and $n$ transitions for each state.</p> <p>Let $opt(i, j)$ be the value of $k$ that minimizes the above expression. Assuming that the  cost function satisfies the quadrangle inequality, we can show that  $opt(i, j) \\leq opt(i, j + 1)$ for all $i, j$. This is known as the monotonicity condition.  Then, we can apply divide and conquer DP. The optimal \"splitting point\" for a fixed $i$ increases as $j$ increases.</p> <p>This lets us solve for all states more efficiently. Say we compute $opt(i, j)$ for some fixed $i$ and $j$. Then for any $j' &lt; j$ we know that $opt(i, j') \\leq opt(i, j)$. This means when computing $opt(i, j')$, we don't have to consider as many splitting points!</p> <p>To minimize the runtime, we apply the idea behind divide and conquer. First, compute $opt(i, n / 2)$. Then, compute $opt(i, n / 4)$, knowing that it is less than or equal to $opt(i, n / 2)$ and $opt(i, 3 n / 4)$ knowing that it is greater than or equal to $opt(i, n / 2)$. By recursively keeping track of the lower and upper bounds on $opt$, we reach a $O(m n \\log n)$ runtime. Each possible value of $opt(i, j)$ only appears in $\\log n$ different nodes.</p> <p>Note that it doesn't matter how \"balanced\" $opt(i, j)$ is. Across a fixed level, each value of $k$ is used at most twice, and there are at most $\\log n$ levels.</p>","tags":["Original"]},{"location":"dynamic_programming/divide-and-conquer-dp.html#generic-implementation","title":"Generic implementation","text":"<p>Even though implementation varies based on problem, here's a fairly generic template. The function <code>compute</code> computes one row $i$ of states <code>dp_cur</code>, given the previous row $i-1$ of states <code>dp_before</code>. It has to be called with <code>compute(0, n-1, 0, n-1)</code>. The function <code>solve</code> computes <code>m</code> rows and returns the result.</p> <pre><code>int m, n;\nvector&lt;long long&gt; dp_before, dp_cur;\n\nlong long C(int i, int j);\n\n// compute dp_cur[l], ... dp_cur[r] (inclusive)\nvoid compute(int l, int r, int optl, int optr) {\n    if (l &gt; r)\n        return;\n\n    int mid = (l + r) &gt;&gt; 1;\n    pair&lt;long long, int&gt; best = {LLONG_MAX, -1};\n\n    for (int k = optl; k &lt;= min(mid, optr); k++) {\n        best = min(best, {(k ? dp_before[k - 1] : 0) + C(k, mid), k});\n    }\n\n    dp_cur[mid] = best.first;\n    int opt = best.second;\n\n    compute(l, mid - 1, optl, opt);\n    compute(mid + 1, r, opt, optr);\n}\n\nlong long solve() {\n    dp_before.assign(n,0);\n    dp_cur.assign(n,0);\n\n    for (int i = 0; i &lt; n; i++)\n        dp_before[i] = C(0, i);\n\n    for (int i = 1; i &lt; m; i++) {\n        compute(0, n - 1, 0, n - 1);\n        dp_before = dp_cur;\n    }\n\n    return dp_before[n - 1];\n}\n</code></pre>","tags":["Original"]},{"location":"dynamic_programming/divide-and-conquer-dp.html#things-to-look-out-for","title":"Things to look out for","text":"<p>The greatest difficulty with Divide and Conquer DP problems is proving the monotonicity of $opt$. One special case where this is true is when the cost function satisfies the quadrangle inequality, i.e., $C(a, c) + C(b, d) \\leq C(a, d) + C(b, c)$ for all $a \\leq b \\leq c \\leq d$.  Many Divide and Conquer DP problems can also be solved with the Convex Hull trick or vice-versa. It is useful to know and understand both! </p>","tags":["Original"]},{"location":"dynamic_programming/divide-and-conquer-dp.html#practice-problems","title":"Practice Problems","text":"<ul> <li>AtCoder - Yakiniku Restaurants</li> <li>CodeForces - Ciel and Gondolas (Be careful with I/O!)</li> <li>CodeForces - Levels And Regions</li> <li>CodeForces - Partition Game</li> <li>CodeForces - The Bakery</li> <li>CodeForces - Yet Another Minimization Problem</li> <li>Codechef - CHEFAOR</li> <li>CodeForces - GUARDS (This is the exact problem in this article.)</li> <li>Hackerrank - Guardians of the Lunatics</li> <li>Hackerrank - Mining</li> <li>Kattis - Money (ACM ICPC World Finals 2017)</li> <li>SPOJ - ADAMOLD</li> <li>SPOJ - LARMY</li> <li>SPOJ - NKLEAVES</li> <li>Timus - Bicolored Horses</li> <li>USACO - Circular Barn</li> <li>UVA - Arranging Heaps</li> <li>UVA - Naming Babies</li> </ul>","tags":["Original"]},{"location":"dynamic_programming/divide-and-conquer-dp.html#references","title":"References","text":"<ul> <li>Quora Answer by Michael Levin</li> <li>Video Tutorial by \"Sothe\" the Algorithm Wolf</li> </ul>","tags":["Original"]},{"location":"dynamic_programming/intro-to-dp.html","title":"Introduction to Dynamic Programming","text":"<p>The essence of dynamic programming is to avoid repeated calculation.  Often, dynamic programming problems are naturally solvable by recursion. In such cases, it's easiest to write the recursive solution, then save repeated states in a lookup table. This process is known as top-down dynamic programming with memoization. That's read \"memoization\" (like we are writing in a memo pad) not memorization.</p> <p>One of the most basic, classic examples of this process is the fibonacci sequence. Its recursive formulation is $f(n) = f(n-1) + f(n-2)$ where $n \\ge 2$ and $f(0)=0$ and $f(1)=1$. In C++, this would be expressed as:</p> <pre><code>int f(int n) {\n    if (n == 0) return 0;\n    if (n == 1) return 1;\n    return f(n - 1) + f(n - 2);\n}\n</code></pre> <p>The runtime of this recursive function is exponential - approximately $O(2^n)$ since one function call ( $f(n)$ ) results in 2 similarly sized function calls ($f(n-1)$ and $f(n-2)$ ).</p>","tags":["Original"]},{"location":"dynamic_programming/intro-to-dp.html#speeding-up-fibonacci-with-dynamic-programming-memoization","title":"Speeding up Fibonacci with Dynamic Programming (Memoization)","text":"<p>Our recursive function currently solves fibonacci in exponential time. This means that we can only handle small input values before the problem becomes too difficult. For instance, $f(29)$ results in over 1 million function calls!</p> <p>To increase the speed, we recognize that the number of subproblems is only $O(n)$. That is, in order to calculate $f(n)$ we only need to know $f(n-1),f(n-2), \\dots ,f(0)$. Therefore, instead of recalculating these subproblems, we solve them once and then save the result in a lookup table.  Subsequent calls will use this lookup table and immediately return a result, thus eliminating exponential work! </p> <p>Each recursive call will check against a lookup table to see if the value has been calculated. This is done in $O(1)$ time.  If we have previously calculated it, return the result, otherwise, we calculate the function normally. The overall runtime is $O(n)$. This is an enormous improvement over our previous exponential time algorithm!</p> <pre><code>const int MAXN = 100;\nbool found[MAXN];\nint memo[MAXN];\n\nint f(int n) {\n    if (found[n]) return memo[n];\n    if (n == 0) return 0;\n    if (n == 1) return 1;\n\n    found[n] = true;\n    return memo[n] = f(n - 1) + f(n - 2);\n}\n</code></pre> <p>With our new memoized recursive function, $f(29)$, which used to result in over 1 million calls, now results in only 57 calls, nearly 20,000 times fewer function calls! Ironically, we are now limited by our data type. $f(46)$ is the last fibonacci number that can fit into a signed 32-bit integer.</p> <p>Typically, we try to save states in arrays, if possible, since the lookup time is $O(1)$ with minimal overhead.  However, more generically, we can save states any way we like. Other examples include binary search trees (<code>map</code> in C++) or hash tables (<code>unordered_map</code> in C++).</p> <p>An example of this might be:</p> <pre><code>unordered_map&lt;int, int&gt; memo;\nint f(int n) {\n    if (memo.count(n)) return memo[n];\n    if (n == 0) return 0;\n    if (n == 1) return 1;\n\n    return memo[n] = f(n - 1) + f(n - 2);\n}\n</code></pre> <p>Or analogously:</p> <pre><code>map&lt;int, int&gt; memo;\nint f(int n) {\n    if (memo.count(n)) return memo[n];\n    if (n == 0) return 0;\n    if (n == 1) return 1;\n\n    return memo[n] = f(n - 1) + f(n - 2);\n}\n</code></pre> <p>Both of these will almost always be slower than the array-based version for a generic memoized recursive function. These alternative ways of saving state are primarily useful when saving vectors or strings as part of the state space.</p> <p>The layman's way of analyzing the runtime of a memoized recursive function is:</p> $$\\text{work per subproblem} * \\text{number of subproblems}$$ <p>Using a binary search tree (map in C++) to save states will technically result in $O(n \\log n)$ as each lookup and insertion will take $O(\\log n)$ work and with $O(n)$ unique subproblems we have $O(n \\log n)$ time.</p> <p>This approach is called top-down, as we can call the function with a query value and the calculation starts going from the top (queried value) down to the bottom (base cases of the recursion), and makes shortcuts via memoization on the way.</p>","tags":["Original"]},{"location":"dynamic_programming/intro-to-dp.html#bottom-up-dynamic-programming","title":"Bottom-up Dynamic Programming","text":"<p>Until now you've only seen top-down dynamic programming with memoization. However, we can also solve problems with bottom-up dynamic programming.  Bottom-up is exactly the opposite of top-down, you start at the bottom (base cases of the recursion), and extend it to more and more values.</p> <p>To create a bottom-up approach for fibonacci numbers, we initialize the base cases in an array. Then, we simply use the recursive definition on array:</p> <pre><code>const int MAXN = 100;\nint fib[MAXN];\n\nint f(int n) {\n    fib[0] = 0;\n    fib[1] = 1;\n    for (int i = 2; i &lt;= n; i++) fib[i] = fib[i - 1] + fib[i - 2];\n\n    return fib[n];\n}\n</code></pre> <p>Of course, as written, this is a bit silly for two reasons:  Firstly, we do repeated work if we call the function more than once.  Secondly, we only need to use the two previous values to calculate the current element. Therefore, we can reduce our memory from $O(n)$ to $O(1)$. </p> <p>An example of a bottom-up dynamic programming solution for fibonacci which uses $O(1)$ memory might be:</p> <pre><code>const int MAX_SAVE = 3;\nint fib[MAX_SAVE];\n\nint f(int n) {\n    fib[0] = 0;\n    fib[1] = 1;\n    for (int i = 2; i &lt;= n; i++)\n        fib[i % MAX_SAVE] = fib[(i - 1) % MAX_SAVE] + fib[(i - 2) % MAX_SAVE];\n\n    return fib[n % MAX_SAVE];\n}\n</code></pre> <p>Note that we've changed the constant from <code>MAXN</code> TO <code>MAX_SAVE</code>. This is because the total number of elements we need to access is only 3. It no longer scales with the size of input and is, by definition, $O(1)$ memory. Additionally, we use a common trick (using the modulo operator) only maintaining the values we need.</p> <p>That's it. That's the basics of dynamic programming: Don't repeat the work you've done before.</p> <p>One of the tricks to getting better at dynamic programming is to study some of the classic examples.</p>","tags":["Original"]},{"location":"dynamic_programming/intro-to-dp.html#classic-dynamic-programming-problems","title":"Classic Dynamic Programming Problems","text":"Name Description/Example 0-1 Knapsack Given $N$ items with weights $w_i$ and values $v_i$ and maximum weight $W$, what is the maximum $\\sum_{i=1}^{k} v_i$ for each subset of items of size $k$ ($1 \\le k \\le N$) while ensuring $\\sum_{i=1}^{k} w_i \\le W$? Subset Sum Given $N$ integers and $T$, determine whether there exists a subset of the given set whose elements sum up to the $T$. Longest Increasing Subsequence (LIS) You are given an array containing $N$ integers. Your task is to determine the LIS in the array, i.e., a subsequence where every element is larger than the previous one. Counting Paths in a 2D Array Given $N$ and $M$, count all possible distinct paths from $(1,1)$ to $(N, M)$, where each step is either from $(i,j)$ to $(i+1,j)$ or $(i,j+1)$. Longest Common Subsequence You are given strings $s$ and $t$. Find the length of the longest string that is a subsequence of both $s$ and $t$. Longest Path in a Directed Acyclic Graph (DAG) Finding the longest path in Directed Acyclic Graph (DAG). Longest Palindromic Subsequence Finding the Longest Palindromic Subsequence (LPS) of a given string. Rod Cutting Given a rod of length $n$ units, Given an integer array cuts where cuts[i] denotes a position you should perform a cut at. The cost of one cut is the length of the rod to be cut. What is the minimum total cost of the cuts. Edit Distance The edit distance between two strings is the minimum number of operations required to transform one string into the other. Operations are [\"Add\", \"Remove\", \"Replace\"]","tags":["Original"]},{"location":"dynamic_programming/intro-to-dp.html#related-topics","title":"Related Topics","text":"<ul> <li>Bitmask Dynamic Programming</li> <li>Digit Dynamic Programming</li> <li>Dynamic Programming on Trees</li> </ul> <p>Of course, the most important trick is to practice.</p>","tags":["Original"]},{"location":"dynamic_programming/intro-to-dp.html#practice-problems","title":"Practice Problems","text":"<ul> <li>LeetCode - 1137. N-th Tribonacci Number</li> <li>LeetCode - 118. Pascal's Triangle</li> <li>LeetCode - 1025. Divisor Game</li> <li>Codeforces - Vacations</li> <li>Codeforces - Hard problem</li> <li>Codeforces - Zuma</li> <li>LeetCode - 221. Maximal Square</li> <li>LeetCode - 1039. Minimum Score Triangulation of Polygon</li> </ul>","tags":["Original"]},{"location":"dynamic_programming/intro-to-dp.html#dp-contests","title":"DP Contests","text":"<ul> <li>Atcoder - Educational DP Contest</li> <li>CSES - Dynamic Programming</li> </ul>","tags":["Original"]},{"location":"dynamic_programming/knapsack.html","title":"Knapsack Problem","text":"<p>Prerequisite knowledge: Introduction to Dynamic Programming</p>","tags":["Original"]},{"location":"dynamic_programming/knapsack.html#introduction","title":"Introduction","text":"<p>Consider the following example:</p>","tags":["Original"]},{"location":"dynamic_programming/knapsack.html#usaco07-dec-charm-bracelet","title":"[USACO07 Dec] Charm Bracelet","text":"<p>There are $n$ distinct items and a knapsack of capacity $W$. Each item has 2 attributes, weight ($w_{i}$) and value ($v_{i}$).  You have to select a subset of items to put into the knapsack such that the total weight does not exceed the capacity $W$ and the total value is maximized.</p> <p>In the example above, each object has only two possible states (taken or not taken), corresponding to binary 0 and 1. Thus, this type of problem is called \"0-1 knapsack problem\".</p>","tags":["Original"]},{"location":"dynamic_programming/knapsack.html#0-1-knapsack","title":"0-1 Knapsack","text":"","tags":["Original"]},{"location":"dynamic_programming/knapsack.html#explanation","title":"Explanation","text":"<p>In the example above, the input to the problem is the following: the weight of $i^{th}$ item $w_{i}$, the value of $i^{th}$ item $v_{i}$, and the total capacity of the knapsack $W$.</p> <p>Let $f_{i, j}$ be the dynamic programming state holding the maximum total value the knapsack can carry with capacity $j$, when only the first $i$ items are considered.</p> <p>Assuming that all states of the first $i-1$ items have been processed, what are the options for the $i^{th}$ item?</p> <ul> <li>When it is not put into the knapsack, the remaining capacity remains unchanged and total value does not change. Therefore, the maximum value in this case is $f_{i-1, j}$</li> <li>When it is put into the knapsack, the remaining capacity decreases by $w_{i}$ and the total value increases by $v_{i}$, so the maximum value in this case is $f_{i-1, j-w_i} + v_i$</li> </ul> <p>From this we can derive the dp transition equation:</p> $$f_{i, j} = \\max(f_{i-1, j}, f_{i-1, j-w_i} + v_i)$$ <p>Further, as $f_{i}$ is only dependent on $f_{i-1}$, we can remove the first dimension. We obtain the transition rule</p> $$f_j \\gets \\max(f_j, f_{j-w_i}+v_i)$$ <p>that should be executed in the decreasing order of $j$ (so that $f_{j-w_i}$ implicitly corresponds to $f_{i-1,j-w_i}$ and not $f_{i,j-w_i}$).</p> <p>It is important to understand this transition rule, because most of the transitions for knapsack problems are derived in a similar way.</p>","tags":["Original"]},{"location":"dynamic_programming/knapsack.html#implementation","title":"Implementation","text":"<p>The algorithm described can be implemented in $O(nW)$ as:</p> <pre><code>for (int i = 1; i &lt;= n; i++)\n  for (int j = W; j &gt;= w[i]; j--)\n    f[j] = max(f[j], f[j - w[i]] + v[i]);\n</code></pre> <p>Again, note the order of execution. It should be strictly followed to ensure the following invariant: Right before the pair $(i, j)$ is processed, $f_k$ corresponds to $f_{i,k}$ for $k &gt; j$, but to $f_{i-1,k}$ for $k &lt; j$. This ensures that $f_{j-w_i}$ is taken from the $(i-1)$-th step, rather than from the $i$-th one.</p>","tags":["Original"]},{"location":"dynamic_programming/knapsack.html#complete-knapsack","title":"Complete Knapsack","text":"<p>The complete knapsack model is similar to the 0-1 knapsack, the only difference from the 0-1 knapsack is that an item can be selected an unlimited number of times instead of only once.</p> <p>We can refer to the idea of 0-1 knapsack to define the state: $f_{i, j}$, the maximum value the knapsack can obtain using the first $i$ items with maximum capacity $j$.</p> <p>It should be noted that although the state definition is similar to that of a 0-1 knapsack, its transition rule is different from that of a 0-1 knapsack.</p>","tags":["Original"]},{"location":"dynamic_programming/knapsack.html#explanation_1","title":"Explanation","text":"<p>The trivial approach is, for the first $i$ items, enumerate how many times each item is to be taken. The time complexity of this is $O(n^2W)$.</p> <p>This yields the following transition equation:</p> $$f_{i, j} = \\max\\limits_{k=0}^{\\infty}(f_{i-1, j-k\\cdot w_i} + k\\cdot v_i)$$ <p>At the same time, it simplifies into a \"flat\" equation:</p> $$f_{i, j} = \\max(f_{i-1, j},f_{i, j-w_i} + v_i)$$ <p>The reason this works is that $f_{i, j-w_i}$ has already been updated by $f_{i, j-2\\cdot w_i}$ and so on.</p> <p>Similar to the 0-1 knapsack, we can remove the first dimension to optimize the space complexity. This gives us the same transition rule as 0-1 knapsack.</p> $$f_j \\gets \\max(f_j, f_{j-w_i}+v_i)$$","tags":["Original"]},{"location":"dynamic_programming/knapsack.html#implementation_1","title":"Implementation","text":"<p>The algorithm described can be implemented in $O(nW)$ as:</p> <pre><code>for (int i = 1; i &lt;= n; i++)\n  for (int j = w[i]; j &lt;= W; j++)\n    f[j] = max(f[j], f[j - w[i]] + v[i]);\n</code></pre> <p>Despite having the same transition rule, the code above is incorrect for 0-1 knapsack.</p> <p>Observing the code carefully, we see that for the currently processed item $i$ and the current state $f_{i,j}$,  when $j\\geqslant w_{i}$, $f_{i,j}$ will be affected by $f_{i,j-w_{i}}$.  This is equivalent to being able to put item $i$ into the backpack multiple times, which is consistent with the complete knapsack problem and not the 0-1 knapsack problem.</p>","tags":["Original"]},{"location":"dynamic_programming/knapsack.html#multiple-knapsack","title":"Multiple Knapsack","text":"<p>Multiple knapsack is also a variant of 0-1 knapsack. The main difference is that there are $k_i$ of each item instead of just $1$.</p>","tags":["Original"]},{"location":"dynamic_programming/knapsack.html#explanation_2","title":"Explanation","text":"<p>A very simple idea is: \"choose each item $k_i$ times\" is equivalent to \"$k_i$ of the same item is selected one by one\". Thus converting it to a 0-1 knapsack model, which can be described by the transition function:</p> $$f_{i, j} = \\max_{k=0}^{k_i}(f_{i-1,j-k\\cdot w_i} + k\\cdot v_i)$$ <p>The time complexity of this process is $O(W\\sum\\limits_{i=1}^{n}k_i)$</p>","tags":["Original"]},{"location":"dynamic_programming/knapsack.html#binary-grouping-optimization","title":"Binary Grouping Optimization","text":"<p>We still consider converting the multiple knapsack model into a 0-1 knapsack model for optimization. The time complexity $O(Wn)$ can not be further optimized with the approach above, so we focus on $O(\\sum k_i)$ component.</p> <p>Let $A_{i, j}$ denote the $j^{th}$ item split from the $i^{th}$ item. In the trivial approach discussed above, $A_{i, j}$ represents the same item for all $j \\leq k_i$. The main reason for our low efficiency is that we are doing a lot of repetetive work. For example, consider selecting $\\{A_{i, 1},A_{i, 2}\\}$, and selecting $\\{A_{i, 2}, A_{i, 3}\\}$. These two situations are completely equivalent. Thus optimizing the splitting method will greatly reduce the time complexity.</p> <p>The grouping is made more efficient by using binary grouping.</p> <p>Specifically, $A_{i, j}$ holds $2^j$ individual items ($j\\in[0,\\lfloor \\log_2(k_i+1)\\rfloor-1]$).If $k_i + 1$ is not an integer power of $2$, another bundle of size $k_i-(2^{\\lfloor \\log_2(k_i+1)\\rfloor}-1)$ is used to make up for it.</p> <p>Through the above splitting method, it is possible to obtain any sum of $\\leq k_i$ items by selecting a few $A_{i, j}$'s. After splitting each item in the described way, it is sufficient to use 0-1 knapsack method to solve the new formulation of the problem.</p> <p>This optimization gives us a time complexity of $O(W\\sum\\limits_{i=1}^{n}\\log k_i)$.</p>","tags":["Original"]},{"location":"dynamic_programming/knapsack.html#implementation_2","title":"Implementation","text":"<pre><code>index = 0;\nfor (int i = 1; i &lt;= n; i++) {\n  int c = 1, p, h, k;\n  cin &gt;&gt; p &gt;&gt; h &gt;&gt; k;\n  while (k &gt; c) {\n    k -= c;\n    list[++index].w = c * p;\n    list[index].v = c * h;\n    c *= 2;\n  }\n  list[++index].w = p * k;\n  list[index].v = h * k;\n}\n</code></pre>","tags":["Original"]},{"location":"dynamic_programming/knapsack.html#monotone-queue-optimization","title":"Monotone Queue Optimization","text":"<p>In this optimization, we aim to convert the knapsack problem into a maximum queue one.</p> <p>For convenience of description, let $g_{x, y} = f_{i, x \\cdot w_i + y} ,\\space g'_{x, y} = f_{i-1, x \\cdot w_i + y}$. Then the transition rule can be written as:</p> $$g_{x, y} = \\max_{k=0}^{k_i}(g'_{x-k, y} + v_i \\cdot k)$$ <p>Further, let $G_{x, y} = g'_{x, y} - v_i \\cdot x$. Then the transition rule can be expressed as:</p> $$g_{x, y} \\gets \\max_{k=0}^{k_i}(G_{x-k, y}) + v_i \\cdot x$$ <p>This transforms into a classic monotone queue optimization form. $G_{x, y}$ can be calculated in $O(1)$, so for a fixed $y$, we can calculate $g_{x, y}$ in $O(\\lfloor \\frac{W}{w_i} \\rfloor)$ time. Therefore, the complexity of finding all $g_{x, y}$ is $O(\\lfloor \\frac{W}{w_i} \\rfloor) \\times O(w_i) = O(W)$. In this way, the total complexity of the algorithm is reduced to $O(nW)$. </p>","tags":["Original"]},{"location":"dynamic_programming/knapsack.html#mixed-knapsack","title":"Mixed Knapsack","text":"<p>The mixed knapsack problem involves a combination of the three problems described above. That is, some items can only be taken once, some can be taken infinitely, and some can be taken atmost $k$ times.</p> <p>The problem may seem daunting, but as long as you understand the core ideas of the previous knapsack problems and combine them together, you can do it. The pseudo code for the solution is as:</p> <pre><code>for (each item) {\n  if (0-1 knapsack)\n    Apply 0-1 knapsack code;\n  else if (complete knapsack)\n    Apply complete knapsack code;\n  else if (multiple knapsack)\n    Apply multiple knapsack code;\n}\n</code></pre>","tags":["Original"]},{"location":"dynamic_programming/knapsack.html#practise-problems","title":"Practise Problems","text":"<ul> <li>Atcoder: Knapsack-1</li> <li>Atcoder: Knapsack-2</li> <li>LeetCode - 494. Target Sum</li> <li>LeetCode - 416. Partition Equal Subset Sum</li> <li>CSES: Book Shop II</li> <li>DMOJ: Knapsack-3</li> <li>DMOJ: Knapsack-4</li> </ul>","tags":["Original"]},{"location":"dynamic_programming/knuth-optimization.html","title":"Knuth's Optimization","text":"<p>Knuth's optimization, also known as the Knuth-Yao Speedup, is a special case of dynamic programming on ranges, that can optimize the time complexity of solutions by a linear factor, from $O(n^3)$ for standard range DP to $O(n^2)$.</p>","tags":["Original"]},{"location":"dynamic_programming/knuth-optimization.html#conditions","title":"Conditions","text":"<p>The Speedup is applied for transitions of the form</p> $$dp(i, j) = \\min_{i \\leq k &lt; j} [ dp(i, k) + dp(k+1, j) + C(i, j) ].$$ <p>Similar to divide and conquer DP, let $opt(i, j)$ be the maximum value of $k$ that minimizes the expression in the transition ($opt$ is referred to as the \"optimal splitting point\" further in this article). The optimization requires that the following holds:</p> $$opt(i, j-1) \\leq opt(i, j) \\leq opt(i+1, j).$$ <p>We can show that it is true when the cost function $C$ satisfies the following conditions for $a \\leq b \\leq c \\leq d$:</p> <ol> <li> <p>$C(b, c) \\leq C(a, d)$;</p> </li> <li> <p>$C(a, c) + C(b, d) \\leq C(a, d) + C(b, c)$ (the quadrangle inequality [QI]).</p> </li> </ol> <p>This result is proved further below.</p>","tags":["Original"]},{"location":"dynamic_programming/knuth-optimization.html#algorithm","title":"Algorithm","text":"<p>Let's process the dp states in such a way that we calculate $dp(i, j-1)$ and $dp(i+1, j)$ before $dp(i, j)$, and in doing so we also calculate $opt(i, j-1)$ and $opt(i+1, j)$. Then for calculating $opt(i, j)$, instead of testing values of $k$ from $i$ to $j-1$, we only need to test from $opt(i, j-1)$ to $opt(i+1, j)$. To process $(i,j)$ pairs in this order it is sufficient to use nested for loops in which $i$ goes from the maximum value to the minimum one and $j$ goes from $i+1$ to the maximum value.</p>","tags":["Original"]},{"location":"dynamic_programming/knuth-optimization.html#generic-implementation","title":"Generic implementation","text":"<p>Though implementation varies, here's a fairly generic example. The structure of the code is almost identical to that of Range DP.</p> <pre><code>int solve() {\n    int N;\n    ... // read N and input\n    int dp[N][N], opt[N][N];\n\n    auto C = [&amp;](int i, int j) {\n        ... // Implement cost function C.\n    };\n\n    for (int i = 0; i &lt; N; i++) {\n        opt[i][i] = i;\n        ... // Initialize dp[i][i] according to the problem\n    }\n\n    for (int i = N-2; i &gt;= 0; i--) {\n        for (int j = i+1; j &lt; N; j++) {\n            int mn = INT_MAX;\n            int cost = C(i, j);\n            for (int k = opt[i][j-1]; k &lt;= min(j-1, opt[i+1][j]); k++) {\n                if (mn &gt;= dp[i][k] + dp[k+1][j] + cost) {\n                    opt[i][j] = k; \n                    mn = dp[i][k] + dp[k+1][j] + cost; \n                }\n            }\n            dp[i][j] = mn; \n        }\n    }\n\n    return dp[0][N-1];\n}\n</code></pre>","tags":["Original"]},{"location":"dynamic_programming/knuth-optimization.html#complexity","title":"Complexity","text":"<p>A complexity of the algorithm can be estimated as the following sum:</p> $$ \\sum\\limits_{i=1}^N \\sum\\limits_{j=i+1}^N [opt(i+1,j)-opt(i,j-1)] = \\sum\\limits_{i=1}^N \\sum\\limits_{j=i}^{N-1} [opt(i+1,j+1)-opt(i,j)]. $$ <p>As you see, most of the terms in this expression cancel each other out, except for positive terms with $j=N-1$ and negative terms with $i=1$. Thus, the whole sum can be estimated as</p> $$ \\sum\\limits_{k=1}^N[opt(k,N)-opt(1,k)] = O(n^2), $$ <p>rather than $O(n^3)$ as it would be if we were using a regular range DP.</p>","tags":["Original"]},{"location":"dynamic_programming/knuth-optimization.html#on-practice","title":"On practice","text":"<p>The most common application of Knuth's optimization is in Range DP, with the given transition. The only difficulty is in proving that the cost function satisfies the given conditions. The simplest case is when the cost function $C(i, j)$ is simply the sum of the elements of the subarray $S[i, i+1, ..., j]$ for some array (depending on the question). However, they can be more complicated at times. </p> <p>Note that more than the conditions on the dp transition and the cost function, the key to this optimization is the inequality on the optimum splitting point. In some problems, such as the optimal binary search tree problem (which is, incidentally, the original problem for which this optimization was developed), the transitions and cost functions will be less obvious, however, one can still prove that $opt(i, j-1) \\leq opt(i, j) \\leq opt(i+1, j)$, and thus, use this optimization.</p>","tags":["Original"]},{"location":"dynamic_programming/knuth-optimization.html#proof-of-correctness","title":"Proof of correctness","text":"<p>To prove the correctness of this algorithm in terms of $C(i,j)$ conditions, it suffices to prove that</p> $$ opt(i, j-1) \\leq opt(i, j) \\leq opt(i+1, j) $$ <p>assuming the given conditions are satisfied. </p> <p>Lemma</p> <p>$dp(i, j)$ also satisfies the quadrangle inequality, given the conditions of the problem are satisfied.</p> Proof <p>The proof for this lemma uses strong induction. It has been taken from the paper Efficient Dynamic Programming Using Quadrangle Inequalities, authored by F. Frances Yao, which introduced the Knuth-Yao Speedup (this particular statement is Lemma 2.1 in the paper). The idea is to induct on the length $l = d - a$. The case where $l = 1$ is trivial. For $l &gt; 1$ consider 2 cases:  </p> <ol> <li> <p>$b = c$ The inequality reduces to $dp(a, b) + dp(b, d) \\leq dp(a, d)$ (This assumes that $dp(i, i) = 0$ for all $i$, which is the case for all problems using this optimization). Let $opt(a,d) = z$. </p> <ul> <li> <p>If $z &lt; j$, Note that</p> $$ dp(a, b) \\leq dp_{z}(a, b) = dp(a, z) + dp(z+1, b) + C(a, b). $$ <p>Therefore,  </p> $$ dp(a, b) + dp(b, d) \\leq dp(a, z) + dp(z+1, b) + dp(b, d) + C(a, b) $$ <p>From the induction hypothesis, $dp(z+1, b) + dp(b, d) \\leq dp(z+1, d)$. Also, it is given that $C(a, b) \\leq C(a, d)$. Combining these 2 facts with above inequality yields the desired result.</p> </li> <li> <p>If $z \\geq j$, the proof of this case is symmetric to the previous case.</p> </li> </ul> </li> <li> <p>$b &lt; c$ Let $opt(b, c) = z$ and $opt(a, d) = y$. </p> <ul> <li> <p>If $z \\leq y$,  </p> $$ dp(a, c) + dp(b, d) \\leq dp_{z}(a, c) + dp_{y}(b, d) $$ <p>where</p> $$ dp_{z}(a, c) + dp_{y}(b, d) = C(a, c) + C(b, d) + dp(a, z) + dp(z+1, c) + dp(b, y) + dp(y+1, d). $$ <p>Using the QI on $C$ and on the dp state for the indices $z+1 \\leq y+1 \\leq c \\leq d$ (from the induction hypothesis) yields the desired result.</p> </li> <li> <p>If $z &gt; y$, the proof of this case is symmetric to the previous case.</p> </li> </ul> </li> </ol> <p>This completes the proof of the lemma.</p> <p>Now, consider the following setup. We have 2 indices $i \\leq p \\leq q &lt; j$. Set $dp_{k} = C(i, j) + dp(i, k) + dp(k+1, j)$.</p> <p>Suppose we show that</p> $$ dp_{p}(i, j-1) \\geq dp_{q}(i, j-1) \\implies dp_{p}(i, j) \\geq dp_{q}(i, j). $$ <p>Setting $q = opt(i, j-1)$, by definition, $dp_{p}(i, j-1) \\geq dp_{q}(i, j-1)$. Therefore, applying the inequality to all $i \\leq p \\leq q$, we can infer that $opt(i, j)$ is at least as much as $opt(i, j-1)$, proving the first half of the inequality.</p> <p>Now, using the QI on some indices $p+1 \\leq q+1 \\leq j-1 \\leq j$, we get</p> $$\\begin{align} &amp;dp(p+1, j-1) + dp(q+1, j) \u2264 dp(q+1, j-1) + dp(p+1, j) \\\\ \\implies&amp; (dp(i, p) + dp(p+1, j-1) + C(i, j-1)) + (dp(i, q) + dp(q+1, j) + C(i, j)) \\\\   \\leq&amp; (dp(i, q) + dp(q+1, j-1) + C(i, j-1)) + (dp(i, p) + dp(p+1, j) + C(i, j)) \\\\   \\implies&amp; dp_{p}(i, j-1) + dp_{q}(i, j) \u2264 dp_{p}(i, j) + dp_{q}(i, j-1) \\\\ \\implies&amp; dp_{p}(i, j-1) - dp_{q}(i, j-1) \u2264 dp_{p}(i, j) - dp_{q}(i, j) \\\\ \\end{align}$$ <p>Finally,</p> $$\\begin{align} &amp;dp_{p}(i, j-1) \\geq dp_{q}(i, j-1) \\\\ &amp;\\implies 0 \\leq dp_{p}(i, j-1) - dp_{q}(i, j-1) \\leq dp_{p}(i, j) - dp_{q}(i, j) \\\\ &amp;\\implies dp_{p}(i, j) \\geq dp_{q}(i, j) \\end{align}$$ <p>This proves the first part of the inequality, i.e., $opt(i, j-1) \\leq opt(i, j)$. The second part $opt(i, j) \\leq opt(i+1, j)$ can be shown with the same idea, starting with the inequality  $dp(i, p) + dp(i+1, q) \u2264 dp(i+1, p) + dp(i, q)$.</p> <p>This completes the proof.</p>","tags":["Original"]},{"location":"dynamic_programming/knuth-optimization.html#practice-problems","title":"Practice Problems","text":"<ul> <li>UVA - Cutting Sticks</li> <li>UVA - Prefix Codes</li> <li>SPOJ - Breaking String</li> <li>UVA - Optimal Binary Search Tree</li> </ul>","tags":["Original"]},{"location":"dynamic_programming/knuth-optimization.html#references","title":"References","text":"<ul> <li>Geeksforgeeks Article</li> <li>Doc on DP Speedups</li> <li>Efficient Dynamic Programming Using Quadrangle Inequalities</li> </ul>","tags":["Original"]},{"location":"dynamic_programming/longest_increasing_subsequence.html","title":"Longest increasing subsequence","text":"<p>We are given an array with $n$ numbers: $a[0 \\dots n-1]$. The task is to find the longest, strictly increasing, subsequence in $a$.</p> <p>Formally we look for the longest sequence of indices $i_1, \\dots i_k$ such that</p> $$i_1 &lt; i_2 &lt; \\dots &lt; i_k,\\quad a[i_1] &lt; a[i_2] &lt; \\dots &lt; a[i_k]$$ <p>In this article we discuss multiple algorithms for solving this task. Also we will discuss some other problems, that can be reduced to this problem.</p>","tags":["Translated"]},{"location":"dynamic_programming/longest_increasing_subsequence.html#solution-in-on2-with-dynamic-programming","title":"Solution in $O(n^2)$ with dynamic programming","text":"<p>Dynamic programming is a very general technique that allows to solve a huge class of problems. Here we apply the technique for our specific task.</p> <p>First we will search only for the length of the longest increasing subsequence, and only later learn how to restore the subsequence itself.</p>","tags":["Translated"]},{"location":"dynamic_programming/longest_increasing_subsequence.html#finding-the-length","title":"Finding the length","text":"<p>To accomplish this task, we define an array $d[0 \\dots n-1]$, where $d[i]$ is the length of the longest increasing subsequence that ends in the element at index $i$.</p> <p>Example</p> $$\\begin{array}{ll} a &amp;= \\{8, 3, 4, 6, 5, 2, 0, 7, 9, 1\\} \\\\ d &amp;= \\{1, 1, 2, 3, 3, 1, 1, 4, 5, 2\\} \\end{array}$$ <p>The longest increasing subsequence that ends at index 4 is $\\{3, 4, 5\\}$ with a length of 3, the longest ending at index 8 is either $\\{3, 4, 5, 7, 9\\}$ or $\\{3, 4, 6, 7, 9\\}$, both having length 5, and the longest ending at index 9 is $\\{0, 1\\}$ having length 2.</p> <p>We will compute this array gradually: first $d[0]$, then $d[1]$, and so on. After this array is computed, the answer to the problem will be the maximum value in the array $d[]$.</p> <p>So let the current index be $i$. I.e. we want to compute the value $d[i]$ and all previous values $d[0], \\dots, d[i-1]$ are already known. Then there are two options:</p> <ul> <li> <p>$d[i] = 1$: the required subsequence consists only of the element $a[i]$.</p> </li> <li> <p>$d[i] &gt; 1$: The subsequence will end at $a[i]$, and right before it will be some number $a[j]$ with $j &lt; i$ and $a[j] &lt; a[i]$.</p> <p>It's easy to see, that the subsequence ending in $a[j]$ will itself be one of the longest increasing subsequences that ends in $a[j]$. The number $a[i]$ just extends that longest increasing subsequence by one number.</p> <p>Therefore, we can just iterate over all $j &lt; i$ with $a[j] &lt; a[i]$, and take the longest sequence that we get by appending $a[i]$ to the longest increasing subsequence ending in $a[j]$. The longest increasing subsequence ending in $a[j]$ has length $d[j]$, extending it by one gives the length $d[j] + 1$.</p> $$d[i] = \\max_{\\substack{j &lt; i \\\\\\\\ a[j] &lt; a[i]}} \\left(d[j] + 1\\right)$$ </li> </ul> <p>If we combine these two cases we get the final answer for $d[i]$:</p> $$d[i] = \\max\\left(1, \\max_{\\substack{j &lt; i \\\\\\\\ a[j] &lt; a[i]}} \\left(d[j] + 1\\right)\\right)$$","tags":["Translated"]},{"location":"dynamic_programming/longest_increasing_subsequence.html#implementation","title":"Implementation","text":"<p>Here is an implementation of the algorithm described above, which computes the length of the longest increasing subsequence.</p> <pre><code>int lis(vector&lt;int&gt; const&amp; a) {\n    int n = a.size();\n    vector&lt;int&gt; d(n, 1);\n    for (int i = 0; i &lt; n; i++) {\n        for (int j = 0; j &lt; i; j++) {\n            if (a[j] &lt; a[i])\n                d[i] = max(d[i], d[j] + 1);\n        }\n    }\n\n    int ans = d[0];\n    for (int i = 1; i &lt; n; i++) {\n        ans = max(ans, d[i]);\n    }\n    return ans;\n}\n</code></pre>","tags":["Translated"]},{"location":"dynamic_programming/longest_increasing_subsequence.html#restoring-the-subsequence","title":"Restoring the subsequence","text":"<p>So far we only learned how to find the length of the subsequence, but not how to find the subsequence itself.</p> <p>To be able to restore the subsequence we generate an additional auxiliary array $p[0 \\dots n-1]$ that we will compute alongside the array $d[]$. $p[i]$ will be the index $j$ of the second last element in the longest increasing subsequence ending in $i$. In other words the index $p[i]$ is the same index $j$ at which the highest value $d[i]$ was obtained. This auxiliary array $p[]$ points in some sense to the ancestors.</p> <p>Then to derive the subsequence, we just start at the index $i$ with the maximal $d[i]$, and follow the ancestors until we deduced the entire subsequence, i.e. until we reach the element with $d[i] = 1$.</p>","tags":["Translated"]},{"location":"dynamic_programming/longest_increasing_subsequence.html#implementation-of-restoring","title":"Implementation of restoring","text":"<p>We will change the code from the previous sections a little bit. We will compute the array $p[]$ alongside $d[]$, and afterwards compute the subsequence.</p> <p>For convenience we originally assign the ancestors with $p[i] = -1$. For elements with $d[i] = 1$, the ancestors value will remain $-1$, which will be slightly more convenient for restoring the subsequence.</p> <pre><code>vector&lt;int&gt; lis(vector&lt;int&gt; const&amp; a) {\n    int n = a.size();\n    vector&lt;int&gt; d(n, 1), p(n, -1);\n    for (int i = 0; i &lt; n; i++) {\n        for (int j = 0; j &lt; i; j++) {\n            if (a[j] &lt; a[i] &amp;&amp; d[i] &lt; d[j] + 1) {\n                d[i] = d[j] + 1;\n                p[i] = j;\n            }\n        }\n    }\n\n    int ans = d[0], pos = 0;\n    for (int i = 1; i &lt; n; i++) {\n        if (d[i] &gt; ans) {\n            ans = d[i];\n            pos = i;\n        }\n    }\n\n    vector&lt;int&gt; subseq;\n    while (pos != -1) {\n        subseq.push_back(a[pos]);\n        pos = p[pos];\n    }\n    reverse(subseq.begin(), subseq.end());\n    return subseq;\n}\n</code></pre>","tags":["Translated"]},{"location":"dynamic_programming/longest_increasing_subsequence.html#alternative-way-of-restoring-the-subsequence","title":"Alternative way of restoring the subsequence","text":"<p>It is also possible to restore the subsequence without the auxiliary array $p[]$. We can simply recalculate the current value of $d[i]$ and also see how the maximum was reached.</p> <p>This method leads to a slightly longer code, but in return we save some memory.</p>","tags":["Translated"]},{"location":"dynamic_programming/longest_increasing_subsequence.html#solution-in-on-log-n-with-dynamic-programming-and-binary-search","title":"Solution in $O(n \\log n)$ with dynamic programming and binary search","text":"<p>In order to obtain a faster solution for the problem, we construct a different dynamic programming solution that runs in $O(n^2)$, and then later improve it to $O(n \\log n)$.</p> <p>We will use the dynamic programming array $d[0 \\dots n]$. This time $d[l]$ doesn't correspond to the element $a[i]$ or to a prefix of the array.  $d[l]$ will be the smallest element at which an increasing subsequence of length $l$ ends.</p> <p>Initially we assume $d[0] = -\\infty$ and for all other lengths $d[l] = \\infty$.</p> <p>We will again gradually process the numbers, first $a[0]$, then $a[1]$, etc, and in each step maintain the array $d[]$ so that it is up to date.</p> <p>Example</p> <p>Given the array $a = \\{8, 3, 4, 6, 5, 2, 0, 7, 9, 1\\}$, here are all their prefixes and their dynamic programming array. Notice, that the values of the array don't always change at the end.</p> $$ \\begin{array}{ll} \\text{prefix} = \\{\\} &amp;\\quad d = \\{-\\infty, \\infty, \\dots\\}\\\\ \\text{prefix} = \\{8\\} &amp;\\quad d = \\{-\\infty, 8, \\infty, \\dots\\}\\\\ \\text{prefix} = \\{8, 3\\} &amp;\\quad d = \\{-\\infty, 3, \\infty, \\dots\\}\\\\ \\text{prefix} = \\{8, 3, 4\\} &amp;\\quad d = \\{-\\infty, 3, 4, \\infty, \\dots\\}\\\\ \\text{prefix} = \\{8, 3, 4, 6\\} &amp;\\quad d = \\{-\\infty, 3, 4, 6, \\infty, \\dots\\}\\\\ \\text{prefix} = \\{8, 3, 4, 6, 5\\} &amp;\\quad d = \\{-\\infty, 3, 4, 5, \\infty, \\dots\\}\\\\ \\text{prefix} = \\{8, 3, 4, 6, 5, 2\\} &amp;\\quad d = \\{-\\infty, 2, 4, 5, \\infty, \\dots \\}\\\\ \\text{prefix} = \\{8, 3, 4, 6, 5, 2, 0\\} &amp;\\quad d = \\{-\\infty, 0, 4, 5, \\infty, \\dots \\}\\\\ \\text{prefix} = \\{8, 3, 4, 6, 5, 2, 0, 7\\} &amp;\\quad d = \\{-\\infty, 0, 4, 5, 7, \\infty, \\dots \\}\\\\ \\text{prefix} = \\{8, 3, 4, 6, 5, 2, 0, 7, 9\\} &amp;\\quad d = \\{-\\infty, 0, 4, 5, 7, 9, \\infty, \\dots \\}\\\\ \\text{prefix} = \\{8, 3, 4, 6, 5, 2, 0, 7, 9, 1\\} &amp;\\quad d = \\{-\\infty, 0, 1, 5, 7, 9, \\infty, \\dots \\}\\\\ \\end{array} $$ <p>When we process $a[i]$, we can ask ourselves. What have the conditions to be, that we write the current number $a[i]$ into the $d[0 \\dots n]$ array?</p> <p>We set $d[l] = a[i]$, if there is a longest increasing sequence of length $l$ that ends in $a[i]$, and there is no longest increasing sequence of length $l$ that ends in a smaller number. Similar to the previous approach, if we remove the number $a[i]$ from the longest increasing sequence of length $l$, we get another longest increasing sequence of length $l -1$. So we want to extend a longest increasing sequence of length $l - 1$ by the number $a[i]$, and obviously the longest increasing sequence of length $l - 1$ that ends with the smallest element will work the best, in other words the sequence of length $l-1$ that ends in element $d[l-1]$.</p> <p>There is a longest increasing sequence of length $l - 1$ that we can extend with the number $a[i]$, exactly if $d[l-1] &lt; a[i]$. So we can just iterate over each length $l$, and check if we can extend a longest increasing sequence of length $l - 1$ by checking the criteria.</p> <p>Additionally we also need to check, if we maybe have already found a longest increasing sequence of length $l$ with a smaller number at the end. So we only update if $a[i] &lt; d[l]$.</p> <p>After processing all the elements of $a[]$ the length of the desired subsequence is the largest $l$ with $d[l] &lt; \\infty$.</p> <pre><code>int lis(vector&lt;int&gt; const&amp; a) {\n    int n = a.size();\n    const int INF = 1e9;\n    vector&lt;int&gt; d(n+1, INF);\n    d[0] = -INF;\n\n    for (int i = 0; i &lt; n; i++) {\n        for (int l = 1; l &lt;= n; l++) {\n            if (d[l-1] &lt; a[i] &amp;&amp; a[i] &lt; d[l])\n                d[l] = a[i];\n        }\n    }\n\n    int ans = 0;\n    for (int l = 0; l &lt;= n; l++) {\n        if (d[l] &lt; INF)\n            ans = l;\n    }\n    return ans;\n}\n</code></pre> <p>We now make two important observations.</p> <ol> <li> <p>The array $d$ will always be sorted:      $d[l-1] &lt; d[l]$ for all $i = 1 \\dots n$.</p> <p>This is trivial, as you can just remove the last element from the increasing subsequence of length $l$, and you get a increasing subsequence of length $l-1$ with a smaller ending number.</p> </li> <li> <p>The element $a[i]$ will only update at most one value $d[l]$.</p> <p>This follows immediately from the above implementation. There can only be one place in the array with $d[l-1] &lt; a[i] &lt; d[l]$.</p> </li> </ol> <p>Thus we can find this element in the array $d[]$ using binary search in $O(\\log n)$. In fact we can simply look in the array $d[]$ for the first number that is strictly greater than $a[i]$, and we try to update this element in the same way as the above implementation.</p>","tags":["Translated"]},{"location":"dynamic_programming/longest_increasing_subsequence.html#implementation_1","title":"Implementation","text":"<p>This gives us the improved $O(n \\log n)$ implementation:</p> <pre><code>int lis(vector&lt;int&gt; const&amp; a) {\n    int n = a.size();\n    const int INF = 1e9;\n    vector&lt;int&gt; d(n+1, INF);\n    d[0] = -INF;\n\n    for (int i = 0; i &lt; n; i++) {\n        int l = upper_bound(d.begin(), d.end(), a[i]) - d.begin();\n        if (d[l-1] &lt; a[i] &amp;&amp; a[i] &lt; d[l])\n            d[l] = a[i];\n    }\n\n    int ans = 0;\n    for (int l = 0; l &lt;= n; l++) {\n        if (d[l] &lt; INF)\n            ans = l;\n    }\n    return ans;\n}\n</code></pre>","tags":["Translated"]},{"location":"dynamic_programming/longest_increasing_subsequence.html#restoring-the-subsequence_1","title":"Restoring the subsequence","text":"<p>It is also possible to restore the subsequence using this approach. This time we have to maintain two auxiliary arrays. One that tells us the index of the elements in $d[]$. And again we have to create an array of \"ancestors\" $p[i]$. $p[i]$ will be the index of the previous element for the optimal subsequence ending in element $i$.</p> <p>It's easy to maintain these two arrays in the course of iteration over the array $a[]$ alongside the computations of $d[]$. And at the end it is not difficult to restore the desired subsequence using these arrays.</p>","tags":["Translated"]},{"location":"dynamic_programming/longest_increasing_subsequence.html#solution-in-on-log-n-with-data-structures","title":"Solution in $O(n \\log n)$ with data structures","text":"<p>Instead of the above method for computing the longest increasing subsequence in $O(n \\log n)$ we can also solve the problem in a different way: using some simple data structures.</p> <p>Let's go back to the first method. Remember that $d[i]$ is the value $d[j] + 1$ with $j &lt; i$ and $a[j] &lt; a[i]$.</p> <p>Thus if we define an additional array $t[]$ such that</p> $$t[a[i]] = d[i],$$ <p>then the problem of computing the value $d[i]$ is equivalent to finding the maximum value in a prefix of the array $t[]$:</p> $$d[i] = \\max\\left(t[0 \\dots a[i] - 1] + 1\\right)$$ <p>The problem of finding the maximum of a prefix of an array (which changes) is a standard problem that can be solved by many different data structures.  For instance we can use a Segment tree or a Fenwick tree.</p> <p>This method has obviously some shortcomings: in terms of length and complexity of the implementation this approach will be worse than the method using binary search. In addition if the input numbers $a[i]$ are especially large, then we would have to use some tricks, like compressing the numbers (i.e. renumber them from $0$ to $n-1$), or use a dynamic segment tree (only generate the branches of the tree that are important). Otherwise the memory consumption will be too high.</p> <p>On the other hand this method has also some advantages: with this method you don't have to think about any tricky properties in the dynamic programming solution. And this approach allows us to generalize the problem very easily (see below).</p>","tags":["Translated"]},{"location":"dynamic_programming/longest_increasing_subsequence.html#related-tasks","title":"Related tasks","text":"<p>Here are several problems that are closely related to the problem of finding the longest increasing subsequence.</p>","tags":["Translated"]},{"location":"dynamic_programming/longest_increasing_subsequence.html#longest-non-decreasing-subsequence","title":"Longest non-decreasing subsequence","text":"<p>This is in fact nearly the same problem. Only now it is allowed to use identical numbers in the subsequence.</p> <p>The solution is essentially also nearly the same. We just have to change the inequality signs, and make a slight modification to the binary search.</p>","tags":["Translated"]},{"location":"dynamic_programming/longest_increasing_subsequence.html#number-of-longest-increasing-subsequences","title":"Number of longest increasing subsequences","text":"<p>We can use the first discussed method, either the $O(n^2)$ version or the version using data structures. We only have to additionally store in how many ways we can obtain longest increasing subsequences ending in the values $d[i]$.</p> <p>The number of ways to form a longest increasing subsequences ending in $a[i]$ is the sum of all ways for all longest increasing subsequences ending in $j$ where $d[j]$ is maximal. There can be multiple such $j$, so we need to sum all of them.</p> <p>Using a Segment tree this approach can also be implemented in $O(n \\log n)$.</p> <p>It is not possible to use the binary search approach for this task.</p>","tags":["Translated"]},{"location":"dynamic_programming/longest_increasing_subsequence.html#smallest-number-of-non-increasing-subsequences-covering-a-sequence","title":"Smallest number of non-increasing subsequences covering a sequence","text":"<p>For a given array with $n$ numbers $a[0 \\dots n - 1]$ we have to colorize the numbers in the smallest number of colors, so that each color forms a non-increasing subsequence.</p> <p>To solve this, we notice that the minimum number of required colors is equal to the length of the longest increasing subsequence.</p> <p>Proof: We need to prove the duality of these two problems.</p> <p>Let's denote by $x$ the length of the longest increasing subsequence and by $y$ the least number of non-increasing subsequences that form a cover. We need to prove that $x = y$.</p> <p>It is clear that $y &lt; x$ is not possible, because if we have $x$ strictly increasing elements, than no two can be part of the same non-increasing subsequence. Therefore we have $y \\ge x$.</p> <p>We now show that $y &gt; x$ is not possible by contradiction. Suppose that $y &gt; x$. Then we consider any optimal set of $y$ non-increasing subsequences. We transform this in set in the following way: as long as there are two such subsequences such that the first begins before the second subsequence, and the first sequence start with a number greater than or equal to the second, then we unhook this starting number and attach it to the beginning of second. After a finite number of steps we have $y$ subsequences, and their starting numbers will form an increasing subsequence of length $y$. Since we assumed that $y &gt; x$ we reached a contradiction.</p> <p>Thus it follows that $y = x$.</p> <p>Restoring the sequences: The desired partition of the sequence into subsequences can be done greedily. I.e. go from left to right and assign the current number or that subsequence ending with the minimal number which is greater than or equal to the current one.</p>","tags":["Translated"]},{"location":"dynamic_programming/longest_increasing_subsequence.html#practice-problems","title":"Practice Problems","text":"<ul> <li>ACMSGURU - \"North-East\"</li> <li>Codeforces - LCIS</li> <li>Codeforces - Tourist</li> <li>SPOJ - DOSA</li> <li>SPOJ - HMLIS</li> <li>SPOJ - ONEXLIS</li> <li>SPOJ - SUPPER</li> <li>Topcoder - AutoMarket</li> <li>Topcoder - BridgeArrangement</li> <li>Topcoder - IntegerSequence</li> <li>UVA - Back To Edit Distance</li> <li>UVA - Happy Birthday</li> <li>UVA - Tiling Up Blocks</li> </ul>","tags":["Translated"]},{"location":"dynamic_programming/profile-dynamics.html","title":"Dynamic Programming on Broken Profile. Problem \"Parquet\"","text":"<p>Common problems solved using DP on broken profile include:</p> <ul> <li>finding number of ways to fully fill an area (e.g. chessboard/grid) with some figures (e.g. dominoes)</li> <li>finding a way to fill an area with minimum number of figures</li> <li>finding a partial fill with minimum number of unfilled space (or cells, in case of grid)</li> <li>finding a partial fill with the minimum number of figures, such that no more figures can be added</li> </ul>","tags":["Translated"]},{"location":"dynamic_programming/profile-dynamics.html#problem-parquet","title":"Problem \"Parquet\"","text":"<p>Problem description. Given a grid of size $N \\times M$. Find number of ways to fill the grid with figures of size $2 \\times 1$ (no cell should be left unfilled, and figures should not overlap each other).</p> <p>Let the DP state be: $dp[i, mask]$, where $i = 1, \\ldots N$ and $mask = 0, \\ldots 2^M - 1$.</p> <p>$i$ represents number of rows in the current grid, and $mask$ is the state of last row of current grid. If $j$-th bit of $mask$ is $0$ then the corresponding cell is filled, otherwise it is unfilled.</p> <p>Clearly, the answer to the problem will be $dp[N, 0]$.</p> <p>We will be building the DP state by iterating over each $i = 1, \\cdots N$ and each $mask = 0, \\ldots 2^M - 1$, and for each $mask$ we will be only transitioning forward, that is, we will be adding figures to the current grid.</p>","tags":["Translated"]},{"location":"dynamic_programming/profile-dynamics.html#implementation","title":"Implementation","text":"<pre><code>int n, m;\nvector &lt; vector&lt;long long&gt; &gt; dp;\n\n\nvoid calc (int x = 0, int y = 0, int mask = 0, int next_mask = 0)\n{\n    if (x == n)\n        return;\n    if (y &gt;= m)\n        dp[x+1][next_mask] += dp[x][mask];\n    else\n    {\n        int my_mask = 1 &lt;&lt; y;\n        if (mask &amp; my_mask)\n            calc (x, y+1, mask, next_mask);\n        else\n        {\n            calc (x, y+1, mask, next_mask | my_mask);\n            if (y+1 &lt; m &amp;&amp; ! (mask &amp; my_mask) &amp;&amp; ! (mask &amp; (my_mask &lt;&lt; 1)))\n                calc (x, y+2, mask, next_mask);\n        }\n    }\n}\n\n\nint main()\n{\n    cin &gt;&gt; n &gt;&gt; m;\n\n    dp.resize (n+1, vector&lt;long long&gt; (1&lt;&lt;m));\n    dp[0][0] = 1;\n    for (int x=0; x&lt;n; ++x)\n        for (int mask=0; mask&lt;(1&lt;&lt;m); ++mask)\n            calc (x, 0, mask, 0);\n\n    cout &lt;&lt; dp[n][0];\n\n}\n</code></pre>","tags":["Translated"]},{"location":"dynamic_programming/profile-dynamics.html#practice-problems","title":"Practice Problems","text":"<ul> <li>UVA 10359 - Tiling</li> <li>UVA 10918 - Tri Tiling</li> <li>SPOJ GNY07H (Four Tiling)</li> <li>SPOJ M5TILE (Five Tiling)</li> <li>SPOJ MNTILE (MxN Tiling)</li> <li>SPOJ DOJ1</li> <li>SPOJ DOJ2</li> <li>SPOJ BTCODE_J</li> <li>SPOJ PBOARD</li> <li>ACM HDU 4285 - Circuits</li> <li>LiveArchive 4608 - Mosaic</li> <li>Timus 1519 - Formula 1</li> <li>Codeforces Parquet</li> </ul>","tags":["Translated"]},{"location":"dynamic_programming/profile-dynamics.html#references","title":"References","text":"<ul> <li>Blog by EvilBunny</li> <li>TopCoder Recipe by \"syg96\"</li> <li>Blogpost by sk765</li> </ul>","tags":["Translated"]},{"location":"dynamic_programming/zero_matrix.html","title":"Finding the largest zero submatrix","text":"<p>You are given a matrix with <code>n</code> rows and <code>m</code> columns. Find the largest submatrix consisting of only zeros (a submatrix is a rectangular area of the matrix).</p>","tags":["Translated"]},{"location":"dynamic_programming/zero_matrix.html#algorithm","title":"Algorithm","text":"<p>Elements of the matrix will be <code>a[i][j]</code>, where <code>i = 0...n - 1</code>, <code>j = 0... m - 1</code>. For simplicity, we will consider all non-zero elements equal to 1.</p>","tags":["Translated"]},{"location":"dynamic_programming/zero_matrix.html#step-1-auxiliary-dynamic","title":"Step 1: Auxiliary dynamic","text":"<p>First, we calculate the following auxiliary matrix: <code>d[i][j]</code>, nearest row that has a 1 above <code>a[i][j]</code>. Formally speaking, <code>d[i][j]</code> is the largest row number (from <code>0</code> to <code>i - 1</code>), in which there is a element equal to <code>1</code> in the <code>j</code>-th column.  While iterating from top-left to bottom-right, when we stand in row <code>i</code>, we know the values from the previous row, so, it is enough to update just the elements with value <code>1</code>. We can save the values in a simple array <code>d[i]</code>, <code>i = 1...m - 1</code>, because in the further algorithm we will process the matrix one row at a time and only need the values of the current row.</p> <pre><code>vector&lt;int&gt; d(m, -1);\nfor (int i = 0; i &lt; n; ++i) {\n    for (int j = 0; j &lt; m; ++j) {\n        if (a[i][j] == 1) {\n            d[j] = i;\n        }\n    }\n}\n</code></pre>","tags":["Translated"]},{"location":"dynamic_programming/zero_matrix.html#step-2-problem-solving","title":"Step 2: Problem solving","text":"<p>We can solve the problem in $O(n m^2)$ iterating through rows, considering every possible left and right columns for a submatrix. The bottom of the rectangle will be the current row, and using <code>d[i][j]</code> we can find the top row. However, it is possible to go further and significantly improve the complexity of the solution.</p> <p>It is clear that the desired zero submatrix is bounded on all four sides by some ones, which prevent it from increasing in size and improving the answer. Therefore,  we will not miss the answer if we act as follows: for every cell <code>j</code> in row <code>i</code> (the bottom row of a potential zero submatrix) we will have <code>d[i][j]</code> as the top row of the current zero submatrix. It now remains to determine the optimal left and right boundaries of the zero submatrix, i.e. maximally push this submatrix to the left and right of the <code>j</code>-th column. </p> <p>What does it mean to push the maximum to the left? It means to find an index <code>k1</code> for which <code>d[i][k1] &gt; d[i][j]</code>, and at the same time <code>k1</code> - the closest one to the left of the index <code>j</code>. It is clear that then <code>k1 + 1</code> gives the number of the left column of the required zero submatrix. If there is no such index at all, then put <code>k1</code> = <code>-1</code>(this means that we were able to extend the current zero submatrix to the left all the way to the border of matrix <code>a</code>).</p> <p>Symmetrically, you can define an index <code>k2</code> for the right border: this is the closest index to the right of <code>j</code> such that <code>d[i][k2] &gt; d[i][j]</code> (or <code>m</code>, if there is no such index).</p> <p>So, the indices <code>k1</code> and <code>k2</code>, if we learn to search for them effectively, will give us all the necessary information about the current zero submatrix. In particular, its area will be equal to <code>(i - d[i][j]) * (k2 - k1 - 1)</code>.</p> <p>How to look for these indexes <code>k1</code> and <code>k2</code> effectively with fixed <code>i</code> and <code>j</code>? We can do that in $O(1)$ on average.</p> <p>To achieve such complexity, you can use the stack as follows. Let's first learn how to search for an index <code>k1</code>, and save its value for each index <code>j</code> within the current row <code>i</code> in matrix <code>d1[i][j]</code>. To do this, we will look through all the columns <code>j</code> from left to right, and we will store in the stack only those columns that have <code>d[][]</code> strictly greater than <code>d[i][j]</code>. It is clear that when moving from a column <code>j</code> to the next column, it is necessary to update the content of the stack. When there is an inappropriate element at the top of the stack (i.e. <code>d[][] &lt;= d[i][j]</code>) pop it. It is easy to understand that it is enough to remove from the stack only from its top, and from none of its other places (because the stack will contain an increasing <code>d</code> sequence of columns).</p> <p>The value <code>d1[i][j]</code> for each <code>j</code> will be equal to the value lying at that moment on top of the stack.</p> <p>The dynamics <code>d2[i][j]</code> for finding the indices <code>k2</code> is considered similar, only you need to view the columns from right to left.</p> <p>It is clear that since there are exactly <code>m</code> pieces added to the stack on each line, there could not be more deletions either, the sum of complexities will be linear, so the final complexity of the algorithm is $O(nm)$.</p> <p>It should also be noted that this algorithm consumes $O(m)$ memory (not counting the input data - the matrix <code>a[][]</code>).</p>","tags":["Translated"]},{"location":"dynamic_programming/zero_matrix.html#implementation","title":"Implementation","text":"<pre><code>int zero_matrix(vector&lt;vector&lt;int&gt;&gt; a) {\n    int n = a.size();\n    int m = a[0].size();\n\n    int ans = 0;\n    vector&lt;int&gt; d(m, -1), d1(m), d2(m);\n    stack&lt;int&gt; st;\n    for (int i = 0; i &lt; n; ++i) {\n        for (int j = 0; j &lt; m; ++j) {\n            if (a[i][j] == 1)\n                d[j] = i;\n        }\n\n        for (int j = 0; j &lt; m; ++j) {\n            while (!st.empty() &amp;&amp; d[st.top()] &lt;= d[j])\n                st.pop();\n            d1[j] = st.empty() ? -1 : st.top();\n            st.push(j);\n        }\n        while (!st.empty())\n            st.pop();\n\n        for (int j = m - 1; j &gt;= 0; --j) {\n            while (!st.empty() &amp;&amp; d[st.top()] &lt;= d[j])\n                st.pop();\n            d2[j] = st.empty() ? m : st.top();\n            st.push(j);\n        }\n        while (!st.empty())\n            st.pop();\n\n        for (int j = 0; j &lt; m; ++j)\n            ans = max(ans, (i - d[j]) * (d2[j] - d1[j] - 1));\n    }\n    return ans;\n}\n</code></pre>","tags":["Translated"]},{"location":"game_theory/games_on_graphs.html","title":"Games on arbitrary graphs","text":"<p>Let a game be played by two players on an arbitrary graph $G$. I.e. the current state of the game is a certain vertex. The players perform moves by turns, and move from the current vertex to an adjacent vertex using a connecting edge. Depending on the game, the person that is unable to move will either lose or win the game.</p> <p>We consider the most general case, the case of an arbitrary directed graph with cycles. It is our task to determine, given an initial state, who will win the game if both players play with optimal strategies or determine that the result of the game will be a draw.</p> <p>We will solve this problem very efficiently. We will find the solution for all possible starting vertices of the graph in linear time with respect to the number of edges: $O(m)$.</p>","tags":["Translated"]},{"location":"game_theory/games_on_graphs.html#description-of-the-algorithm","title":"Description of the algorithm","text":"<p>We will call a vertex a winning vertex, if the player starting at this state will win the game, if they play optimally (regardless of what turns the other player makes). Similarly, we will call a vertex a losing vertex, if the player starting at this vertex will lose the game, if the opponent plays optimally.</p> <p>For some of the vertices of the graph, we already know in advance that they are winning or losing vertices: namely all vertices that have no outgoing edges.</p> <p>Also we have the following rules:</p> <ul> <li>if a vertex has an outgoing edge that leads to a losing vertex, then the vertex itself is a winning vertex.</li> <li>if all outgoing edges of a certain vertex lead to winning vertices, then the vertex itself is a losing vertex.</li> <li>if at some point there are still undefined vertices, and neither will fit the first or the second rule, then each of these vertices, when used as a starting vertex, will lead to a draw if both player play optimally.</li> </ul> <p>Thus, we can define an algorithm which runs in $O(n m)$ time immediately. We go through all vertices and try to apply the first or second rule, and repeat.</p> <p>However, we can accelerate this procedure, and get the complexity down to $O(m)$.</p> <p>We will go over all the vertices, for which we initially know if they are winning or losing states. For each of them, we start a depth first search. This DFS will move back over the reversed edges. First of all, it will not enter vertices which already are defined as winning or losing vertices. And further, if the search goes from a losing vertex to an undefined vertex, then we mark this one as a winning vertex, and continue the DFS using this new vertex. If we go from a winning vertex to an undefined vertex, then we must check whether all edges from this one leads to winning vertices. We can perform this test in $O(1)$ by storing the number of edges that lead to a winning vertex for each vertex. So if we go from a winning vertex to an undefined one, then we increase the counter, and check if this number is equal to the number of outgoing edges. If this is the case, we can mark this vertex as a losing vertex, and continue the DFS from this vertex. Otherwise we don't know yet, if this vertex is a winning or losing vertex, and therefore it doesn't make sense to keep continuing the DFS using it.</p> <p>In total we visit every winning and every losing vertex exactly once (undefined vertices are not visited), and we go over each edge also at most one time. Hence the complexity is $O(m)$.</p>","tags":["Translated"]},{"location":"game_theory/games_on_graphs.html#implementation","title":"Implementation","text":"<p>Here is the implementation of such a DFS. We assume that the variable <code>adj_rev</code> stores the adjacency list for the graph in reversed form, i.e. instead of storing the edge $(i, j)$ of the graph, we store $(j, i)$. Also for each vertex we assume that the outgoing degree is already computed.</p> <pre><code>vector&lt;vector&lt;int&gt;&gt; adj_rev;\n\nvector&lt;bool&gt; winning;\nvector&lt;bool&gt; losing;\nvector&lt;bool&gt; visited;\nvector&lt;int&gt; degree;\n\nvoid dfs(int v) {\n    visited[v] = true;\n    for (int u : adj_rev[v]) {\n        if (!visited[u]) {\n            if (losing[v])\n                winning[u] = true;\n            else if (--degree[u] == 0)\n                losing[u] = true;\n            else\n                continue;\n            dfs(u);\n        }\n    }\n}\n</code></pre>","tags":["Translated"]},{"location":"game_theory/games_on_graphs.html#example-policeman-and-thief","title":"Example: \"Policeman and thief\"","text":"<p>Here is a concrete example of such a game.</p> <p>There is $m \\times n$ board. Some of the cells cannot be entered. The initial coordinates of the police officer and of the thief are known. One of the cells is the exit. If the policeman and the thief are located at the same cell at any moment, the policeman wins. If the thief is at the exit cell (without the policeman also being on the cell), then the thief wins. The policeman can walk in all 8 directions, the thief only in 4 (along the coordinate axis). Both the policeman and the thief will take turns moving. However they also can skip a turn if they want to. The first move is made by the policeman.</p> <p>We will now construct the graph. For this we must formalize the rules of the game. The current state of the game is determined by the coordinates of the police offices $P$, the coordinates of the thief $T$, and also by whose turn it is, let's call this variable $P_{\\text{turn}}$ (which is true when it is the policeman's turn). Therefore a vertex of the graph is determined by the triple $(P, T, P_{\\text{turn}})$ The graph then can be easily constructed, simply by following the rules of the game.</p> <p>Next we need to determine which vertices are winning and which are losing ones initially. There is a subtle point here. The winning / losing vertices depend, in addition to the coordinates, also on $P_{\\text{turn}}$ - whose turn it. If it is the policeman's turn, then the vertex is a winning vertex, if the coordinates of the policeman and the thief coincide, and the vertex is a losing one if it is not a winning one and the thief is on the exit vertex. If it is the thief's turn, then a vertex is a losing vertex, if the coordinates of the two players coincide, and it is a winning vertex if it is not a losing one, and the thief is at the exit vertex.</p> <p>The only point before implementing is not, that you need to decide if you want to build the graph explicitly or just construct it on the fly. On one hand, building the graph explicitly will be a lot easier and there is less chance of making mistakes. On the other hand, it will increase the amount of code and the running time will be slower than if you build the graph on the fly.</p> <p>The following implementation will construct the graph explicitly:</p> <pre><code>struct State {\n    int P, T;\n    bool Pstep;\n};\n\nvector&lt;State&gt; adj_rev[100][100][2]; // [P][T][Pstep]\nbool winning[100][100][2];\nbool losing[100][100][2];\nbool visited[100][100][2];\nint degree[100][100][2];\n\nvoid dfs(State v) {\n    visited[v.P][v.T][v.Pstep] = true;\n    for (State u : adj_rev[v.P][v.T][v.Pstep]) {\n        if (!visited[u.P][u.T][u.Pstep]) {\n            if (losing[v.P][v.T][v.Pstep])\n                winning[u.P][u.T][u.Pstep] = true;\n            else if (--degree[u.P][u.T][u.Pstep] == 0)\n                losing[u.P][u.T][u.Pstep] = true;\n            else\n                continue;\n            dfs(u);\n        }\n    }\n}\n\nint main() {\n    int n, m;\n    cin &gt;&gt; n &gt;&gt; m;\n    vector&lt;string&gt; a(n);\n    for (int i = 0; i &lt; n; i++)\n        cin &gt;&gt; a[i];\n\n    for (int P = 0; P &lt; n*m; P++) {\n        for (int T = 0; T &lt; n*m; T++) {\n            for (int Pstep = 0; Pstep &lt;= 1; Pstep++) {\n                int Px = P/m, Py = P%m, Tx = T/m, Ty = T%m;\n                if (a[Px][Py]=='*' || a[Tx][Ty]=='*')\n                    continue;\n\n                bool&amp; win = winning[P][T][Pstep];\n                bool&amp; lose = losing[P][T][Pstep];\n                if (Pstep) {\n                    win = Px==Tx &amp;&amp; Py==Ty;\n                    lose = !win &amp;&amp; a[Tx][Ty] == 'E';\n                } else {\n                    lose = Px==Tx &amp;&amp; Py==Ty;\n                    win = !lose &amp;&amp; a[Tx][Ty] == 'E';\n                }\n                if (win || lose)\n                    continue;\n\n                State st = {P,T,!Pstep};\n                adj_rev[P][T][Pstep].push_back(st);\n                st.Pstep = Pstep;\n                degree[P][T][Pstep]++;\n\n                const int dx[] = {-1, 0, 1, 0, -1, -1, 1, 1};\n                const int dy[] = {0, 1, 0, -1, -1, 1, -1, 1};\n                for (int d = 0; d &lt; (Pstep ? 8 : 4); d++) {\n                    int PPx = Px, PPy = Py, TTx = Tx, TTy = Ty;\n                    if (Pstep) {\n                        PPx += dx[d];\n                        PPy += dy[d];\n                    } else {\n                        TTx += dx[d];\n                        TTy += dy[d];\n                    }\n\n                    if (PPx &gt;= 0 &amp;&amp; PPx &lt; n &amp;&amp; PPy &gt;= 0 &amp;&amp; PPy &lt; m &amp;&amp; a[PPx][PPy] != '*' &amp;&amp;\n                        TTx &gt;= 0 &amp;&amp; TTx &lt; n &amp;&amp; TTy &gt;= 0 &amp;&amp; TTy &lt; m &amp;&amp; a[TTx][TTy] != '*')\n                    {\n                        adj_rev[PPx*m+PPy][TTx*m+TTy][!Pstep].push_back(st);\n                        ++degree[P][T][Pstep];\n                    }\n                }\n            }\n        }\n    }\n\n    for (int P = 0; P &lt; n*m; P++) {\n        for (int T = 0; T &lt; n*m; T++) {\n            for (int Pstep = 0; Pstep &lt;= 1; Pstep++) {\n                if ((winning[P][T][Pstep] || losing[P][T][Pstep]) &amp;&amp; !visited[P][T][Pstep])\n                    dfs({P, T, (bool)Pstep});\n            }\n        }\n    }\n\n    int P_st, T_st;\n    for (int i = 0; i &lt; n; i++) {\n        for (int j = 0; j &lt; m; j++) {\n            if (a[i][j] == 'P')\n                P_st = i*m+j;\n            else if (a[i][j] == 'T')\n                T_st = i*m+j;\n        }\n    }\n\n    if (winning[P_st][T_st][true]) {\n        cout &lt;&lt; \"Police catches the thief\"  &lt;&lt; endl;\n    } else if (losing[P_st][T_st][true]) {\n        cout &lt;&lt; \"The thief escapes\" &lt;&lt; endl;\n    } else {\n        cout &lt;&lt; \"Draw\" &lt;&lt; endl;\n    }\n}\n</code></pre>","tags":["Translated"]},{"location":"game_theory/sprague-grundy-nim.html","title":"Sprague-Grundy theorem. Nim","text":"","tags":["Translated"]},{"location":"game_theory/sprague-grundy-nim.html#introduction","title":"Introduction","text":"<p>This theorem describes the so-called impartial two-player game, i.e. those in which the available moves and winning/losing depends only on the state of the game. In other words, the only difference between the two players is that one of them moves first.</p> <p>Additionally, we assume that the game has perfect information, i.e. no information is hidden from the players (they know the rules and the possible moves).</p> <p>It is assumed that the game is finite, i.e. after a certain number of moves, one of the players will end up in a losing position \u2014 from which they can't move to another position. On the other side, the player who set up this position for the opponent wins. Understandably, there are no draws in this game.</p> <p>Such games can be completely described by a directed acyclic graph: the vertices are game states and the edges are transitions (moves). A vertex without outgoing edges is a losing vertex (a player who must make a move from this vertex loses).</p> <p>Since there are no draws, we can classify all game states as either winning or losing. Winning states are those from which there is a move that causes inevitable defeat of the other player, even with their best response. Losing states are those from which all moves lead to winning states for the other player. Summarizing, a state is winning if there is at least one transition to a losing state and is losing if there isn't at least one transition to a losing state.</p> <p>Our task is to classify the states of a given game.</p> <p>The theory of such games was independently developed by Roland Sprague in 1935 and Patrick Michael Grundy in 1939.</p>","tags":["Translated"]},{"location":"game_theory/sprague-grundy-nim.html#nim","title":"Nim","text":"<p>This game obeys the restrictions described above. Moreover, any perfect-information impartial two-player game can be reduced to the game of Nim. Studying this game will allow us to solve all other similar games, but more on that later.</p> <p>Historically this game was popular in ancient times. Its origin is probably in China \u2014 or at least the game Jianshizi is very similar to it. In Europe the earliest references to it are from the 16th century. The name was given by Charles Bouton, who in 1901 published a full analysis of this game.</p>","tags":["Translated"]},{"location":"game_theory/sprague-grundy-nim.html#game-description","title":"Game description","text":"<p>There are several piles, each with several stones. In a move a player can take any positive number of stones from any one pile and throw them away. A player loses if they can't make a move, which happens when all the piles are empty.</p> <p>The game state is unambiguously described by a multiset of positive integers. A move consists of strictly decreasing a chosen integer (if it becomes zero, it is removed from the set).</p>","tags":["Translated"]},{"location":"game_theory/sprague-grundy-nim.html#the-solution","title":"The solution","text":"<p>The solution by Charles L. Bouton looks like this:</p> <p>Theorem. The current player has a winning strategy if and only if the xor-sum of the pile sizes is non-zero. The xor-sum of a sequence $a$ is $a_1 \\oplus a_2 \\oplus \\ldots \\oplus  a_n$, where $\\oplus$ is the bitwise exclusive or.</p> <p>Proof. The key to the proof is the presence of a symmetric strategy for the opponent. We show that a once in a position with the xor-sum equal to zero, the player won't be able to make it non-zero in the long term \u2014 if they transition to a position with a non-zero xor-sum, the opponent will always have a move returning the xor-sum back to zero.</p> <p>We will prove the theorem by mathematical induction.</p> <p>For an empty Nim (where all the piles are empty i.e. the multiset is empty) the xor-sum is zero and the theorem is true.</p> <p>Now suppose we are in a non-empty state. Using the assumption of induction (and the acyclicity of the game) we assume that the theorem is proven for all states reachable from the current one.</p> <p>Then the proof splits into two parts: if for the current position the xor-sum $s = 0$, we have to prove that this state is losing, i.e. all reachable states have xor-sum $t \\neq 0$. If $s \\neq 0$, we have to prove that there is a move leading to a state with $t = 0$.</p> <ul> <li> <p>Let $s = 0$ and let's consider any move.     This move reduces the size of a pile $x$ to a size $y$.     Using elementary properties of $\\oplus$, we have</p> $$ t = s \\oplus x \\oplus y = 0 \\oplus x \\oplus y = x \\oplus y $$ <p>Since $y &lt; x$, $y \\oplus x$ can't be zero, so $t \\neq 0$. That means any reachable state is a winning one (by the assumption of induction), so we are in a losing position.</p> </li> <li> <p>Let $s \\neq 0$.     Consider the binary representation of the number $s$.     Let $d$ be the index of its leading (biggest value) non-zero bit.     Our move will be on a pile whose size's bit number $d$ is set (it must exist, otherwise the bit wouldn't be set in $s$).     We will reduce its size $x$ to $y = x \\oplus s$.     All bits at positions greater than $d$ in $x$ and $y$ match and bit $d$ is set in $x$ but not set in $y$.     Therefore, $y &lt; x$, which is all we need for a move to be legal.     Now we have:</p> $$ t = s \\oplus x \\oplus y = s \\oplus x \\oplus (s \\oplus x) = 0 $$ <p>This means we found a reachable losing state (by the assumption of induction) and the current state is winning.</p> </li> </ul> <p>Corollary. Any state of Nim can be replaced by an equivalent state as long as the xor-sum doesn't change. Moreover, when analyzing a Nim with several piles, we can replace it with a single pile of size $s$.</p>","tags":["Translated"]},{"location":"game_theory/sprague-grundy-nim.html#misere-game","title":"Mis\u00e8re Game","text":"<p>In a mis\u00e8re game, the goal of the game is opposite, so the player who removes the last stick loses the game. It turns out that the mis\u00e8re nim game can be optimally played almost like a standard nim game.  The idea is to first play the mis\u00e8re game like the standard game, but change the strategy at the end of the game.  The new strategy will be introduced in a situation where each heap would contain at most one stick after the next move. In the standard game, we should choose a move after which there is an even number of heaps with one stick. However, in  the mis\u00e8re game,we choose a move so that there is an odd number of heaps with one stick.   This strategy works because a state where the strategy changes always appears in the game, and this state is a    winning state, because it contains exactly one heap that has more than one stick so the nim sum is not 0.</p>","tags":["Translated"]},{"location":"game_theory/sprague-grundy-nim.html#the-equivalence-of-impartial-games-and-nim-sprague-grundy-theorem","title":"The equivalence of impartial games and Nim (Sprague-Grundy theorem)","text":"<p>Now we will learn how to find, for any game state of any impartial game, a corresponding state of Nim.</p>","tags":["Translated"]},{"location":"game_theory/sprague-grundy-nim.html#lemma-about-nim-with-increases","title":"Lemma about Nim with increases","text":"<p>We consider the following modification to Nim: we also allow adding stones to a chosen pile. The exact rules about how and when increasing is allowed do not interest us, however the rules should keep our game acyclic. In later sections, example games are considered.</p> <p>Lemma. The addition of increasing to Nim doesn't change how winning and losing states are determined. In other words, increases are useless, and we don't have to use them in a winning strategy.</p> <p>Proof. Suppose a player added stones to a pile. Then his opponent can simply undo his move \u2014 decrease the number back to the previous value. Since the game is acyclic, sooner or later the current player won't be able to use an increase move and will have to do the usual Nim move.</p>","tags":["Translated"]},{"location":"game_theory/sprague-grundy-nim.html#sprague-grundy-theorem","title":"Sprague-Grundy theorem","text":"<p>Let's consider a state $v$ of a two-player impartial game and let $v_i$ be the states reachable from it (where $i \\in \\{ 1, 2, \\dots, k \\} , k \\ge 0$). To this state, we can assign a fully equivalent game of Nim with one pile of size $x$. The number $x$ is called the Grundy value or nim-value of state $v$.</p> <p>Moreover, this number can be found in the following recursive way:</p> $$ x = \\text{mex}\\ \\{ x_1, \\ldots, x_k \\}, $$ <p>where $x_i$ is the Grundy value for state $v_i$ and the function $\\text{mex}$ (minimum excludant) is the smallest non-negative integer not found in the given set.</p> <p>Viewing the game as a graph, we can gradually calculate the Grundy values starting from vertices without outgoing edges. Grundy value being equal to zero means a state is losing.</p> <p>Proof. We will use a proof by induction.</p> <p>For vertices without a move, the value $x$ is the $\\text{mex}$ of an empty set, which is zero. That is correct, since an empty Nim is losing.</p> <p>Now consider any other vertex $v$. By induction, we assume the values $x_i$ corresponding to its reachable vertices are already calculated.</p> <p>Let $p = \\text{mex}\\ \\{ x_1, \\ldots, x_k \\}$. Then we know that for any integer $i \\in [0, p)$ there exists a reachable vertex with Grundy value $i$. This means $v$ is equivalent to a state of the game of Nim with increases with one pile of size $p$. In such a game we have transitions to piles of every size smaller than $p$ and possibly transitions to piles with sizes greater than $p$. Therefore, $p$ is indeed the desired Grundy value for the currently considered state.</p>","tags":["Translated"]},{"location":"game_theory/sprague-grundy-nim.html#application-of-the-theorem","title":"Application of the theorem","text":"<p>Finally, we describe an algorithm to determine the win/loss outcome of a game, which is applicable to any impartial two-player game.</p> <p>To calculate the Grundy value of a given state you need to:</p> <ul> <li> <p>Get all possible transitions from this state</p> </li> <li> <p>Each transition can lead to a sum of independent games (one game in the degenerate case). Calculate the Grundy value for each independent game and xor-sum them. Of course xor does nothing if there is just one game.</p> </li> <li> <p>After we calculated Grundy values for each transition we find the state's value as the $\\text{mex}$ of these numbers.</p> </li> <li> <p>If the value is zero, then the current state is losing, otherwise it is winning.</p> </li> </ul> <p>In comparison to the previous section, we take into account the fact that there can be transitions to combined games. We consider them a Nim with pile sizes equal to the independent games' Grundy values. We can xor-sum them just like usual Nim according to Bouton's theorem.</p>","tags":["Translated"]},{"location":"game_theory/sprague-grundy-nim.html#patterns-in-grundy-values","title":"Patterns in Grundy values","text":"<p>Very often when solving specific tasks using Grundy values, it may be beneficial to study the table of the values in search of patterns.</p> <p>In many games, which may seem rather difficult for theoretical analysis, the Grundy values turn out to be periodic or of an easily understandable form. In the overwhelming majority of cases the observed pattern turns out to be true and can be proved by induction if desired.</p> <p>However, Grundy values are far from always containing such regularities and even for some very simple games, the problem asking if those regularities exist is still open (e.g. \"Grundy's game\").</p>","tags":["Translated"]},{"location":"game_theory/sprague-grundy-nim.html#example-games","title":"Example games","text":"","tags":["Translated"]},{"location":"game_theory/sprague-grundy-nim.html#crosses-crosses","title":"Crosses-crosses","text":"<p>The rules. Consider a checkered strip of size $1 \\times n$. In one move, the player must put one cross, but it is forbidden to put two crosses next to each other (in adjacent cells). As usual, the player without a valid move loses.</p> <p>The solution. When a player puts a cross in any cell, we can think of the strip being split into two independent parts: to the left of the cross and to the right of it. In this case, the cell with a cross, as well as its left and right neighbours are destroyed \u2014 nothing more can be put in them. Therefore, if we number the cells from $1$ to $n$ then putting the cross in position $1 &lt; i &lt; n$ breaks the strip into two strips of length $i-2$ and $n-i-1$ i.e. we go to the sum of games $i-2$ and $n-i-1$. For the edge case of the cross being marked on position $1$ or $n$, we go to the game $n-2$.</p> <p>Thus, the Grundy value $g(n)$ has the form:</p> $$g(n) = \\text{mex} \\Bigl( \\{ g(n-2) \\} \\cup \\{g(i-2) \\oplus g(n-i-1) \\mid 2 \\leq i \\leq n-1\\} \\Bigr) .$$ <p>So we've got a $O(n^2)$ solution.</p> <p>In fact, $g(n)$ has a period of length 34 starting with $n=52$.</p>","tags":["Translated"]},{"location":"game_theory/sprague-grundy-nim.html#practice-problems","title":"Practice Problems","text":"<ul> <li>KATTIS S-Nim</li> <li>CodeForces - Marbles (2018-2019 ACM-ICPC Brazil Subregional)</li> <li>KATTIS - Cuboid Slicing Game</li> <li>HackerRank - Tower Breakers, Revisited!</li> <li>HackerRank - Tower Breakers, Again!</li> <li>HackerRank - Chessboard Game, Again!</li> <li>Atcoder - ABC368F - Dividing Game</li> </ul>","tags":["Translated"]},{"location":"geometry/area-of-simple-polygon.html","title":"Finding area of simple polygon in $O(N)$","text":"<p>Let a simple polygon (i.e. without self intersection, not necessarily convex) be given. It is required to calculate its area given its vertices.</p>","tags":["Translated"]},{"location":"geometry/area-of-simple-polygon.html#method-1","title":"Method 1","text":"<p>This is easy to do if we go through all edges and add trapezoid areas bounded by each edge and x-axis. The area needs to be taken with sign so that the extra area will be reduced. Hence, the formula is as follows:</p> $$A = \\sum_{(p,q)\\in \\text{edges}} \\frac{(p_x - q_x) \\cdot (p_y + q_y)}{2}$$ <p>Code:</p> <pre><code>double area(const vector&lt;point&gt;&amp; fig) {\n    double res = 0;\n    for (unsigned i = 0; i &lt; fig.size(); i++) {\n        point p = i ? fig[i - 1] : fig.back();\n        point q = fig[i];\n        res += (p.x - q.x) * (p.y + q.y);\n    }\n    return fabs(res) / 2;\n}\n</code></pre>","tags":["Translated"]},{"location":"geometry/area-of-simple-polygon.html#method-2","title":"Method 2","text":"<p>We can choose a point $O$ arbitrarily, iterate over all edges adding the oriented area of the triangle formed by the edge and point $O$. Again, due to the sign of area, extra area will be reduced.</p> <p>This method is better as it can be generalized to more complex cases (such as when some sides are arcs instead of straight lines)</p>","tags":["Translated"]},{"location":"geometry/basic-geometry.html","title":"Basic Geometry","text":"<p>In this article we will consider basic operations on points in Euclidean space which maintains the foundation of the whole analytical geometry. We will consider for each point $\\mathbf r$ the vector $\\vec{\\mathbf r}$ directed from $\\mathbf 0$ to $\\mathbf r$. Later we will not distinguish between $\\mathbf r$ and $\\vec{\\mathbf r}$ and use the term point as a synonym for vector.</p>","tags":["Original"]},{"location":"geometry/basic-geometry.html#linear-operations","title":"Linear operations","text":"<p>Both 2D and 3D points maintain linear space, which means that for them sum of points and multiplication of point by some number are defined. Here are those basic implementations for 2D:</p> <p><pre><code>struct point2d {\n    ftype x, y;\n    point2d() {}\n    point2d(ftype x, ftype y): x(x), y(y) {}\n    point2d&amp; operator+=(const point2d &amp;t) {\n        x += t.x;\n        y += t.y;\n        return *this;\n    }\n    point2d&amp; operator-=(const point2d &amp;t) {\n        x -= t.x;\n        y -= t.y;\n        return *this;\n    }\n    point2d&amp; operator*=(ftype t) {\n        x *= t;\n        y *= t;\n        return *this;\n    }\n    point2d&amp; operator/=(ftype t) {\n        x /= t;\n        y /= t;\n        return *this;\n    }\n    point2d operator+(const point2d &amp;t) const {\n        return point2d(*this) += t;\n    }\n    point2d operator-(const point2d &amp;t) const {\n        return point2d(*this) -= t;\n    }\n    point2d operator*(ftype t) const {\n        return point2d(*this) *= t;\n    }\n    point2d operator/(ftype t) const {\n        return point2d(*this) /= t;\n    }\n};\npoint2d operator*(ftype a, point2d b) {\n    return b * a;\n}\n</code></pre> And 3D points: <pre><code>struct point3d {\n    ftype x, y, z;\n    point3d() {}\n    point3d(ftype x, ftype y, ftype z): x(x), y(y), z(z) {}\n    point3d&amp; operator+=(const point3d &amp;t) {\n        x += t.x;\n        y += t.y;\n        z += t.z;\n        return *this;\n    }\n    point3d&amp; operator-=(const point3d &amp;t) {\n        x -= t.x;\n        y -= t.y;\n        z -= t.z;\n        return *this;\n    }\n    point3d&amp; operator*=(ftype t) {\n        x *= t;\n        y *= t;\n        z *= t;\n        return *this;\n    }\n    point3d&amp; operator/=(ftype t) {\n        x /= t;\n        y /= t;\n        z /= t;\n        return *this;\n    }\n    point3d operator+(const point3d &amp;t) const {\n        return point3d(*this) += t;\n    }\n    point3d operator-(const point3d &amp;t) const {\n        return point3d(*this) -= t;\n    }\n    point3d operator*(ftype t) const {\n        return point3d(*this) *= t;\n    }\n    point3d operator/(ftype t) const {\n        return point3d(*this) /= t;\n    }\n};\npoint3d operator*(ftype a, point3d b) {\n    return b * a;\n}\n</code></pre></p> <p>Here <code>ftype</code> is some type used for coordinates, usually <code>int</code>, <code>double</code> or <code>long long</code>.</p>","tags":["Original"]},{"location":"geometry/basic-geometry.html#dot-product","title":"Dot product","text":"","tags":["Original"]},{"location":"geometry/basic-geometry.html#definition","title":"Definition","text":"<p>The dot (or scalar) product $\\mathbf a \\cdot \\mathbf b$ for vectors $\\mathbf a$ and $\\mathbf b$ can be defined in two identical ways. Geometrically it is product of the length of the first vector by the length of the projection of the second vector onto the first one. As you may see from the image below this projection is nothing but $|\\mathbf a| \\cos \\theta$ where $\\theta$ is the angle between $\\mathbf a$ and $\\mathbf b$. Thus $\\mathbf a\\cdot  \\mathbf b = |\\mathbf a| \\cos \\theta \\cdot |\\mathbf b|$.</p> <p>The dot product holds some notable properties:</p> <ol> <li>$\\mathbf a \\cdot \\mathbf b = \\mathbf b \\cdot \\mathbf a$</li> <li>$(\\alpha \\cdot \\mathbf a)\\cdot \\mathbf b = \\alpha \\cdot (\\mathbf a \\cdot \\mathbf b)$</li> <li>$(\\mathbf a + \\mathbf b)\\cdot \\mathbf c = \\mathbf a \\cdot \\mathbf c + \\mathbf b \\cdot \\mathbf c$</li> </ol> <p>I.e. it is a commutative function which is linear with respect to both arguments. Let's denote the unit vectors as</p> $$\\mathbf e_x = \\begin{pmatrix} 1 \\\\ 0 \\\\ 0 \\end{pmatrix}, \\mathbf e_y = \\begin{pmatrix} 0 \\\\ 1 \\\\ 0 \\end{pmatrix}, \\mathbf e_z = \\begin{pmatrix} 0 \\\\ 0 \\\\ 1 \\end{pmatrix}.$$ <p>With this notation we can write the vector $\\mathbf r = (x;y;z)$ as $r = x \\cdot \\mathbf e_x + y \\cdot \\mathbf e_y + z \\cdot \\mathbf e_z$. And since for unit vectors </p> $$\\mathbf e_x\\cdot \\mathbf e_x = \\mathbf e_y\\cdot \\mathbf e_y = \\mathbf e_z\\cdot \\mathbf e_z = 1,\\\\ \\mathbf e_x\\cdot \\mathbf e_y = \\mathbf e_y\\cdot \\mathbf e_z = \\mathbf e_z\\cdot \\mathbf e_x = 0$$ <p>we can see that in terms of coordinates for $\\mathbf a = (x_1;y_1;z_1)$ and $\\mathbf b = (x_2;y_2;z_2)$ holds</p> $$\\mathbf a\\cdot \\mathbf b = (x_1 \\cdot \\mathbf e_x + y_1 \\cdot\\mathbf e_y + z_1 \\cdot\\mathbf e_z)\\cdot( x_2 \\cdot\\mathbf e_x + y_2 \\cdot\\mathbf e_y + z_2 \\cdot\\mathbf e_z) = x_1 x_2 + y_1 y_2 + z_1 z_2$$ <p>That is also the algebraic definition of the dot product. From this we can write functions which calculate it.</p> <pre><code>ftype dot(point2d a, point2d b) {\n    return a.x * b.x + a.y * b.y;\n}\nftype dot(point3d a, point3d b) {\n    return a.x * b.x + a.y * b.y + a.z * b.z;\n}\n</code></pre> <p>When solving problems one should use algebraic definition to calculate dot products, but keep in mind geometric definition and properties to use it.</p>","tags":["Original"]},{"location":"geometry/basic-geometry.html#properties","title":"Properties","text":"<p>We can define many geometrical properties via the dot product. For example </p> <ol> <li>Norm of $\\mathbf a$ (squared length): $|\\mathbf a|^2 = \\mathbf a\\cdot \\mathbf a$</li> <li>Length of $\\mathbf a$: $|\\mathbf a| = \\sqrt{\\mathbf a\\cdot \\mathbf a}$</li> <li>Projection of $\\mathbf a$ onto $\\mathbf b$: $\\dfrac{\\mathbf a\\cdot\\mathbf b}{|\\mathbf b|}$</li> <li>Angle between vectors: $\\arccos \\left(\\dfrac{\\mathbf a\\cdot \\mathbf b}{|\\mathbf a| \\cdot |\\mathbf b|}\\right)$</li> <li>From the previous point we may see that the dot product is positive if the angle between them is acute, negative if it is obtuse and it equals zero if they are orthogonal, i.e. they form a right angle.</li> </ol> <p>Note that all these functions do not depend on the number of dimensions, hence they will be the same for the 2D and 3D case:</p> <pre><code>ftype norm(point2d a) {\n    return dot(a, a);\n}\ndouble abs(point2d a) {\n    return sqrt(norm(a));\n}\ndouble proj(point2d a, point2d b) {\n    return dot(a, b) / abs(b);\n}\ndouble angle(point2d a, point2d b) {\n    return acos(dot(a, b) / abs(a) / abs(b));\n}\n</code></pre> <p>To see the next important property we should take a look at the set of points $\\mathbf r$ for which $\\mathbf r\\cdot \\mathbf a = C$ for some fixed constant $C$. You can see that this set of points is exactly the set of points for which the projection onto $\\mathbf a$ is the point $C \\cdot \\dfrac{\\mathbf a}{|\\mathbf a| ^ 2}$ and they form a hyperplane orthogonal to $\\mathbf a$. You can see the vector $\\mathbf a$ alongside with several such vectors having same dot product with it in 2D on the picture below:</p> <p>In 2D these vectors will form a line, in 3D they will form a plane. Note that this result allows us to define a line in 2D as $\\mathbf r\\cdot \\mathbf n=C$ or $(\\mathbf r - \\mathbf r_0)\\cdot \\mathbf n=0$ where $\\mathbf n$ is vector orthogonal to the line and $\\mathbf r_0$ is any vector already present on the line and $C = \\mathbf r_0\\cdot \\mathbf n$. In the same manner a plane can be defined in 3D.</p>","tags":["Original"]},{"location":"geometry/basic-geometry.html#cross-product","title":"Cross product","text":"","tags":["Original"]},{"location":"geometry/basic-geometry.html#definition_1","title":"Definition","text":"<p>Assume you have three vectors $\\mathbf a$, $\\mathbf b$ and $\\mathbf c$ in 3D space joined in a parallelepiped as in the picture below:</p> <p>How would you calculate its volume? From school we know that we should multiply the area of the base with the height, which is projection of $\\mathbf a$ onto direction orthogonal to base. That means that if we define $\\mathbf b \\times \\mathbf c$ as the vector which is orthogonal to both $\\mathbf b$ and $\\mathbf c$ and which length is equal to the area of the parallelogram formed by $\\mathbf b$ and $\\mathbf c$ then $|\\mathbf a\\cdot (\\mathbf b\\times\\mathbf c)|$ will be equal to the volume of the parallelepiped. For integrity we will say that $\\mathbf b\\times \\mathbf c$ will be always directed in such way that the rotation from the vector $\\mathbf b$ to the vector $\\mathbf c$ from the point of $\\mathbf b\\times \\mathbf c$ is always counter-clockwise (see the picture below).</p> <p>This defines the cross (or vector) product $\\mathbf b\\times \\mathbf c$ of the vectors $\\mathbf b$ and $\\mathbf c$ and the triple product $\\mathbf a\\cdot(\\mathbf b\\times \\mathbf c)$ of the vectors $\\mathbf a$, $\\mathbf b$ and $\\mathbf c$.</p> <p>Some notable properties of cross and triple products:</p> <ol> <li>$\\mathbf a\\times \\mathbf b = -\\mathbf b\\times \\mathbf a$</li> <li>$(\\alpha \\cdot \\mathbf a)\\times \\mathbf b = \\alpha \\cdot (\\mathbf a\\times \\mathbf b)$</li> <li>For any $\\mathbf b$ and $\\mathbf c$ there is exactly one vector $\\mathbf r$ such that $\\mathbf a\\cdot (\\mathbf b\\times \\mathbf c) = \\mathbf a\\cdot\\mathbf r$ for any vector $\\mathbf a$. Indeed if there are two such vectors $\\mathbf r_1$ and $\\mathbf r_2$ then $\\mathbf a\\cdot (\\mathbf r_1 - \\mathbf r_2)=0$ for all vectors $\\mathbf a$ which is possible only when $\\mathbf r_1 = \\mathbf r_2$.</li> <li>$\\mathbf a\\cdot (\\mathbf b\\times \\mathbf c) = \\mathbf b\\cdot (\\mathbf c\\times \\mathbf a) = -\\mathbf a\\cdot( \\mathbf c\\times \\mathbf b)$</li> <li> <p>$(\\mathbf a + \\mathbf b)\\times \\mathbf c = \\mathbf a\\times \\mathbf c + \\mathbf b\\times \\mathbf c$.     Indeed for all vectors $\\mathbf r$ the chain of equations holds:</p> $$\\mathbf r\\cdot( (\\mathbf a + \\mathbf b)\\times \\mathbf c) = (\\mathbf a + \\mathbf b) \\cdot (\\mathbf c\\times \\mathbf r) =  \\mathbf a \\cdot(\\mathbf c\\times \\mathbf r) + \\mathbf b\\cdot(\\mathbf c\\times \\mathbf r) = \\mathbf r\\cdot (\\mathbf a\\times \\mathbf c) + \\mathbf r\\cdot(\\mathbf b\\times \\mathbf c) = \\mathbf r\\cdot(\\mathbf a\\times \\mathbf c + \\mathbf b\\times \\mathbf c)$$ <p>Which proves $(\\mathbf a + \\mathbf b)\\times \\mathbf c = \\mathbf a\\times \\mathbf c + \\mathbf b\\times \\mathbf c$ due to point 3.</p> </li> <li> <p>$|\\mathbf a\\times \\mathbf b|=|\\mathbf a| \\cdot |\\mathbf b| \\sin \\theta$ where $\\theta$ is angle between $\\mathbf a$ and $\\mathbf b$, since $|\\mathbf a\\times \\mathbf b|$ equals to the area of the parallelogram formed by $\\mathbf a$ and $\\mathbf b$. </p> </li> </ol> <p>Given all this and that the following equation holds for the unit vectors</p> $$\\mathbf e_x\\times \\mathbf e_x = \\mathbf e_y\\times \\mathbf e_y = \\mathbf e_z\\times \\mathbf e_z = \\mathbf 0,\\\\ \\mathbf e_x\\times \\mathbf e_y = \\mathbf e_z,~\\mathbf e_y\\times \\mathbf e_z = \\mathbf e_x,~\\mathbf e_z\\times \\mathbf e_x = \\mathbf e_y$$ <p>we can calculate the cross product of $\\mathbf a = (x_1;y_1;z_1)$ and $\\mathbf b = (x_2;y_2;z_2)$ in coordinate form:</p> $$\\mathbf a\\times \\mathbf b = (x_1 \\cdot \\mathbf e_x + y_1 \\cdot \\mathbf e_y + z_1 \\cdot \\mathbf e_z)\\times (x_2 \\cdot \\mathbf e_x + y_2 \\cdot \\mathbf e_y + z_2 \\cdot \\mathbf e_z) =$$ $$(y_1 z_2 - z_1 y_2)\\mathbf e_x  + (z_1 x_2 - x_1 z_2)\\mathbf e_y + (x_1 y_2 - y_1 x_2)$$ <p>Which also can be written in the more elegant form:</p> $$\\mathbf a\\times \\mathbf b = \\begin{vmatrix}\\mathbf e_x &amp; \\mathbf e_y &amp; \\mathbf e_z \\\\ x_1 &amp; y_1 &amp; z_1 \\\\ x_2 &amp; y_2 &amp; z_2 \\end{vmatrix},~a\\cdot(b\\times c) = \\begin{vmatrix} x_1 &amp; y_1 &amp; z_1 \\\\ x_2 &amp; y_2 &amp; z_2 \\\\ x_3 &amp; y_3 &amp; z_3 \\end{vmatrix}$$ <p>Here $| \\cdot |$ stands for the determinant of a matrix. </p> <p>Some kind of cross product (namely the pseudo-scalar product) can also be implemented in the 2D case. If we would like to calculate the area of parallelogram formed by vectors $\\mathbf a$ and $\\mathbf b$ we would compute $|\\mathbf e_z\\cdot(\\mathbf a\\times \\mathbf b)| = |x_1 y_2 - y_1 x_2|$. Another way to obtain the same result is to multiply $|\\mathbf a|$ (base of parallelogram) with the height, which is the projection of vector $\\mathbf b$ onto vector $\\mathbf a$ rotated by $90^\\circ$ which in turn is $\\widehat{\\mathbf a}=(-y_1;x_1)$. That is, to calculate $|\\widehat{\\mathbf a}\\cdot\\mathbf b|=|x_1y_2 - y_1 x_2|$. </p> <p>If we will take the sign into consideration then the area will be positive if the rotation from $\\mathbf a$ to $\\mathbf b$ (i.e. from the view of the point of $\\mathbf e_z$) is performed counter-clockwise and negative otherwise. That defines the pseudo-scalar product. Note that it also equals $|\\mathbf a| \\cdot |\\mathbf b| \\sin \\theta$ where $\\theta$ is angle from $\\mathbf a$ to $\\mathbf b$ count counter-clockwise (and negative if rotation is clockwise).</p> <p>Let's implement all this stuff!</p> <pre><code>point3d cross(point3d a, point3d b) {\n    return point3d(a.y * b.z - a.z * b.y,\n                   a.z * b.x - a.x * b.z,\n                   a.x * b.y - a.y * b.x);\n}\nftype triple(point3d a, point3d b, point3d c) {\n    return dot(a, cross(b, c));\n}\nftype cross(point2d a, point2d b) {\n    return a.x * b.y - a.y * b.x;\n}\n</code></pre>","tags":["Original"]},{"location":"geometry/basic-geometry.html#properties_1","title":"Properties","text":"<p>As for the cross product, it equals to the zero vector iff the vectors $\\mathbf a$ and $\\mathbf b$ are collinear (they form a common line, i.e. they are parallel). The same thing holds for the triple product, it is equal to zero iff the vectors $\\mathbf a$, $\\mathbf b$ and $\\mathbf c$ are coplanar (they form a common plane).</p> <p>From this we can obtain universal equations defining lines and planes. A line can be defined via its direction vector $\\mathbf d$ and an initial point $\\mathbf r_0$ or by two points $\\mathbf a$ and $\\mathbf b$. It is defined as $(\\mathbf r - \\mathbf r_0)\\times\\mathbf d=0$ or as $(\\mathbf r - \\mathbf a)\\times (\\mathbf b - \\mathbf a) = 0$. As for planes, it can be defined by three points $\\mathbf a$, $\\mathbf b$ and $\\mathbf c$ as $(\\mathbf r - \\mathbf a)\\cdot((\\mathbf b - \\mathbf a)\\times (\\mathbf c - \\mathbf a))=0$ or by initial point $\\mathbf r_0$ and two direction vectors lying in this plane $\\mathbf d_1$ and $\\mathbf d_2$: $(\\mathbf r - \\mathbf r_0)\\cdot(\\mathbf d_1\\times \\mathbf d_2)=0$.</p> <p>In 2D the pseudo-scalar product also may be used to check the orientation between two vectors because it is positive if the rotation from the first to the second vector is clockwise and negative otherwise. And, of course, it can be used to calculate areas of polygons, which is described in a different article. A triple product can be used for the same purpose in 3D space.</p>","tags":["Original"]},{"location":"geometry/basic-geometry.html#exercises","title":"Exercises","text":"","tags":["Original"]},{"location":"geometry/basic-geometry.html#line-intersection","title":"Line intersection","text":"<p>There are many possible ways to define a line in 2D and you shouldn't hesitate to combine them. For example we have two lines and we want to find their intersection points. We can say that all points from first line can be parameterized as $\\mathbf r = \\mathbf a_1 + t \\cdot \\mathbf d_1$ where $\\mathbf a_1$ is initial point, $\\mathbf d_1$ is direction and $t$ is some real parameter. As for second line all its points must satisfy $(\\mathbf r - \\mathbf a_2)\\times \\mathbf d_2=0$. From this we can easily find parameter $t$:</p> $$(\\mathbf a_1 + t \\cdot \\mathbf d_1 - \\mathbf a_2)\\times \\mathbf d_2=0 \\quad\\Rightarrow\\quad t = \\dfrac{(\\mathbf a_2 - \\mathbf a_1)\\times\\mathbf d_2}{\\mathbf d_1\\times \\mathbf d_2}$$ <p>Let's implement function to intersect two lines.</p> <pre><code>point2d intersect(point2d a1, point2d d1, point2d a2, point2d d2) {\n    return a1 + cross(a2 - a1, d2) / cross(d1, d2) * d1;\n}\n</code></pre>","tags":["Original"]},{"location":"geometry/basic-geometry.html#planes-intersection","title":"Planes intersection","text":"<p>However sometimes it might be hard to use some geometric insights. For example, you're given three planes defined by initial points $\\mathbf a_i$ and directions $\\mathbf d_i$ and you want to find their intersection point. You may note that you just have to solve the system of equations:</p> $$\\begin{cases}\\mathbf r\\cdot \\mathbf n_1 = \\mathbf a_1\\cdot \\mathbf n_1, \\\\ \\mathbf r\\cdot \\mathbf n_2 = \\mathbf a_2\\cdot \\mathbf n_2, \\\\ \\mathbf r\\cdot \\mathbf n_3 = \\mathbf a_3\\cdot \\mathbf n_3\\end{cases}$$ <p>Instead of thinking on geometric approach, you can work out an algebraic one which can be obtained immediately. For example, given that you already implemented a point class, it will be easy for you to solve this system using Cramer's rule because the triple product is simply the determinant of the matrix obtained from the vectors being its columns:</p> <pre><code>point3d intersect(point3d a1, point3d n1, point3d a2, point3d n2, point3d a3, point3d n3) {\n    point3d x(n1.x, n2.x, n3.x);\n    point3d y(n1.y, n2.y, n3.y);\n    point3d z(n1.z, n2.z, n3.z); \n    point3d d(dot(a1, n1), dot(a2, n2), dot(a3, n3));\n    return point3d(triple(d, y, z),\n                   triple(x, d, z),\n                   triple(x, y, d)) / triple(n1, n2, n3);\n}\n</code></pre> <p>Now you may try to find out approaches for common geometric operations yourself to get used to all this stuff.</p>","tags":["Original"]},{"location":"geometry/check-segments-intersection.html","title":"Check if two segments intersect","text":"<p>You are given two segments $(a, b)$ and $(c, d)$. You have to check if they intersect. Of course, you may find their intersection and check if it isn't empty, but this can't be done in integers for segments with integer coordinates. The approach described here can work in integers.</p>","tags":["Translated"]},{"location":"geometry/check-segments-intersection.html#algorithm","title":"Algorithm","text":"<p>Firstly, consider the case when the segments are part of the same line. In this case it is sufficient to check if their projections on $Ox$ and $Oy$ intersect. In the other case $a$ and $b$ must not lie on the same side of line $(c, d)$, and $c$ and $d$ must not lie on the same side of line $(a, b)$. It can be checked with a couple of cross products.</p>","tags":["Translated"]},{"location":"geometry/check-segments-intersection.html#implementation","title":"Implementation","text":"<p>The given algorithm is implemented for integer points. Of course, it can be easily modified to work with doubles.</p> <pre><code>struct pt {\n    long long x, y;\n    pt() {}\n    pt(long long _x, long long _y) : x(_x), y(_y) {}\n    pt operator-(const pt&amp; p) const { return pt(x - p.x, y - p.y); }\n    long long cross(const pt&amp; p) const { return x * p.y - y * p.x; }\n    long long cross(const pt&amp; a, const pt&amp; b) const { return (a - *this).cross(b - *this); }\n};\n\nint sgn(const long long&amp; x) { return x &gt;= 0 ? x ? 1 : 0 : -1; }\n\nbool inter1(long long a, long long b, long long c, long long d) {\n    if (a &gt; b)\n        swap(a, b);\n    if (c &gt; d)\n        swap(c, d);\n    return max(a, c) &lt;= min(b, d);\n}\n\nbool check_inter(const pt&amp; a, const pt&amp; b, const pt&amp; c, const pt&amp; d) {\n    if (c.cross(a, d) == 0 &amp;&amp; c.cross(b, d) == 0)\n        return inter1(a.x, b.x, c.x, d.x) &amp;&amp; inter1(a.y, b.y, c.y, d.y);\n    return sgn(a.cross(b, c)) != sgn(a.cross(b, d)) &amp;&amp;\n           sgn(c.cross(d, a)) != sgn(c.cross(d, b));\n}\n</code></pre>","tags":["Translated"]},{"location":"geometry/circle-circle-intersection.html","title":"Circle-Circle Intersection","text":"<p>You are given two circles on a 2D plane, each one described as coordinates of its center and its radius. Find the points of their intersection (possible cases: one or two points, no intersection or circles coincide).</p>","tags":["Translated"]},{"location":"geometry/circle-circle-intersection.html#solution","title":"Solution","text":"<p>Let's reduce this problem to the circle-line intersection problem.</p> <p>Assume without loss of generality that the first circle is centered at the origin (if this is not true, we can move the origin to the center of the first circle and adjust the coordinates of intersection points accordingly at output time). We have a system of two equations:</p> $$x^2+y^2=r_1^2$$ $$(x - x_2)^2 + (y - y_2)^2 = r_2^2$$ <p>Subtract the first equation from the second one to get rid of the second powers of variables:</p> $$x^2+y^2=r_1^2$$ $$x \\cdot (-2x_2) + y \\cdot (-2y_2) + (x_2^2+y_2^2+r_1^2-r_2^2) = 0$$ <p>Thus, we've reduced the original problem to the problem of finding intersections of the first circle and a line:</p> $$Ax + By + C = 0$$ $$\\begin{align} A &amp;= -2x_2 \\\\ B &amp;= -2y_2 \\\\ C &amp;= x_2^2+y_2^2+r_1^2-r_2^2 \\end{align}$$ <p>And this problem can be solved as described in the corresponding article.</p> <p>The only degenerate case we need to consider separately is when the centers of the circles coincide. In this case $x_2=y_2=0$, and the line equation will be $C = r_1^2-r_2^2 = 0$. If the radii of the circles are the same, there are infinitely many intersection points, if they differ, there are no intersections.</p>","tags":["Translated"]},{"location":"geometry/circle-circle-intersection.html#practice-problems","title":"Practice Problems","text":"<ul> <li>RadarFinder</li> <li>Runaway to a shadow - Codeforces Round #357</li> <li>ASC 1 Problem F \"Get out!\"</li> <li>SPOJ: CIRCINT</li> <li>UVA - 10301 - Rings and Glue</li> <li>Codeforces 933C A Colorful Prospect</li> <li>TIMUS 1429 Biscuits</li> </ul>","tags":["Translated"]},{"location":"geometry/circle-line-intersection.html","title":"Circle-Line Intersection","text":"<p>Given the coordinates of the center of a circle and its radius, and the equation of a line, you're required to find the points of intersection.</p>","tags":["Translated"]},{"location":"geometry/circle-line-intersection.html#solution","title":"Solution","text":"<p>Instead of solving the system of two equations, we will approach the problem geometrically. This way we get a more accurate solution from the point of view of numerical stability.</p> <p>We assume without loss of generality that the circle is centered at the origin. If it's not, we translate it there and correct the $C$ constant in the line equation. So we have a circle centered at $(0,0)$ of radius $r$ and a line with equation $Ax+By+C=0$.</p> <p>Let's start by find the point on the line which is closest to the origin $(x_0, y_0)$. First, it has to be at a distance</p> $$ d_0 = \\frac{|C|}{\\sqrt{A^2+B^2}} $$ <p>Second, since the vector $(A, B)$ is perpendicular to the line, the coordinates of the point must be proportional to the coordinates of this vector. Since we know the distance of the point to the origin, we just need to scale the vector $(A, B)$ to this length, and we'll get:</p> $$\\begin{align} x_0 &amp;= - \\frac{AC}{A^2 + B^2} \\\\ y_0 &amp;= - \\frac{BC}{A^2 + B^2}  \\end{align}$$ <p>The minus signs are not obvious, but they can be easily verified by substituting $x_0$ and $y_0$ in the equation of the line.</p> <p>At this stage we can determine the number of intersection points, and even find the solution when there is one or zero points. Indeed, if the distance from $(x_0, y_0)$ to the origin $d_0$ is greater than the radius $r$, the answer is zero points. If $d_0=r$, the answer is one point $(x_0, y_0)$. If $d_0&lt;r$, there are two points of intersection, and now we have to find their coordinates.</p> <p>So, we know that the point $(x_0, y_0)$ is inside the circle. The two points of intersection, $(a_x, a_y)$ and $(b_x, b_y)$, must belong to the line $Ax+By+C=0$ and must be at the same distance $d$ from $(x_0, y_0)$, and this distance is easy to find:</p> $$ d = \\sqrt{r^2 - \\frac{C^2}{A^2 + B^2}} $$ <p>Note that the vector $(-B, A)$ is collinear to the line, and thus we can find the points in question by adding and subtracting  vector $(-B,A)$, scaled to the length $d$, to the point $(x_0, y_0)$. </p> <p>Finally, the equations of the two points of intersection are:</p> $$\\begin{align} m &amp;= \\sqrt{\\frac{d^2}{A^2 + B^2}} \\\\ a_x &amp;= x_0 + B \\cdot m, a_y = y_0 - A \\cdot m \\\\ b_x &amp;= x_0 - B \\cdot m, b_y = y_0 + A \\cdot m \\end{align}$$ <p>Had we solved the original system of equations using algebraic methods, we would likely get an answer in a different form with a larger error. The geometric method described here is more graphic and more accurate.</p>","tags":["Translated"]},{"location":"geometry/circle-line-intersection.html#implementation","title":"Implementation","text":"<p>As indicated at the outset, we assume that the circle is centered at the origin, and therefore the input to the program is the radius $r$ of the circle and the parameters $A$, $B$ and $C$ of the equation of the line.</p> <pre><code>double r, a, b, c; // given as input\ndouble x0 = -a*c/(a*a+b*b), y0 = -b*c/(a*a+b*b);\nif (c*c &gt; r*r*(a*a+b*b)+EPS)\n    puts (\"no points\");\nelse if (abs (c*c - r*r*(a*a+b*b)) &lt; EPS) {\n    puts (\"1 point\");\n    cout &lt;&lt; x0 &lt;&lt; ' ' &lt;&lt; y0 &lt;&lt; '\\n';\n}\nelse {\n    double d = r*r - c*c/(a*a+b*b);\n    double mult = sqrt (d / (a*a+b*b));\n    double ax, ay, bx, by;\n    ax = x0 + b * mult;\n    bx = x0 - b * mult;\n    ay = y0 - a * mult;\n    by = y0 + a * mult;\n    puts (\"2 points\");\n    cout &lt;&lt; ax &lt;&lt; ' ' &lt;&lt; ay &lt;&lt; '\\n' &lt;&lt; bx &lt;&lt; ' ' &lt;&lt; by &lt;&lt; '\\n';\n}\n</code></pre>","tags":["Translated"]},{"location":"geometry/circle-line-intersection.html#practice-problems","title":"Practice Problems","text":"<ul> <li>CODECHEF: ANDOOR</li> </ul>","tags":["Translated"]},{"location":"geometry/convex-hull.html","title":"Convex Hull construction","text":"<p>In this article we will discuss the problem of constructing a convex hull from a set of points.</p> <p>Consider $N$ points given on a plane, and the objective is to generate a convex hull, i.e. the smallest convex polygon that contains all the given points.</p> <p>We will see the Graham's scan algorithm published in 1972 by Graham, and also the Monotone chain algorithm published in 1979 by Andrew. Both are $\\mathcal{O}(N \\log N)$, and are asymptotically optimal (as it is proven that there is no algorithm asymptotically better), with the exception of a few problems where parallel or online processing is involved.</p>","tags":["Translated"]},{"location":"geometry/convex-hull.html#grahams-scan-algorithm","title":"Graham's scan Algorithm","text":"<p>The algorithm first finds the bottom-most point $P_0$. If there are multiple points with the same Y coordinate, the one with the smaller X coordinate is considered. This step takes $\\mathcal{O}(N)$ time.</p> <p>Next, all the other points are sorted by polar angle in clockwise order. If the polar angle between two or more points is the same, the tie should be broken by distance from $P_0$, in increasing order.</p> <p>Then we iterate through each point one by one, and make sure that the current point and the two before it make a clockwise turn, otherwise the previous point is discarded, since it would make a non-convex shape. Checking for clockwise or anticlockwise nature can be done by checking the orientation.</p> <p>We use a stack to store the points, and once we reach the original point $P_0$, the algorithm is done and we return the stack containing all the points of the convex hull in clockwise order.</p> <p>If you need to include the collinear points while doing a Graham scan, you need another step after sorting. You need to get the points that have the biggest polar distance from $P_0$ (these should be at the end of the sorted vector) and are collinear. The points in this line should be reversed so that we can output all the collinear points, otherwise the algorithm would get the nearest point in this line and bail. This step shouldn't be included in the non-collinear version of the algorithm, otherwise you wouldn't get the smallest convex hull.</p>","tags":["Translated"]},{"location":"geometry/convex-hull.html#implementation","title":"Implementation","text":"<pre><code>struct pt {\n    double x, y;\n    bool operator == (pt const&amp; t) const {\n        return x == t.x &amp;&amp; y == t.y;\n    }\n};\n\nint orientation(pt a, pt b, pt c) {\n    double v = a.x*(b.y-c.y)+b.x*(c.y-a.y)+c.x*(a.y-b.y);\n    if (v &lt; 0) return -1; // clockwise\n    if (v &gt; 0) return +1; // counter-clockwise\n    return 0;\n}\n\nbool cw(pt a, pt b, pt c, bool include_collinear) {\n    int o = orientation(a, b, c);\n    return o &lt; 0 || (include_collinear &amp;&amp; o == 0);\n}\nbool collinear(pt a, pt b, pt c) { return orientation(a, b, c) == 0; }\n\nvoid convex_hull(vector&lt;pt&gt;&amp; a, bool include_collinear = false) {\n    pt p0 = *min_element(a.begin(), a.end(), [](pt a, pt b) {\n        return make_pair(a.y, a.x) &lt; make_pair(b.y, b.x);\n    });\n    sort(a.begin(), a.end(), [&amp;p0](const pt&amp; a, const pt&amp; b) {\n        int o = orientation(p0, a, b);\n        if (o == 0)\n            return (p0.x-a.x)*(p0.x-a.x) + (p0.y-a.y)*(p0.y-a.y)\n                &lt; (p0.x-b.x)*(p0.x-b.x) + (p0.y-b.y)*(p0.y-b.y);\n        return o &lt; 0;\n    });\n    if (include_collinear) {\n        int i = (int)a.size()-1;\n        while (i &gt;= 0 &amp;&amp; collinear(p0, a[i], a.back())) i--;\n        reverse(a.begin()+i+1, a.end());\n    }\n\n    vector&lt;pt&gt; st;\n    for (int i = 0; i &lt; (int)a.size(); i++) {\n        while (st.size() &gt; 1 &amp;&amp; !cw(st[st.size()-2], st.back(), a[i], include_collinear))\n            st.pop_back();\n        st.push_back(a[i]);\n    }\n\n    if (include_collinear == false &amp;&amp; st.size() == 2 &amp;&amp; st[0] == st[1])\n        st.pop_back();\n\n    a = st;\n}\n</code></pre>","tags":["Translated"]},{"location":"geometry/convex-hull.html#monotone-chain-algorithm","title":"Monotone chain Algorithm","text":"<p>The algorithm first finds the leftmost and rightmost points A and B. In the event multiple such points exist, the lowest among the left (lowest Y-coordinate) is taken as A, and the highest among the right (highest Y-coordinate) is taken as B. Clearly, A and B must both belong to the convex hull as they are the farthest away and they cannot be contained by any line formed by a pair among the given points.</p> <p>Now, draw a line through AB. This divides all the other points into two sets, S1 and S2, where S1 contains all the points above the line connecting A and B, and S2 contains all the points below the line joining A and B. The points that lie on the line joining A and B may belong to either set. The points A and B belong to both sets. Now the algorithm constructs the upper set S1 and the lower set S2 and then combines them to obtain the answer. </p> <p>To get the upper set, we sort all points by the x-coordinate. For each point we check if either - the current point is the last point, (which we defined as B), or if the orientation between the line between A and the current point and the line between the current point and B is clockwise. In those cases the  current point belongs to the upper set S1. Checking for clockwise or anticlockwise nature can be done by checking the orientation.</p> <p>If the given point belongs to the upper set, we check the angle made by the line connecting the second last point and the last point in the upper convex hull, with the line connecting the last point in the upper convex hull and the current point. If the angle is not clockwise, we remove the most recent point added to the upper convex hull as the current point will be able to contain the previous point once it is added to the convex hull.</p> <p>The same logic applies for the lower set S2. If either - the current point is B, or the orientation of the lines, formed by A and the  current point and the current point and B, is counterclockwise - then it belongs to S2.</p> <p>If the given point belongs to the lower set, we act similarly as for a point on the upper set except we check for a counterclockwise orientation instead of a clockwise orientation. Thus, if the angle made by the line connecting the second last point and the last point in the lower convex hull, with the line connecting the last point in the lower convex hull and the current point is not counterclockwise, we remove the most recent point added to the lower convex hull as the current point will be able to contain the previous point once added to the hull.</p> <p>The final convex hull is obtained from the union of the upper and lower convex hull, forming a clockwise hull, and the implementation is as follows.</p> <p>If you need collinear points, you just need to check for them in the clockwise/counterclockwise routines. However, this allows for a degenerate case where all the input points are collinear in a single line, and the algorithm would output repeated points. To solve this, we check whether the upper hull contains all the points, and if it does, we just return the points in reverse, as that is what Graham's implementation would return in this case.</p>","tags":["Translated"]},{"location":"geometry/convex-hull.html#implementation_1","title":"Implementation","text":"<pre><code>struct pt {\n    double x, y;\n};\n\nint orientation(pt a, pt b, pt c) {\n    double v = a.x*(b.y-c.y)+b.x*(c.y-a.y)+c.x*(a.y-b.y);\n    if (v &lt; 0) return -1; // clockwise\n    if (v &gt; 0) return +1; // counter-clockwise\n    return 0;\n}\n\nbool cw(pt a, pt b, pt c, bool include_collinear) {\n    int o = orientation(a, b, c);\n    return o &lt; 0 || (include_collinear &amp;&amp; o == 0);\n}\nbool ccw(pt a, pt b, pt c, bool include_collinear) {\n    int o = orientation(a, b, c);\n    return o &gt; 0 || (include_collinear &amp;&amp; o == 0);\n}\n\nvoid convex_hull(vector&lt;pt&gt;&amp; a, bool include_collinear = false) {\n    if (a.size() == 1)\n        return;\n\n    sort(a.begin(), a.end(), [](pt a, pt b) {\n        return make_pair(a.x, a.y) &lt; make_pair(b.x, b.y);\n    });\n    pt p1 = a[0], p2 = a.back();\n    vector&lt;pt&gt; up, down;\n    up.push_back(p1);\n    down.push_back(p1);\n    for (int i = 1; i &lt; (int)a.size(); i++) {\n        if (i == a.size() - 1 || cw(p1, a[i], p2, include_collinear)) {\n            while (up.size() &gt;= 2 &amp;&amp; !cw(up[up.size()-2], up[up.size()-1], a[i], include_collinear))\n                up.pop_back();\n            up.push_back(a[i]);\n        }\n        if (i == a.size() - 1 || ccw(p1, a[i], p2, include_collinear)) {\n            while (down.size() &gt;= 2 &amp;&amp; !ccw(down[down.size()-2], down[down.size()-1], a[i], include_collinear))\n                down.pop_back();\n            down.push_back(a[i]);\n        }\n    }\n\n    if (include_collinear &amp;&amp; up.size() == a.size()) {\n        reverse(a.begin(), a.end());\n        return;\n    }\n    a.clear();\n    for (int i = 0; i &lt; (int)up.size(); i++)\n        a.push_back(up[i]);\n    for (int i = down.size() - 2; i &gt; 0; i--)\n        a.push_back(down[i]);\n}\n</code></pre>","tags":["Translated"]},{"location":"geometry/convex-hull.html#practice-problems","title":"Practice Problems","text":"<ul> <li>Kattis - Convex Hull</li> <li>Kattis - Keep the Parade Safe</li> <li>Latin American Regionals 2006 - Onion Layers</li> <li>Timus 1185: Wall</li> <li>Usaco 2014 January Contest, Gold - Cow Curling</li> </ul>","tags":["Translated"]},{"location":"geometry/convex_hull_trick.html","title":"Convex hull trick and Li Chao tree","text":"<p>Consider the following problem. There are $n$ cities. You want to travel from city $1$ to city $n$ by car. To do this you have to buy some gasoline. It is known that a liter of gasoline costs $cost_k$ in the $k^{th}$ city. Initially your fuel tank is empty and you spend one liter of gasoline per kilometer. Cities are located on the same line in ascending order with $k^{th}$ city having coordinate $x_k$. Also you have to pay $toll_k$ to enter $k^{th}$ city. Your task is to make the trip with minimum possible cost. It's obvious that the solution can be calculated via dynamic programming:</p> $$dp_i = toll_i+\\min\\limits_{j&lt;i}(cost_j \\cdot (x_i - x_j)+dp_j)$$ <p>Naive approach will give you $O(n^2)$ complexity which can be improved to $O(n \\log n)$ or $O(n \\log [C \\varepsilon^{-1}])$ where $C$ is largest possible $|x_i|$ and $\\varepsilon$ is precision with which $x_i$ is considered ($\\varepsilon = 1$ for integers which is usually the case). To do this one should note that the problem can be reduced to adding linear functions $k \\cdot x + b$ to the set and finding minimum value of the functions in some particular point $x$. There are two main approaches one can use here.</p>","tags":["Original"]},{"location":"geometry/convex_hull_trick.html#convex-hull-trick","title":"Convex hull trick","text":"<p>The idea of this approach is to maintain a lower convex hull of linear functions. Actually it would be a bit more convenient to consider them not as linear functions, but as points $(k;b)$ on the plane such that we will have to find the point which has the least dot product with a given point $(x;1)$, that is, for this point $kx+b$ is minimized which is the same as initial problem. Such minimum will necessarily be on lower convex envelope of these points as can be seen below:</p> <p> </p> <p>One has to keep points on the convex hull and normal vectors of the hull's edges. When you have a $(x;1)$ query you'll have to find the normal vector closest to it in terms of angles between them, then the optimum linear function will correspond to one of its endpoints. To see that, one should note that points having a constant dot product with $(x;1)$ lie on a line which is orthogonal to $(x;1)$, so the optimum linear function will be the one in which tangent to convex hull which is collinear with normal to $(x;1)$ touches the hull. This point is the one such that normals of edges lying to the left and to the right of it are headed in different sides of $(x;1)$.</p> <p>This approach is useful when queries of adding linear functions are monotone in terms of $k$ or if we work offline, i.e. we may firstly add all linear functions and answer queries afterwards. So we cannot solve the cities/gasoline problems using this way. That would require handling online queries. When it comes to deal with online queries however, things will go tough and one will have to use some kind of set data structure to implement a proper convex hull. Online approach will however not be considered in this article due to its hardness and because second approach (which is Li Chao tree) allows to solve the problem way more simply. Worth mentioning that one can still use this approach online without complications by square-root-decomposition. That is, rebuild convex hull from scratch each $\\sqrt n$ new lines. </p> <p>To implement this approach one should begin with some geometric utility functions, here we suggest to use the C++ complex number type.</p> <pre><code>typedef int ftype;\ntypedef complex&lt;ftype&gt; point;\n#define x real\n#define y imag\n\nftype dot(point a, point b) {\n    return (conj(a) * b).x();\n}\n\nftype cross(point a, point b) {\n    return (conj(a) * b).y();\n}\n</code></pre> <p>Here we will assume that when linear functions are added, their $k$ only increases and we want to find minimum values. We will keep points in vector $hull$ and normal vectors in vector $vecs$. When we add a new point, we have to look at the angle formed between last edge in convex hull and vector from last point in convex hull to new point. This angle has to be directed counter-clockwise, that is the dot product of the last normal vector in the hull (directed inside hull) and the vector from the last point to the new one has to be non-negative. As long as this isn't true, we should erase the last point in the convex hull alongside with the corresponding edge.</p> <p><pre><code>vector&lt;point&gt; hull, vecs;\n\nvoid add_line(ftype k, ftype b) {\n    point nw = {k, b};\n    while(!vecs.empty() &amp;&amp; dot(vecs.back(), nw - hull.back()) &lt; 0) {\n        hull.pop_back();\n        vecs.pop_back();\n    }\n    if(!hull.empty()) {\n        vecs.push_back(1i * (nw - hull.back()));\n    }\n    hull.push_back(nw);\n}\n</code></pre> Now to get the minimum value in some point we will find the first normal vector in the convex hull that is directed counter-clockwise from $(x;1)$. The left endpoint of such edge will be the answer. To check if vector $a$ is not directed counter-clockwise of vector $b$, we should check if their cross product $[a,b]$ is positive. <pre><code>int get(ftype x) {\n    point query = {x, 1};\n    auto it = lower_bound(vecs.begin(), vecs.end(), query, [](point a, point b) {\n        return cross(a, b) &gt; 0;\n    });\n    return dot(query, hull[it - vecs.begin()]);\n}\n</code></pre></p>","tags":["Original"]},{"location":"geometry/convex_hull_trick.html#li-chao-tree","title":"Li Chao tree","text":"<p>Assume you're given a set of functions such that each two can intersect at most once. Let's keep in each vertex of a segment tree some function in such way, that if we go from root to the leaf it will be guaranteed that one of the functions we met on the path will be the one giving the minimum value in that leaf. Let's see how to construct it.</p> <p>Assume we're in some vertex corresponding to half-segment $[l,r)$ and the function $f_{old}$ is kept there and we add the function $f_{new}$. Then the intersection point will be either in $[l;m)$ or in $[m;r)$ where $m=\\left\\lfloor\\tfrac{l+r}{2}\\right\\rfloor$. We can efficiently find that out by comparing the values of the functions in points $l$ and $m$. If the dominating function changes, then it is in $[l;m)$ otherwise it is in $[m;r)$. Now for the half of the segment with no intersection we will pick the lower function and write it in the current vertex. You can see that it will always be the one which is lower in point $m$. After that we recursively go to the other half of the segment with the function which was the upper one. As you can see this will keep correctness on the first half of segment and in the other one correctness will be maintained during the recursive call. Thus we can add functions and check the minimum value in the point in $O(\\log [C\\varepsilon^{-1}])$.</p> <p>Here is the illustration of what is going on in the vertex when we add new function:</p> <p>Let's go to implementation now. Once again we will use complex numbers to keep linear functions.</p> <p><pre><code>typedef long long ftype;\ntypedef complex&lt;ftype&gt; point;\n#define x real\n#define y imag\n\nftype dot(point a, point b) {\n    return (conj(a) * b).x();\n}\n\nftype f(point a,  ftype x) {\n    return dot(a, {x, 1});\n}\n</code></pre> We will keep functions in the array $line$ and use binary indexing of the segment tree. If you want to use it on large numbers or doubles, you should use a dynamic segment tree.  The segment tree should be initialized with default values, e.g. with lines $0x + \\infty$.</p> <p><pre><code>const int maxn = 2e5;\n\npoint line[4 * maxn];\n\nvoid add_line(point nw, int v = 1, int l = 0, int r = maxn) {\n    int m = (l + r) / 2;\n    bool lef = f(nw, l) &lt; f(line[v], l);\n    bool mid = f(nw, m) &lt; f(line[v], m);\n    if(mid) {\n        swap(line[v], nw);\n    }\n    if(r - l == 1) {\n        return;\n    } else if(lef != mid) {\n        add_line(nw, 2 * v, l, m);\n    } else {\n        add_line(nw, 2 * v + 1, m, r);\n    }\n}\n</code></pre> Now to get the minimum in some point $x$ we simply choose the minimum value along the path to the point. <pre><code>ftype get(int x, int v = 1, int l = 0, int r = maxn) {\n    int m = (l + r) / 2;\n    if(r - l == 1) {\n        return f(line[v], x);\n    } else if(x &lt; m) {\n        return min(f(line[v], x), get(x, 2 * v, l, m));\n    } else {\n        return min(f(line[v], x), get(x, 2 * v + 1, m, r));\n    }\n}\n</code></pre></p>","tags":["Original"]},{"location":"geometry/convex_hull_trick.html#problems","title":"Problems","text":"<ul> <li>Codebreaker - TROUBLES (simple application of Convex Hull Trick after a couple of observations)</li> <li>CS Academy - Squared Ends</li> <li>Codeforces - Escape Through Leaf</li> <li>CodeChef - Polynomials</li> <li>Codeforces - Kalila and Dimna in the Logging Industry</li> <li>Codeforces - Product Sum</li> <li>Codeforces - Bear and Bowling 4</li> <li>APIO 2010 - Commando</li> </ul>","tags":["Original"]},{"location":"geometry/delaunay.html","title":"Delaunay triangulation and Voronoi diagram","text":"<p>Consider a set $\\{p_i\\}$ of points on the plane. A Voronoi diagram $V(\\{p_i\\})$ of $\\{p_i\\}$ is a partition of the plane into $n$ regions $V_i$, where $V_i = \\{p\\in\\mathbb{R}^2;\\ \\rho(p, p_i) = \\min\\ \\rho(p, p_k)\\}$. The cells of the Voronoi diagram are polygons (possibly infinite). A Delaunay triangulation $D(\\{p_i\\})$ of $\\{p_i\\}$ is a triangulation where every point $p_i$ is outside or on the boundary of the circumcircle of each triangle $T \\in D(\\{p_i\\})$.</p> <p>There is a nasty degenerated case when the Voronoi diagram isn't connected and Delaunay triangulation doesn't exist. This case is when all points are collinear.</p>","tags":["Translated"]},{"location":"geometry/delaunay.html#properties","title":"Properties","text":"<p>The Delaunay triangulation maximizes the minimum angle among all possible triangulations.</p> <p>The Minimum Euclidean spanning tree of a point set is a subset of edges of its' Delaunay triangulation.</p>","tags":["Translated"]},{"location":"geometry/delaunay.html#duality","title":"Duality","text":"<p>Suppose that $\\{p_i\\}$ is not collinear and among $\\{p_i\\}$ no four points lie on one circle. Then $V(\\{p_i\\})$ and $D(\\{p_i\\})$ are dual, so if we obtain one of them, we may obtain the other in $O(n)$. What to do if it's not the case? The collinear case may be processed easily. Otherwise, $V$ and $D'$ are dual, where $D'$ is obtained from $D$ by removing all the edges such that two triangles on this edge share the circumcircle.</p>","tags":["Translated"]},{"location":"geometry/delaunay.html#building-delaunay-and-voronoi","title":"Building Delaunay and Voronoi","text":"<p>Because of the duality, we only need a fast algorithm to compute only one of $V$ and $D$. We will describe how to build $D(\\{p_i\\})$ in $O(n\\log n)$. The triangulation will be built via divide-and-conquer algorithm due to Guibas and Stolfi.</p>","tags":["Translated"]},{"location":"geometry/delaunay.html#quad-edge-data-structure","title":"Quad-edge data structure","text":"<p>During the algorithm $D$ will be stored inside the quad-edge data structure. This structure is described in the picture:</p> <p>In the algorithm we will use the following functions on edges:</p> <ol> <li><code>make_edge(a, b)</code>     This function creates an isolated edge from point <code>a</code> to point <code>b</code> together with its' reverse edge and both dual edges.</li> <li><code>splice(a, b)</code>     This is a key function of the algorithm. It swaps <code>a-&gt;Onext</code> with <code>b-&gt;Onext</code> and <code>a-&gt;Onext-&gt;Rot-&gt;Onext</code> with <code>b-&gt;Onext-&gt;Rot-&gt;Onext</code>.</li> <li><code>delete_edge(e)</code>     This function deletes e from the triangulation. To delete <code>e</code>, we may simply call <code>splice(e, e-&gt;Oprev)</code> and <code>splice(e-&gt;Rev, e-&gt;Rev-&gt;Oprev)</code>.</li> <li><code>connect(a, b)</code>     This function creates a new edge <code>e</code> from <code>a-&gt;Dest</code> to <code>b-&gt;Org</code> in such a way that <code>a</code>, <code>b</code>, <code>e</code> all have the same left face. To do this, we call <code>e = make_edge(a-&gt;Dest, b-&gt;Org)</code>, <code>splice(e, a-&gt;Lnext)</code> and <code>splice(e-&gt;Rev, b)</code>.</li> </ol>","tags":["Translated"]},{"location":"geometry/delaunay.html#algorithm","title":"Algorithm","text":"<p>The algorithm will compute the triangulation and return two quad-edges: the counterclockwise convex hull edge out of the leftmost vertex and the clockwise convex hull edge out of the rightmost vertex.</p> <p>Let's sort all points by x, and if $x_1 = x_2$ then by y. Let's solve the problem for some segment $(l, r)$ (initially $(l, r) = (0, n - 1)$). If $r - l + 1 = 2$, we will add an edge $(p[l], p[r])$ and return. If $r - l + 1 = 3$, we will firstly add the edges $(p[l], p[l + 1])$ and $(p[l + 1], p[r])$. We must also connect them using <code>splice(a-&gt;Rev, b)</code>. Now we must close the triangle. Our next action will depend on the orientation of $p[l], p[l + 1], p[r]$. If they are collinear, we can't make a triangle, so we simply return <code>(a, b-&gt;Rev)</code>. Otherwise, we create a new edge <code>c</code> by calling <code>connect(b, a)</code>. If the points are oriented counter-clockwise, we return <code>(a, b-&gt;Rev)</code>. Otherwise we return <code>(c-&gt;Rev, c)</code>.</p> <p>Now suppose that $r - l + 1 \\ge 4$. Firstly, let's solve $L = (l, \\frac{l + r}{2})$ and $R = (\\frac{l + r}{2} + 1, r)$ recursively. Now we have to merge these triangulations into one triangulation. Note that our points are sorted, so while merging we will add edges from L to R (so-called cross edges) and remove some edges from L to L and from R to R. What is the structure of the cross edges? All these edges must cross a line parallel to the y-axis and placed at the splitting x value. This establishes a linear ordering of the cross edges, so we can talk about successive cross edges, the bottom-most cross edge, etc. The algorithm will add the cross edges in ascending order. Note that any two adjacent cross edges will have a common endpoint, and the third side of the triangle they define goes from L to L or from R to R. Let's call the current cross edge the base. The successor of the base will either go from the left endpoint of the base to one of the R-neighbors of the right endpoint or vice versa. Consider the circumcircle of base and the previous cross edge. Suppose this circle is transformed into other circles having base as a chord but lying further into the Oy direction. Our circle will go up for a while, but unless base is an upper tangent of L and R we will encounter a point belonging either to L or to R giving rise to a new triangle without any points in the circumcircle. The new L-R edge of this triangle is the next cross edge added. To do this efficiently, we compute two edges <code>lcand</code> and <code>rcand</code> so that <code>lcand</code> points to the first L point encountered in this process, and <code>rcand</code> points to the first R point. Then we choose the one that would be encountered first. Initially base points to the lower tangent of L and R.</p>","tags":["Translated"]},{"location":"geometry/delaunay.html#implementation","title":"Implementation","text":"<p>Note that the implementation of the in_circle function is GCC-specific.</p> <pre><code>typedef long long ll;\n\nbool ge(const ll&amp; a, const ll&amp; b) { return a &gt;= b; }\nbool le(const ll&amp; a, const ll&amp; b) { return a &lt;= b; }\nbool eq(const ll&amp; a, const ll&amp; b) { return a == b; }\nbool gt(const ll&amp; a, const ll&amp; b) { return a &gt; b; }\nbool lt(const ll&amp; a, const ll&amp; b) { return a &lt; b; }\nint sgn(const ll&amp; a) { return a &gt;= 0 ? a ? 1 : 0 : -1; }\n\nstruct pt {\n    ll x, y;\n    pt() { }\n    pt(ll _x, ll _y) : x(_x), y(_y) { }\n    pt operator-(const pt&amp; p) const {\n        return pt(x - p.x, y - p.y);\n    }\n    ll cross(const pt&amp; p) const {\n        return x * p.y - y * p.x;\n    }\n    ll cross(const pt&amp; a, const pt&amp; b) const {\n        return (a - *this).cross(b - *this);\n    }\n    ll dot(const pt&amp; p) const {\n        return x * p.x + y * p.y;\n    }\n    ll dot(const pt&amp; a, const pt&amp; b) const {\n        return (a - *this).dot(b - *this);\n    }\n    ll sqrLength() const {\n        return this-&gt;dot(*this);\n    }\n    bool operator==(const pt&amp; p) const {\n        return eq(x, p.x) &amp;&amp; eq(y, p.y);\n    }\n};\n\nconst pt inf_pt = pt(1e18, 1e18);\n\nstruct QuadEdge {\n    pt origin;\n    QuadEdge* rot = nullptr;\n    QuadEdge* onext = nullptr;\n    bool used = false;\n    QuadEdge* rev() const {\n        return rot-&gt;rot;\n    }\n    QuadEdge* lnext() const {\n        return rot-&gt;rev()-&gt;onext-&gt;rot;\n    }\n    QuadEdge* oprev() const {\n        return rot-&gt;onext-&gt;rot;\n    }\n    pt dest() const {\n        return rev()-&gt;origin;\n    }\n};\n\nQuadEdge* make_edge(pt from, pt to) {\n    QuadEdge* e1 = new QuadEdge;\n    QuadEdge* e2 = new QuadEdge;\n    QuadEdge* e3 = new QuadEdge;\n    QuadEdge* e4 = new QuadEdge;\n    e1-&gt;origin = from;\n    e2-&gt;origin = to;\n    e3-&gt;origin = e4-&gt;origin = inf_pt;\n    e1-&gt;rot = e3;\n    e2-&gt;rot = e4;\n    e3-&gt;rot = e2;\n    e4-&gt;rot = e1;\n    e1-&gt;onext = e1;\n    e2-&gt;onext = e2;\n    e3-&gt;onext = e4;\n    e4-&gt;onext = e3;\n    return e1;\n}\n\nvoid splice(QuadEdge* a, QuadEdge* b) {\n    swap(a-&gt;onext-&gt;rot-&gt;onext, b-&gt;onext-&gt;rot-&gt;onext);\n    swap(a-&gt;onext, b-&gt;onext);\n}\n\nvoid delete_edge(QuadEdge* e) {\n    splice(e, e-&gt;oprev());\n    splice(e-&gt;rev(), e-&gt;rev()-&gt;oprev());\n    delete e-&gt;rev()-&gt;rot;\n    delete e-&gt;rev();\n    delete e-&gt;rot;\n    delete e;\n}\n\nQuadEdge* connect(QuadEdge* a, QuadEdge* b) {\n    QuadEdge* e = make_edge(a-&gt;dest(), b-&gt;origin);\n    splice(e, a-&gt;lnext());\n    splice(e-&gt;rev(), b);\n    return e;\n}\n\nbool left_of(pt p, QuadEdge* e) {\n    return gt(p.cross(e-&gt;origin, e-&gt;dest()), 0);\n}\n\nbool right_of(pt p, QuadEdge* e) {\n    return lt(p.cross(e-&gt;origin, e-&gt;dest()), 0);\n}\n\ntemplate &lt;class T&gt;\nT det3(T a1, T a2, T a3, T b1, T b2, T b3, T c1, T c2, T c3) {\n    return a1 * (b2 * c3 - c2 * b3) - a2 * (b1 * c3 - c1 * b3) +\n           a3 * (b1 * c2 - c1 * b2);\n}\n\nbool in_circle(pt a, pt b, pt c, pt d) {\n// If there is __int128, calculate directly.\n// Otherwise, calculate angles.\n#if defined(__LP64__) || defined(_WIN64)\n    __int128 det = -det3&lt;__int128&gt;(b.x, b.y, b.sqrLength(), c.x, c.y,\n                                   c.sqrLength(), d.x, d.y, d.sqrLength());\n    det += det3&lt;__int128&gt;(a.x, a.y, a.sqrLength(), c.x, c.y, c.sqrLength(), d.x,\n                          d.y, d.sqrLength());\n    det -= det3&lt;__int128&gt;(a.x, a.y, a.sqrLength(), b.x, b.y, b.sqrLength(), d.x,\n                          d.y, d.sqrLength());\n    det += det3&lt;__int128&gt;(a.x, a.y, a.sqrLength(), b.x, b.y, b.sqrLength(), c.x,\n                          c.y, c.sqrLength());\n    return det &gt; 0;\n#else\n    auto ang = [](pt l, pt mid, pt r) {\n        ll x = mid.dot(l, r);\n        ll y = mid.cross(l, r);\n        long double res = atan2((long double)x, (long double)y);\n        return res;\n    };\n    long double kek = ang(a, b, c) + ang(c, d, a) - ang(b, c, d) - ang(d, a, b);\n    if (kek &gt; 1e-8)\n        return true;\n    else\n        return false;\n#endif\n}\n\npair&lt;QuadEdge*, QuadEdge*&gt; build_tr(int l, int r, vector&lt;pt&gt;&amp; p) {\n    if (r - l + 1 == 2) {\n        QuadEdge* res = make_edge(p[l], p[r]);\n        return make_pair(res, res-&gt;rev());\n    }\n    if (r - l + 1 == 3) {\n        QuadEdge *a = make_edge(p[l], p[l + 1]), *b = make_edge(p[l + 1], p[r]);\n        splice(a-&gt;rev(), b);\n        int sg = sgn(p[l].cross(p[l + 1], p[r]));\n        if (sg == 0)\n            return make_pair(a, b-&gt;rev());\n        QuadEdge* c = connect(b, a);\n        if (sg == 1)\n            return make_pair(a, b-&gt;rev());\n        else\n            return make_pair(c-&gt;rev(), c);\n    }\n    int mid = (l + r) / 2;\n    QuadEdge *ldo, *ldi, *rdo, *rdi;\n    tie(ldo, ldi) = build_tr(l, mid, p);\n    tie(rdi, rdo) = build_tr(mid + 1, r, p);\n    while (true) {\n        if (left_of(rdi-&gt;origin, ldi)) {\n            ldi = ldi-&gt;lnext();\n            continue;\n        }\n        if (right_of(ldi-&gt;origin, rdi)) {\n            rdi = rdi-&gt;rev()-&gt;onext;\n            continue;\n        }\n        break;\n    }\n    QuadEdge* basel = connect(rdi-&gt;rev(), ldi);\n    auto valid = [&amp;basel](QuadEdge* e) { return right_of(e-&gt;dest(), basel); };\n    if (ldi-&gt;origin == ldo-&gt;origin)\n        ldo = basel-&gt;rev();\n    if (rdi-&gt;origin == rdo-&gt;origin)\n        rdo = basel;\n    while (true) {\n        QuadEdge* lcand = basel-&gt;rev()-&gt;onext;\n        if (valid(lcand)) {\n            while (in_circle(basel-&gt;dest(), basel-&gt;origin, lcand-&gt;dest(),\n                             lcand-&gt;onext-&gt;dest())) {\n                QuadEdge* t = lcand-&gt;onext;\n                delete_edge(lcand);\n                lcand = t;\n            }\n        }\n        QuadEdge* rcand = basel-&gt;oprev();\n        if (valid(rcand)) {\n            while (in_circle(basel-&gt;dest(), basel-&gt;origin, rcand-&gt;dest(),\n                             rcand-&gt;oprev()-&gt;dest())) {\n                QuadEdge* t = rcand-&gt;oprev();\n                delete_edge(rcand);\n                rcand = t;\n            }\n        }\n        if (!valid(lcand) &amp;&amp; !valid(rcand))\n            break;\n        if (!valid(lcand) ||\n            (valid(rcand) &amp;&amp; in_circle(lcand-&gt;dest(), lcand-&gt;origin,\n                                       rcand-&gt;origin, rcand-&gt;dest())))\n            basel = connect(rcand, basel-&gt;rev());\n        else\n            basel = connect(basel-&gt;rev(), lcand-&gt;rev());\n    }\n    return make_pair(ldo, rdo);\n}\n\nvector&lt;tuple&lt;pt, pt, pt&gt;&gt; delaunay(vector&lt;pt&gt; p) {\n    sort(p.begin(), p.end(), [](const pt&amp; a, const pt&amp; b) {\n        return lt(a.x, b.x) || (eq(a.x, b.x) &amp;&amp; lt(a.y, b.y));\n    });\n    auto res = build_tr(0, (int)p.size() - 1, p);\n    QuadEdge* e = res.first;\n    vector&lt;QuadEdge*&gt; edges = {e};\n    while (lt(e-&gt;onext-&gt;dest().cross(e-&gt;dest(), e-&gt;origin), 0))\n        e = e-&gt;onext;\n    auto add = [&amp;p, &amp;e, &amp;edges]() {\n        QuadEdge* curr = e;\n        do {\n            curr-&gt;used = true;\n            p.push_back(curr-&gt;origin);\n            edges.push_back(curr-&gt;rev());\n            curr = curr-&gt;lnext();\n        } while (curr != e);\n    };\n    add();\n    p.clear();\n    int kek = 0;\n    while (kek &lt; (int)edges.size()) {\n        if (!(e = edges[kek++])-&gt;used)\n            add();\n    }\n    vector&lt;tuple&lt;pt, pt, pt&gt;&gt; ans;\n    for (int i = 0; i &lt; (int)p.size(); i += 3) {\n        ans.push_back(make_tuple(p[i], p[i + 1], p[i + 2]));\n    }\n    return ans;\n}\n</code></pre>","tags":["Translated"]},{"location":"geometry/delaunay.html#problems","title":"Problems","text":"<ul> <li>TIMUS 1504 Good Manners</li> <li>TIMUS 1520 Empire Strikes Back</li> <li>SGU 383 Caravans</li> </ul>","tags":["Translated"]},{"location":"geometry/enclosing-circle.html","title":"Minimum Enclosing Circle","text":"<p>Consider the following problem:</p> <p>Library Checker - Minimum Enclosing Circle</p> <p>You're given $n \\leq 10^5$ points $p_i=(x_i, y_i)$.</p> <p>For each $p_i$, find whether it lies on the circumference of the minimum enclosing circle of $\\{p_1,\\dots,p_n\\}$.</p> <p>Here, by the minimum enclosing circle (MEC) we mean a circle with minimum possible radius that contains all the $n$ points, inside the circle or on its boundary. This problem has a simple randomized solution that, on first glance, looks like it would run in $O(n^3)$, but actually works in $O(n)$ expected time.</p> <p>To better understand the reasoning below, we should immediately note that the solution to the problem is unique:</p> Why is the MEC unique? <p>Consider the following setup: Let $r$ be the radius of the MEC. We draw a circle of radius $r$ around each of the points $p_1,\\dots,p_n$. Geometrically, the centers of circles that have radius $r$ and cover all the points $p_1,\\dots,p_n$ form the intersection of all $n$ circles.</p> <p>Now, if the intersection is just a single point, this already proves that it is unique. Otherwise, the intersection is a shape of non-zero area, so we can reduce $r$ by a tiny bit, and still have non-empty intersection, which contradicts the assumption that $r$ was the minimum possible radius of the enclosing circle.</p> <p>With a similar logic, we can also show the uniqueness of the MEC if we additionally demand that it passes through a given specific point $p_i$ or two points $p_i$ and $p_j$ (it is also unique because its radius uniquely defines it).</p> <p>Alternatively, we can also assume that there are two MECs, and then notice that their intersection (which contains the points $p_1,\\dots,p_n$ already) must have a smaller diameter than initial circles, and thus can be covered with a smaller circle.</p>","tags":["Original"]},{"location":"geometry/enclosing-circle.html#welzls-algorithm","title":"Welzl's algorithm","text":"<p>For brevity, let's denote $\\operatorname{mec}(p_1,\\dots,p_n)$ to be the MEC of $\\{p_1,\\dots,p_n\\}$, and let $P_i = \\{p_1,\\dots,p_i\\}$.</p> <p>The algorithm, initially proposed by Welzl in 1991, goes as follows:</p> <ol> <li>Apply a random permutation to the input sequence of points.</li> <li>Maintain the current candidate to be the MEC $C$, starting with $C = \\operatorname{mec}(p_1, p_2)$.</li> <li>Iterate over $i=3..n$ and check if $p_i \\in C$.<ol> <li>If $p_i \\in C$ it means that $C$ is the MEC of $P_i$.</li> <li>Otherwise, assign $C = \\operatorname{mec}(p_i, p_1)$ and iterate over $j=2..i$ and check if $p_j \\in C$.<ol> <li>If $p_j \\in C$, then $C$ is the MEC of $P_j$ among circles that pass through $p_i$.</li> <li>Otherwise, assign $C=\\operatorname{mec}(p_i, p_j)$ and iterate over $k=1..j$ and check if $p_k \\in C$.<ol> <li>If $p_k \\in C$, then $C$ is the MEC of $P_k$ among circles that pass through $p_i$ and $p_j$.</li> <li>Otherwise, $C=\\operatorname{mec}(p_i,p_j,p_k)$ is the MEC of $P_k$ among circles that pass through $p_i$ and $p_j$.</li> </ol> </li> </ol> </li> </ol> </li> </ol> <p>We can see that each level of nestedness here has an invariant to maintain (that $C$ is the MEC among circles that also pass through additionally given $0$, $1$ or $2$ points), and whenever the inner loop closes, its invariant becomes equivalent to the invariant of the current iteration of its parent loop. This, in turn, ensures the correctness of the algorithm as a whole.</p> <p>Omitting some technical details, for now, the whole algorithm can be implemented in C++ as follows:</p> <pre><code>struct point {...};\n\n// Is represented by 2 or 3 points on its circumference\nstruct mec {...};\n\nbool inside(mec const&amp; C, point p) {\n    return ...;\n}\n\n// Choose some good generator of randomness for the shuffle\nmt19937_64 gen(...);\nmec enclosing_circle(vector&lt;point&gt; &amp;p) {\n    int n = p.size();\n    ranges::shuffle(p, gen);\n    auto C = mec{p[0], p[1]};\n    for(int i = 0; i &lt; n; i++) {\n        if(!inside(C, p[i])) {\n            C = mec{p[i], p[0]};\n            for(int j = 0; j &lt; i; j++) {\n                if(!inside(C, p[j])) {\n                    C = mec{p[i], p[j]};\n                    for(int k = 0; k &lt; j; k++) {\n                        if(!inside(C, p[k])) {\n                            C = mec{p[i], p[j], p[k]};\n                        }\n                    }\n                }\n            }\n        }\n    }\n    return C;\n}\n</code></pre> <p>Now, it is to be expected that checking that a point $p_i$ is inside the MEC of $2$ or $3$ points can be done in $O(1)$ (we will discuss this later on). But even then, the algorithm above looks as if it would take $O(n^3)$ in the worst case just because of all the nested loops. So, how come we claimed the linear expected runtime? Let's figure out!</p>","tags":["Original"]},{"location":"geometry/enclosing-circle.html#complexity-analysis","title":"Complexity analysis","text":"<p>For the inner-most loop (over $k$), clearly its expected runtime is $O(j)$ operations. What about the loop over $j$?</p> <p>It only triggers the next loop if $p_j$ is on the boundary of the MEC of $P_j$ that also passes through point $i$, and removing $p_j$ would further shrink the circle. Of all points in $P_j$ there can only be at most $2$ points with such property, because if there are more than $2$ points from $P_j$ on the boundary, it means that after removing any of them, there will still be at least $3$ points on the boundary, sufficient to uniquely define the circle.</p> <p>In other words, after initial random shuffle, there is at most $\\frac{2}{j}$ probability that we get one of the at most two unlucky points as $p_j$. Summing it up over all $j$ from $1$ to $i$, we get the expected runtime of</p> $$ \\sum\\limits_{j=1}^i \\frac{2}{j} \\cdot O(j) = O(i). $$ <p>In exactly same fashion we can now also prove that the outermost loop has expected runtime of $O(n)$.</p>","tags":["Original"]},{"location":"geometry/enclosing-circle.html#checking-that-a-point-is-in-the-mec-of-2-or-3-points","title":"Checking that a point is in the MEC of 2 or 3 points","text":"<p>Let's now figure out the implementation detail of <code>point</code> and <code>mec</code>. In this problem, it turns out to be particularly useful to use std::complex as a class for points:</p> <pre><code>using ftype = int64_t;\nusing point = complex&lt;ftype&gt;;\n</code></pre> <p>As a reminder, a complex number is a number of type $x+yi$, where $i^2=-1$ and $x, y \\in \\mathbb R$. In C++, such complex number is represented by a 2-dimensional point $(x, y)$. Complex numbers already implement basic component-wise linear operations (addition, multiplication by a real number), but also their multiplication and division carry certain geometric meaning.</p> <p>Without going in too much detail, we will note the most important property for this particular task: Multiplying two complex numbers adds up their polar angles (counted from $Ox$ counter-clockwise), and taking a conjugate (i.e. changing $z=x+yi$ into $\\overline{z} = x-yi$) multiplies the polar angle with $-1$. This allows us to formulate some very simple criteria for whether a point $z$ is inside the MEC of $2$ or $3$ specific points.</p>","tags":["Original"]},{"location":"geometry/enclosing-circle.html#mec-of-2-points","title":"MEC of 2 points","text":"<p>For $2$ points $a$ and $b$, their MEC is simply the circle centered at $\\frac{a+b}{2}$ with the radius $\\frac{|a-b|}{2}$, in other words the circle that has $ab$ as a diameter. To check if $z$ is inside this circle we simply need to check that the angle between $za$ and $zb$ is not acute.</p> Inner angles are obtuse, external angles are acute and angles on the circumference are right <p>Equivalently, we need to check that</p> $$ I_0=(b-z)\\overline{(a-z)} $$ <p>doesn't have a positive real coordinate (corresponding to points that have a polar angle between $-90^\\circ$ and $90^\\circ$).</p>","tags":["Original"]},{"location":"geometry/enclosing-circle.html#mec-of-3-points","title":"MEC of 3 points","text":"<p>Adding $z$ to the triangle $abc$ will make it a quadrilateral. Consider the following expression:</p> $$ \\angle azb + \\angle bca $$ <p>In a cyclic quadrilateral, if $c$ and $z$ are from the same side of $ab$, then the angles are equal, and will add up to $0^\\circ$ when summed up signed (i.e. positive if counter-clockwise and negative if clockwise). Correspondingly, if $c$ and $z$ are on the opposite sides, the angles will add up to $180^\\circ$.</p> Adjacent inscribed angles are same, opposing angles complement to 180 degrees <p>In terms of complex numbers, we can note that $\\angle azb$ is the polar angle of $(b-z)\\overline{(a-z)}$ and $\\angle bca$ is the polar angle of $(a-c)\\overline{(b-c)}$. Thus, we can conclude that $\\angle azb + \\angle bca$ is the polar angle of</p> $$ I_1 = (b-z) \\overline{(a-z)} (a-c) \\overline{(b-c)} $$ <p>If the angle is $0^\\circ$ or $180^\\circ$, it means that the imaginary part of $I_1$ is $0$, otherwise we can deduce whether $z$ is inside or outside of the enclosing circle of $abc$ by checking the sign of the imaginary part of $I_1$. Positive imaginary part corresponds to positive angles, and negative imaginary part corresponds to negative angles.</p> <p>But which one of them means that $z$ is inside or outside of the circle? As we already noticed, having $z$ inside the circle generally increases the magnitude of $\\angle azb$, while having it outside the circle decreases it. As such, we have the following 4 cases:</p> <ol> <li>$\\angle bca &gt; 0^\\circ$, $c$ on the same side of $ab$ as $z$. Then, $\\angle azb &lt; 0^\\circ$, and $\\angle azb + \\angle bca &lt; 0^\\circ$ for points inside the circle.</li> <li>$\\angle bca &lt; 0^\\circ$, $c$ on the same side of $ab$ as $z$. Then, $\\angle azb &gt; 0^\\circ$, and $\\angle azb + \\angle bca &gt; 0^\\circ$ for points inside the circle.</li> <li>$\\angle bca &gt; 0^\\circ$, $c$ on the opposite side of $ab$ to $z$. Then, $\\angle azb &gt; 0^\\circ$ and $\\angle azb + \\angle bca &gt; 180^\\circ$ for points inside the circle.</li> <li>$\\angle bca &lt; 0^\\circ$, $c$ on the opposite side of $ab$ to $z$. Then, $\\angle azb &lt; 0^\\circ$ and $\\angle azb + \\angle bca &lt; 180^\\circ$ for points inside the circle.</li> </ol> <p>In other words, if $\\angle bca$ is positive, points inside the circle will have $\\angle azb + \\angle bca &lt; 0^\\circ$, otherwise they will have $\\angle azb + \\angle bca &gt; 0^\\circ$, assuming that we normalize the angles between $-180^\\circ$ and $180^\\circ$. This, in turn, can be checked by the signs of imaginary parts of $I_2=(a-c)\\overline{(b-c)}$ and $I_1 = I_0 I_2$.</p> <p>Note: As we multiply four complex numbers to get $I_1$, the intermediate coefficients can be as large as $O(A^4)$, where $A$ is the largest coordinate magnitude in the input. On the bright side, if the input is integer, both checks above can be done fully in integers.</p>","tags":["Original"]},{"location":"geometry/enclosing-circle.html#implementation","title":"Implementation","text":"<p>Now, to actually implement the check, we should first decide how to represent the MEC. As our criteria work with the points directly, a natural and efficient way to do this is to say that MEC is directly represented as a pair or triple of points that defines it:</p> <pre><code>using mec = variant&lt;\n    array&lt;point, 2&gt;,\n    array&lt;point, 3&gt;\n&gt;;\n</code></pre> <p>Now, we can use <code>std::visit</code> to efficiently deal with both cases in accordance with criteria above:</p> <pre><code>/* I &lt; 0 if z inside C,\n   I &gt; 0 if z outside C,\n   I = 0 if z on the circumference of C */\nftype indicator(mec const&amp; C, point z) {\n    return visit([&amp;](auto &amp;&amp;C) {\n        point a = C[0], b = C[1];\n        point I0 = (b - z) * conj(a - z);\n        if constexpr (size(C) == 2) {\n            return real(I0);\n        } else {\n            point c = C[2];\n            point I2 = (a - c) * conj(b - c);\n            point I1 = I0 * I2;\n            return imag(I2) &lt; 0 ? -imag(I1) : imag(I1);\n        }\n    }, C);\n}\n\nbool inside(mec const&amp; C, point p) {\n    return indicator(C, p) &lt;= 0;\n}\n</code></pre> <p>Now, we can finally ensure that everything works by submitting the problem to the Library Checker: #308668.</p>","tags":["Original"]},{"location":"geometry/enclosing-circle.html#practice-problems","title":"Practice problems","text":"<ul> <li>Library Checker - Minimum Enclosing Circle</li> <li>BOI 2002 - Aliens</li> </ul>","tags":["Original"]},{"location":"geometry/halfplane-intersection.html","title":"Half-plane intersection","text":"<p>In this article we will discuss the problem of computing the intersection of a set of half-planes. Such an intersection can be conveniently represented as a convex region/polygon, where every point inside of it is also inside all of the half-planes, and it is this polygon that we're trying to find or construct. We give some initial intuition for the problem, describe a $O(N \\log N)$ approach known as the Sort-and-Incremental algorithm and give some sample applications of this technique.</p> <p>It is strongly recommended for the reader to be familiar with basic geometrical primitives and operations (points, vectors, intersection of lines). Additionally, knowledge about Convex Hulls or the Convex Hull Trick may help to better understand the concepts in this article, but they are not a prerequisite by any means.</p>","tags":["Original"]},{"location":"geometry/halfplane-intersection.html#initial-clarifications-and-definitions","title":"Initial clarifications and definitions","text":"<p>For the entire article, we will make some assumptions (unless specified otherwise):</p> <ol> <li>We define $N$ to be the quantity of half-planes in the given set.</li> <li>We will represent lines and half-planes by one point and one vector (any point that lies on the given line, and the direction vector of the line). In the case of half-planes, we assume that every half-plane allows the region to the left side of its direction vector. Additionally, we define the angle of a half-plane to be the polar angle of its direction vector. See image below for example.</li> <li>We will assume that the resulting intersection is always either bounded or empty. If we need to handle the unbounded case, we can simply add 4 half-planes that define a large-enough bounding box. </li> <li>We will assume, for simplicity, that there are no parallel half-planes in the given set. Towards the end of the article we will discuss how to deal with such cases.</li> </ol> <p> </p> <p>The half-plane $y \\geq 2x - 2$ can be represented as the point $P = (1, 0)$ with direction vector $PQ = Q - P = (1, 2)$</p>","tags":["Original"]},{"location":"geometry/halfplane-intersection.html#brute-force-approach-on3","title":"Brute force approach - $O(N^3)$","text":"<p>One of the most straightforward and obvious solutions would be to compute the intersection point of the lines of all pairs of half-planes and, for each point, check if it is inside all of the other half-planes. Since there are $O(N^2)$ intersection points, and for each of them we have to check $O(N)$ half-planes, the total time complexity is $O(N^3)$. The actual region of the intersection can then be reconstructed using, for example, a Convex Hull algorithm on the set of intersection points that were included in all the half-planes. </p> <p>It is fairly easy to see why this works: the vertices of the resulting convex polygon are all intersection points of the half-plane lines, and each of those vertices is obviously part of all the half-planes. The main advantage of this method is that its easy to understand, remember and code on-the-fly if you just need to check if the intersection is empty or not. However, it is awfully slow and unfit for most problems, so we need something faster.</p>","tags":["Original"]},{"location":"geometry/halfplane-intersection.html#incremental-approach-on2","title":"Incremental approach - $O(N^2)$","text":"<p>Another fairly straightforward approach is to incrementally construct the intersection of the half-planes, one at a time. This method is basically equivalent to cutting a convex polygon by a line $N$ times, and removing the redundant half-planes at every step. To do this, we can represent the convex polygon as a list of line segments, and to cut it with a half-plane we simply find the intersection points of the segments with the half-plane line (there will only be two intersection points if the line properly intersects the polygon), and replace all the line segments in-between with the new segment corresponding to the half-plane. Since such procedure can be implemented in linear time, we can simply start with a big bounding box and cut it down with each one of the half-planes, obtaining a total time complexity of $O(N^2)$.</p> <p>This method is a big step in the right direction, but it does feel wasteful to have to iterate over $O(N)$ half-planes at every step. We will see next that, by making some clever observations, the ideas behind this incremental approach can be recycled to create a $O(N \\log N)$ algorithm.</p>","tags":["Original"]},{"location":"geometry/halfplane-intersection.html#sort-and-incremental-algorithm-on-log-n","title":"Sort-and-Incremental algorithm - $O(N \\log N)$","text":"<p>The first properly-documented source of this algorithm we could find was Zeyuan Zhu's thesis for Chinese Team Selecting Contest titled New Algorithm for Half-plane Intersection and its Practical Value, from the year 2006. The approach we'll describe next is based on this same algorithm, but instead of computing two separate intersections for the lower and upper halves of the intersections, we'll construct it all at once in one pass with a deque (double-ended queue).</p> <p>The algorithm itself, as the name may spoil, takes advantage of the fact that the resulting region from the intersection of half-planes is convex, and thus it will consist of some segments of half-planes in order sorted by their angles. This leads to a crucial observation: if we incrementally intersect the half-planes in their order sorted by angle (as they would appear in the final, resulting shape of the intersection) and store them in a double-ended queue, then we will only ever need to remove half-planes from the front and the back of the deque.</p> <p>To better visualize this fact, suppose we're performing the incremental approach described previously on a set of half-planes that is sorted by angle (in this case, we'll assume they're sorted from $-\\pi$ to $\\pi$), and suppose that we're about to start some arbitrary $k$'th step. This means we have already constructed the intersection of the first $k-1$ half-planes. Now, because the half-planes are sorted by angle, whatever the $k$'th half-plane is, we can be sure that it will form a convex turn with the $(K-1)$'th half-plane. For that reason, a few things may happen:</p> <ol> <li>Some (possibly none) of the half-planes in the back of the intersection may become redundant. In this case, we need to pop these now-useless half-planes from the back of the deque. </li> <li>Some (possibly none) of the half-planes at the front may become redundant. Analogous to case 1, we just pop them from the front of the deque.</li> <li>The intersection may become empty (after handling cases 1 and/or 2). In this case, we just report the intersection is empty and terminate the algorithm.</li> </ol> <p>We say a half-plane is \"redundant\" if it does not contribute anything to the intersection. Such a half-plane could be removed and the resulting intersection would not change at all.</p> <p>Here's a small example with an illustration:</p> <p>Let $H = \\{ A, B, C, D, E \\}$ be the set of half-planes currently present in the intersection. Additionally, let $P = \\{ p, q, r, s \\}$ be the set of intersection points of adjacent half-planes in H. Now, suppose we wish to intersect it with the half-plane $F$, as seen in the illustration below:</p> <p></p> <p>Notice the half-plane $F$ makes $A$ and $E$ redundant in the intersection. So we remove both $A$ and $E$ from the front and back of the intersection, respectively, and add $F$ at the end. And we finally obtain the new intersection $H = \\{ B, C, D, F\\}$ with $P = \\{ q, r, t, u \\}$.</p> <p></p> <p>With all of this in mind, we have almost everything we need to actually implement the algorithm, but we still need to talk about some special cases. At the beginning of the article we said we would add a bounding box to take care of the cases where the intersection could be unbounded, so the only tricky case we actually need to handle is parallel half-planes. We can have two sub-cases: two half-planes can be parallel with the same direction or with opposite direction. The reason this case needs to be handled separately is because we will need to compute intersection points of half-plane lines to be able to check if a half-plane is redundant or not, and two parallel lines have no intersection point, so we need a special way to deal with them.</p> <p>For the case of parallel half-planes of opposite orientation: Notice that, because we're adding the bounding box to deal with the unbounded case, this also deals with the case where we have two adjacent parallel half-planes with opposite directions after sorting, since there will have to be at least one of the bounding-box half-planes in between these two (remember they are sorted by angle). </p> <ul> <li>However, it is possible that, after removing some half-planes from the back of the deque, two parallel half-planes of opposite direction end up together. This case only happens, specifically, when these two half-planes form an empty intersection, as this last half-plane will cause everything to be removed from the deque. To avoid this problem, we have to manually check for parallel half-planes, and if they have opposite direction, we just instantly stop the algorithm and return an empty intersection.</li> </ul> <p>Thus the only case we actually need to handle is having multiple half-planes with the same angle, and it turns out this case is fairly easy to handle: we only have keep the leftmost half-plane and erase the rest, since they will be completely redundant anyways. To sum up, the full algorithm will roughly look as follows:</p> <ol> <li>We begin by sorting the set of half-planes by angle, which takes $O(N \\log N)$ time.</li> <li>We will iterate over the set of half-planes, and for each one, we will perform the incremental procedure, popping from the front and the back of the double-ended queue as necessary. This will take linear time in total, as every half-plane can only be added or removed once.</li> <li>At the end, the convex polygon resulting from the intersection can be simply obtained by computing the intersection points of adjacent half-planes in the deque at the end of the procedure. This will take linear time as well. It is also possible to store such points during step 2 and skip this step entirely, but we believe it is slightly easier (in terms of implementation) to compute them on-the-fly.</li> </ol> <p>In total, we have achieved a time complexity of $O(N \\log N)$. Since sorting is clearly the bottleneck, the algorithm can be made to run in linear time in the special case where we are given half-planes sorted in advance by their angles (an example of such a case would be obtaining the half-planes that define a convex polygon). </p>","tags":["Original"]},{"location":"geometry/halfplane-intersection.html#direct-implementation","title":"Direct implementation","text":"<p>Here is a sample, direct implementation of the algorithm, with comments explaining most parts: </p> <p>Simple point/vector and half-plane structs:</p> <pre><code>// Redefine epsilon and infinity as necessary. Be mindful of precision errors.\nconst long double eps = 1e-9, inf = 1e9; \n\n// Basic point/vector struct.\nstruct Point { \n\n    long double x, y;\n    explicit Point(long double x = 0, long double y = 0) : x(x), y(y) {}\n\n    // Addition, substraction, multiply by constant, dot product, cross product.\n\n    friend Point operator + (const Point&amp; p, const Point&amp; q) {\n        return Point(p.x + q.x, p.y + q.y); \n    }\n\n    friend Point operator - (const Point&amp; p, const Point&amp; q) { \n        return Point(p.x - q.x, p.y - q.y); \n    }\n\n    friend Point operator * (const Point&amp; p, const long double&amp; k) { \n        return Point(p.x * k, p.y * k); \n    } \n\n    friend long double dot(const Point&amp; p, const Point&amp; q) {\n        return p.x * q.x + p.y * q.y;\n    }\n\n    friend long double cross(const Point&amp; p, const Point&amp; q) { \n        return p.x * q.y - p.y * q.x; \n    }\n};\n\n// Basic half-plane struct.\nstruct Halfplane { \n\n    // 'p' is a passing point of the line and 'pq' is the direction vector of the line.\n    Point p, pq; \n    long double angle;\n\n    Halfplane() {}\n    Halfplane(const Point&amp; a, const Point&amp; b) : p(a), pq(b - a) {\n        angle = atan2l(pq.y, pq.x);    \n    }\n\n    // Check if point 'r' is outside this half-plane. \n    // Every half-plane allows the region to the LEFT of its line.\n    bool out(const Point&amp; r) { \n        return cross(pq, r - p) &lt; -eps; \n    }\n\n    // Comparator for sorting. \n    bool operator &lt; (const Halfplane&amp; e) const { \n        return angle &lt; e.angle;\n    } \n\n    // Intersection point of the lines of two half-planes. It is assumed they're never parallel.\n    friend Point inter(const Halfplane&amp; s, const Halfplane&amp; t) {\n        long double alpha = cross((t.p - s.p), t.pq) / cross(s.pq, t.pq);\n        return s.p + (s.pq * alpha);\n    }\n};\n</code></pre> <p>Algorithm: </p> <pre><code>// Actual algorithm\nvector&lt;Point&gt; hp_intersect(vector&lt;Halfplane&gt;&amp; H) { \n\n    Point box[4] = {  // Bounding box in CCW order\n        Point(inf, inf), \n        Point(-inf, inf), \n        Point(-inf, -inf), \n        Point(inf, -inf) \n    };\n\n    for(int i = 0; i&lt;4; i++) { // Add bounding box half-planes.\n        Halfplane aux(box[i], box[(i+1) % 4]);\n        H.push_back(aux);\n    }\n\n    // Sort by angle and start algorithm\n    sort(H.begin(), H.end());\n    deque&lt;Halfplane&gt; dq;\n    int len = 0;\n    for(int i = 0; i &lt; int(H.size()); i++) {\n\n        // Remove from the back of the deque while last half-plane is redundant\n        while (len &gt; 1 &amp;&amp; H[i].out(inter(dq[len-1], dq[len-2]))) {\n            dq.pop_back();\n            --len;\n        }\n\n        // Remove from the front of the deque while first half-plane is redundant\n        while (len &gt; 1 &amp;&amp; H[i].out(inter(dq[0], dq[1]))) {\n            dq.pop_front();\n            --len;\n        }\n\n        // Special case check: Parallel half-planes\n        if (len &gt; 0 &amp;&amp; fabsl(cross(H[i].pq, dq[len-1].pq)) &lt; eps) {\n            // Opposite parallel half-planes that ended up checked against each other.\n            if (dot(H[i].pq, dq[len-1].pq) &lt; 0.0)\n                return vector&lt;Point&gt;();\n\n            // Same direction half-plane: keep only the leftmost half-plane.\n            if (H[i].out(dq[len-1].p)) {\n                dq.pop_back();\n                --len;\n            }\n            else continue;\n        }\n\n        // Add new half-plane\n        dq.push_back(H[i]);\n        ++len;\n    }\n\n    // Final cleanup: Check half-planes at the front against the back and vice-versa\n    while (len &gt; 2 &amp;&amp; dq[0].out(inter(dq[len-1], dq[len-2]))) {\n        dq.pop_back();\n        --len;\n    }\n\n    while (len &gt; 2 &amp;&amp; dq[len-1].out(inter(dq[0], dq[1]))) {\n        dq.pop_front();\n        --len;\n    }\n\n    // Report empty intersection if necessary\n    if (len &lt; 3) return vector&lt;Point&gt;();\n\n    // Reconstruct the convex polygon from the remaining half-planes.\n    vector&lt;Point&gt; ret(len);\n    for(int i = 0; i+1 &lt; len; i++) {\n        ret[i] = inter(dq[i], dq[i+1]);\n    }\n    ret.back() = inter(dq[len-1], dq[0]);\n    return ret;\n}\n</code></pre>","tags":["Original"]},{"location":"geometry/halfplane-intersection.html#implementation-discussion","title":"Implementation discussion","text":"<p>A special thing to note is that, in case there multiple half-planes that intersect at the same point, then this algorithm could return repeated adjacent points in the final polygon. However, this should not have any impact on judging correctly whether the intersection is empty or not, and it does not affect the polygon area at all either. You may want to remove these duplicates depending on what tasks you need to do after. You can do this very easily with std::unique. We want to keep the repeat points during the execution of the algorithm so that the intersections with area equal to zero can be computed correctly (for example, intersections that consist of a single point, line or line-segment). I encourage the reader to test some small hand-made cases where the intersection results in a single point or line.</p> <p>One more thing that should be talked about is what to do if we are given half-planes in the form of a linear constraint (for example, $ax + by + c \\leq 0$). In such case, there are two options. You can either implement the algorithm with the corresponding modifications to work with such representation (essentially create your own half-plane struct, should be fairly straightforward if you're familiar with the convex hull trick), or you can transform the lines into the representation we used in this article by taking any 2 points of each line. In general, it is recommended to work with the representation that you're given in the problem to avoid additional precision issues.</p>","tags":["Original"]},{"location":"geometry/halfplane-intersection.html#problems-tasks-and-applications","title":"Problems, tasks and applications","text":"<p>Many problems that can be solved with half-plane intersection can also be solved without it, but with (usually) more complicated or uncommon approaches. Generally, half-plane intersection can appear when dealing with problems related to polygons (mostly convex), visibility in the plane and two-dimensional linear programming. Here are some sample tasks that can be solved with this technique: </p>","tags":["Original"]},{"location":"geometry/halfplane-intersection.html#convex-polygon-intersection","title":"Convex polygon intersection","text":"<p>One of the classical applications of half-plane intersection: Given $N$ polygons, compute the region that is included inside all of the polygons. </p> <p>Since the intersection of a set of half-planes is a convex polygon, we can also represent a convex polygon as a set of half-planes (every edge of the polygon is a segment of a half-plane). Generate these half-planes for every polygon and compute the intersection of the whole set. The total time complexity is $O(S \\log S)$, where S is the total number of sides of all the polygons. The problem can also theoretically be solved in $O(S \\log N)$ by merging the $N$ sets of half-planes using a heap and then running the algorithm without the sorting step, but such solution has much worse constant factor than straightforward sorting and only provides minor speed gains for very small $N$.</p>","tags":["Original"]},{"location":"geometry/halfplane-intersection.html#visibility-in-the-plane","title":"Visibility in the plane","text":"<p>Problems that require something among the lines of \"determine if some line segments are visible from some point(s) in the plane\" can usually be formulated as half-plane intersection problems. Take, for example, the following task: Given some simple polygon (not necessarily convex), determine if there's any point inside the polygon such that the whole boundary of the polygon can be observed from that point. This is also known as finding the kernel of a polygon and can be solved by simple half-plane intersection, taking each edge of the polygon as a half-plane and then computing its intersection.</p> <p>Here's a related, more interesting problem that was presented by Artem Vasilyev in one of his Brazilian ICPC Summer School lectures:  Given a set $p$ of points $p_1, p_2\\ \\dots \\ p_n$ in the plane, determine if there's any point $q$ you can stand at such that you can see all the points of $p$ from left to right in increasing order of their index.</p> <p>Such problem can be solved by noticing that being able to see some point $p_i$ to the left of $p_j$ is the same as being able to see the right side of the line segment from $p_i$ to $p_j$ (or equivalently, being able to see the left side of the segment from $p_j$ to $p_i$). With that in mind, we can simply create a half-plane for every line segment $p_i p_{i+1}$ (or $p_{i+1} p_i$ depending on the orientation you choose) and check if the intersection of the whole set is empty or not.</p>","tags":["Original"]},{"location":"geometry/halfplane-intersection.html#half-plane-intersection-with-binary-search","title":"Half-plane intersection with binary search","text":"<p>Another common application is utilizing half-plane intersection as a tool to validate the predicate of a binary search procedure. Here's an example of such a problem, also presented by Artem Vasilyev in the same lecture that was previously mentioned: Given a convex polygon $P$, find the biggest circumference that can be inscribed inside of it.</p> <p>Instead of looking for some sort of closed-form solution, annoying formulas or obscure algorithmic solutions, lets instead try to binary search on the answer. Notice that, for some fixed $r$, a circle with radius $r$ can be inscribed inside $P$ only if there exists some point inside $P$ that has distance greater or equal than $r$ to all the points of the boundary of $P$. This condition can be validated by \"shrinking\" the polygon inwards by a distance of $r$ and checking that the polygon remains non-degenerate (or is a point/segment itself). Such procedure can be simulated by taking the half-planes of the polygon sides in counter-clockwise order, translating each of them by a distance of $r$ in the direction of the region they allow (that is, orthogonal to the direction vector of the half-plane), and checking if the intersection is not empty.</p> <p>Clearly, if we can inscribe a circle of radius $r$, we can also inscribe any other circle of radius smaller than $r$. So we can perform a binary search on the radius $r$ and validate every step using half-plane intersection. Also, note that the half-planes of a convex polygon are already sorted by angle, so the sorting step can be skipped in the algorithm. Thus we obtain a total time complexity of $O(NK)$, where $N$ is the number of polygon vertices and $K$ is the number of iterations of the binary search (the actual value will depend on the range of possible answers and the desired precision).</p>","tags":["Original"]},{"location":"geometry/halfplane-intersection.html#two-dimensional-linear-programming","title":"Two-dimensional linear programming","text":"<p>One more application of half-plane intersection is linear programming in two variables. All linear constraints for two variables can be expressed in the form of $Ax + By + C \\leq 0$ (inequality comparator may vary). Clearly, these are just half-planes, so checking if a feasible solution exists for a set of linear constraints can be done with half-plane intersection. Additionally, for a given set of linear constraints, it is possible to compute the region of feasible solutions (i.e. the intersection of the half-planes) and then answer multiple queries of maximizing/minimizing some linear function $f(x, y)$ subject to the constraints in $O(\\log N)$ per query using binary search (very similar to the convex hull trick).</p> <p>It is worth mentioning that there also exists a fairly simple randomized algorithm that can check whether a set of linear constraints has a feasible solution or not, and maximize/minimize some linear function subject to the given constraints. This randomized algorithm was also explained nicely by Artem Vasilyev in the lecture mentioned earlier. Here are some additional resources on it, should the reader be interested: CG - Lecture 4, parts 4 and 5 and Petr Mitrichev's blog (which includes the solution to the hardest problem in the practice problems list below).</p>","tags":["Original"]},{"location":"geometry/halfplane-intersection.html#practice-problems","title":"Practice problems","text":"","tags":["Original"]},{"location":"geometry/halfplane-intersection.html#classic-problems-direct-application","title":"Classic problems, direct application","text":"<ul> <li>Codechef - Animesh decides to settle down</li> <li>POJ - How I mathematician Wonder What You Are!</li> <li>POJ - Rotating Scoreboard</li> <li>POJ - Video Surveillance</li> <li>POJ - Art Gallery</li> <li>POJ - Uyuw's Concert</li> </ul>","tags":["Original"]},{"location":"geometry/halfplane-intersection.html#harder-problems","title":"Harder problems","text":"<ul> <li>POJ - Most Distant Point from the Sea - Medium</li> <li>Baekjoon - Jeju's Island - Same as above but seemingly stronger test cases</li> <li>POJ - Feng Shui - Medium</li> <li>POJ - Triathlon - Medium/hard</li> <li>DMOJ - Arrow - Medium/hard</li> <li>POJ - Jungle Outpost - Hard</li> <li>Codeforces - Jungle Outpost (alternative link, problem J) - Hard </li> <li>Yandex - Asymmetry Value (need virtual contest to see, problem F) - Very Hard</li> </ul>","tags":["Original"]},{"location":"geometry/halfplane-intersection.html#additional-problems","title":"Additional problems","text":"<ul> <li>40th Petrozavodsk Programming Camp, Winter 2021 - Day 1: Jagiellonian U Contest, Grand Prix of Krakow - Problem B: (Almost) Fair Cake-Cutting. At the time of writing the article, this problem was private and only accessible by participants of the Programming Camp.</li> </ul>","tags":["Original"]},{"location":"geometry/halfplane-intersection.html#references-bibliography-and-other-sources","title":"References, bibliography and other sources","text":"","tags":["Original"]},{"location":"geometry/halfplane-intersection.html#main-sources","title":"Main sources","text":"<ul> <li>New Algorithm for Half-plane Intersection and its Practical Value. Original paper of the algorithm.</li> <li>Artem Vasilyev's Brazilian ICPC Summer School 2020 lecture. Amazing lecture on half-plane intersection. Also covers other geometry topics.</li> </ul>","tags":["Original"]},{"location":"geometry/halfplane-intersection.html#good-blogs-chinese","title":"Good blogs (Chinese)","text":"<ul> <li>Fundamentals of Computational Geometry - Intersection of Half-planes.</li> <li>Detailed introduction to the half-plane intersection algorithm.</li> <li>Summary of Half-plane intersection problems.</li> <li>Sorting incremental method of half-plane intersection.</li> </ul>","tags":["Original"]},{"location":"geometry/halfplane-intersection.html#randomized-algorithm","title":"Randomized algorithm","text":"<ul> <li>Linear Programming and Half-Plane intersection - Parts 4 and 5.</li> <li>Petr Mitrichev's Blog: A half-plane week.</li> </ul>","tags":["Original"]},{"location":"geometry/intersecting_segments.html","title":"Search for a pair of intersecting segments","text":"<p>Given $n$ line segments on the plane. It is required to check whether at least two of them intersect with each other. If the answer is yes, then print this pair of intersecting segments; it is enough to choose any of them among several answers.</p> <p>The naive solution algorithm is to iterate over all pairs of segments in $O(n^2)$ and check for each pair whether they intersect or not. This article describes an algorithm with the runtime time $O(n \\log n)$, which is based on the sweep line algorithm.</p>","tags":["Translated"]},{"location":"geometry/intersecting_segments.html#algorithm","title":"Algorithm","text":"<p>Let's draw a vertical line $x = -\\infty$ mentally and start moving this line to the right. In the course of its movement, this line will meet with segments, and at each time a segment intersects with our line it intersects in exactly one point (we will assume that there are no vertical segments).</p> <p>Thus, for each segment, at some point in time, its point will appear on the sweep line, then with the movement of the line, this point will move, and finally, at some point, the segment will disappear from the line.</p> <p>We are interested in the relative order of the segments along the vertical. Namely, we will store a list of segments crossing the sweep line at a given time, where the segments will be sorted by their $y$-coordinate on the sweep line.</p> <p>This order is interesting because intersecting segments will have the same $y$-coordinate at least at one time:</p> <p>We formulate key statements:</p> <ul> <li>To find an intersecting pair, it is sufficient to consider only adjacent segments at each fixed position of the sweep line.</li> <li>It is enough to consider the sweep line not in all possible real positions $(-\\infty \\ldots +\\infty)$, but only in those positions when new segments appear or old ones disappear. In other words, it is enough to limit yourself only to the positions equal to the abscissas of the end points of the segments.</li> <li>When a new line segment appears, it is enough to insert it to the desired location in the list obtained for the previous sweep line. We should only check for the intersection of the added segment with its immediate neighbors in the list above and below.</li> <li>If the segment disappears, it is enough to remove it from the current list. After that, it is necessary check for the intersection of the upper and lower neighbors in the list.</li> <li>Other changes in the sequence of segments in the list, except for those described, do not exist. No other intersection checks are required.</li> </ul> <p>To understand the truth of these statements, the following remarks are sufficient:</p> <ul> <li>Two disjoint segments never change their relative order.     In fact, if one segment was first higher than the other, and then became lower, then between these two moments there was an intersection of these two segments.</li> <li>Two non-intersecting segments also cannot have the same $y$-coordinates.</li> <li>From this it follows that at the moment of the segment appearance we can find the position for this segment in the queue, and we will not have to rearrange this segment in the queue any more: its order relative to other segments in the queue will not change.</li> <li>Two intersecting segments at the moment of their intersection point will be neighbors of each other in the queue.</li> <li>Therefore, for finding pairs of intersecting line segments is sufficient to check the intersection of all and only those pairs of segments that sometime during the movement of the sweep line at least once were neighbors to each other.      It is easy to notice that it is enough only to check the added segment with its upper and lower neighbors, as well as when removing the segment \u2014 its upper and lower neighbors (which after removal will become neighbors of each other).</li> <li>It should be noted that at a fixed position of the sweep line, we must first add all the segments that start at this x-coordinate, and only then remove all the segments that end here.     Thus, we do not miss the intersection of segments on the vertex: i.e. such cases when two segments have a common vertex.</li> <li>Note that vertical segments do not actually affect the correctness of the algorithm.     These segments are distinguished by the fact that they appear and disappear at the same time. However, due to the previous comment, we know that all segments will be added to the queue first, and only then they will be deleted. Therefore, if the vertical segment intersects with some other segment opened at that moment (including the vertical one), it will be detected. In what place of the queue to place vertical segments? After all, a vertical segment does not have one specific $y$-coordinate, it extends for an entire segment along the $y$-coordinate. However, it is easy to understand that any coordinate from this segment can be taken as a $y$-coordinate.</li> </ul> <p>Thus, the entire algorithm will perform no more than $2n$ tests on the intersection of a pair of segments, and will perform $O(n)$ operations with a queue of segments ($O(1)$ operations at the time of appearance and disappearance of each segment).</p> <p>The final asymptotic behavior of the algorithm is thus $O(n \\log n)$.</p>","tags":["Translated"]},{"location":"geometry/intersecting_segments.html#implementation","title":"Implementation","text":"<p>We present the full implementation of the described algorithm:</p> <pre><code>const double EPS = 1E-9;\n\nstruct pt {\n    double x, y;\n};\n\nstruct seg {\n    pt p, q;\n    int id;\n\n    double get_y(double x) const {\n        if (abs(p.x - q.x) &lt; EPS)\n            return p.y;\n        return p.y + (q.y - p.y) * (x - p.x) / (q.x - p.x);\n    }\n};\n\nbool intersect1d(double l1, double r1, double l2, double r2) {\n    if (l1 &gt; r1)\n        swap(l1, r1);\n    if (l2 &gt; r2)\n        swap(l2, r2);\n    return max(l1, l2) &lt;= min(r1, r2) + EPS;\n}\n\nint vec(const pt&amp; a, const pt&amp; b, const pt&amp; c) {\n    double s = (b.x - a.x) * (c.y - a.y) - (b.y - a.y) * (c.x - a.x);\n    return abs(s) &lt; EPS ? 0 : s &gt; 0 ? +1 : -1;\n}\n\nbool intersect(const seg&amp; a, const seg&amp; b)\n{\n    return intersect1d(a.p.x, a.q.x, b.p.x, b.q.x) &amp;&amp;\n           intersect1d(a.p.y, a.q.y, b.p.y, b.q.y) &amp;&amp;\n           vec(a.p, a.q, b.p) * vec(a.p, a.q, b.q) &lt;= 0 &amp;&amp;\n           vec(b.p, b.q, a.p) * vec(b.p, b.q, a.q) &lt;= 0;\n}\n\nbool operator&lt;(const seg&amp; a, const seg&amp; b)\n{\n    double x = max(min(a.p.x, a.q.x), min(b.p.x, b.q.x));\n    return a.get_y(x) &lt; b.get_y(x) - EPS;\n}\n\nstruct event {\n    double x;\n    int tp, id;\n\n    event() {}\n    event(double x, int tp, int id) : x(x), tp(tp), id(id) {}\n\n    bool operator&lt;(const event&amp; e) const {\n        if (abs(x - e.x) &gt; EPS)\n            return x &lt; e.x;\n        return tp &gt; e.tp;\n    }\n};\n\nset&lt;seg&gt; s;\nvector&lt;set&lt;seg&gt;::iterator&gt; where;\n\nset&lt;seg&gt;::iterator prev(set&lt;seg&gt;::iterator it) {\n    return it == s.begin() ? s.end() : --it;\n}\n\nset&lt;seg&gt;::iterator next(set&lt;seg&gt;::iterator it) {\n    return ++it;\n}\n\npair&lt;int, int&gt; solve(const vector&lt;seg&gt;&amp; a) {\n    int n = (int)a.size();\n    vector&lt;event&gt; e;\n    for (int i = 0; i &lt; n; ++i) {\n        e.push_back(event(min(a[i].p.x, a[i].q.x), +1, i));\n        e.push_back(event(max(a[i].p.x, a[i].q.x), -1, i));\n    }\n    sort(e.begin(), e.end());\n\n    s.clear();\n    where.resize(a.size());\n    for (size_t i = 0; i &lt; e.size(); ++i) {\n        int id = e[i].id;\n        if (e[i].tp == +1) {\n            set&lt;seg&gt;::iterator nxt = s.lower_bound(a[id]), prv = prev(nxt);\n            if (nxt != s.end() &amp;&amp; intersect(*nxt, a[id]))\n                return make_pair(nxt-&gt;id, id);\n            if (prv != s.end() &amp;&amp; intersect(*prv, a[id]))\n                return make_pair(prv-&gt;id, id);\n            where[id] = s.insert(nxt, a[id]);\n        } else {\n            set&lt;seg&gt;::iterator nxt = next(where[id]), prv = prev(where[id]);\n            if (nxt != s.end() &amp;&amp; prv != s.end() &amp;&amp; intersect(*nxt, *prv))\n                return make_pair(prv-&gt;id, nxt-&gt;id);\n            s.erase(where[id]);\n        }\n    }\n\n    return make_pair(-1, -1);\n}\n</code></pre> <p>The main function here is <code>solve()</code>, which returns the intersecting segments if exists, or $(-1, -1)$, if there are no intersections.</p> <p>Checking for the intersection of two segments is carried out by the <code>intersect ()</code> function, using an algorithm based on the oriented area of the triangle.</p> <p>The queue of segments is the global variable <code>s</code>, a <code>set&lt;event&gt;</code>. Iterators that specify the position of each segment in the queue (for convenient removal of segments from the queue) are stored in the global array <code>where</code>.</p> <p>Two auxiliary functions <code>prev()</code> and <code>next()</code> are also introduced, which return iterators to the previous and next elements (or <code>end()</code>, if one does not exist).</p> <p>The constant <code>EPS</code> denotes the error of comparing two real numbers (it is mainly used when checking two segments for intersection).</p>","tags":["Translated"]},{"location":"geometry/intersecting_segments.html#problems","title":"Problems","text":"<ul> <li>TIMUS 1469 No Smoking!</li> </ul>","tags":["Translated"]},{"location":"geometry/lattice-points.html","title":"Lattice points inside non-lattice polygon","text":"<p>For lattice polygons there is Pick's formula to enumerate the lattice points inside the polygon. What about polygons with arbitrary vertices?</p> <p>Let's process each of the polygon's edges individually, and after that we may sum up the amounts of lattice points under each edge considering its orientations to choose a sign (like in calculating the area of a polygon using trapezoids).</p> <p>First of all we should note that if current edge has endpoints in $A=(x_1;y_1)$ and $B=(x_2;y_2)$ then it can be represented as a linear function:</p> $$y=y_1+(y_2-y_1) \\cdot \\dfrac{x-x_1}{x_2-x_1}=\\left(\\dfrac{y_2-y_1}{x_2-x_1}\\right)\\cdot x + \\left(\\dfrac{y_1x_2-x_1y_2}{x_2-x_1}\\right)$$ $$y = k \\cdot x + b,~k = \\dfrac{y_2-y_1}{x_2-x_1},~b = \\dfrac{y_1x_2-x_1y_2}{x_2-x_1}$$ <p>Now we will perform a substitution $x=x'+\\lceil x_1 \\rceil$ so that $b' = b + k \\cdot \\lceil x_1 \\rceil$. This allows us to work with $x_1'=0$ and $x_2'=x_2 - \\lceil x_1 \\rceil$. Let's denote $n = \\lfloor x_2' \\rfloor$.</p> <p>We will not sum up points at $x = n$ and on $y = 0$ for the integrity of the algorithm. They may be added manually afterwards. Thus we have to sum up $\\sum\\limits_{x'=0}^{n - 1} \\lfloor k' \\cdot x' + b'\\rfloor$. We also assume that $k' \\geq 0$ and $b'\\geq 0$. Otherwise one should substitute $x'=-t$ and add $\\lceil|b'|\\rceil$ to $b'$.</p> <p>Let's discuss how we can evaluate a sum $\\sum\\limits_{x=0}^{n - 1} \\lfloor k \\cdot x + b\\rfloor$. We have two cases:</p> <ul> <li> <p>$k \\geq 1$ or $b \\geq 1$.</p> <p>Then we should start with summing up points below $y=\\lfloor k \\rfloor \\cdot x + \\lfloor b \\rfloor$. Their amount equals to</p> $$ \\sum\\limits_{x=0}^{n - 1} \\lfloor k \\rfloor \\cdot x + \\lfloor b \\rfloor=\\dfrac{(\\lfloor k \\rfloor(n-1)+2\\lfloor b \\rfloor) n}{2}. $$ <p>Now we are interested only in points $(x;y)$ such that $\\lfloor k \\rfloor \\cdot x + \\lfloor b \\rfloor &lt; y \\leq k\\cdot x + b$. This amount is the same as the number of points such that $0 &lt; y \\leq (k - \\lfloor k \\rfloor) \\cdot x + (b - \\lfloor b \\rfloor)$. So we reduced our problem to $k'= k - \\lfloor k \\rfloor$, $b' = b - \\lfloor b \\rfloor$ and both $k'$ and $b'$ less than $1$ now. Here is a picture, we just summed up blue points and subtracted the blue linear function from the black one to reduce problem to smaller values for $k$ and $b$:  </p> </li> <li> <p>$k &lt; 1$ and $b &lt; 1$.</p> <p>If $\\lfloor k \\cdot n + b\\rfloor$ equals $0$, we can safely return $0$. If this is not the case, we can say that there are no lattice points such that $x &lt; 0$ and $0 &lt; y \\leq k \\cdot x + b$. That means that we will have the same answer if we consider new reference system in which $O'=(n;\\lfloor k\\cdot n + b\\rfloor)$, axis $x'$ is directed down and axis $y'$ is directed to the left. For this reference system we are interested in lattice points on the set</p> $$ \\left\\{(x;y)~\\bigg|~0 \\leq x &lt; \\lfloor k \\cdot n + b\\rfloor,~ 0 &lt; y \\leq \\dfrac{x+(k\\cdot n+b)-\\lfloor k\\cdot n + b \\rfloor}{k}\\right\\} $$ <p>which returns us back to the case $k&gt;1$. You can see new reference point $O'$ and axes $X'$ and $Y'$ in the picture below:   As you see, in new reference system linear function will have coefficient $\\tfrac 1 k$ and its zero will be in the point $\\lfloor k\\cdot n + b \\rfloor-(k\\cdot n+b)$ which makes formula above correct.</p> </li> </ul>","tags":["Original"]},{"location":"geometry/lattice-points.html#complexity-analysis","title":"Complexity analysis","text":"<p>We have to count at most $\\dfrac{(k(n-1)+2b)n}{2}$ points. Among them we will count $\\dfrac{\\lfloor k \\rfloor (n-1)+2\\lfloor b \\rfloor}{2}$ on the very first step. We may consider that $b$ is negligibly small because we can start with making it less than $1$. In that case we cay say that we count about $\\dfrac{\\lfloor k \\rfloor}{k} \\geq \\dfrac 1 2$  of all points. Thus we will finish in $O(\\log n)$ steps.</p>","tags":["Original"]},{"location":"geometry/lattice-points.html#implementation","title":"Implementation","text":"<p>Here is simple function which calculates number of integer points $(x;y)$ such for $0 \\leq x &lt; n$ and $0 &lt; y \\leq \\lfloor k x+b\\rfloor$:</p> <pre><code>int count_lattices(Fraction k, Fraction b, long long n) {\n    auto fk = k.floor();\n    auto fb = b.floor();\n    auto cnt = 0LL;\n    if (k &gt;= 1 || b &gt;= 1) {\n        cnt += (fk * (n - 1) + 2 * fb) * n / 2;\n        k -= fk;\n        b -= fb;\n    }\n    auto t = k * n + b;\n    auto ft = t.floor();\n    if (ft &gt;= 1) {\n        cnt += count_lattices(1 / k, (t - t.floor()) / k, t.floor());\n    }\n    return cnt;\n}\n</code></pre> <p>Here <code>Fraction</code> is some class handling rational numbers. On practice it seems that if all denominators and numerators are at most $C$ by absolute value then in the recursive calls they will be at most $C^2$ if you keep dividing numerators and denominators by their greatest common divisor. Given this assumption we can say that one may use doubles and require accuracy of $\\varepsilon^2$ where $\\varepsilon$ is accuracy with which $k$ and $b$ are given. That means that in floor one should consider numbers as integer if they differs at most by $\\varepsilon^2$ from an integer.</p>","tags":["Original"]},{"location":"geometry/length-of-segments-union.html","title":"Length of the union of segments","text":"<p>Given $n$ segments on a line, each described by a pair of coordinates $(a_{i1}, a_{i2})$. We have to find the length of their union.</p> <p>The following algorithm was proposed by Klee in 1977. It works in $O(n\\log n)$ and has been proven to be the asymptotically optimal.</p>","tags":["Translated"]},{"location":"geometry/length-of-segments-union.html#solution","title":"Solution","text":"<p>We store in an array $x$ the endpoints of all the segments sorted by their values. And additionally we store whether it is a left end or a right end of a segment. Now we iterate over the array, keeping a counter $c$ of currently opened segments. Whenever the current element is a left end, we increase this counter, and otherwise we decrease it. To compute the answer, we take the length between the last to $x$ values $x_i - x_{i-1}$, whenever we come to a new coordinate, and there is currently at least one segment is open.</p>","tags":["Translated"]},{"location":"geometry/length-of-segments-union.html#implementation","title":"Implementation","text":"<pre><code>int length_union(const vector&lt;pair&lt;int, int&gt;&gt; &amp;a) {\n    int n = a.size();\n    vector&lt;pair&lt;int, bool&gt;&gt; x(n*2);\n    for (int i = 0; i &lt; n; i++) {\n        x[i*2] = {a[i].first, false};\n        x[i*2+1] = {a[i].second, true};\n    }\n\n    sort(x.begin(), x.end());\n\n    int result = 0;\n    int c = 0;\n    for (int i = 0; i &lt; n * 2; i++) {\n        if (i &gt; 0 &amp;&amp; x[i].first &gt; x[i-1].first &amp;&amp; c &gt; 0)\n            result += x[i].first - x[i-1].first;\n        if (x[i].second)\n            c--;\n        else\n            c++;\n    }\n    return result;\n}\n</code></pre>","tags":["Translated"]},{"location":"geometry/lines-intersection.html","title":"Intersection Point of Lines","text":"<p>You are given two lines, described via the equations $a_1 x + b_1 y + c_1 = 0$ and  $a_2 x + b_2 y + c_2 = 0$. We have to find the intersection point of the lines, or determine that the lines are parallel.</p>","tags":["Translated"]},{"location":"geometry/lines-intersection.html#solution","title":"Solution","text":"<p>If two lines are not parallel, they intersect. To find their intersection point, we need to solve the following system of linear equations:</p> $$\\begin{cases} a_1 x + b_1 y + c_1 = 0 \\\\ a_2 x + b_2 y + c_2 = 0 \\end{cases}$$ <p>Using Cramer's rule, we can immediately write down the solution for the system, which will give us the required intersection point of the lines:</p> $$x = - \\frac{\\begin{vmatrix}c_1 &amp; b_1 \\cr c_2 &amp; b_2\\end{vmatrix}}{\\begin{vmatrix}a_1 &amp; b_1 \\cr a_2 &amp; b_2\\end{vmatrix} } = - \\frac{c_1 b_2 - c_2 b_1}{a_1 b_2 - a_2 b_1},$$ $$y = - \\frac{\\begin{vmatrix}a_1 &amp; c_1 \\cr a_2 &amp; c_2\\end{vmatrix}}{\\begin{vmatrix}a_1 &amp; b_1 \\cr a_2 &amp; b_2\\end{vmatrix}} = - \\frac{a_1 c_2 - a_2 c_1}{a_1 b_2 - a_2 b_1}.$$ <p>If the denominator equals $0$, i.e.</p> $$\\begin{vmatrix}a_1 &amp; b_1 \\cr a_2 &amp; b_2\\end{vmatrix} = a_1 b_2 - a_2 b_1 = 0 $$ <p>then either the system has no solutions (the lines are parallel and distinct) or there are infinitely many solutions (the lines overlap). If we need to distinguish these two cases, we have to check if coefficients $c$ are proportional with the same ratio as the coefficients $a$ and $b$. To do that we only have calculate the following determinants, and if they both equal $0$, the lines overlap:</p> $$\\begin{vmatrix}a_1 &amp; c_1 \\cr a_2 &amp; c_2\\end{vmatrix}, \\begin{vmatrix}b_1 &amp; c_1 \\cr b_2 &amp; c_2\\end{vmatrix} $$ <p>Notice, a different approach for computing the intersection point is explained in the article Basic Geometry.</p>","tags":["Translated"]},{"location":"geometry/lines-intersection.html#implementation","title":"Implementation","text":"<pre><code>struct pt {\n    double x, y;\n};\n\nstruct line {\n    double a, b, c;\n};\n\nconst double EPS = 1e-9;\n\ndouble det(double a, double b, double c, double d) {\n    return a*d - b*c;\n}\n\nbool intersect(line m, line n, pt &amp; res) {\n    double zn = det(m.a, m.b, n.a, n.b);\n    if (abs(zn) &lt; EPS)\n        return false;\n    res.x = -det(m.c, m.b, n.c, n.b) / zn;\n    res.y = -det(m.a, m.c, n.a, n.c) / zn;\n    return true;\n}\n\nbool parallel(line m, line n) {\n    return abs(det(m.a, m.b, n.a, n.b)) &lt; EPS;\n}\n\nbool equivalent(line m, line n) {\n    return abs(det(m.a, m.b, n.a, n.b)) &lt; EPS\n        &amp;&amp; abs(det(m.a, m.c, n.a, n.c)) &lt; EPS\n        &amp;&amp; abs(det(m.b, m.c, n.b, n.c)) &lt; EPS;\n}\n</code></pre>","tags":["Translated"]},{"location":"geometry/manhattan-distance.html","title":"Manhattan Distance","text":"","tags":["Original"]},{"location":"geometry/manhattan-distance.html#definition","title":"Definition","text":"<p>For points $p$ and $q$ on a plane, we can define the distance between them as the sum of the differences between their $x$ and $y$ coordinates: </p> $$d(p,q) = |x_p - x_q| + |y_p - y_q|$$ <p>Defined this way, the distance corresponds to the so-called Manhattan (taxicab) geometry, in which the points are considered intersections in a well designed city, like Manhattan, where you can only move on the streets horizontally or vertically, as shown in the image below:</p> <p>This images show some of the smallest paths from one black point to the other, all of them with length $12$.</p> <p>There are some interesting tricks and algorithms that can be done with this distance, and we will show some of them here.</p>","tags":["Original"]},{"location":"geometry/manhattan-distance.html#farthest-pair-of-points-in-manhattan-distance","title":"Farthest pair of points in Manhattan distance","text":"<p>Given $n$ points $P$, we want to find the pair of points $p,q$ that are farther apart, that is, maximize $|x_p - x_q| + |y_p - y_q|$.</p> <p>Let's think first in one dimension, so $y=0$. The main observation is that we can bruteforce if $|x_p - x_q|$ is equal to $x_p - x_q$ or $-x_p + x_q$, because if we \"miss the sign\" of the absolute value, we will get only a smaller value, so it can't affect the answer. More formally, it holds that:</p> $$|x_p - x_q| = \\max(x_p - x_q, -x_p + x_q)$$ <p>So, for example, we can try to have $p$ such that $x_p$ has the plus sign, and then $q$ must have the negative sign. This way we want to find:</p> $$\\max\\limits_{p, q \\in P}(x_p + (-x_q)) = \\max\\limits_{p \\in P}(x_p) + \\max\\limits_{q \\in P}( - x_q ).$$ <p>Notice that we can extend this idea further for 2 (or more!) dimensions. For $d$ dimensions, we must bruteforce $2^d$ possible values of the signs. For example, if we are in $2$ dimensions and bruteforce that $p$ has both the plus signs we want to find: </p> $$\\max\\limits_{p, q \\in P} [(x_p + (-x_q)) + (y_p + (-y_q))] = \\max\\limits_{p \\in P}(x_p + y_p) + \\max\\limits_{q \\in P}(-x_q - y_q).$$ <p>As we made $p$ and $q$ independent, it is now easy to find the $p$ and $q$ that maximize the expression.</p> <p>The code below generalizes this to $d$ dimensions and runs in $O(n \\cdot 2^d \\cdot d)$.</p> <pre><code>long long ans = 0;\nfor (int msk = 0; msk &lt; (1 &lt;&lt; d); msk++) {\n    long long mx = LLONG_MIN, mn = LLONG_MAX;\n    for (int i = 0; i &lt; n; i++) {\n        long long cur = 0;\n        for (int j = 0; j &lt; d; j++) {\n            if (msk &amp; (1 &lt;&lt; j)) cur += p[i][j];\n            else cur -= p[i][j];\n        }\n        mx = max(mx, cur);\n        mn = min(mn, cur);\n    }\n    ans = max(ans, mx - mn);\n}\n</code></pre>","tags":["Original"]},{"location":"geometry/manhattan-distance.html#rotating-the-points-and-chebyshev-distance","title":"Rotating the points and Chebyshev distance","text":"<p>It's well known that, for all $m, n \\in \\mathbb{R}$,</p> $$|m| + |n| = \\text{max}(|m + n|, |m - n|).$$ <p>To prove this, we just need to analyze the signs of $m$ and $n$. And it's left as an exercise.</p> <p>We may apply this equation to the Manhattan distance formula to find out that</p> $$d((x_1, y_1), (x_2, y_2)) = |x_1 - x_2| + |y_1 - y_2| = \\text{max}(|(x_1 + y_1) - (x_2 + y_2)|, |(y_1 - x_1) - (y_2 - x_2)|).$$ <p>The last expression in the previous equation is the Chebyshev distance of the points $(x_1 + y_1, y_1 - x_1)$ and $(x_2 + y_2, y_2 - x_2)$. This means that, after applying the transformation</p> $$\\alpha : (x, y) \\to (x + y, y - x),$$ <p>the Manhattan distance between the points $p$ and $q$ turns into the Chebyshev distance between $\\alpha(p)$ and $\\alpha(q)$.</p> <p>Also, we may realize that $\\alpha$ is a spiral similarity (rotation of the plane followed by a dilation about a center $O$) with center $(0, 0)$, rotation angle of $45^{\\circ}$ in clockwise direction and dilation by $\\sqrt{2}$.</p> <p>Here's an image to help visualizing the transformation:</p>","tags":["Original"]},{"location":"geometry/manhattan-distance.html#manhattan-minimum-spanning-tree","title":"Manhattan Minimum Spanning Tree","text":"<p>The Manhattan MST problem consists of, given some points in the plane, find the edges that connect all the points and have a minimum total sum of weights. The weight of an edge that connects two points is their Manhattan distance. For simplicity, we assume that all points have different locations. Here we show a way of finding the MST in $O(n \\log{n})$ by finding for each point its nearest neighbor in each octant, as represented by the image below. This will give us $O(n)$ candidate edges, which, as we show below, will guarantee that they contain the MST. The final step is then using some standard MST, for example, Kruskal algorithm using disjoint set union.</p>    *The 8 octants relative to a point S*  <p>The algorithm shown here was first presented in a paper from H. Zhou, N. Shenoy, and W. Nichollos (2002). There is also another know algorithm that uses a Divide and conquer approach by J. Stolfi, which is also very interesting and only differ in the way they find the nearest neighbor in each octant. They both have the same complexity, but the one presented here is easier to implement and has a lower constant factor.</p> <p>First, let's understand why it is enough to consider only the nearest neighbor in each octant. The idea is to show that for a point $s$ and any two other points $p$ and $q$ in the same octant, $d(p, q) &lt; \\max(d(s, p), d(s, q))$. This is important, because it shows that if there was a MST where $s$ is connected to both $p$ and $q$, we could erase one of these edges and add the edge $(p,q)$, which would decrease the total cost. To prove this, we assume without loss of generality that $p$ and $q$ are in the octanct $R_1$, which is defined by: $x_s \\leq x$ and $x_s - y_s &gt; x -  y$, and then do some casework. The image below give some intuition on why this is true.</p>    *Intuitively, the limitation of the octant makes it impossible that $p$ and $q$ are both closer to $s$ than to each other*  <p>Therefore, the main question is how to find the nearest neighbor in each octant for every single of the $n$ points.</p>","tags":["Original"]},{"location":"geometry/manhattan-distance.html#nearest-neighbor-in-each-octant-in-on-log-n","title":"Nearest Neighbor in each Octant in O(n log n)","text":"<p>For simplicity we focus on the NNE octant ($R_1$ in the image above). All other directions can be found with the same algorithm by rotating the input.</p> <p>We will use a sweep-line approach. We process the points from south-west to north-east, that is, by non-decreasing $x + y$. We also keep a set of points which don't have their nearest neighbor yet, which we call \"active set\". We add the images below to help visualize the algorithm.</p>    *In black with an arrow you can see the direction of the line-sweep. All the points below this lines are in the active set, and the points above are still not processed. In green we see the points which are in the octant of the processed point. In red the points that are not in the searched octant.*     *In this image we see the active set after processing the point $p$. Note that the $2$ green points of the previous image had $p$ in its north-north-east octant and are not in the active set anymore, because they already found their nearest neighbor.*  <p>When we add a new point point $p$, for every point $s$ that has it in its octant we can safely assign $p$ as the nearest neighbor. This is true because their distance is $d(p,s) = |x_p - x_s| + |y_p - y_s| = (x_p + y_p) - (x_s + y_s)$, because $p$ is in the north-north-east octant. As all the next points will not have a smaller value of $x + y$ because of the sorting step, $p$ is guaranteed to have the smaller distance. We can then remove all such points from the active set, and finally add $p$ to the active set.</p> <p>The next question is how to efficiently find which points $s$ have $p$ in the north-north-east octant. That is, which points $s$ satisfy:</p> <ul> <li>$x_s \\leq x_p$</li> <li>$x_p - y_p &lt; x_s - y_s$</li> </ul> <p>Because no points in the active set are in the $R_1$ region of another, we also have that for two points $q_1$ and $q_2$ in the active set, $x_{q_1} \\neq x_{q_2}$ and their ordering implies $x_{q_1} &lt; x_{q_2} \\implies x_{q_1} - y_{q_1} \\leq x_{q_2} - y_{q_2}$.</p> <p>You can try to visualize this on the images above by thinking of the ordering of $x - y$ as a \"sweep-line\" that goes from the north-west to the south-east, so perpendicular to the one that is drawn.</p> <p>This means that if we keep the active set ordered by $x$ the candidates $s$ are consecutively placed. We can then find the largest $x_s \\leq x_p$ and process the points in decreasing order of $x$ until the second condition $x_p - y_p &lt; x_s - y_s$ breaks (we can actually allow that $x_p - y_p = x_s - y_s$ and that deals with the case of points with equal coordinates). Notice that because we remove from the set right after processing, this will have an amortized complexity of $O(n \\log(n))$.     Now that we have the nearest point in the north-east direction, we rotate the points and repeat. It is possible to show that actually we also find this way the nearest point in the south-west direction, so we can repeat only 4 times, instead of 8.</p> <p>In summary we:</p> <ul> <li>Sort the points by $x + y$ in non-decreasing order;</li> <li>For every point, we iterate over the active set starting with the point with the largest $x$ such that $x \\leq x_p$, and we break the loop if  $x_p - y_p \\geq x_s - y_s$. For every valid point $s$ we add the edge $(s,p, d(s,p))$ in our list;</li> <li>We add the point $p$ to the active set;</li> <li>Rotate the points and repeat until we iterate over all the octants.</li> <li>Apply Kruskal algorithm in the list of edges to get the MST. </li> </ul> <p>Below you can find a implementation, based on the one from KACTL.</p> <pre><code>struct point {\n    long long x, y;\n};\n\n// Returns a list of edges in the format (weight, u, v). \n// Passing this list to Kruskal algorithm will give the Manhattan MST.\nvector&lt;tuple&lt;long long, int, int&gt;&gt; manhattan_mst_edges(vector&lt;point&gt; ps) {\n    vector&lt;int&gt; ids(ps.size());\n    iota(ids.begin(), ids.end(), 0);\n    vector&lt;tuple&lt;long long, int, int&gt;&gt; edges;\n    for (int rot = 0; rot &lt; 4; rot++) { // for every rotation\n        sort(ids.begin(), ids.end(), [&amp;](int i, int j){\n            return (ps[i].x + ps[i].y) &lt; (ps[j].x + ps[j].y);\n        });\n        map&lt;int, int, greater&lt;int&gt;&gt; active; // (xs, id)\n        for (auto i : ids) {\n            for (auto it = active.lower_bound(ps[i].x); it != active.end();\n            active.erase(it++)) {\n                int j = it-&gt;second;\n                if (ps[i].x - ps[i].y &gt; ps[j].x - ps[j].y) break;\n                assert(ps[i].x &gt;= ps[j].x &amp;&amp; ps[i].y &gt;= ps[j].y);\n                edges.push_back({(ps[i].x - ps[j].x) + (ps[i].y - ps[j].y), i, j});\n            }\n            active[ps[i].x] = i;\n        }\n        for (auto &amp;p : ps) { // rotate\n            if (rot &amp; 1) p.x *= -1;\n            else swap(p.x, p.y);\n        }\n    }\n    return edges;\n}\n</code></pre>","tags":["Original"]},{"location":"geometry/manhattan-distance.html#problems","title":"Problems","text":"<ul> <li>AtCoder Beginner Contest 178E - Dist Max</li> <li>CodeForces 1093G - Multidimensional Queries</li> <li>CodeForces 944F - Game with Tokens</li> <li>AtCoder Code Festival 2017D - Four Coloring</li> <li>The 2023 ICPC Asia EC Regionals Online Contest (I) - J. Minimum Manhattan Distance</li> <li>Petrozavodsk Winter Training Camp 2016 Contest 4 - B. Airports</li> </ul>","tags":["Original"]},{"location":"geometry/minkowski.html","title":"Minkowski sum of convex polygons","text":"","tags":["Original"]},{"location":"geometry/minkowski.html#definition","title":"Definition","text":"<p>Consider two sets $A$ and $B$ of points on a plane. Minkowski sum $A + B$ is defined as $\\{a + b| a \\in A, b \\in B\\}$. Here we will consider the case when $A$ and $B$ consist of convex polygons $P$ and $Q$ with their interiors. Throughout this article we will identify polygons with ordered sequences of their vertices, so that notation like $|P|$ or $P_i$ makes sense. It turns out that the sum of convex polygons $P$ and $Q$ is a convex polygon with at most $|P| + |Q|$ vertices.</p>","tags":["Original"]},{"location":"geometry/minkowski.html#algorithm","title":"Algorithm","text":"<p>Here we consider the polygons to be cyclically enumerated, i. e. $P_{|P|} = P_0,\\ Q_{|Q|} = Q_0$ and so on.</p> <p>Since the size of the sum is linear in terms of the sizes of initial polygons, we should aim at finding a linear-time algorithm. Suppose that both polygons are ordered counter-clockwise. Consider sequences of edges $\\{\\overrightarrow{P_iP_{i+1}}\\}$ and $\\{\\overrightarrow{Q_jQ_{j+1}}\\}$ ordered by polar angle. We claim that the sequence of edges of $P + Q$ can be obtained by merging these two sequences preserving polar angle order and replacing consecutive co-directed vectors with their sum. Straightforward usage of this idea results in a linear-time algorithm, however, restoring the vertices of $P + Q$ from the sequence of sides requires repeated addition of vectors, which may introduce unwanted precision issues if we're working with floating-point coordinates, so we will describe a slight modification of this idea.</p> <p>Firstly we should reorder the vertices in such a way that the first vertex of each polygon has the lowest y-coordinate (in case of several such vertices pick the one with the smallest x-coordinate). After that the sides of both polygons will become sorted by polar angle, so there is no need to sort them manually. Now we create two pointers $i$ (pointing to a vertex of $P$) and $j$ (pointing to a vertex of $Q$), both initially set to 0. We repeat the following steps while $i &lt; |P|$ or $j &lt; |Q|$.</p> <ol> <li> <p>Append $P_i + Q_j$ to $P + Q$.</p> </li> <li> <p>Compare polar angles of $\\overrightarrow{P_iP_{i + 1}}$ and $\\overrightarrow{Q_jQ_{j+1}}$.</p> </li> <li> <p>Increment the pointer which corresponds to the smallest angle (if the angles are equal, increment both).</p> </li> </ol>","tags":["Original"]},{"location":"geometry/minkowski.html#visualization","title":"Visualization","text":"<p>Here is a nice visualization, which may help you understand what is going on.</p>","tags":["Original"]},{"location":"geometry/minkowski.html#distance-between-two-polygons","title":"Distance between two polygons","text":"<p>One of the most common applications of Minkowski sum is computing the distance between two convex polygons (or simply checking whether they intersect). The distance between two convex polygons $P$ and $Q$ is defined as $\\min\\limits_{a \\in P, b \\in Q} ||a - b||$. One can note that the distance is always attained between two vertices or a vertex and an edge, so we can easily find the distance in $O(|P||Q|)$. However, with clever usage of Minkowski sum we can reduce the complexity to $O(|P| + |Q|)$.</p> <p>If we reflect $Q$ through the point $(0, 0)$ obtaining polygon $-Q$, the problem boils down to finding the smallest distance between a point in $P + (-Q)$ and $(0, 0)$. We can find that distance in linear time using the following idea. If $(0, 0)$ is inside or on the boundary of polygon, the distance is $0$, otherwise the distance is attained between $(0, 0)$ and some vertex or edge of the polygon. Since Minkowski sum can be computed in linear time, we obtain a linear-time algorithm for finding the distance between two convex polygons.</p>","tags":["Original"]},{"location":"geometry/minkowski.html#implementation","title":"Implementation","text":"<p>Below is the implementation of Minkowski sum for polygons with integer points. Note that in this case all computations can be done in integers since instead of computing polar angles and directly comparing them we can look at the sign of cross product of two vectors.</p> <pre><code>struct pt{\n    long long x, y;\n    pt operator + (const pt &amp; p) const {\n        return pt{x + p.x, y + p.y};\n    }\n    pt operator - (const pt &amp; p) const {\n        return pt{x - p.x, y - p.y};\n    }\n    long long cross(const pt &amp; p) const {\n        return x * p.y - y * p.x;\n    }\n};\n\nvoid reorder_polygon(vector&lt;pt&gt; &amp; P){\n    size_t pos = 0;\n    for(size_t i = 1; i &lt; P.size(); i++){\n        if(P[i].y &lt; P[pos].y || (P[i].y == P[pos].y &amp;&amp; P[i].x &lt; P[pos].x))\n            pos = i;\n    }\n    rotate(P.begin(), P.begin() + pos, P.end());\n}\n\nvector&lt;pt&gt; minkowski(vector&lt;pt&gt; P, vector&lt;pt&gt; Q){\n    // the first vertex must be the lowest\n    reorder_polygon(P);\n    reorder_polygon(Q);\n    // we must ensure cyclic indexing\n    P.push_back(P[0]);\n    P.push_back(P[1]);\n    Q.push_back(Q[0]);\n    Q.push_back(Q[1]);\n    // main part\n    vector&lt;pt&gt; result;\n    size_t i = 0, j = 0;\n    while(i &lt; P.size() - 2 || j &lt; Q.size() - 2){\n        result.push_back(P[i] + Q[j]);\n        auto cross = (P[i + 1] - P[i]).cross(Q[j + 1] - Q[j]);\n        if(cross &gt;= 0 &amp;&amp; i &lt; P.size() - 2)\n            ++i;\n        if(cross &lt;= 0 &amp;&amp; j &lt; Q.size() - 2)\n            ++j;\n    }\n    return result;\n}\n</code></pre>","tags":["Original"]},{"location":"geometry/minkowski.html#problems","title":"Problems","text":"<ul> <li>Codeforces 87E Mogohu-Rea Idol</li> <li>Codeforces 1195F Geometers Anonymous Club</li> <li>TIMUS 1894 Non-Flying Weather</li> </ul>","tags":["Original"]},{"location":"geometry/nearest_points.html","title":"Finding the nearest pair of points","text":"","tags":["Translated"]},{"location":"geometry/nearest_points.html#problem-statement","title":"Problem statement","text":"<p>Given $n$ points on the plane. Each point $p_i$ is defined by its coordinates $(x_i,y_i)$. It is required to find among them two such points, such that the distance between them is minimal:</p> $$ \\min_{\\scriptstyle i, j=0 \\ldots n-1,\\atop \\scriptstyle i \\neq j } \\rho (p_i, p_j). $$ <p>We take the usual Euclidean distances:</p> $$ \\rho (p_i,p_j) = \\sqrt{(x_i-x_j)^2 + (y_i-y_j)^2} .$$ <p>The trivial algorithm - iterating over all pairs and calculating the distance for each \u2014 works in $O(n^2)$. </p> <p>The algorithm running in time $O(n \\log n)$ is described below. This algorithm was proposed by Shamos and Hoey in 1975. (Source: Ch. 5 Notes of Algorithm Design by Kleinberg &amp; Tardos, also see here) Preparata and Shamos also showed that this algorithm is optimal in the decision tree model.</p>","tags":["Translated"]},{"location":"geometry/nearest_points.html#algorithm","title":"Algorithm","text":"<p>We construct an algorithm according to the general scheme of divide-and-conquer algorithms: the algorithm is designed as a recursive function, to which we pass a set of points; this recursive function splits this set in half, calls itself recursively on each half, and then performs some operations to combine the answers. The operation of combining consist of  detecting the cases when one point of the optimal solution fell into one half, and the other point into the other (in this case, recursive calls from each of the halves cannot detect this pair separately). The main difficulty, as always in case of divide and conquer algorithms, lies in the effective implementation of the merging stage. If a set of $n$ points is passed to the recursive function, then the merge stage should work no more than $O(n)$, then the asymptotics of the whole algorithm $T(n)$ will be found from the equation:</p> $$T(n) = 2T(n/2) + O(n).$$ <p>The solution to this equation, as is known, is $T(n) = O(n \\log n).$</p> <p>So, we proceed on to the construction of the algorithm. In order to come to an effective implementation of the merge stage in the future, we will divide the set of points into two subsets, according to their $x$-coordinates: In fact, we draw some vertical line dividing the set of points into two subsets of approximately the same size. It is convenient to make such a partition as follows: We sort the points in the standard way as pairs of numbers, ie.:</p> $$p_i &lt; p_j \\Longleftrightarrow (x_i &lt; x_j) \\lor \\Big(\\left(x_i = x_j\\right) \\wedge \\left(y_i &lt; y_j \\right) \\Big) $$ <p>Then take the middle point after sorting $p_m (m = \\lfloor n/2 \\rfloor)$, and all the points before it and the $p_m$ itself are assigned to the first half, and all the points after it - to the second half:</p> $$A_1 = \\{p_i \\ | \\ i = 0 \\ldots m \\}$$ $$A_2 = \\{p_i \\ | \\ i = m + 1 \\ldots n-1 \\}.$$ <p>Now, calling recursively on each of the sets $A_1$ and $A_2$, we will find the answers $h_1$ and $h_2$ for each of the halves. And take the best of them: $h = \\min(h_1, h_2)$.</p> <p>Now we need to make a merge stage, i.e. we try to find such pairs of points, for which the distance between which is less than $h$ and one point is lying in $A_1$ and the other in $A_2$. It is obvious that it is sufficient to consider only those points that are separated from the vertical line by a distance less than $h$, i.e. the set $B$ of the points considered at this stage is equal to:</p> $$B = \\{ p_i\\ | \\ | x_i - x_m\\ | &lt; h \\}.$$ <p>For each point in the set $B$, we try to find the points that are closer to it than $h$. For example, it is sufficient to consider only those points whose $y$-coordinate differs by no more than $h$. Moreover, it makes no sense to consider those points whose $y$-coordinate is greater than the $y$-coordinate of the current point. Thus, for each point $p_i$ we define the set of considered points $C(p_i)$ as follows:</p> $$C(p_i) = \\{ p_j\\ |\\ p_j \\in B,\\ \\ y_i - h &lt; y_j \\le y_i \\}.$$ <p>If we sort the points of the set $B$ by $y$-coordinate, it will be very easy to find $C(p_i)$: these are several points in a row ahead to the point $p_i$.</p> <p>So, in the new notation, the merging stage looks like this: build a set $B$, sort the points in it by $y$-coordinate, then for each point $p_i \\in B$ consider all points $p_j \\in C(p_i)$, and for each pair $(p_i,p_j)$ calculate the distance and compare with the current best distance.</p> <p>At first glance, this is still a non-optimal algorithm: it seems that the sizes of sets $C(p_i)$ will be of order $n$, and the required asymptotics will not work. However, surprisingly, it can be proved that the size of each of the sets $C(p_i)$ is a quantity $O(1)$, i.e. it does not exceed some small constant regardless of the points themselves. Proof of this fact is given in the next section.</p> <p>Finally, we pay attention to the sorting, which the above algorithm contains: first,sorting by pairs $(x, y)$, and then second, sorting the elements of the set $B$ by $y$. In fact, both of these sorts inside the recursive function can be eliminated (otherwise we would not reach the $O(n)$ estimate for the merging stage, and the general asymptotics of the algorithm would be $O(n \\log^2 n)$). It is easy to get rid of the first sort \u2014 it is enough to perform this sort before starting the recursion: after all, the elements themselves do not change inside the recursion, so there is no need to sort again. With the second sorting a little more difficult to perform, performing it previously will not work. But, remembering the merge sort, which also works on the principle of divide-and-conquer, we can simply embed this sort in our recursion. Let recursion, taking some set of points (as we remember,ordered by pairs $(x, y)$), return the same set, but sorted by the $y$-coordinate. To do this, simply merge (in $O(n)$) the two results returned by recursive calls. This will result in a set sorted by $y$-coordinate.</p>","tags":["Translated"]},{"location":"geometry/nearest_points.html#evaluation-of-the-asymptotics","title":"Evaluation of the asymptotics","text":"<p>To show that the above algorithm is actually executed in $O(n \\log n)$, we need to prove the following fact: $|C(p_i)| = O(1)$.</p> <p>So, let us consider some point $p_i$; recall that the set $C(p_i)$ is a set of points whose $y$-coordinate lies in the segment $[y_i-h; y_i]$, and, moreover, along the $x$ coordinate, the point $p_i$ itself, and all the points of the set $C(p_i)$ lie in the band width $2h$. In other words, the points we are considering $p_i$ and $C(p_i)$ lie in a rectangle of size $2h \\times h$.</p> <p>Our task is to estimate the maximum number of points that can lie in this rectangle $2h \\times h$; thus, we estimate the maximum size of the set $C(p_i)$. At the same time, when evaluating, we must not forget that there may be repeated points.</p> <p>Remember that $h$ was obtained from the results of two recursive calls \u2014 on sets $A_1$ and $A_2$, and $A_1$ contains points to the left of the partition line and partially on it, $A_2$ contains the remaining points of the partition line and points to the right of it. For any pair of points from $A_1$, as well as from $A_2$, the distance can not be less than $h$ \u2014 otherwise it would mean incorrect operation of the recursive function.</p> <p>To estimate the maximum number of points in the rectangle $2h \\times h$ we divide it into two squares $h \\times h$, the first square include all points $C(p_i) \\cap A_1$, and the second contains all the others, i.e. $C(p_i) \\cap A_2$. It follows from the above considerations that in each of these squares the distance between any two points is at least $h$.</p> <p>We show that there are at most four points in each square. For example, this can be done as follows: divide the square into $4$ sub-squares with sides $h/2$. Then there can be no more than one point in each of these sub-squares (since even the diagonal is equal to $h / \\sqrt{2}$, which is less than $h$). Therefore, there can be no more than $4$ points in the whole square.</p> <p>So, we have proved that in a rectangle $2h \\times h$ can not be more than $4 \\cdot 2 = 8$ points, and, therefore, the size of the set $C(p_i)$ cannot exceed $7$, as required.</p>","tags":["Translated"]},{"location":"geometry/nearest_points.html#implementation","title":"Implementation","text":"<p>We introduce a data structure to store a point (its coordinates and a number) and comparison operators required for two types of sorting:</p> <pre><code>struct pt {\n    int x, y, id;\n};\n\nstruct cmp_x {\n    bool operator()(const pt &amp; a, const pt &amp; b) const {\n        return a.x &lt; b.x || (a.x == b.x &amp;&amp; a.y &lt; b.y);\n    }\n};\n\nstruct cmp_y {\n    bool operator()(const pt &amp; a, const pt &amp; b) const {\n        return a.y &lt; b.y;\n    }\n};\n\nint n;\nvector&lt;pt&gt; a;\n</code></pre> <p>For a convenient implementation of recursion, we introduce an auxiliary function upd_ans(), which will calculate the distance between two points and check whether it is better than the current answer:</p> <pre><code>double mindist;\npair&lt;int, int&gt; best_pair;\n\nvoid upd_ans(const pt &amp; a, const pt &amp; b) {\n    double dist = sqrt((a.x - b.x)*(a.x - b.x) + (a.y - b.y)*(a.y - b.y));\n    if (dist &lt; mindist) {\n        mindist = dist;\n        best_pair = {a.id, b.id};\n    }\n}\n</code></pre> <p>Finally, the implementation of the recursion itself. It is assumed that before calling it, the array $a[]$ is already sorted by $x$-coordinate. In recursion we pass just two pointers $l, r$, which indicate that it should look for the answer for $a[l \\ldots r)$. If the distance between $r$ and $l$ is too small, the recursion must be stopped, and perform a trivial algorithm to find the nearest pair and then sort the subarray by $y$-coordinate.</p> <p>To merge two sets of points received from recursive calls into one (ordered by $y$-coordinate), we use the standard STL $merge()$ function, and create an auxiliary buffer $t[]$(one for all recursive calls). (Using inplace_merge () is impractical because it generally does not work in linear time.)</p> <p>Finally, the set $B$ is stored in the same array $t$.</p> <pre><code>vector&lt;pt&gt; t;\n\nvoid rec(int l, int r) {\n    if (r - l &lt;= 3) {\n        for (int i = l; i &lt; r; ++i) {\n            for (int j = i + 1; j &lt; r; ++j) {\n                upd_ans(a[i], a[j]);\n            }\n        }\n        sort(a.begin() + l, a.begin() + r, cmp_y());\n        return;\n    }\n\n    int m = (l + r) &gt;&gt; 1;\n    int midx = a[m].x;\n    rec(l, m);\n    rec(m, r);\n\n    merge(a.begin() + l, a.begin() + m, a.begin() + m, a.begin() + r, t.begin(), cmp_y());\n    copy(t.begin(), t.begin() + r - l, a.begin() + l);\n\n    int tsz = 0;\n    for (int i = l; i &lt; r; ++i) {\n        if (abs(a[i].x - midx) &lt; mindist) {\n            for (int j = tsz - 1; j &gt;= 0 &amp;&amp; a[i].y - t[j].y &lt; mindist; --j)\n                upd_ans(a[i], t[j]);\n            t[tsz++] = a[i];\n        }\n    }\n}\n</code></pre> <p>By the way, if all the coordinates are integer, then at the time of the recursion you can not move to fractional values, and store in $mindist$ the square of the minimum distance.</p> <p>In the main program, recursion should be called as follows:</p> <pre><code>t.resize(n);\nsort(a.begin(), a.end(), cmp_x());\nmindist = 1E20;\nrec(0, n);\n</code></pre>","tags":["Translated"]},{"location":"geometry/nearest_points.html#linear-time-randomized-algorithms","title":"Linear time randomized algorithms","text":"","tags":["Translated"]},{"location":"geometry/nearest_points.html#a-randomized-algorithm-with-linear-expected-time","title":"A randomized algorithm with linear expected time","text":"<p>An alternative method, originally proposed by Rabin in 1976, arises from a very simple idea to heuristically improve the runtime: We can divide the plane into a grid of $d \\times d$ squares, then it is only required to test distances between same-block or adjacent-block points (unless all squares are disconnected from each other, but we will avoid this by design), since any other pair has a larger distance than the two points in the same square.</p> <p>We will consider only the squares containing at least one point. Denote by $n_1, n_2, \\dots, n_k$ the number of points in each of the $k$ remaining squares. Assuming at least two points are in the same or in adjacent squares, and that there are no duplicated points, the time complexity is $\\Theta\\!\\left(\\sum\\limits_{i=1}^k n_i^2\\right)$. We can look for duplicated points in expected linear time using a hash table, and in the affirmative case, the answer is this pair.</p> Proof <p>For the $i$-th square containing $n_i$ points, the number of pairs inside is $\\Theta(n_i^2)$. If the $i$-th square is adjacent to the $j$-th square, then we also perform $n_i n_j \\le \\max(n_i, n_j)^2 \\le n_i^2 + n_j^2$ distance comparisons. Notice that each square has at most $8$ adjacent squares, so we can bound the sum of all comparisons by $\\Theta(\\sum_{i=1}^{k} n_i^2)$. $\\quad \\blacksquare$</p> <p>Now we need to decide on how to set $d$ so that it minimizes $\\Theta\\!\\left(\\sum\\limits_{i=1}^k n_i^2\\right)$.</p>","tags":["Translated"]},{"location":"geometry/nearest_points.html#choosing-d","title":"Choosing d","text":"<p>We need $d$ to be an approximation of the minimum distance $d$. Richard Lipton proposed to sample $n$ distances randomly and choose $d$ to be the smallest of these distances as an approximation for $d$. We now prove that the expected running time of the algorithm is linear.</p> Proof <p>Imagine the disposition of points in squares with a particular choice of $d$, say $x$. Consider $d$ a random variable, resulting from our sampling of distances. Let's define $C(x) := \\sum_{i=1}^{k(x)} n_i(x)^2$ as the cost estimation for a particular disposition when we choose $d=x$. Now, let's define $\\lambda(x)$ such that $C(x) = \\lambda(x) \\, n$. What is the probability that such choice $x$ survives the sampling of $n$ independent distances? If a single pair among the sampled ones has distance smaller than $x$, this arrangement will be replaced by the smaller $d$. Inside a square, about $1/16$ of the pairs would raise a smaller distance (imagine four subsquares in every square; using the pigeonhole principle, at least one subsquare has $n_i/4$ points), so we have about $\\sum_{i=1}^{k} {n_i/4 \\choose 2} \\approx \\sum_{i=1}^{k} \\frac{1}{16} {n_i \\choose 2}$ pairs which yield a smaller final $d$. This is, approximately, $\\frac{1}{32} \\sum_{i=1}^{k} n_i^2 = \\frac{1}{32} \\lambda(x) n$. On the other hand, there are about $\\frac{1}{2} n^2$ pairs that can be sampled. We have that the probability of sampling a pair with distance smaller than $x$ is at least (approximately) </p> $$\\frac{\\lambda(x) \\, n / 32}{n^2 / 2} = \\frac{\\lambda(x)/16}{n}$$ <p>so the probability of at least one such pair being chosen during the $n$ rounds (and therefore finding a smaller $d$) is </p> $$1 - \\left(1 - \\frac{\\lambda(x)/16}{n}\\right)^n \\ge 1 - e^{-\\lambda(x)/16}$$ <p>(we have used that $(1 + x)^n \\le e^{xn}$ for any real number $x$, check Bernoulli inequalities).  Notice this goes to $1$ exponentially as $\\lambda(x)$ increases. This hints that $\\lambda$ will be small for a poorly chosen $d$.</p> <p>We have shown that $\\Pr(d \\le x) \\ge 1 - e^{-\\lambda(x)/16}$, or equivalently, $\\Pr(d \\ge x) \\le e^{-\\lambda(x)/16}$. We need to know $\\Pr(\\lambda(d) \\ge \\text{something})$ to be able to estimate its expected value. We notice that $\\lambda(d) \\ge \\lambda(x) \\iff d \\ge x$. This is because making the squares smaller only reduces the number of points in each square (splits the points into other squares), and this keeps reducing the sum of squares. Therefore,</p> $$\\Pr(\\lambda(d) \\ge \\lambda(x)) = \\Pr(d \\ge x) \\le e^{-\\lambda(x)/16} \\implies \\Pr(\\lambda(d) \\ge t) \\le e^{-t/16} \\implies \\mathbb{E}[\\lambda(d)] \\le \\int_{0}^{+\\infty} e^{-t/16} \\, \\mathrm{d}t = 16$$ <p>(we have used that $E[X] = \\int_0^{+\\infty} \\Pr(X \\ge x) \\, \\mathrm{d}x$, check Stackexchange proof).</p> <p>Finally, $\\mathbb{E}[C(d)] = \\mathbb{E}[\\lambda(d) \\, n] \\le 16n$, and the expected running time is $O(n)$, with a reasonable constant factor. $\\quad \\blacksquare$</p>","tags":["Translated"]},{"location":"geometry/nearest_points.html#implementation-of-the-algorithm","title":"Implementation of the algorithm","text":"<p>The advantage of this algorithm is that it is straightforward to implement, but still has good performance in practise. We first sample $n$ distances and set $d$ as the minimum of the distances. Then we insert points into the \"blocks\" by using a hash table from 2D coordinates to a vector of points. Finally, just compute distances between same-block pairs and adjacent-block pairs. Hash table operations have $O(1)$ expected time cost, and therefore our algorithm retains the $O(n)$ expected time cost with an increased constant.</p> <p>Check out this submission to Library Checker.</p> <pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n\n\nusing ll = long long;\nusing ld = long double;\n\n\nstruct pt {\n    ll x, y;\n    pt() {}\n    pt(ll x_, ll y_) : x(x_), y(y_) {}\n    void read() {\n        cin &gt;&gt; x &gt;&gt; y;\n    }\n};\n\nbool operator==(const pt&amp; a, const pt&amp; b) {\n    return a.x == b.x and a.y == b.y;\n}\n\n\nstruct CustomHashPoint {\n    size_t operator()(const pt&amp; p) const {\n        static const uint64_t C = chrono::steady_clock::now().time_since_epoch().count();\n        return C ^ ((p.x &lt;&lt; 32) ^ p.y);\n    }\n};\n\n\nll dist2(pt a, pt b) {\n    ll dx = a.x - b.x;\n    ll dy = a.y - b.y;\n    return dx*dx + dy*dy;\n}\n\n\npair&lt;int,int&gt; closest_pair_of_points(vector&lt;pt&gt; P) {\n    int n = int(P.size());\n    assert(n &gt;= 2);\n\n    // if there is a duplicated point, we have the solution\n    unordered_map&lt;pt,int,CustomHashPoint&gt; previous;\n    for (int i = 0; i &lt; int(P.size()); ++i) {\n        auto it = previous.find(P[i]);\n        if (it != previous.end()) {\n            return {it-&gt;second, i};\n        }\n        previous[P[i]] = i;\n    }\n\n    unordered_map&lt;pt,vector&lt;int&gt;,CustomHashPoint&gt; grid;\n    grid.reserve(n);\n\n    mt19937 rd(chrono::system_clock::now().time_since_epoch().count());\n    uniform_int_distribution&lt;int&gt; dis(0, n-1);\n\n    ll d2 = dist2(P[0], P[1]);\n    pair&lt;int,int&gt; closest = {0, 1};\n\n    auto candidate_closest = [&amp;](int i, int j) -&gt; void {\n        ll ab2 = dist2(P[i], P[j]);\n        if (ab2 &lt; d2) {\n            d2 = ab2;\n            closest = {i, j};\n        }\n    };\n\n    for (int i = 0; i &lt; n; ++i) {\n        int j = dis(rd);\n        int k = dis(rd);\n        while (j == k) k = dis(rd);\n        candidate_closest(j, k);\n    }\n\n    ll d = ll( sqrt(ld(d2)) + 1 );\n\n    for (int i = 0; i &lt; n; ++i) {\n        grid[{P[i].x/d, P[i].y/d}].push_back(i);\n    }\n\n    // same block\n    for (const auto&amp; it : grid) {\n        int k = int(it.second.size());\n        for (int i = 0; i &lt; k; ++i) {\n            for (int j = i+1; j &lt; k; ++j) {\n                candidate_closest(it.second[i], it.second[j]);\n            }\n        }\n    }\n\n    // adjacent blocks\n    for (const auto&amp; it : grid) {\n        auto coord = it.first;\n        for (int dx = 0; dx &lt;= 1; ++dx) {\n            for (int dy = -1; dy &lt;= 1; ++dy) {\n                if (dx == 0 and dy == 0) continue;\n                pt neighbour = pt(\n                    coord.x  + dx, \n                    coord.y + dy\n                );\n                for (int i : it.second) {\n                    if (not grid.count(neighbour)) continue;\n                    for (int j : grid.at(neighbour)) {\n                        candidate_closest(i, j);\n                    }\n                }\n            }\n        }\n    }\n\n    return closest;\n}\n</code></pre>","tags":["Translated"]},{"location":"geometry/nearest_points.html#an-alternative-randomized-linear-expected-time-algorithm","title":"An alternative randomized linear expected time algorithm","text":"<p>Now we introduce a different randomized algorithm which is less practical but very easy to show that it runs in expected linear time.</p> <ul> <li>Permute the $n$ points randomly</li> <li>Take $\\delta := \\operatorname{dist}(p_1, p_2)$</li> <li>Partition the plane in squares of side $\\delta/2$</li> <li>For $i = 1,2,\\dots,n$:<ul> <li>Take the square corresponding to $p_i$</li> <li>Iterate over the $25$ squares within two steps to our square in the grid of squares partitioning the plane</li> <li>If some $p_j$ in those squares has $\\operatorname{dist}(p_j, p_i) &lt; \\delta$, then<ul> <li>Recompute the partition and squares with $\\delta := \\operatorname{dist}(p_j, p_i)$</li> <li>Store points $p_1, \\dots, p_i$ in the corresponding squares</li> </ul> </li> <li>else, store $p_i$ in the corresponding square</li> </ul> </li> <li>output $\\delta$</li> </ul> <p>The correctness follows from the fact that at any moment we already have some pair with distance $\\delta$, so we try to find only new pairs with distance smaller than $\\delta$. Since each square has side $\\delta/2$, a candidate pair can be at most at a distance of $2$ squares, so for a given point we check candidates in the surrounding $25$ squares. Any point in a square further away will always give a distace larger than $\\delta$.</p> <p>While this algorithm may look slow, because of recomputing everything multiple times, we can show the total expected cost is linear. </p> Proof <p>Let $X_i$ the random variable that is $1$ when point $p_i$ causes a change of $\\delta$ and a recomputation of the data structures, and $0$ if not. It is easy to show that the cost is $O(n + \\sum_{i=1}^{n} i X_i)$, since on the $i$-th step we are considering only the first $i$ points. However, turns out that $\\Pr(X_i = 1) \\le \\frac{2}{i}$. This is because on the $i$-th step, $\\delta$ is the distance of the closest pair in $\\{p_1,\\dots,p_i\\}$, and $\\Pr(X_i = 1)$ is the probability of $p_i$ belonging to the closest pair, which only happens in $2(i-1)$ pairs out of the $i(i-1)$ possible pairs (assuming all distances are different), so the probability is at most $\\frac{2(i-1)}{i(i-1)} = \\frac{2}{i}$, since we previously shuffled the points uniformly.</p> <p>We can therefore see that the expected cost is </p> $$O\\!\\left(n + \\sum_{i=1}^{n} i \\Pr(X_i = 1)\\right) \\le O\\!\\left(n + \\sum_{i=1}^{n} i \\frac{2}{i}\\right) = O(3n) = O(n) \\quad \\quad \\blacksquare$$","tags":["Translated"]},{"location":"geometry/nearest_points.html#generalization-finding-a-triangle-with-minimal-perimeter","title":"Generalization: finding a triangle with minimal perimeter","text":"<p>The algorithm described above is interestingly generalized to this problem: among a given set of points, choose three different points so that the sum of pairwise distances between them is the smallest.</p> <p>In fact, to solve this problem, the algorithm remains the same: we divide the field into two halves of the vertical line, call the solution recursively on both halves, choose the minimum $minper$ from the found perimeters, build a strip with the thickness of $minper / 2$, and iterate through all triangles that can improve the answer. (Note that the triangle with perimeter $\\le minper$ has the longest side $\\le minper / 2$.)</p>","tags":["Translated"]},{"location":"geometry/nearest_points.html#practice-problems","title":"Practice problems","text":"<ul> <li>UVA 10245 \"The Closest Pair Problem\" [difficulty: low]</li> <li>SPOJ #8725 CLOPPAIR \"Closest Point Pair\" [difficulty: low]</li> <li>CODEFORCES Team Olympiad Saratov - 2011 \"Minimum amount\" [difficulty: medium]</li> <li>Google CodeJam 2009 Final \"Min Perimeter\" [difficulty: medium]</li> <li>SPOJ #7029 CLOSEST \"Closest Triple\" [difficulty: medium]</li> <li>TIMUS 1514 National Park [difficulty: medium]</li> </ul>","tags":["Translated"]},{"location":"geometry/oriented-triangle-area.html","title":"Oriented area of a triangle","text":"<p>Given three points $p_1$, $p_2$ and $p_3$, calculate an oriented (signed) area of a triangle formed by them. The sign of the area is determined in the following way: imagine you are standing in the plane at point $p_1$ and are facing $p_2$. You go to $p_2$ and if $p_3$ is to your right (then we say the three vectors turn \"clockwise\"), the sign of the area is negative, otherwise it is positive. If the three points are collinear, the area is zero.</p> <p>Using this signed area, we can both get the regular unsigned area (as the absolute value of the signed area) and determine if the points lie clockwise or counterclockwise in their specified order (which is useful, for example, in convex hull algorithms).</p>","tags":["Translated"]},{"location":"geometry/oriented-triangle-area.html#calculation","title":"Calculation","text":"<p>We can use the fact that a determinant of a $2\\times 2$ matrix is equal to the signed area of a parallelogram spanned by column (or row) vectors of the matrix. This is analog to the definition of the cross product in 2D (see Basic Geometry). By dividing this area by two we get the area of a triangle that we are interested in. We will use $\\vec{p_1p_2}$ and $\\vec{p_2p_3}$ as the column vectors and calculate a $2\\times 2$ determinant:</p> $$2S=\\left|\\begin{matrix}x_2-x_1 &amp; x_3-x_2\\\\y_2-y_1 &amp; y_3-y_2\\end{matrix}\\right|=(x_2-x_1)(y_3-y_2)-(x_3-x_2)(y_2-y_1)$$","tags":["Translated"]},{"location":"geometry/oriented-triangle-area.html#implementation","title":"Implementation","text":"<pre><code>int signed_area_parallelogram(point2d p1, point2d p2, point2d p3) {\n    return cross(p2 - p1, p3 - p2);\n}\n\ndouble triangle_area(point2d p1, point2d p2, point2d p3) {\n    return abs(signed_area_parallelogram(p1, p2, p3)) / 2.0;\n}\n\nbool clockwise(point2d p1, point2d p2, point2d p3) {\n    return signed_area_parallelogram(p1, p2, p3) &lt; 0;\n}\n\nbool counter_clockwise(point2d p1, point2d p2, point2d p3) {\n    return signed_area_parallelogram(p1, p2, p3) &gt; 0;\n}\n</code></pre>","tags":["Translated"]},{"location":"geometry/oriented-triangle-area.html#practice-problems","title":"Practice Problems","text":"<ul> <li>Codechef - Chef and Polygons</li> </ul>","tags":["Translated"]},{"location":"geometry/picks-theorem.html","title":"Pick's Theorem","text":"<p>A polygon without self-intersections is called lattice if all its vertices have integer coordinates in some 2D grid. Pick's theorem provides a way to compute the area of this polygon through the number of vertices that are lying on the boundary and the number of vertices that lie strictly inside the polygon.</p>","tags":["Translated"]},{"location":"geometry/picks-theorem.html#formula","title":"Formula","text":"<p>Given a certain lattice polygon with non-zero area.</p> <p>We denote its area by $S$, the number of points with integer coordinates lying strictly inside the polygon by $I$ and the number of points lying on polygon sides by $B$.</p> <p>Then, the Pick's formula states:</p> $$S=I+\\frac{B}{2}-1$$ <p>In particular, if the values of $I$ and $B$ for a polygon are given, the area can be calculated in $O(1)$ without even knowing the vertices.</p> <p>This formula was discovered and proven by Austrian mathematician Georg Alexander Pick in 1899.</p>","tags":["Translated"]},{"location":"geometry/picks-theorem.html#proof","title":"Proof","text":"<p>The proof is carried out in many stages: from simple polygons to arbitrary ones:</p> <ul> <li> <p>A single square: $S=1, I=0, B=4$, which satisfies the formula.</p> </li> <li> <p>An arbitrary non-degenerate rectangle with sides parallel to coordinate axes: Assume $a$ and $b$ be the length of the sides of rectangle. Then, $S=ab, I=(a-1)(b-1), B=2(a+b)$. On substituting, we see that formula is true.</p> </li> <li> <p>A right angle with legs parallel to the axes: To prove this, note that any such triangle can be obtained by cutting off a rectangle by a diagonal. Denoting the number of integral points lying on diagonal by $c$, it can be shown that Pick's formula holds for this triangle regardless of $c$.</p> </li> <li> <p>An arbitrary triangle: Note that any such triangle can be turned into a rectangle by attaching it to sides of right-angled triangles with legs parallel to the axes (you will not need more than 3 such triangles). From here, we can get correct formula for any triangle.</p> </li> <li> <p>An arbitrary polygon: To prove this, triangulate it, ie, divide into triangles with integral coordinates. Further, it is possible to prove that Pick's theorem retains its validity when a polygon is added to a triangle. Thus, we have proven Pick's formula for arbitrary polygon.</p> </li> </ul>","tags":["Translated"]},{"location":"geometry/picks-theorem.html#generalization-to-higher-dimensions","title":"Generalization to higher dimensions","text":"<p>Unfortunately, this simple and beautiful formula cannot be generalized to higher dimensions.</p> <p>John Reeve demonstrated this by proposing a tetrahedron (Reeve tetrahedron) with following vertices in 1957:</p> $$A=(0,0,0), B=(1,0,0), C=(0,1,0), D=(1,1,k),$$ <p>where $k$ can be any natural number. Then for any $k$, the tetrahedron $ABCD$ does not contain integer point inside it and has only $4$ points on its borders, $A, B, C, D$. Thus, the volume and surface area may vary in spite of unchanged number of points within and on boundary. Therefore, Pick's theorem doesn't allow generalizations.</p> <p>However, higher dimensions still has a generalization using Ehrhart polynomials but they are quite complex and depends not only on points inside but also on the boundary of polytype.</p>","tags":["Translated"]},{"location":"geometry/picks-theorem.html#extra-resources","title":"Extra Resources","text":"<p>A few simple examples and a simple proof of Pick's theorem can be found here.</p>","tags":["Translated"]},{"location":"geometry/planar.html","title":"Finding faces of a planar graph","text":"<p>Consider a graph $G$ with $n$ vertices and $m$ edges, which can be drawn on a plane in such a way that two edges intersect only at a common vertex (if it exists). Such graphs are called planar. Now suppose that we are given a planar graph together with its straight-line embedding, which means that for each vertex $v$ we have a corresponding point $(x, y)$ and all edges are drawn as line segments between these points without intersection (such embedding always exists). These line segments split the plane into several regions, which are called faces. Exactly one of the faces is unbounded. This face is called outer, while the other faces are called inner.</p> <p>In this article we will deal with finding both inner and outer faces of a planar graph. We will assume that the graph is connected.</p>","tags":["Translated"]},{"location":"geometry/planar.html#some-facts-about-planar-graphs","title":"Some facts about planar graphs","text":"<p>In this section we present several facts about planar graphs without proof. Readers who are interested in proofs should refer to Graph Theory by R. Diestel (see also video lectures on planarity based on this book) or some other book.</p>","tags":["Translated"]},{"location":"geometry/planar.html#eulers-theorem","title":"Euler's theorem","text":"<p>Euler's theorem states that any correct embedding of a connected planar graph with $n$ vertices, $m$ edges and $f$ faces satisfies:</p> $$n - m + f = 2$$ <p>And more generally, every planar graph with $k$ connected components satisfies:</p> $$n - m + f = 1 + k$$","tags":["Translated"]},{"location":"geometry/planar.html#number-of-edges-of-a-planar-graph","title":"Number of edges of a planar graph.","text":"<p>If $n \\ge 3$ then the maximum number of edges of a planar graph with $n$ vertices is $3n - 6$. This number is achieved by any connected planar graph where each face is bounded by a triangle. In terms of complexity this fact means that $m = O(n)$ for any planar graph.</p>","tags":["Translated"]},{"location":"geometry/planar.html#number-of-faces-of-a-planar-graph","title":"Number of faces of a planar graph.","text":"<p>As a direct consequence of the above fact, if $n \\ge 3$ then the maximum number of faces of a planar graph with $n$ vertices is $2n - 4$.</p>","tags":["Translated"]},{"location":"geometry/planar.html#minimum-vertex-degree-in-a-planar-graph","title":"Minimum vertex degree in a planar graph.","text":"<p>Every planar graph has a vertex of degree 5 or less.</p>","tags":["Translated"]},{"location":"geometry/planar.html#the-algorithm","title":"The algorithm","text":"<p>Firstly, sort the adjacent edges for each vertex by polar angle. Now let's traverse the graph in the following way. Suppose that we entered vertex $u$ through the edge $(v, u)$ and $(u, w)$ is the next edge after $(v, u)$ in the sorted adjacency list of $u$. Then the next vertex will be $w$. It turns out that if we start this traversal at some edge $(v, u)$, we will traverse exactly one of the faces adjacent to $(v, u)$, the exact face depending on whether our first step is from $u$ to $v$ or from $v$ to $u$.</p> <p>Now the algorithm is quite obvious. We must iterate over all edges of the graph and start the traversal for each edge that wasn't visited by one of the previous traversals. This way we will find each face exactly once, and each edge will be traversed twice (once in each direction).</p>","tags":["Translated"]},{"location":"geometry/planar.html#finding-the-next-edge","title":"Finding the next edge","text":"<p>During the traversal we have to find the next edge in counter-clockwise order. The most obvious way to find the next edge is binary search by angle. However, given the counter-clockwise order of adjacent edges for each vertex, we can precompute the next edges and store them in a hash table. If the edges are already sorted by angle, the complexity of finding all faces in this case becomes linear.</p>","tags":["Translated"]},{"location":"geometry/planar.html#finding-the-outer-face","title":"Finding the outer face","text":"<p>It's not hard to see that the algorithm traverses each inner face in a clockwise order and the outer face in the counter-clockwise order, so the outer face can be found by checking the order of each face.</p>","tags":["Translated"]},{"location":"geometry/planar.html#complexity","title":"Complexity","text":"<p>It's quite clear that the complexity of the algorithm is $O(m \\log m)$ because of sorting, and since $m = O(n)$, it's actually $O(n \\log n)$. As mentioned before, without sorting the complexity becomes $O(n)$.</p>","tags":["Translated"]},{"location":"geometry/planar.html#what-if-the-graph-isnt-connected","title":"What if the graph isn't connected?","text":"<p>At the first glance it may seem that finding faces of a disconnected graph is not much harder because we can run the same algorithm for each connected component. However, the components may be drawn in a nested way, forming holes (see the image below). In this case the inner face of some component becomes the outer face of some other components and has a complex disconnected border. Dealing with such cases is quite hard, one possible approach is to identify nested components with point location algorithms. </p>","tags":["Translated"]},{"location":"geometry/planar.html#implementation","title":"Implementation","text":"<p>The following implementation returns a vector of vertices for each face, outer face goes first. Inner faces are returned in counter-clockwise orders and the outer face is returned in clockwise order.</p> <p>For simplicity we find the next edge by doing binary search by angle. <pre><code>struct Point {\n    int64_t x, y;\n\n    Point(int64_t x_, int64_t y_): x(x_), y(y_) {}\n\n    Point operator - (const Point &amp; p) const {\n        return Point(x - p.x, y - p.y);\n    }\n\n    int64_t cross (const Point &amp; p) const {\n        return x * p.y - y * p.x;\n    }\n\n    int64_t cross (const Point &amp; p, const Point &amp; q) const {\n        return (p - *this).cross(q - *this);\n    }\n\n    int half () const {\n        return int(y &lt; 0 || (y == 0 &amp;&amp; x &lt; 0));\n    }\n};\n\nstd::vector&lt;std::vector&lt;size_t&gt;&gt; find_faces(std::vector&lt;Point&gt; vertices, std::vector&lt;std::vector&lt;size_t&gt;&gt; adj) {\n    size_t n = vertices.size();\n    std::vector&lt;std::vector&lt;char&gt;&gt; used(n);\n    for (size_t i = 0; i &lt; n; i++) {\n        used[i].resize(adj[i].size());\n        used[i].assign(adj[i].size(), 0);\n        auto compare = [&amp;](size_t l, size_t r) {\n            Point pl = vertices[l] - vertices[i];\n            Point pr = vertices[r] - vertices[i];\n            if (pl.half() != pr.half())\n                return pl.half() &lt; pr.half();\n            return pl.cross(pr) &gt; 0;\n        };\n        std::sort(adj[i].begin(), adj[i].end(), compare);\n    }\n    std::vector&lt;std::vector&lt;size_t&gt;&gt; faces;\n    for (size_t i = 0; i &lt; n; i++) {\n        for (size_t edge_id = 0; edge_id &lt; adj[i].size(); edge_id++) {\n            if (used[i][edge_id]) {\n                continue;\n            }\n            std::vector&lt;size_t&gt; face;\n            size_t v = i;\n            size_t e = edge_id;\n            while (!used[v][e]) {\n                used[v][e] = true;\n                face.push_back(v);\n                size_t u = adj[v][e];\n                size_t e1 = std::lower_bound(adj[u].begin(), adj[u].end(), v, [&amp;](size_t l, size_t r) {\n                    Point pl = vertices[l] - vertices[u];\n                    Point pr = vertices[r] - vertices[u];\n                    if (pl.half() != pr.half())\n                        return pl.half() &lt; pr.half();\n                    return pl.cross(pr) &gt; 0;\n                }) - adj[u].begin() + 1;\n                if (e1 == adj[u].size()) {\n                    e1 = 0;\n                }\n                v = u;\n                e = e1;\n            }\n            std::reverse(face.begin(), face.end());\n            Point p1 = vertices[face[0]];\n            __int128 sum = 0;\n            for (int j = 0; j &lt; face.size(); ++j) {\n                Point p2 = vertices[face[j]];\n                Point p3 = vertices[face[(j + 1) % face.size()]];\n                sum += (p2 - p1).cross(p3 - p2);\n            }\n            if (sum &lt;= 0) {\n                faces.insert(faces.begin(), face);\n            } else {\n                faces.emplace_back(face);\n            }\n        }\n    }\n    return faces;\n}\n</code></pre></p>","tags":["Translated"]},{"location":"geometry/planar.html#building-planar-graph-from-line-segments","title":"Building planar graph from line segments","text":"<p>Sometimes you are not given a graph explicitly, but rather as a set of line segments on a plane, and the actual graph is formed by intersecting those segments, as shown in the picture below. In this case you have to build the graph manually. The easiest way to do so is as follows. Fix a segment and intersect it with all other segments. Then sort all intersection points together with the two endpoints of the segment lexicographically and add them to the graph as vertices. Also link each two adjacent vertices in lexicographical order by an edge. After doing this procedure for all edges we will obtain the graph. Of course, we should ensure that two equal intersection points will always correspond to the same vertex. The easiest way to do this is to store the points in a map by their coordinates, regarding points whose coordinates differ by a small number (say, less than $10^{-9}$) as equal. This algorithm works in $O(n^2 \\log n)$.</p>","tags":["Translated"]},{"location":"geometry/planar.html#implementation_1","title":"Implementation","text":"<pre><code>using dbl = long double;\n\nconst dbl eps = 1e-9;\n\nstruct Point {\n    dbl x, y;\n\n    Point(){}\n    Point(dbl x_, dbl y_): x(x_), y(y_) {}\n\n    Point operator * (dbl d) const {\n        return Point(x * d, y * d);\n    }\n\n    Point operator + (const Point &amp; p) const {\n        return Point(x + p.x, y + p.y);\n    }\n\n    Point operator - (const Point &amp; p) const {\n        return Point(x - p.x, y - p.y);\n    }\n\n    dbl cross (const Point &amp; p) const {\n        return x * p.y - y * p.x;\n    }\n\n    dbl cross (const Point &amp; p, const Point &amp; q) const {\n        return (p - *this).cross(q - *this);\n    }\n\n    dbl dot (const Point &amp; p) const {\n        return x * p.x + y * p.y;\n    }\n\n    dbl dot (const Point &amp; p, const Point &amp; q) const {\n        return (p - *this).dot(q - *this);\n    }\n\n    bool operator &lt; (const Point &amp; p) const {\n        if (fabs(x - p.x) &lt; eps) {\n            if (fabs(y - p.y) &lt; eps) {\n                return false;\n            } else {\n                return y &lt; p.y;\n            }\n        } else {\n            return x &lt; p.x;\n        }\n    }\n\n    bool operator == (const Point &amp; p) const {\n        return fabs(x - p.x) &lt; eps &amp;&amp; fabs(y - p.y) &lt; eps;\n    }\n\n    bool operator &gt;= (const Point &amp; p) const {\n        return !(*this &lt; p);\n    }\n};\n\nstruct Line{\n    Point p[2];\n\n    Line(Point l, Point r){p[0] = l; p[1] = r;}\n    Point&amp; operator [](const int &amp; i){return p[i];}\n    const Point&amp; operator[](const int &amp; i)const{return p[i];}\n    Line(const Line &amp; l){\n        p[0] = l.p[0]; p[1] = l.p[1];\n    }\n    Point getOrth()const{\n        return Point(p[1].y - p[0].y, p[0].x - p[1].x);\n    }\n    bool hasPointLine(const Point &amp; t)const{\n        return std::fabs(p[0].cross(p[1], t)) &lt; eps;\n    }\n    bool hasPointSeg(const Point &amp; t)const{\n        return hasPointLine(t) &amp;&amp; t.dot(p[0], p[1]) &lt; eps;\n    }\n};\n\nstd::vector&lt;Point&gt; interLineLine(Line l1, Line l2){\n    if(std::fabs(l1.getOrth().cross(l2.getOrth())) &lt; eps){\n        if(l1.hasPointLine(l2[0]))return {l1[0], l1[1]};\n        else return {};\n    }\n    Point u = l2[1] - l2[0];\n    Point v = l1[1] - l1[0];\n    dbl s = u.cross(l2[0] - l1[0])/u.cross(v);\n    return {Point(l1[0] + v * s)};\n}\n\nstd::vector&lt;Point&gt; interSegSeg(Line l1, Line l2){\n    if (l1[0] == l1[1]) {\n        if (l2[0] == l2[1]) {\n            if (l1[0] == l2[0])\n                return {l1[0]};\n            else \n                return {};\n        } else {\n            if (l2.hasPointSeg(l1[0]))\n                return {l1[0]};\n            else\n                return {};\n        }\n    }\n    if (l2[0] == l2[1]) {\n        if (l1.hasPointSeg(l2[0]))\n            return {l2[0]};\n        else \n            return {};\n    }\n    auto li = interLineLine(l1, l2);\n    if (li.empty())\n        return li;\n    if (li.size() == 2) {\n        if (l1[0] &gt;= l1[1])\n            std::swap(l1[0], l1[1]);\n        if (l2[0] &gt;= l2[1])\n            std::swap(l2[0], l2[1]);\n        std::vector&lt;Point&gt; res(2);\n        if (l1[0] &lt; l2[0])\n            res[0] = l2[0];\n        else\n            res[0] = l1[0];\n        if (l1[1] &lt; l2[1])\n            res[1] = l1[1];\n        else\n            res[1] = l2[1];\n        if (res[0] == res[1])\n            res.pop_back();\n        if (res.size() == 2u &amp;&amp; res[1] &lt; res[0])\n            return {};\n        else \n            return res;\n    }\n    Point cand = li[0];\n    if (l1.hasPointSeg(cand) &amp;&amp; l2.hasPointSeg(cand))\n        return {cand};\n    else \n        return {};\n}\n\nstd::pair&lt;std::vector&lt;Point&gt;, std::vector&lt;std::vector&lt;size_t&gt;&gt;&gt; build_graph(std::vector&lt;Line&gt; segments) {\n    std::vector&lt;Point&gt; p;\n    std::vector&lt;std::vector&lt;size_t&gt;&gt; adj;\n    std::map&lt;std::pair&lt;int64_t, int64_t&gt;, size_t&gt; point_id;\n    auto get_point_id = [&amp;](Point pt) {\n        auto repr = std::make_pair(\n            int64_t(std::round(pt.x * 1000000000) + 1e-6),\n            int64_t(std::round(pt.y * 1000000000) + 1e-6)\n        );\n        if (!point_id.count(repr)) {\n            adj.emplace_back();\n            size_t id = point_id.size();\n            point_id[repr] = id;\n            p.push_back(pt);\n            return id;\n        } else {\n            return point_id[repr];\n        }\n    };\n    for (size_t i = 0; i &lt; segments.size(); i++) {\n        std::vector&lt;size_t&gt; curr = {\n            get_point_id(segments[i][0]),\n            get_point_id(segments[i][1])\n        };\n        for (size_t j = 0; j &lt; segments.size(); j++) {\n            if (i == j)\n                continue;\n            auto inter = interSegSeg(segments[i], segments[j]);\n            for (auto pt: inter) {\n                curr.push_back(get_point_id(pt));\n            }\n        }\n        std::sort(curr.begin(), curr.end(), [&amp;](size_t l, size_t r) { return p[l] &lt; p[r]; });\n        curr.erase(std::unique(curr.begin(), curr.end()), curr.end());\n        for (size_t j = 0; j + 1 &lt; curr.size(); j++) {\n            adj[curr[j]].push_back(curr[j + 1]);\n            adj[curr[j + 1]].push_back(curr[j]);\n        }\n    }\n    for (size_t i = 0; i &lt; adj.size(); i++) {\n        std::sort(adj[i].begin(), adj[i].end());\n        // removing edges that were added multiple times\n        adj[i].erase(std::unique(adj[i].begin(), adj[i].end()), adj[i].end());\n    }\n    return {p, adj};\n}\n</code></pre>","tags":["Translated"]},{"location":"geometry/planar.html#problems","title":"Problems","text":"<ul> <li>TIMUS 1664 Pipeline Transportation</li> <li>TIMUS 1681 Brother Bear's Garden</li> </ul>","tags":["Translated"]},{"location":"geometry/point-in-convex-polygon.html","title":"Check if point belongs to the convex polygon in $O(\\log N)$","text":"<p>Consider the following problem: you are given a convex polygon with integer vertices and a lot of queries. Each query is a point, for which we should determine whether it lies inside or on the boundary of the polygon or not. Suppose the polygon is ordered counter-clockwise. We will answer each query in $O(\\log n)$ online.</p>","tags":["Translated"]},{"location":"geometry/point-in-convex-polygon.html#algorithm","title":"Algorithm","text":"<p>Let's pick the point with the smallest x-coordinate. If there are several of them, we pick the one with the smallest y-coordinate. Let's denote it as $p_0$. Now all other points $p_1,\\dots,p_n$ of the polygon are ordered by their polar angle from the chosen point (because the polygon is ordered counter-clockwise).</p> <p>If the point belongs to the polygon, it belongs to some triangle $p_0, p_i, p_{i + 1}$ (maybe more than one if it lies on the boundary of triangles). Consider the triangle $p_0, p_i, p_{i + 1}$ such that $p$ belongs to this triangle and $i$ is maximum among all such triangles.</p> <p>There is one special case. $p$ lies on the segment $(p_0, p_n)$. This case we will check separately. Otherwise all points $p_j$ with $j \\le i$ are counter-clockwise from $p$ with respect to $p_0$, and all other points are not counter-clockwise from $p$. This means that we can apply binary search for the point $p_i$, such that $p_i$ is not counter-clockwise from $p$ with respect to $p_0$, and $i$ is maximum among all such points. And afterwards we check if the points is actually in the determined triangle.</p> <p>The sign of $(a - c) \\times (b - c)$ will tell us, if the point $a$ is clockwise or counter-clockwise from the point $b$ with respect to the point $c$. If $(a - c) \\times (b - c) &gt; 0$, then the point $a$ is to the right of the vector going from $c$ to $b$, which means clockwise from $b$ with respect to $c$. And if $(a - c) \\times (b - c) &lt; 0$, then the point is to the left, or counter clockwise. And it is exactly on the line between the points $b$ and $c$.</p> <p>Back to the algorithm: Consider a query point $p$. Firstly, we must check if the point lies between $p_1$ and $p_n$. Otherwise we already know that it cannot be part of the polygon. This can be done by checking if the cross product $(p_1 - p_0)\\times(p - p_0)$ is zero or has the same sign with $(p_1 - p_0)\\times(p_n - p_0)$, and $(p_n - p_0)\\times(p - p_0)$ is zero or has the same sign with $(p_n - p_0)\\times(p_1 - p_0)$. Then we handle the special case in which $p$ is part of the line $(p_0, p_1)$. And then we can binary search the last point from $p_1,\\dots p_n$ which is not counter-clockwise from $p$ with respect to $p_0$. For a single point $p_i$ this condition can be checked by checking that $(p_i - p_0)\\times(p - p_0) \\le 0$. After we found such a point $p_i$, we must test if $p$ lies inside the triangle $p_0, p_i, p_{i + 1}$. To test if it belongs to the triangle, we may simply check that $|(p_i - p_0)\\times(p_{i + 1} - p_0)| = |(p_0 - p)\\times(p_i - p)| + |(p_i - p)\\times(p_{i + 1} - p)| + |(p_{i + 1} - p)\\times(p_0 - p)|$. This checks if the area of the triangle $p_0, p_i, p_{i+1}$ has to exact same size as the sum of the sizes of the triangle $p_0, p_i, p$, the triangle $p_0, p, p_{i+1}$ and the triangle $p_i, p_{i+1}, p$. If $p$ is outside, then the sum of those three triangle will be bigger than the size of the triangle. If it is inside, then it will be equal.</p>","tags":["Translated"]},{"location":"geometry/point-in-convex-polygon.html#implementation","title":"Implementation","text":"<p>The function <code>prepare</code> will make sure that the lexicographical smallest point (smallest x value, and in ties smallest y value) will be $p_0$, and computes the vectors $p_i - p_0$. Afterwards the function <code>pointInConvexPolygon</code> computes the result of a query. We additionally remember the point $p_0$ and translate all queried points with it in order compute the correct distance, as vectors don't have an initial point. By translating the query points we can assume that all vectors start at the origin $(0, 0)$, and simplify the computations for distances and lengths.</p> <pre><code>struct pt {\n    long long x, y;\n    pt() {}\n    pt(long long _x, long long _y) : x(_x), y(_y) {}\n    pt operator+(const pt &amp;p) const { return pt(x + p.x, y + p.y); }\n    pt operator-(const pt &amp;p) const { return pt(x - p.x, y - p.y); }\n    long long cross(const pt &amp;p) const { return x * p.y - y * p.x; }\n    long long dot(const pt &amp;p) const { return x * p.x + y * p.y; }\n    long long cross(const pt &amp;a, const pt &amp;b) const { return (a - *this).cross(b - *this); }\n    long long dot(const pt &amp;a, const pt &amp;b) const { return (a - *this).dot(b - *this); }\n    long long sqrLen() const { return this-&gt;dot(*this); }\n};\n\nbool lexComp(const pt &amp;l, const pt &amp;r) {\n    return l.x &lt; r.x || (l.x == r.x &amp;&amp; l.y &lt; r.y);\n}\n\nint sgn(long long val) { return val &gt; 0 ? 1 : (val == 0 ? 0 : -1); }\n\nvector&lt;pt&gt; seq;\npt translation;\nint n;\n\nbool pointInTriangle(pt a, pt b, pt c, pt point) {\n    long long s1 = abs(a.cross(b, c));\n    long long s2 = abs(point.cross(a, b)) + abs(point.cross(b, c)) + abs(point.cross(c, a));\n    return s1 == s2;\n}\n\nvoid prepare(vector&lt;pt&gt; &amp;points) {\n    n = points.size();\n    int pos = 0;\n    for (int i = 1; i &lt; n; i++) {\n        if (lexComp(points[i], points[pos]))\n            pos = i;\n    }\n    rotate(points.begin(), points.begin() + pos, points.end());\n\n    n--;\n    seq.resize(n);\n    for (int i = 0; i &lt; n; i++)\n        seq[i] = points[i + 1] - points[0];\n    translation = points[0];\n}\n\nbool pointInConvexPolygon(pt point) {\n    point = point - translation;\n    if (seq[0].cross(point) != 0 &amp;&amp;\n            sgn(seq[0].cross(point)) != sgn(seq[0].cross(seq[n - 1])))\n        return false;\n    if (seq[n - 1].cross(point) != 0 &amp;&amp;\n            sgn(seq[n - 1].cross(point)) != sgn(seq[n - 1].cross(seq[0])))\n        return false;\n\n    if (seq[0].cross(point) == 0)\n        return seq[0].sqrLen() &gt;= point.sqrLen();\n\n    int l = 0, r = n - 1;\n    while (r - l &gt; 1) {\n        int mid = (l + r) / 2;\n        int pos = mid;\n        if (seq[pos].cross(point) &gt;= 0)\n            l = mid;\n        else\n            r = mid;\n    }\n    int pos = l;\n    return pointInTriangle(seq[pos], seq[pos + 1], pt(0, 0), point);\n}\n</code></pre>","tags":["Translated"]},{"location":"geometry/point-in-convex-polygon.html#problems","title":"Problems","text":"<ul> <li>SGU253 Theodore Roosevelt</li> <li>Codeforces 55E Very simple problem</li> <li>Codeforces 166B Polygons</li> </ul>","tags":["Translated"]},{"location":"geometry/point-location.html","title":"Point location in $O(log n)$","text":"<p>Consider the following problem: you are given a planar subdivision without any vertices of degree one and zero, and a lot of queries. Each query is a point, for which we should determine the face of the subdivision it belongs to. We will answer each query in $O(\\log n)$ offline. This problem may arise when you need to locate some points in a Voronoi diagram or in some simple polygon.</p>","tags":["Original"]},{"location":"geometry/point-location.html#algorithm","title":"Algorithm","text":"<p>Firstly, for each query point $p\\ (x_0, y_0)$ we want to find such an edge that if the point belongs to any edge, the point lies on the edge we found, otherwise this edge must intersect the line $x = x_0$ at some unique point $(x_0, y)$ where $y &lt; y_0$ and this $y$ is maximum among all such edges. The following image shows both cases.</p> <p>We will solve this problem offline using the sweep line algorithm. Let's iterate over x-coordinates of query points and edges' endpoints in increasing order and keep a set of edges $s$. For each x-coordinate we will add some events beforehand.</p> <p>The events will be of four types: add, remove, vertical, get. For each vertical edge (both endpoints have the same x-coordinate) we will add one vertical event for the corresponding x-coordinate. For every other edge we will add one add event for the minimum of x-coordinates of the endpoints and one remove event for the maximum of x-coordinates of the endpoints. Finally, for each query point we will add one get event for its x-coordinate.</p> <p>For each x-coordinate we will sort the events by their types in order (vertical, get, remove, add). The following image shows all events in sorted order for each x-coordinate.</p> <p>We will keep two sets during the sweep-line process. A set $t$ for all non-vertical edges, and one set $vert$ especially for the vertical ones. We will clear the set $vert$ at the beginning of processing each x-coordinate.</p> <p>Now let's process the events for a fixed x-coordinate.</p> <ul> <li>If we got a vertical event, we will simply insert the minimum y-coordinate of the corresponding edge's endpoints to $vert$.</li> <li>If we got a remove or add event, we will remove the corresponding edge from $t$ or add it to $t$.</li> <li>Finally, for each get event we must check if the point lies on some vertical edge by performing a binary search in $vert$. If the point doesn't lie on any vertical edge, we must find the answer for this query in $t$. To do this, we again make a binary search. In order to handle some degenerate cases (e.g. in case of the triangle $(0,~0)$, $(0,~2)$, $(1, 1)$ when we query the point $(0,~0)$), we must answer all get events again after we processed all the events for this x-coordinate and choose the best of two answers.</li> </ul> <p>Now let's choose a comparator for the set $t$. This comparator should check if one edge doesn't lie above other for every x-coordinate they both cover. Suppose that we have two edges $(a, b)$ and $(c, d)$. Then the comparator is (in pseudocode):</p> <p>$val = sgn((b - a)\\times(c - a)) + sgn((b - a)\\times(d - a))$ if $val \\neq 0$ then return $val &gt; 0$ $val = sgn((d - c)\\times(a - c)) + sgn((d - c)\\times(b - c))$ return $val &lt; 0$</p> <p>Now for every query we have the corresponding edge. How to find the face? If we couldn't find the edge it means that the point is in the outer face. If the point belongs to the edge we found, the face is not unique. Otherwise, there are two candidates - the faces that are bounded by this edge. How to check which one is the answer? Note that the edge is not vertical. Then the answer is the face that is above this edge. Let's find such a face for each non-vertical edge. Consider a counter-clockwise traversal of each face. If during this traversal we increased x-coordinate while passing through the edge, then this face is the face we need to find for this edge.</p>","tags":["Original"]},{"location":"geometry/point-location.html#notes","title":"Notes","text":"<p>Actually, with persistent trees this approach can be used to answer the queries online.</p>","tags":["Original"]},{"location":"geometry/point-location.html#implementation","title":"Implementation","text":"<p>The following code is implemented for integers, but it can be easily modified to work with doubles (by changing the compare methods and the point type). This implementation assumes that the subdivision is correctly stored inside a DCEL and the outer face is numbered $-1$. For each query a pair $(1, i)$ is returned if the point lies strictly inside the face number $i$, and a pair $(0, i)$ is returned if the point lies on the edge number $i$.</p> <pre><code>typedef long long ll;\n\nbool ge(const ll&amp; a, const ll&amp; b) { return a &gt;= b; }\nbool le(const ll&amp; a, const ll&amp; b) { return a &lt;= b; }\nbool eq(const ll&amp; a, const ll&amp; b) { return a == b; }\nbool gt(const ll&amp; a, const ll&amp; b) { return a &gt; b; }\nbool lt(const ll&amp; a, const ll&amp; b) { return a &lt; b; }\nint sgn(const ll&amp; x) { return le(x, 0) ? eq(x, 0) ? 0 : -1 : 1; }\n\nstruct pt {\n    ll x, y;\n    pt() {}\n    pt(ll _x, ll _y) : x(_x), y(_y) {}\n    pt operator-(const pt&amp; a) const { return pt(x - a.x, y - a.y); }\n    ll dot(const pt&amp; a) const { return x * a.x + y * a.y; }\n    ll dot(const pt&amp; a, const pt&amp; b) const { return (a - *this).dot(b - *this); }\n    ll cross(const pt&amp; a) const { return x * a.y - y * a.x; }\n    ll cross(const pt&amp; a, const pt&amp; b) const { return (a - *this).cross(b - *this); }\n    bool operator==(const pt&amp; a) const { return a.x == x &amp;&amp; a.y == y; }\n};\n\nstruct Edge {\n    pt l, r;\n};\n\nbool edge_cmp(Edge* edge1, Edge* edge2)\n{\n    const pt a = edge1-&gt;l, b = edge1-&gt;r;\n    const pt c = edge2-&gt;l, d = edge2-&gt;r;\n    int val = sgn(a.cross(b, c)) + sgn(a.cross(b, d));\n    if (val != 0)\n        return val &gt; 0;\n    val = sgn(c.cross(d, a)) + sgn(c.cross(d, b));\n    return val &lt; 0;\n}\n\nenum EventType { DEL = 2, ADD = 3, GET = 1, VERT = 0 };\n\nstruct Event {\n    EventType type;\n    int pos;\n    bool operator&lt;(const Event&amp; event) const { return type &lt; event.type; }\n};\n\nvector&lt;Edge*&gt; sweepline(vector&lt;Edge*&gt; planar, vector&lt;pt&gt; queries)\n{\n    using pt_type = decltype(pt::x);\n\n    // collect all x-coordinates\n    auto s =\n        set&lt;pt_type, std::function&lt;bool(const pt_type&amp;, const pt_type&amp;)&gt;&gt;(lt);\n    for (pt p : queries)\n        s.insert(p.x);\n    for (Edge* e : planar) {\n        s.insert(e-&gt;l.x);\n        s.insert(e-&gt;r.x);\n    }\n\n    // map all x-coordinates to ids\n    int cid = 0;\n    auto id =\n        map&lt;pt_type, int, std::function&lt;bool(const pt_type&amp;, const pt_type&amp;)&gt;&gt;(\n            lt);\n    for (auto x : s)\n        id[x] = cid++;\n\n    // create events\n    auto t = set&lt;Edge*, decltype(*edge_cmp)&gt;(edge_cmp);\n    auto vert_cmp = [](const pair&lt;pt_type, int&gt;&amp; l,\n                       const pair&lt;pt_type, int&gt;&amp; r) {\n        if (!eq(l.first, r.first))\n            return lt(l.first, r.first);\n        return l.second &lt; r.second;\n    };\n    auto vert = set&lt;pair&lt;pt_type, int&gt;, decltype(vert_cmp)&gt;(vert_cmp);\n    vector&lt;vector&lt;Event&gt;&gt; events(cid);\n    for (int i = 0; i &lt; (int)queries.size(); i++) {\n        int x = id[queries[i].x];\n        events[x].push_back(Event{GET, i});\n    }\n    for (int i = 0; i &lt; (int)planar.size(); i++) {\n        int lx = id[planar[i]-&gt;l.x], rx = id[planar[i]-&gt;r.x];\n        if (lx &gt; rx) {\n            swap(lx, rx);\n            swap(planar[i]-&gt;l, planar[i]-&gt;r);\n        }\n        if (lx == rx) {\n            events[lx].push_back(Event{VERT, i});\n        } else {\n            events[lx].push_back(Event{ADD, i});\n            events[rx].push_back(Event{DEL, i});\n        }\n    }\n\n    // perform sweep line algorithm\n    vector&lt;Edge*&gt; ans(queries.size(), nullptr);\n    for (int x = 0; x &lt; cid; x++) {\n        sort(events[x].begin(), events[x].end());\n        vert.clear();\n        for (Event event : events[x]) {\n            if (event.type == DEL) {\n                t.erase(planar[event.pos]);\n            }\n            if (event.type == VERT) {\n                vert.insert(make_pair(\n                    min(planar[event.pos]-&gt;l.y, planar[event.pos]-&gt;r.y),\n                    event.pos));\n            }\n            if (event.type == ADD) {\n                t.insert(planar[event.pos]);\n            }\n            if (event.type == GET) {\n                auto jt = vert.upper_bound(\n                    make_pair(queries[event.pos].y, planar.size()));\n                if (jt != vert.begin()) {\n                    --jt;\n                    int i = jt-&gt;second;\n                    if (ge(max(planar[i]-&gt;l.y, planar[i]-&gt;r.y),\n                           queries[event.pos].y)) {\n                        ans[event.pos] = planar[i];\n                        continue;\n                    }\n                }\n                Edge* e = new Edge;\n                e-&gt;l = e-&gt;r = queries[event.pos];\n                auto it = t.upper_bound(e);\n                if (it != t.begin())\n                    ans[event.pos] = *(--it);\n                delete e;\n            }\n        }\n\n        for (Event event : events[x]) {\n            if (event.type != GET)\n                continue;\n            if (ans[event.pos] != nullptr &amp;&amp;\n                eq(ans[event.pos]-&gt;l.x, ans[event.pos]-&gt;r.x))\n                continue;\n\n            Edge* e = new Edge;\n            e-&gt;l = e-&gt;r = queries[event.pos];\n            auto it = t.upper_bound(e);\n            delete e;\n            if (it == t.begin())\n                e = nullptr;\n            else\n                e = *(--it);\n            if (ans[event.pos] == nullptr) {\n                ans[event.pos] = e;\n                continue;\n            }\n            if (e == nullptr)\n                continue;\n            if (e == ans[event.pos])\n                continue;\n            if (id[ans[event.pos]-&gt;r.x] == x) {\n                if (id[e-&gt;l.x] == x) {\n                    if (gt(e-&gt;l.y, ans[event.pos]-&gt;r.y))\n                        ans[event.pos] = e;\n                }\n            } else {\n                ans[event.pos] = e;\n            }\n        }\n    }\n    return ans;\n}\n\nstruct DCEL {\n    struct Edge {\n        pt origin;\n        Edge* nxt = nullptr;\n        Edge* twin = nullptr;\n        int face;\n    };\n    vector&lt;Edge*&gt; body;\n};\n\nvector&lt;pair&lt;int, int&gt;&gt; point_location(DCEL planar, vector&lt;pt&gt; queries)\n{\n    vector&lt;pair&lt;int, int&gt;&gt; ans(queries.size());\n    vector&lt;Edge*&gt; planar2;\n    map&lt;intptr_t, int&gt; pos;\n    map&lt;intptr_t, int&gt; added_on;\n    int n = planar.body.size();\n    for (int i = 0; i &lt; n; i++) {\n        if (planar.body[i]-&gt;face &gt; planar.body[i]-&gt;twin-&gt;face)\n            continue;\n        Edge* e = new Edge;\n        e-&gt;l = planar.body[i]-&gt;origin;\n        e-&gt;r = planar.body[i]-&gt;twin-&gt;origin;\n        added_on[(intptr_t)e] = i;\n        pos[(intptr_t)e] =\n            lt(planar.body[i]-&gt;origin.x, planar.body[i]-&gt;twin-&gt;origin.x)\n                ? planar.body[i]-&gt;face\n                : planar.body[i]-&gt;twin-&gt;face;\n        planar2.push_back(e);\n    }\n    auto res = sweepline(planar2, queries);\n    for (int i = 0; i &lt; (int)queries.size(); i++) {\n        if (res[i] == nullptr) {\n            ans[i] = make_pair(1, -1);\n            continue;\n        }\n        pt p = queries[i];\n        pt l = res[i]-&gt;l, r = res[i]-&gt;r;\n        if (eq(p.cross(l, r), 0) &amp;&amp; le(p.dot(l, r), 0)) {\n            ans[i] = make_pair(0, added_on[(intptr_t)res[i]]);\n            continue;\n        }\n        ans[i] = make_pair(1, pos[(intptr_t)res[i]]);\n    }\n    for (auto e : planar2)\n        delete e;\n    return ans;\n}\n</code></pre>","tags":["Original"]},{"location":"geometry/point-location.html#problems","title":"Problems","text":"<ul> <li>TIMUS 1848 Fly Hunt</li> <li>UVA 12310 Point Location</li> </ul>","tags":["Original"]},{"location":"geometry/segment-to-line.html","title":"Finding the equation of a line for a segment","text":"<p>The task is: given the coordinates of the ends of a segment, construct a line passing through it.</p> <p>We assume that the segment is non-degenerate, i.e. has a length greater than zero (otherwise, of course, infinitely many different lines pass through it).</p>","tags":["Translated"]},{"location":"geometry/segment-to-line.html#two-dimensional-case","title":"Two-dimensional case","text":"<p>Let the given segment be $PQ$ i.e. the known coordinates of its ends $P_x , P_y , Q_x , Q_y$ .</p> <p>It is necessary to construct the equation of a line in the plane passing through this segment, i.e. find the coefficients $A , B , C$ in the equation of a line:</p> $$A x + B y + C = 0.$$ <p>Note that for the required triples $(A, B, C)$ there are infinitely many solutions which describe the given segment: you can multiply all three coefficients by an arbitrary non-zero number and get the same straight line. Therefore, our task is to find one of these triples.</p> <p>It is easy to verify (by substitution of these expressions and the coordinates of the points $P$ and $Q$ into the equation of a straight line) that the following set of coefficients fits:</p> $$\\begin{align} A &amp;= P_y - Q_y, \\\\ B &amp;= Q_x - P_x, \\\\ C &amp;= - A P_x - B P_y. \\end{align}$$","tags":["Translated"]},{"location":"geometry/segment-to-line.html#integer-case","title":"Integer case","text":"<p>An important advantage of this method of constructing a straight line is that if the coordinates of the ends were integer, then the coefficients obtained will also be integer . In some cases, this allows one to perform geometric operations without resorting to real numbers at all.</p> <p>However, there is a small drawback: for the same straight line different triples of coefficients can be obtained. To avoid this, but do not go away from the integer coefficients, you can apply the following technique, often called rationing. Find the greatest common divisor of numbers $| A | , | B | , | C |$ , we divide all three coefficients by it, and then we make the normalization of the sign: if $A &lt;0$ or $A = 0, B &lt;0$ then multiply all three coefficients by $-1$ . As a result, we will come to the conclusion that for identical straight lines, identical triples of coefficients will be obtained, which makes it easy to check straight lines for equality.</p>","tags":["Translated"]},{"location":"geometry/segment-to-line.html#real-case","title":"Real case","text":"<p>When working with real numbers, you should always be aware of errors.</p> <p>The coefficients $A$ and $B$ will have the order of the original coordinates, the coefficient $C$ is of the order of the square of them. This may already be quite large numbers, and, for example, when we intersect straight lines, they will become even larger, which can lead to large rounding errors already when the coordinates of the end points are of order $10^3$.</p> <p>Therefore, when working with real numbers, it is desirable to produce the so-called normalization, this is straightforward: namely, to make the coefficients such that $A ^ 2 + B ^ 2 = 1$ . To do this, calculate the number $Z$ :</p> $$Z = \\sqrt{A ^ 2 + B ^ 2},$$ <p>and divide all three coefficients $A , B , C$ by it.</p> <p>Thus, the order of the coefficients $A$ and $B$ will not depend on the order of the input coordinates, and the coefficient $C$ will be of the same order as the input coordinates. In practice, this leads to a significant improvement in the accuracy of calculations.</p> <p>Finally, we mention the comparison of straight lines - in fact, after such a normalization, for the same straight line, only two triples of coefficients can be obtained: up to multiplication by $-1$. Accordingly, if we make an additional normalization taking into account the sign (if $A &lt; -\\varepsilon$  or $| A | &lt; \\varepsilon$, $B &lt;- \\varepsilon$ then multiply by $-1$ ), the resulting coefficients will be unique.</p>","tags":["Translated"]},{"location":"geometry/segment-to-line.html#three-dimensional-and-multidimensional-case","title":"Three-dimensional and multidimensional case","text":"<p>Already in the three-dimensional case there is no simple equation describing a straight line (it can be defined as the intersection of two planes, that is, a system of two equations, but this is an inconvenient method).</p> <p>Consequently, in the three-dimensional and multidimensional cases we must use the parametric method of defining a straight line , i.e. as a point $p$ and a vector $v$ :</p> $$p + v t, ~~~ t \\in \\mathbb{R}.$$ <p>Those. a straight line is all points that can be obtained from a point $p$ adding a vector $v$ with an arbitrary coefficient.</p> <p>The construction of a straight line in a parametric form along the coordinates of the ends of a segment is trivial, we just take one end of the segment for the point $p$, and the vector from the first to the second end \u2014 for the vector $v$.</p>","tags":["Translated"]},{"location":"geometry/segments-intersection.html","title":"Finding intersection of two segments","text":"<p>You are given two segments AB and CD, described as pairs of their endpoints. Each segment can be a single point if its endpoints are the same.  You have to find the intersection of these segments, which can be empty (if the segments don't intersect), a single point or a segment (if the given segments overlap).</p>","tags":["Translated"]},{"location":"geometry/segments-intersection.html#solution","title":"Solution","text":"<p>We can find the intersection point of segments in the same way as the intersection of lines:  reconstruct line equations from the segments' endpoints and check whether they are parallel. </p> <p>If the lines are not parallel, we need to find their point of intersection and check whether it belongs to both segments (to do this it's sufficient to verify that the intersection point belongs to each segment projected on X and Y axes).  In this case the answer will be either \"no intersection\" or the single point of lines' intersection.</p> <p>The case of parallel lines is slightly more complicated (the case of one or more segments being a single point also belongs here). In this case we need to check that both segments belong to the same line. If they don't, the answer is \"no intersection\". If they do, the answer is the intersection of the segments belonging to the same line, which is obtained by  ordering the endpoints of both segments in the increasing order of certain coordinate and taking the rightmost of left endpoints and the leftmost of right endpoints.</p> <p>If both segments are single points, these points have to be identical, and it makes sense to perform this check separately.</p> <p>In the beginning of the algorithm let's add a bounding box check - it is necessary for the case when the segments belong to the same line,  and (being a lightweight check) it allows the algorithm to work faster on average on random tests.</p>","tags":["Translated"]},{"location":"geometry/segments-intersection.html#implementation","title":"Implementation","text":"<p>Here is the implementation, including all helper functions for lines and segments processing.</p> <p>The main function <code>intersect</code> returns true if the segments have a non-empty intersection,  and stores endpoints of the intersection segment in arguments <code>left</code> and <code>right</code>.  If the answer is a single point, the values written to <code>left</code> and <code>right</code> will be the same.</p> <pre><code>const double EPS = 1E-9;\n\nstruct pt {\n    double x, y;\n\n    bool operator&lt;(const pt&amp; p) const\n    {\n        return x &lt; p.x - EPS || (abs(x - p.x) &lt; EPS &amp;&amp; y &lt; p.y - EPS);\n    }\n};\n\nstruct line {\n    double a, b, c;\n\n    line() {}\n    line(pt p, pt q)\n    {\n        a = p.y - q.y;\n        b = q.x - p.x;\n        c = -a * p.x - b * p.y;\n        norm();\n    }\n\n    void norm()\n    {\n        double z = sqrt(a * a + b * b);\n        if (abs(z) &gt; EPS)\n            a /= z, b /= z, c /= z;\n    }\n\n    double dist(pt p) const { return a * p.x + b * p.y + c; }\n};\n\ndouble det(double a, double b, double c, double d)\n{\n    return a * d - b * c;\n}\n\ninline bool betw(double l, double r, double x)\n{\n    return min(l, r) &lt;= x + EPS &amp;&amp; x &lt;= max(l, r) + EPS;\n}\n\ninline bool intersect_1d(double a, double b, double c, double d)\n{\n    if (a &gt; b)\n        swap(a, b);\n    if (c &gt; d)\n        swap(c, d);\n    return max(a, c) &lt;= min(b, d) + EPS;\n}\n\nbool intersect(pt a, pt b, pt c, pt d, pt&amp; left, pt&amp; right)\n{\n    if (!intersect_1d(a.x, b.x, c.x, d.x) || !intersect_1d(a.y, b.y, c.y, d.y))\n        return false;\n    line m(a, b);\n    line n(c, d);\n    double zn = det(m.a, m.b, n.a, n.b);\n    if (abs(zn) &lt; EPS) {\n        if (abs(m.dist(c)) &gt; EPS || abs(n.dist(a)) &gt; EPS)\n            return false;\n        if (b &lt; a)\n            swap(a, b);\n        if (d &lt; c)\n            swap(c, d);\n        left = max(a, c);\n        right = min(b, d);\n        return true;\n    } else {\n        left.x = right.x = -det(m.c, m.b, n.c, n.b) / zn;\n        left.y = right.y = -det(m.a, m.c, n.a, n.c) / zn;\n        return betw(a.x, b.x, left.x) &amp;&amp; betw(a.y, b.y, left.y) &amp;&amp;\n               betw(c.x, d.x, left.x) &amp;&amp; betw(c.y, d.y, left.y);\n    }\n}\n</code></pre>","tags":["Translated"]},{"location":"geometry/tangents-to-two-circles.html","title":"Finding common tangents to two circles","text":"<p>Given two circles. It is required to find all their common tangents, i.e. all such lines that touch both circles simultaneously.</p> <p>The described algorithm will also work in the case when one (or both) circles degenerate into points. Thus, this algorithm can also be used to find tangents to a circle passing through a given point.</p>","tags":["Translated"]},{"location":"geometry/tangents-to-two-circles.html#the-number-of-common-tangents","title":"The number of common tangents","text":"<p>The number of common tangents to two circles can be 0,1,2,3,4 and infinite. Look at the images for different cases.</p> <p>Here, we won't be considering degenerate cases, i.e when the circles coincide (in this case they have infinitely many common tangents), or one circle lies inside the other (in this case they have no common tangents, or if the circles are tangent, there is one common tangent).</p> <p>In most cases, two circles have four common tangents.</p> <p>If the circles are tangent , then they will have three common tangents, but this can be understood as a degenerate case: as if the two tangents coincided.</p> <p>Moreover, the algorithm described below will work in the case when one or both circles have zero radius: in this case there will be, respectively, two or one common tangent.</p> <p>Summing up, we will always look for four tangents for all cases except infinite tangents case (The infinite tangents case needs to be handled separately and it is not discussed here). In degenerate cases, some of tangents will coincide, but nevertheless, these cases will also fit into the big picture.</p>","tags":["Translated"]},{"location":"geometry/tangents-to-two-circles.html#algorithm","title":"Algorithm","text":"<p>For the sake of simplicity of the algorithm, we will assume, without losing generality, that the center of the first circle has coordinates $(0, 0)$. (If this is not the case, then this can be achieved by simply shifting the whole picture, and after finding a solution, by shifting the obtained straight lines back.)</p> <p>Denote $r_1$ and $r_2$ the radii of the first and second circles, and by $(v_x,v_y)$ the coordinates of the center of the second circle and point $v$ different from origin. (Note: we are not considering the case in which both the circles are same).</p> <p>To solve the problem, we approach it purely algebraically . We need to find all the lines of the form $ax + by + c = 0$ that lie at a distance $r_1$ from the origin of coordinates, and at a distance $r_2$ from a point $v$. In addition, we impose the condition of normalization of the straight line: the sum of the squares of the coefficients and must be equal to one (this is necessary, otherwise the same straight line will correspond to infinitely many representations of the form $ax + by + c = 0$). Total we get such a system of equations for the desired $a, b, c$:</p> $$\\begin{align} a^2 + b^2 &amp;= 1 \\\\ \\mid a \\cdot 0 + b \\cdot 0 + c \\mid &amp;= r_1 \\\\ \\mid a \\cdot v_x + b \\cdot v_y + c \\mid &amp;= r_2 \\end{align}$$ <p>To get rid of the modulus, note that there are only four ways to open the modulus in this system. All these methods can be considered by the general case, if we understand the opening of the modulus as the fact that the coefficient on the right-hand side may be multiplied by -1. In other words, we turn to this system:</p> $$\\begin{align} a^2 + b^2 &amp;= 1 \\\\ c &amp;= \\pm r_1 \\\\ a \\cdot v_x + b \\cdot v_y + c &amp;= \\pm r_2 \\end{align}$$ <p>Entering the notation $d_1 = \\pm r_1$ and $d_2 = \\pm r_2$ , we come to the conclusion that the system must have four solutions:</p> $$\\begin{align} a^2 + b^2 &amp;= 1 \\\\ c &amp;= d_1 \\\\ a \\cdot v_x + b \\cdot v_y + c &amp;= d_2 \\end{align}$$ <p>The solution of this system is reduced to solving a quadratic equation. We will omit all the cumbersome calculations, and immediately give a ready answer:</p> $$\\begin{align} a &amp;= {( d_2 - d_1 ) v_x \\pm v_y \\sqrt{v_x^2 + v_y^2-(d_2-d_1)^2} \\over {v_x^2 + v_y^2} } \\\\ b &amp;= {( d_2 - d_1 ) v_y \\pm v_x \\sqrt{v_x^2 + v_y^2-(d_2-d_1)^2} \\over {v_x^2 + v_y^2} } \\\\ c &amp;= d_1 \\end{align}$$ <p>Total we got eight solutions instead four. However, it is easy to understand where superfluous decisions arise: in fact, in the latter system, it is enough to take only one solution (for example, the first). In fact, the geometric meaning of what we take $\\pm r_1$ and $\\pm r_2$ is clear: we are actually sorting out which side of each circle there is a straight line. Therefore, the two methods that arise when solving the latter system are redundant: it is enough to choose one of the two solutions (only, of course, in all four cases, you must choose the same family of solutions).</p> <p>The last thing that we have not yet considered is how to shift the straight lines in the case when the first circle was not originally located at the origin. However, everything is simple here: it follows from the linearity of the equation of a straight line that the value $a \\cdot x_0 + b \\cdot y_0$ (where $x_0$ and $y_0$ are the coordinates of the original center of the first circle) must be subtracted from the coefficient $c$.</p>","tags":["Translated"]},{"location":"geometry/tangents-to-two-circles.html#implementation","title":"Implementation","text":"<p>We first describe all the necessary data structures and other auxiliary definitions:</p> <p><pre><code>struct pt {\n    double x, y;\n\n    pt operator- (pt p) {\n        pt res = { x-p.x, y-p.y };\n        return res;\n    }\n};\n\nstruct circle : pt {\n    double r;\n};\n\nstruct line {\n    double a, b, c;\n};\n\nconst double EPS = 1E-9;\n\ndouble sqr (double a) {\n    return a * a;\n}\n</code></pre> Then the solution itself can be written this way (where the main function for the call is the second; and the first function is an auxiliary):</p> <pre><code>void tangents (pt c, double r1, double r2, vector&lt;line&gt; &amp; ans) {\n    double r = r2 - r1;\n    double z = sqr(c.x) + sqr(c.y);\n    double d = z - sqr(r);\n    if (d &lt; -EPS)  return;\n    d = sqrt (abs (d));\n    line l;\n    l.a = (c.x * r + c.y * d) / z;\n    l.b = (c.y * r - c.x * d) / z;\n    l.c = r1;\n    ans.push_back (l);\n}\n\nvector&lt;line&gt; tangents (circle a, circle b) {\n    vector&lt;line&gt; ans;\n    for (int i=-1; i&lt;=1; i+=2)\n        for (int j=-1; j&lt;=1; j+=2)\n            tangents (b-a, a.r*i, b.r*j, ans);\n    for (size_t i=0; i&lt;ans.size(); ++i)\n        ans[i].c -= ans[i].a * a.x + ans[i].b * a.y;\n    return ans;\n}\n</code></pre>","tags":["Translated"]},{"location":"geometry/tangents-to-two-circles.html#problems","title":"Problems","text":"<p>TIMUS 1163 Chapaev</p>","tags":["Translated"]},{"location":"geometry/vertical_decomposition.html","title":"Vertical decomposition","text":"","tags":["Translated"]},{"location":"geometry/vertical_decomposition.html#overview","title":"Overview","text":"<p>Vertical decomposition is a powerful technique used in various geometry problems. The general idea is to cut the plane into several vertical stripes with some \"good\" properties and solve the problem for these stripes independently. We will illustrate the idea on some examples.</p>","tags":["Translated"]},{"location":"geometry/vertical_decomposition.html#area-of-the-union-of-triangles","title":"Area of the union of triangles","text":"<p>Suppose that there are $n$ triangles on a plane and we are to find the area of their union. The problem would be easy if the triangles didn't intersect, so let's get rid of these intersections by dividing the plane into vertical stripes by drawing vertical lines through all vertices and all points of intersection of sides of different triangles. There may be $O(n^2)$ such lines so we obtained $O(n^2)$ stripes. Now consider some vertical stripe. Each non-vertical segment either crosses it from left to right or doesn't cross at all. Also, no two segments intersect strictly inside the stripe. It means that the part of the union of triangles that lies inside this stripe is composed of disjoint trapezoids with bases lying on the sides of the stripe. This property allows us to compute the area inside each stripe with a following scanline algorithm. Each segment crossing the stripe is either upper or lower, depending on whether the interior of the corresponding triangle is above or below the segment. We can visualize each upper segment as an opening bracket and each lower segment as a closing bracket and decompose the stripe into trapezoids by decomposing the bracket sequence into smaller correct bracket sequences. This algorithm requires $O(n^3\\log n)$ time and $O(n^2)$ memory.</p>","tags":["Translated"]},{"location":"geometry/vertical_decomposition.html#optimization-1","title":"Optimization 1","text":"<p>Firstly we will reduce the runtime to $O(n^2\\log n)$. Instead of generating trapezoids for each stripe let's fix some triangle side (segment $s = (s_0, s_1)$) and find the set of stripes where this segment is a side of some trapezoid. Note that in this case we only have to find the stripes where the balance of brackets below (or above, in case of a lower segment) $s$ is zero. It means that instead of running vertical scanline for each stripe we can run a horizontal scanline for all parts of other segments which affect the balance of brackets with respect to $s$. For simplicity we will show how to do this for an upper segment, the algorithm for lower segments is similar. Consider some other non-vertical segment $t = (t_0, t_1)$ and find the intersection $[x_1, x_2]$ of projections of $s$ and $t$ on $Ox$. If this intersection is empty or consists of one point, $t$ can be discarded since $s$ and $t$ do not intersect the interior of the same stripe. Otherwise consider the intersection $I$ of $s$ and $t$. There are three cases.</p> <ol> <li> <p>$I = \\varnothing$</p> <p>In this case $t$ is either above or below $s$ on $[x_1, x_2]$. If $t$ is above, it doesn't affect whether $s$ is a side of some trapezoid or not. If $t$ is below $s$, we should add $1$ or $-1$ to the balance of bracket sequences for all stripes in $[x_1, x_2]$, depending on whether $t$ is upper or lower.</p> </li> <li> <p>$I$ consists of a single point $p$</p> <p>This case can be reduced to the previous one by splitting $[x_1, x_2]$ into $[x_1, p_x]$ and $[p_x, x_2]$.</p> </li> <li> <p>$I$ is some segment $l$</p> <p>This case means that the parts of $s$ and $t$ for $x\\in[x_1, x_2]$ coincide. If $t$ is lower, $s$ is clearly not a side of a trapezoid. Otherwise, it could happen that both $s$ and $t$ can be considered as a side of some trapezoid. In order to resolve this ambiguity, we can decide that only the segment with the lowest index should be considered as a side (here we suppose that triangle sides are enumerated in some way). So, if $index(s) &lt; index(t)$, we should ignore this case, otherwise we should mark that $s$ can never be a side on $[x_1, x_2]$ (for example, by adding a corresponding event with balance $-2$).</p> </li> </ol> <p>Here is a graphic representation of the three cases.</p> <p>Finally we should remark on processing all the additions of $1$ or $-1$ on all stripes in $[x_1, x_2]$. For each addition of $w$ on $[x_1, x_2]$ we can create events $(x_1, w),\\ (x_2, -w)$ and process all these events with a sweep line.</p>","tags":["Translated"]},{"location":"geometry/vertical_decomposition.html#optimization-2","title":"Optimization 2","text":"<p>Note that if we apply the previous optimization, we no longer have to find all stripes explicitly. This reduces the memory consumption to $O(n)$.</p>","tags":["Translated"]},{"location":"geometry/vertical_decomposition.html#intersection-of-convex-polygons","title":"Intersection of convex polygons","text":"<p>Another usage of vertical decomposition is to compute the intersection of two convex polygons in linear time. Suppose the plane is split into vertical stripes by vertical lines passing through each vertex of each polygon. Then if we consider one of the input polygons and some stripe, their intersection is either a trapezoid, a triangle or a point. Therefore we can simply intersect these shapes for each vertical stripe and merge these intersections into a single polygon.</p>","tags":["Translated"]},{"location":"geometry/vertical_decomposition.html#implementation","title":"Implementation","text":"<p>Below is the code that calculates area of the union of a set of triangles in $O(n^2\\log n)$ time and $O(n)$ memory.</p> <pre><code>typedef double dbl;\n\nconst dbl eps = 1e-9;\n\ninline bool eq(dbl x, dbl y){\n    return fabs(x - y) &lt; eps;\n}\n\ninline bool lt(dbl x, dbl y){\n    return x &lt; y - eps;\n}\n\ninline bool gt(dbl x, dbl y){\n    return x &gt; y + eps;\n}\n\ninline bool le(dbl x, dbl y){\n    return x &lt; y + eps;\n}\n\ninline bool ge(dbl x, dbl y){\n    return x &gt; y - eps;\n}\n\nstruct pt{\n    dbl x, y;\n    inline pt operator - (const pt &amp; p)const{\n        return pt{x - p.x, y - p.y};\n    }\n    inline pt operator + (const pt &amp; p)const{\n        return pt{x + p.x, y + p.y};\n    }\n    inline pt operator * (dbl a)const{\n        return pt{x * a, y * a};\n    }\n    inline dbl cross(const pt &amp; p)const{\n        return x * p.y - y * p.x;\n    }\n    inline dbl dot(const pt &amp; p)const{\n        return x * p.x + y * p.y;\n    }\n    inline bool operator == (const pt &amp; p)const{\n        return eq(x, p.x) &amp;&amp; eq(y, p.y);\n    }\n};\n\nstruct Line{\n    pt p[2];\n    Line(){}\n    Line(pt a, pt b):p{a, b}{}\n    pt vec()const{\n        return p[1] - p[0];\n    }\n    pt&amp; operator [](size_t i){\n        return p[i];\n    }\n};\n\ninline bool lexComp(const pt &amp; l, const pt &amp; r){\n    if(fabs(l.x - r.x) &gt; eps){\n        return l.x &lt; r.x;\n    }\n    else return l.y &lt; r.y;\n}\n\nvector&lt;pt&gt; interSegSeg(Line l1, Line l2){\n    if(eq(l1.vec().cross(l2.vec()), 0)){\n        if(!eq(l1.vec().cross(l2[0] - l1[0]), 0))\n            return {};\n        if(!lexComp(l1[0], l1[1]))\n            swap(l1[0], l1[1]);\n        if(!lexComp(l2[0], l2[1]))\n            swap(l2[0], l2[1]);\n        pt l = lexComp(l1[0], l2[0]) ? l2[0] : l1[0];\n        pt r = lexComp(l1[1], l2[1]) ? l1[1] : l2[1];\n        if(l == r)\n            return {l};\n        else return lexComp(l, r) ? vector&lt;pt&gt;{l, r} : vector&lt;pt&gt;();\n    }\n    else{\n        dbl s = (l2[0] - l1[0]).cross(l2.vec()) / l1.vec().cross(l2.vec());\n        pt inter = l1[0] + l1.vec() * s;\n        if(ge(s, 0) &amp;&amp; le(s, 1) &amp;&amp; le((l2[0] - inter).dot(l2[1] - inter), 0))\n            return {inter};\n        else\n            return {};\n    }\n}\ninline char get_segtype(Line segment, pt other_point){\n    if(eq(segment[0].x, segment[1].x))\n        return 0;\n    if(!lexComp(segment[0], segment[1]))\n        swap(segment[0], segment[1]);\n    return (segment[1] - segment[0]).cross(other_point - segment[0]) &gt; 0 ? 1 : -1;\n}\n\ndbl union_area(vector&lt;tuple&lt;pt, pt, pt&gt; &gt; triangles){\n    vector&lt;Line&gt; segments(3 * triangles.size());\n    vector&lt;char&gt; segtype(segments.size());\n    for(size_t i = 0; i &lt; triangles.size(); i++){\n        pt a, b, c;\n        tie(a, b, c) = triangles[i];\n        segments[3 * i] = lexComp(a, b) ? Line(a, b) : Line(b, a);\n        segtype[3 * i] = get_segtype(segments[3 * i], c);\n        segments[3 * i + 1] = lexComp(b, c) ? Line(b, c) : Line(c, b);\n        segtype[3 * i + 1] = get_segtype(segments[3 * i + 1], a);\n        segments[3 * i + 2] = lexComp(c, a) ? Line(c, a) : Line(a, c);\n        segtype[3 * i + 2] = get_segtype(segments[3 * i + 2], b);\n    }\n    vector&lt;dbl&gt; k(segments.size()), b(segments.size());\n    for(size_t i = 0; i &lt; segments.size(); i++){\n        if(segtype[i]){\n            k[i] = (segments[i][1].y - segments[i][0].y) / (segments[i][1].x - segments[i][0].x);\n            b[i] = segments[i][0].y - k[i] * segments[i][0].x;\n        }\n    }\n    dbl ans = 0;\n    for(size_t i = 0; i &lt; segments.size(); i++){\n        if(!segtype[i])\n            continue;\n        dbl l = segments[i][0].x, r = segments[i][1].x;\n        vector&lt;pair&lt;dbl, int&gt; &gt; evts;\n        for(size_t j = 0; j &lt; segments.size(); j++){\n            if(!segtype[j] || i == j)\n                continue;\n            dbl l1 = segments[j][0].x, r1 = segments[j][1].x;\n            if(ge(l1, r) || ge(l, r1))\n                continue;\n            dbl common_l = max(l, l1), common_r = min(r, r1);\n            auto pts = interSegSeg(segments[i], segments[j]);\n            if(pts.empty()){\n                dbl yl1 = k[j] * common_l + b[j];\n                dbl yl = k[i] * common_l + b[i];\n                if(lt(yl1, yl) == (segtype[i] == 1)){\n                    int evt_type = -segtype[i] * segtype[j];\n                    evts.emplace_back(common_l, evt_type);\n                    evts.emplace_back(common_r, -evt_type);\n                }\n            }\n            else if(pts.size() == 1u){\n                dbl yl = k[i] * common_l + b[i], yl1 = k[j] * common_l + b[j];\n                int evt_type = -segtype[i] * segtype[j];\n                if(lt(yl1, yl) == (segtype[i] == 1)){\n                    evts.emplace_back(common_l, evt_type);\n                    evts.emplace_back(pts[0].x, -evt_type);\n                }\n                yl = k[i] * common_r + b[i], yl1 = k[j] * common_r + b[j];\n                if(lt(yl1, yl) == (segtype[i] == 1)){\n                    evts.emplace_back(pts[0].x, evt_type);\n                    evts.emplace_back(common_r, -evt_type);\n                }\n            }\n            else{\n                if(segtype[j] != segtype[i] || j &gt; i){\n                    evts.emplace_back(common_l, -2);\n                    evts.emplace_back(common_r, 2);\n                }\n            }\n        }\n        evts.emplace_back(l, 0);\n        sort(evts.begin(), evts.end());\n        size_t j = 0;\n        int balance = 0;\n        while(j &lt; evts.size()){\n            size_t ptr = j;\n            while(ptr &lt; evts.size() &amp;&amp; eq(evts[j].first, evts[ptr].first)){\n                balance += evts[ptr].second;\n                ++ptr;\n            }\n            if(!balance &amp;&amp; !eq(evts[j].first, r)){\n                dbl next_x = ptr == evts.size() ? r : evts[ptr].first;\n                ans -= segtype[i] * (k[i] * (next_x + evts[j].first) + 2 * b[i]) * (next_x - evts[j].first);\n            }\n            j = ptr;\n        }\n    }\n    return ans/2;\n}\n</code></pre>","tags":["Translated"]},{"location":"geometry/vertical_decomposition.html#problems","title":"Problems","text":"<ul> <li>Codeforces 62C Inquisition</li> <li>Codeforces 107E Darts</li> </ul>","tags":["Translated"]},{"location":"graph/01_bfs.html","title":"0-1 BFS","text":"<p>It is well-known, that you can find the shortest paths between a single source and all other vertices in $O(|E|)$ using Breadth First Search in an unweighted graph, i.e. the distance is the minimal number of edges that you need to traverse from the source to another vertex. We can interpret such a graph also as a weighted graph, where every edge has the weight $1$. If not all edges in graph have the same weight, then we need a more general algorithm, like Dijkstra which runs in $O(|V|^2 + |E|)$ or $O(|E| \\log |V|)$ time.</p> <p>However if the weights are more constrained, we can often do better. In this article we demonstrate how we can use BFS to solve the SSSP (single-source shortest path) problem in $O(|E|)$, if the weight of each edge is either $0$ or $1$.</p>","tags":["Original"]},{"location":"graph/01_bfs.html#algorithm","title":"Algorithm","text":"<p>We can develop the algorithm by closely studying Dijkstra's algorithm and thinking about the consequences that our special graph implies. The general form of Dijkstra's algorithm is (here a <code>set</code> is used for the priority queue):</p> <pre><code>d.assign(n, INF);\nd[s] = 0;\nset&lt;pair&lt;int, int&gt;&gt; q;\nq.insert({0, s});\nwhile (!q.empty()) {\n    int v = q.begin()-&gt;second;\n    q.erase(q.begin());\n\n    for (auto edge : adj[v]) {\n        int u = edge.first;\n        int w = edge.second;\n\n        if (d[v] + w &lt; d[u]) {\n            q.erase({d[u], u});\n            d[u] = d[v] + w;\n            q.insert({d[u], u});\n        }\n    }\n}\n</code></pre> <p>We can notice that the difference between the distances between the source <code>s</code> and two other vertices in the queue differs by at most one. Especially, we know that $d[v] \\le d[u] \\le d[v] + 1$ for each $u \\in Q$. The reason for this is, that we only add vertices with equal distance or with distance plus one to the queue during each iteration. Assuming there exists a $u$ in the queue with $d[u] - d[v] &gt; 1$, then $u$ must have been inserted into the queue via a different vertex $t$ with $d[t] \\ge d[u] - 1 &gt; d[v]$. However this is impossible, since Dijkstra's algorithm iterates over the vertices in increasing order.</p> <p>This means, that the order of the queue looks like this:</p> $$Q = \\underbrace{v}_{d[v]}, \\dots, \\underbrace{u}_{d[v]}, \\underbrace{m}_{d[v]+1} \\dots \\underbrace{n}_{d[v]+1}$$ <p>This structure is so simple, that we don't need an actual priority queue, i.e. using a balanced binary tree would be an overkill. We can simply use a normal queue, and append new vertices at the beginning if the corresponding edge has weight $0$, i.e. if $d[u] = d[v]$, or at the end if the edge has weight $1$, i.e. if $d[u] = d[v] + 1$. This way the queue still remains sorted at all time.</p> <pre><code>vector&lt;int&gt; d(n, INF);\nd[s] = 0;\ndeque&lt;int&gt; q;\nq.push_front(s);\nwhile (!q.empty()) {\n    int v = q.front();\n    q.pop_front();\n    for (auto edge : adj[v]) {\n        int u = edge.first;\n        int w = edge.second;\n        if (d[v] + w &lt; d[u]) {\n            d[u] = d[v] + w;\n            if (w == 1)\n                q.push_back(u);\n            else\n                q.push_front(u);\n        }\n    }\n}\n</code></pre>","tags":["Original"]},{"location":"graph/01_bfs.html#dials-algorithm","title":"Dial's algorithm","text":"<p>We can extend this even further if we allow the weights of the edges to be even bigger. If every edge in the graph has a weight $\\le k$, then the distances of vertices in the queue will differ by at most $k$ from the distance of $v$ to the source. So we can keep $k + 1$ buckets for the vertices in the queue, and whenever the bucket corresponding to the smallest distance gets empty, we make a cyclic shift to get the bucket with the next higher distance. This extension is called Dial's algorithm.</p>","tags":["Original"]},{"location":"graph/01_bfs.html#practice-problems","title":"Practice problems","text":"<ul> <li>CodeChef - Chef and Reversing</li> <li>Labyrinth</li> <li>KATHTHI</li> <li>DoNotTurn</li> <li>Ocean Currents</li> <li>Olya and Energy Drinks</li> <li>Three States</li> <li>Colliding Traffic</li> <li>CHamber of Secrets</li> <li>Spiral Maximum</li> <li>Minimum Cost to Make at Least One Valid Path in a Grid</li> </ul>","tags":["Original"]},{"location":"graph/2SAT.html","title":"2-SAT","text":"<p>SAT (Boolean satisfiability problem) is the problem of assigning Boolean values to variables to satisfy a given Boolean formula. The Boolean formula will usually be given in CNF (conjunctive normal form), which is a conjunction of multiple clauses, where each clause is a disjunction of literals (variables or negation of variables). 2-SAT (2-satisfiability) is a restriction of the SAT problem, in 2-SAT every clause has exactly two literals. Here is an example of such a 2-SAT problem. Find an assignment of $a, b, c$ such that the following formula is true:</p> $$(a \\lor \\lnot b) \\land (\\lnot a \\lor b) \\land (\\lnot a \\lor \\lnot b) \\land (a \\lor \\lnot c)$$ <p>SAT is NP-complete, there is no known efficient solution for it. However 2SAT can be solved efficiently in $O(n + m)$ where $n$ is the number of variables and $m$ is the number of clauses.</p>","tags":["Translated"]},{"location":"graph/2SAT.html#algorithm","title":"Algorithm:","text":"<p>First we need to convert the problem to a different form, the so-called implicative normal form. Note that the expression $a \\lor b$ is equivalent to $\\lnot a \\Rightarrow b \\land \\lnot b \\Rightarrow a$ (if one of the two variables is false, then the other one must be true).</p> <p>We now construct a directed graph of these implications: for each variable $x$ there will be two vertices $v_x$ and $v_{\\lnot x}$. The edges will correspond to the implications.</p> <p>Let's look at the example in 2-CNF form:</p> $$(a \\lor \\lnot b) \\land (\\lnot a \\lor b) \\land (\\lnot a \\lor \\lnot b) \\land (a \\lor \\lnot c)$$ <p>The oriented graph will contain the following vertices and edges:</p> $$\\begin{array}{cccc} \\lnot a \\Rightarrow \\lnot b &amp; a \\Rightarrow b &amp; a \\Rightarrow \\lnot b &amp; \\lnot a \\Rightarrow \\lnot c\\\\ b \\Rightarrow a &amp; \\lnot b \\Rightarrow \\lnot a &amp; b \\Rightarrow \\lnot a &amp; c \\Rightarrow a \\end{array}$$ <p>You can see the implication graph in the following image:</p> <p>It is worth paying attention to the property of the implication graph: if there is an edge $a \\Rightarrow b$, then there also is an edge $\\lnot b \\Rightarrow \\lnot a$. </p> <p>Also note, that if $x$ is reachable from $\\lnot x$, and $\\lnot x$ is reachable from $x$, then the problem has no solution. Whatever value we choose for the variable $x$, it will always end in a contradiction - if $x$ will be assigned $\\text{true}$ then the implication tells us that $\\lnot x$ should also be $\\text{true}$ and visa versa. It turns out, that this condition is not only necessary, but also sufficient. We will prove this in a few paragraphs below. First recall, if a vertex is reachable from a second one, and the second one is reachable from the first one, then these two vertices are in the same strongly connected component. Therefore we can formulate the criterion for the existence of a solution as follows:</p> <p>In order for this 2-SAT problem to have a solution, it is necessary and sufficient that for any variable $x$ the vertices $x$ and $\\lnot x$ are in different strongly connected components of the strong connection of the implication graph.</p> <p>This criterion can be verified in $O(n + m)$ time by finding all strongly connected components.</p> <p>The following image shows all strongly connected components for the example. As we can check easily, neither of the four components contain a vertex $x$ and its negation $\\lnot x$, therefore the example has a solution. We will learn in the next paragraphs how to compute a valid assignment, but just for demonstration purposes the solution $a = \\text{false}$, $b = \\text{false}$, $c = \\text{false}$ is given.</p> <p>Now we construct the algorithm for finding the solution of the 2-SAT problem on the assumption that the solution exists.</p> <p>Note that, in spite of the fact that the solution exists, it can happen that $\\lnot x$ is reachable from $x$ in the implication graph, or that (but not simultaneously) $x$ is reachable from $\\lnot x$. In that case the choice of either $\\text{true}$ or $\\text{false}$ for $x$ will lead to a contradiction, while the choice of the other one will not. Let's learn how to choose a value, such that we don't generate a contradiction.</p> <p>Let us sort the strongly connected components in topological order (i.e. $\\text{comp}[v] \\le \\text{comp}[u]$ if there is a path from $v$ to $u$) and let $\\text{comp}[v]$ denote the index of strongly connected component to which the vertex $v$ belongs. Then, if $\\text{comp}[x] &lt; \\text{comp}[\\lnot x]$ we assign $x$ with $\\text{false}$ and $\\text{true}$ otherwise.</p> <p>Let us prove that with this assignment of the variables we do not arrive at a contradiction. Suppose $x$ is assigned with $\\text{true}$. The other case can be proven in a similar way.</p> <p>First we prove that the vertex $x$ cannot reach the vertex $\\lnot x$. Because we assigned $\\text{true}$ it has to hold that the index of strongly connected component of $x$ is greater than the index of the component of $\\lnot x$. This means that $\\lnot x$ is located on the left of the component containing $x$, and the later vertex cannot reach the first.</p> <p>Secondly we prove that there doesn't exist a variable $y$, such that the vertices $y$ and $\\lnot y$ are both reachable from $x$ in the implication graph. This would cause a contradiction, because $x = \\text{true}$ implies that $y = \\text{true}$ and $\\lnot y = \\text{true}$. Let us prove this by contradiction. Suppose that $y$ and $\\lnot y$ are both reachable from $x$, then by the property of the implication graph $\\lnot x$ is reachable from both $y$ and $\\lnot y$. By transitivity this results that $\\lnot x$ is reachable by $x$, which contradicts the assumption.</p> <p>So we have constructed an algorithm that finds the required values of variables under the assumption that for any variable $x$ the vertices $x$ and $\\lnot x$ are in different strongly connected components. Above showed the correctness of this algorithm. Consequently we simultaneously proved the above criterion for the existence of a solution.</p>","tags":["Translated"]},{"location":"graph/2SAT.html#implementation","title":"Implementation:","text":"<p>Now we can implement the entire algorithm. First we construct the graph of implications and find all strongly connected components. This can be accomplished with Kosaraju's algorithm in $O(n + m)$ time. In the second traversal of the graph Kosaraju's algorithm visits the strongly connected components in topological order, therefore it is easy to compute $\\text{comp}[v]$ for each vertex $v$.</p> <p>Afterwards we can choose the assignment of $x$ by comparing $\\text{comp}[x]$ and $\\text{comp}[\\lnot x]$.  If $\\text{comp}[x] = \\text{comp}[\\lnot x]$ we return $\\text{false}$ to indicate that there doesn't exist a valid assignment that satisfies the 2-SAT problem.</p> <p>Below is the implementation of the solution of the 2-SAT problem for the already constructed graph of implication $adj$ and the transpose graph $adj^{\\intercal}$ (in which the direction of each edge is reversed). In the graph the vertices with indices $2k$ and $2k+1$ are the two vertices corresponding to variable $k$ with $2k+1$ corresponding to the negated variable.</p> <pre><code>struct TwoSatSolver {\n    int n_vars;\n    int n_vertices;\n    vector&lt;vector&lt;int&gt;&gt; adj, adj_t;\n    vector&lt;bool&gt; used;\n    vector&lt;int&gt; order, comp;\n    vector&lt;bool&gt; assignment;\n\n    TwoSatSolver(int _n_vars) : n_vars(_n_vars), n_vertices(2 * n_vars), adj(n_vertices), adj_t(n_vertices), used(n_vertices), order(), comp(n_vertices, -1), assignment(n_vars) {\n        order.reserve(n_vertices);\n    }\n    void dfs1(int v) {\n        used[v] = true;\n        for (int u : adj[v]) {\n            if (!used[u])\n                dfs1(u);\n        }\n        order.push_back(v);\n    }\n\n    void dfs2(int v, int cl) {\n        comp[v] = cl;\n        for (int u : adj_t[v]) {\n            if (comp[u] == -1)\n                dfs2(u, cl);\n        }\n    }\n\n    bool solve_2SAT() {\n        order.clear();\n        used.assign(n_vertices, false);\n        for (int i = 0; i &lt; n_vertices; ++i) {\n            if (!used[i])\n                dfs1(i);\n        }\n\n        comp.assign(n_vertices, -1);\n        for (int i = 0, j = 0; i &lt; n_vertices; ++i) {\n            int v = order[n_vertices - i - 1];\n            if (comp[v] == -1)\n                dfs2(v, j++);\n        }\n\n        assignment.assign(n_vars, false);\n        for (int i = 0; i &lt; n_vertices; i += 2) {\n            if (comp[i] == comp[i + 1])\n                return false;\n            assignment[i / 2] = comp[i] &gt; comp[i + 1];\n        }\n        return true;\n    }\n\n    void add_disjunction(int a, bool na, int b, bool nb) {\n        // na and nb signify whether a and b are to be negated \n        a = 2 * a ^ na;\n        b = 2 * b ^ nb;\n        int neg_a = a ^ 1;\n        int neg_b = b ^ 1;\n        adj[neg_a].push_back(b);\n        adj[neg_b].push_back(a);\n        adj_t[b].push_back(neg_a);\n        adj_t[a].push_back(neg_b);\n    }\n\n    static void example_usage() {\n        TwoSatSolver solver(3); // a, b, c\n        solver.add_disjunction(0, false, 1, true);  //     a  v  not b\n        solver.add_disjunction(0, true, 1, true);   // not a  v  not b\n        solver.add_disjunction(1, false, 2, false); //     b  v      c\n        solver.add_disjunction(0, false, 0, false); //     a  v      a\n        assert(solver.solve_2SAT() == true);\n        auto expected = vector&lt;bool&gt;(True, False, True);\n        assert(solver.assignment == expected);\n    }\n};\n</code></pre>","tags":["Translated"]},{"location":"graph/2SAT.html#practice-problems","title":"Practice Problems","text":"<ul> <li>Codeforces: The Door Problem</li> <li>Kattis: Illumination</li> <li>UVA: Rectangles</li> <li>Codeforces : Radio Stations</li> <li>CSES : Giant Pizza</li> <li>Codeforces: +-1</li> </ul>","tags":["Translated"]},{"location":"graph/Assignment-problem-min-flow.html","title":"Solving assignment problem using min-cost-flow","text":"<p>The assignment problem has two equivalent statements:</p> <ul> <li>Given a square matrix $A[1..N, 1..N]$, you need to select $N$ elements in it so that exactly one element is selected in each row and column, and the sum of the values of these elements is the smallest.</li> <li>There are $N$ orders and $N$ machines. The cost of manufacturing on each machine is known for each order.  Only one order can be performed on each machine. It is required to assign all orders to the machines so that the total cost is minimized.</li> </ul> <p>Here we will consider the solution of the problem based on the algorithm for finding the minimum cost flow (min-cost-flow), solving the assignment problem in $\\mathcal{O}(N^3)$.</p>","tags":["Translated"]},{"location":"graph/Assignment-problem-min-flow.html#description","title":"Description","text":"<p>Let's build a bipartite network: there is a source $S$, a drain $T$, in the first part there are $N$ vertices (corresponding to rows of the matrix, or orders), in the second there are also $N$ vertices (corresponding to the columns of the matrix, or machines). Between each vertex $i$ of the first set and each vertex $j$ of the second set, we draw an edge with bandwidth 1 and cost $A_{ij}$. From the source $S$ we draw edges to all vertices $i$ of the first set with bandwidth 1 and cost 0. We draw an edge with bandwidth 1 and cost 0 from each vertex of the second set $j$ to the drain $T$.</p> <p>We find in the resulting network the maximum flow of the minimum cost. Obviously, the value of the flow will be $N$. Further, for each vertex $i$ of the first segment there is exactly one vertex $j$ of the second segment, such that the flow $F_{ij}$ = 1. Finally, this is a one-to-one correspondence between the vertices of the first segment and the vertices of the second part, which is the solution to the problem (since the found flow has a minimal cost, then the sum of the costs of the selected edges will be the lowest possible, which is the optimality criterion).</p> <p>The complexity of this solution of the assignment problem depends on the algorithm by which the search for the maximum flow of the minimum cost is performed. The complexity will be $\\mathcal{O}(N^3)$ using Dijkstra or $\\mathcal{O}(N^4)$ using Bellman-Ford. This is due to the fact that the flow is of size $O(N)$ and each iteration of Dijkstra algorithm can be performed in $O(N^2)$, while it is $O(N^3)$ for Bellman-Ford.</p>","tags":["Translated"]},{"location":"graph/Assignment-problem-min-flow.html#implementation","title":"Implementation","text":"<p>The implementation given here is long, it can probably be significantly reduced. It uses the SPFA algorithm for finding shortest paths.</p> <pre><code>const int INF = 1000 * 1000 * 1000;\n\nvector&lt;int&gt; assignment(vector&lt;vector&lt;int&gt;&gt; a) {\n    int n = a.size();\n    int m = n * 2 + 2;\n    vector&lt;vector&lt;int&gt;&gt; f(m, vector&lt;int&gt;(m));\n    int s = m - 2, t = m - 1;\n    int cost = 0;\n    while (true) {\n        vector&lt;int&gt; dist(m, INF);\n        vector&lt;int&gt; p(m);\n        vector&lt;bool&gt; inq(m, false);\n        queue&lt;int&gt; q;\n        dist[s] = 0;\n        p[s] = -1;\n        q.push(s);\n        while (!q.empty()) {\n            int v = q.front();\n            q.pop();\n            inq[v] = false;\n            if (v == s) {\n                for (int i = 0; i &lt; n; ++i) {\n                    if (f[s][i] == 0) {\n                        dist[i] = 0;\n                        p[i] = s;\n                        inq[i] = true;\n                        q.push(i);\n                    }\n                }\n            } else {\n                if (v &lt; n) {\n                    for (int j = n; j &lt; n + n; ++j) {\n                        if (f[v][j] &lt; 1 &amp;&amp; dist[j] &gt; dist[v] + a[v][j - n]) {\n                            dist[j] = dist[v] + a[v][j - n];\n                            p[j] = v;\n                            if (!inq[j]) {\n                                q.push(j);\n                                inq[j] = true;\n                            }\n                        }\n                    }\n                } else {\n                    for (int j = 0; j &lt; n; ++j) {\n                        if (f[v][j] &lt; 0 &amp;&amp; dist[j] &gt; dist[v] - a[j][v - n]) {\n                            dist[j] = dist[v] - a[j][v - n];\n                            p[j] = v;\n                            if (!inq[j]) {\n                                q.push(j);\n                                inq[j] = true;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        int curcost = INF;\n        for (int i = n; i &lt; n + n; ++i) {\n            if (f[i][t] == 0 &amp;&amp; dist[i] &lt; curcost) {\n                curcost = dist[i];\n                p[t] = i;\n            }\n        }\n        if (curcost == INF)\n            break;\n        cost += curcost;\n        for (int cur = t; cur != -1; cur = p[cur]) {\n            int prev = p[cur];\n            if (prev != -1)\n                f[cur][prev] = -(f[prev][cur] = 1);\n        }\n    }\n\n    vector&lt;int&gt; answer(n);\n    for (int i = 0; i &lt; n; ++i) {\n        for (int j = 0; j &lt; n; ++j) {\n            if (f[i][j + n] == 1)\n                answer[i] = j;\n        }\n    }\n    return answer;\n}\n</code></pre>","tags":["Translated"]},{"location":"graph/all-pair-shortest-path-floyd-warshall.html","title":"Floyd-Warshall Algorithm","text":"<p>Given a directed or an undirected weighted graph $G$ with $n$ vertices. The task is to find the length of the shortest path $d_{ij}$ between each pair of vertices $i$ and $j$.</p> <p>The graph may have negative weight edges, but no negative weight cycles.</p> <p>If there is such a negative cycle, you can just traverse this cycle over and over, in each iteration making the cost of the path smaller. So you can make certain paths arbitrarily small, or in other words that shortest path is undefined. That automatically means that an undirected graph cannot have any negative weight edges, as such an edge forms already a negative cycle as you can move back and forth along that edge as long as you like.</p> <p>This algorithm can also be used to detect the presence of negative cycles. The graph has a negative cycle if at the end of the algorithm, the distance from a vertex $v$ to itself is negative.</p> <p>This algorithm has been simultaneously published in articles by Robert Floyd and Stephen Warshall in 1962. However, in 1959, Bernard Roy published essentially the same algorithm, but its publication went unnoticed.</p>","tags":["Translated"]},{"location":"graph/all-pair-shortest-path-floyd-warshall.html#description-of-the-algorithm","title":"Description of the algorithm","text":"<p>The key idea of the algorithm is to partition the process of finding the shortest path between any two vertices to several incremental phases.</p> <p>Let us number the vertices starting from 1 to $n$. The matrix of distances is $d[ ][ ]$.</p> <p>Before $k$-th phase ($k = 1 \\dots n$), $d[i][j]$ for any vertices $i$ and $j$ stores the length of the shortest path between the vertex $i$ and vertex $j$, which contains only the vertices $\\{1, 2, ..., k-1\\}$ as internal vertices in the path.</p> <p>In other words, before $k$-th phase the value of $d[i][j]$ is equal to the length of the shortest path from vertex $i$ to the vertex $j$, if this path is allowed to enter only the vertex with numbers smaller than $k$ (the beginning and end of the path are not restricted by this property).</p> <p>It is easy to make sure that this property holds for the first phase. For $k = 0$, we can fill matrix with $d[i][j] = w_{i j}$ if there exists an edge between $i$ and $j$ with weight $w_{i j}$ and $d[i][j] = \\infty$ if there doesn't exist an edge. In practice $\\infty$ will be some high value. As we shall see later, this is a requirement for the algorithm.</p> <p>Suppose now that we are in the $k$-th phase, and we want to compute the matrix $d[ ][ ]$ so that it meets the requirements for the $(k + 1)$-th phase. We have to fix the distances for some vertices pairs $(i, j)$. There are two fundamentally different cases:</p> <ul> <li> <p>The shortest way from the vertex $i$ to the vertex $j$ with internal vertices from the set $\\{1, 2, \\dots, k\\}$ coincides with the shortest path with internal vertices from the set $\\{1, 2, \\dots, k-1\\}$.</p> <p>In this case, $d[i][j]$ will not change during the transition.</p> </li> <li> <p>The shortest path with internal vertices from $\\{1, 2, \\dots, k\\}$ is shorter.</p> <p>This means that the new, shorter path passes through the vertex $k$. This means that we can split the shortest path between $i$ and $j$ into two paths: the path between $i$ and $k$, and the path between $k$ and $j$. It is clear that both this paths only use internal vertices of $\\{1, 2, \\dots, k-1\\}$ and are the shortest such paths in that respect. Therefore we already have computed the lengths of those paths before, and we can compute the length of the shortest path between $i$ and $j$ as $d[i][k] + d[k][j]$.</p> </li> </ul> <p>Combining these two cases we find that we can recalculate the length of all pairs $(i, j)$ in the $k$-th phase in the following way:</p> $$d_{\\text{new}}[i][j] = min(d[i][j], d[i][k] + d[k][j])$$ <p>Thus, all the work that is required in the $k$-th phase is to iterate over all pairs of vertices and recalculate the length of the shortest path between them. As a result, after the $n$-th phase, the value $d[i][j]$ in the distance matrix is the length of the shortest path between $i$ and $j$, or is $\\infty$ if the path between the vertices $i$ and $j$ does not exist.</p> <p>A last remark - we don't need to create a separate distance matrix $d_{\\text{new}}[ ][ ]$ for temporarily storing the shortest paths of the $k$-th phase, i.e. all changes can be made directly in the matrix $d[ ][ ]$ at any phase. In fact at any $k$-th phase we are at most improving the distance of any path in the distance matrix, hence we cannot worsen the length of the shortest path for any pair of the vertices that are to be processed in the $(k+1)$-th phase or later.</p> <p>The time complexity of this algorithm is obviously $O(n^3)$.</p>","tags":["Translated"]},{"location":"graph/all-pair-shortest-path-floyd-warshall.html#implementation","title":"Implementation","text":"<p>Let $d[][]$ is a 2D array of size $n \\times n$, which is filled according to the $0$-th phase as explained earlier. Also we will set $d[i][i] = 0$ for any $i$ at the $0$-th phase.</p> <p>Then the algorithm is implemented as follows:</p> <pre><code>for (int k = 0; k &lt; n; ++k) {\n    for (int i = 0; i &lt; n; ++i) {\n        for (int j = 0; j &lt; n; ++j) {\n            d[i][j] = min(d[i][j], d[i][k] + d[k][j]); \n        }\n    }\n}\n</code></pre> <p>It is assumed that if there is no edge between any two vertices $i$ and $j$, then the matrix at $d[i][j]$ contains a large number (large enough so that it is greater than the length of any path in this graph). Then this edge will always be unprofitable to take, and the algorithm will work correctly.</p> <p>However if there are negative weight edges in the graph, special measures have to be taken. Otherwise the resulting values in matrix may be of the form $\\infty - 1$,  $\\infty - 2$, etc., which, of course, still indicates that between the respective vertices doesn't exist a path. Therefore, if the graph has negative weight edges, it is better to write the Floyd-Warshall algorithm in the following way, so that it does not perform transitions using paths that don't exist.</p> <pre><code>for (int k = 0; k &lt; n; ++k) {\n    for (int i = 0; i &lt; n; ++i) {\n        for (int j = 0; j &lt; n; ++j) {\n            if (d[i][k] &lt; INF &amp;&amp; d[k][j] &lt; INF)\n                d[i][j] = min(d[i][j], d[i][k] + d[k][j]); \n        }\n    }\n}\n</code></pre>","tags":["Translated"]},{"location":"graph/all-pair-shortest-path-floyd-warshall.html#retrieving-the-sequence-of-vertices-in-the-shortest-path","title":"Retrieving the sequence of vertices in the shortest path","text":"<p>It is easy to maintain additional information with which it will be possible to retrieve the shortest path between any two given vertices in the form of a sequence of vertices.</p> <p>For this, in addition to the distance matrix $d[ ][ ]$, a matrix of ancestors $p[ ][ ]$ must be maintained, which will contain the number of the phase where the shortest distance between two vertices was last modified. It is clear that the number of the phase is nothing more than a vertex in the middle of the desired shortest path. Now we just need to find the shortest path between vertices $i$ and $p[i][j]$, and between $p[i][j]$ and $j$. This leads to a simple recursive reconstruction algorithm of the shortest path.</p>","tags":["Translated"]},{"location":"graph/all-pair-shortest-path-floyd-warshall.html#the-case-of-real-weights","title":"The case of real weights","text":"<p>If the weights of the edges are not integer but real, it is necessary to take the errors, which occur when working with float types, into account.</p> <p>The Floyd-Warshall algorithm has the unpleasant effect, that the errors accumulate very quickly. In fact if there is an error in the first phase of $\\delta$, this error may propagate to the second iteration as $2 \\delta$, to the third iteration as $4 \\delta$, and so on.</p> <p>To avoid this the algorithm can be modified to take the error (EPS = $\\delta$) into account by using following comparison:</p> <pre><code>if (d[i][k] + d[k][j] &lt; d[i][j] - EPS)\n    d[i][j] = d[i][k] + d[k][j]; \n</code></pre>","tags":["Translated"]},{"location":"graph/all-pair-shortest-path-floyd-warshall.html#the-case-of-negative-cycles","title":"The case of negative cycles","text":"<p>Formally the Floyd-Warshall algorithm does not apply to graphs containing negative weight cycle(s). But for all pairs of vertices $i$ and $j$ for which there doesn't exist a path starting at $i$, visiting a negative cycle, and end at $j$,  the algorithm will still work correctly.</p> <p>For the pair of vertices for which the answer does not exist (due to the presence of a negative cycle in the path between them), the Floyd algorithm will store any number (perhaps highly negative, but not necessarily) in the distance matrix. However it is possible to improve the Floyd-Warshall algorithm, so that it carefully treats such pairs of vertices, and outputs them, for example as $-\\text{INF}$.</p> <p>This can be done in the following way: let us run the usual Floyd-Warshall algorithm for a given graph. Then a shortest path between vertices $i$ and $j$ does not exist, if and only if, there is a vertex $t$ such that, $t$ is reachable from $i$ and $j$ is reachable from $t$, for which $d[t][t] &lt; 0$.</p> <p>In addition, when using the Floyd-Warshall algorithm for graphs with negative cycles, we should keep in mind that situations may arise in which distances can get exponentially fast into the negative. Therefore integer overflow must be handled by limiting the minimal distance by some value (e.g. $-\\text{INF}$).</p> <p>To learn more about finding negative cycles in a graph, see the separate article Finding a negative cycle in the graph.</p>","tags":["Translated"]},{"location":"graph/all-pair-shortest-path-floyd-warshall.html#practice-problems","title":"Practice Problems","text":"<ul> <li>UVA: Page Hopping</li> <li>SPOJ: Possible Friends</li> <li>CODEFORCES: Greg and Graph</li> <li>SPOJ: CHICAGO - 106 miles to Chicago</li> <li>UVA 10724 - Road Construction</li> <li>UVA  117 - The Postal Worker Rings Once</li> <li>Codeforces - Traveling Graph</li> <li>UVA - 1198 - The Geodetic Set Problem</li> <li>UVA - 10048 - Audiophobia</li> <li>UVA - 125 - Numbering Paths</li> <li>LOJ - Travel Company</li> <li>UVA 423 - MPI Maelstrom</li> <li>UVA 1416 - Warfare And Logistics</li> <li>UVA 1233 - USHER</li> <li>UVA 10793 - The Orc Attack</li> <li>UVA 10099 The Tourist Guide</li> <li>UVA 869 - Airline Comparison</li> <li>UVA 13211 - Geonosis</li> <li>SPOJ - Defend the Rohan</li> <li>Codeforces - Roads in Berland</li> <li>Codeforces - String Problem</li> <li>GYM - Manic Moving (C)</li> <li>SPOJ - Arbitrage</li> <li>UVA - 12179 - Randomly-priced Tickets</li> <li>LOJ - 1086 - Jogging Trails</li> <li>SPOJ - Ingredients</li> <li>CSES - Shortest Routes II</li> </ul>","tags":["Translated"]},{"location":"graph/bellman_ford.html","title":"Bellman-Ford Algorithm","text":"<p>Single source shortest path with negative weight edges</p> <p>Suppose that we are given a weighted directed graph $G$ with $n$ vertices and $m$ edges, and some specified vertex $v$. You want to find the length of shortest paths from vertex $v$ to every other vertex.</p> <p>Unlike the Dijkstra algorithm, this algorithm can also be applied to graphs containing negative weight edges . However, if the graph contains a negative cycle, then, clearly, the shortest path to some vertices may not exist (due to the fact that the weight of the shortest path must be equal to minus infinity); however, this algorithm can be modified to signal the presence of a cycle of negative weight, or even deduce this cycle.</p> <p>The algorithm bears the name of two American scientists: Richard Bellman and Lester Ford. Ford actually invented this algorithm in 1956 during the study of another mathematical problem, which eventually reduced to a subproblem of finding the shortest paths in the graph, and Ford gave an outline of the algorithm to solve this problem. Bellman in 1958 published an article devoted specifically to the problem of finding the shortest path, and in this article he clearly formulated the algorithm in the form in which it is known to us now.</p>","tags":["Translated"]},{"location":"graph/bellman_ford.html#description-of-the-algorithm","title":"Description of the algorithm","text":"<p>Let us assume that the graph contains no negative weight cycle. The case of presence of a negative weight cycle will be discussed below in a separate section.</p> <p>We will create an array of distances $d[0 \\ldots n-1]$, which after execution of the algorithm will contain the answer to the problem. In the beginning we fill it as follows: $d[v] = 0$, and all other elements $d[ ]$ equal to infinity $\\infty$.</p> <p>The algorithm consists of several phases. Each phase scans through all edges of the graph, and the algorithm tries to produce relaxation along each edge $(a,b)$ having weight $c$. Relaxation along the edges is an attempt to improve the value $d[b]$ using value $d[a] + c$. In fact, it means that we are trying to improve the answer for this vertex using edge $(a,b)$ and current answer for vertex $a$.</p> <p>It is claimed that $n-1$ phases of the algorithm are sufficient to correctly calculate the lengths of all shortest paths in the graph (again, we believe that the cycles of negative weight do not exist). For unreachable vertices the distance $d[ ]$ will remain equal to infinity $\\infty$.</p>","tags":["Translated"]},{"location":"graph/bellman_ford.html#implementation","title":"Implementation","text":"<p>Unlike many other graph algorithms, for Bellman-Ford algorithm, it is more convenient to represent the graph using a single list of all edges (instead of $n$ lists of edges - edges from each vertex). We start the implementation with a structure $\\rm edge$ for representing the edges. The input to the algorithm are numbers $n$, $m$, list $e$ of edges and the starting vertex $v$. All the vertices are numbered $0$ to $n - 1$.</p>","tags":["Translated"]},{"location":"graph/bellman_ford.html#the-simplest-implementation","title":"The simplest implementation","text":"<p>The constant $\\rm INF$ denotes the number \"infinity\" \u2014 it should be selected in such a way that it is greater than all possible path lengths.</p> <pre><code>struct Edge {\n    int a, b, cost;\n};\n\nint n, m, v;\nvector&lt;Edge&gt; edges;\nconst int INF = 1000000000;\n\nvoid solve()\n{\n    vector&lt;int&gt; d(n, INF);\n    d[v] = 0;\n    for (int i = 0; i &lt; n - 1; ++i)\n        for (Edge e : edges)\n            if (d[e.a] &lt; INF)\n                d[e.b] = min(d[e.b], d[e.a] + e.cost);\n    // display d, for example, on the screen\n}\n</code></pre> <p>The check <code>if (d[e.a] &lt; INF)</code> is needed only if the graph contains negative weight edges: no such verification would result in relaxation from the vertices to which paths have not yet found, and incorrect distance, of the type $\\infty - 1$, $\\infty - 2$ etc. would appear.</p>","tags":["Translated"]},{"location":"graph/bellman_ford.html#a-better-implementation","title":"A better implementation","text":"<p>This algorithm can be somewhat speeded up: often we already get the answer in a few phases and no useful work is done in remaining phases, just a waste visiting all edges. So, let's keep the flag, to tell whether something changed in the current phase or not, and if any phase, nothing changed, the algorithm can be stopped. (This optimization does not improve the asymptotic behavior, i.e., some graphs will still need all $n-1$ phases, but significantly accelerates the behavior of the algorithm \"on an average\", i.e., on random graphs.)</p> <p>With this optimization, it is generally unnecessary to restrict manually the number of phases of the algorithm to $n-1$ \u2014 the algorithm will stop after the desired number of phases.</p> <pre><code>void solve()\n{\n    vector&lt;int&gt; d(n, INF);\n    d[v] = 0;\n    for (;;) {\n        bool any = false;\n\n        for (Edge e : edges)\n            if (d[e.a] &lt; INF)\n                if (d[e.b] &gt; d[e.a] + e.cost) {\n                    d[e.b] = d[e.a] + e.cost;\n                    any = true;\n                }\n\n        if (!any)\n            break;\n    }\n    // display d, for example, on the screen\n}\n</code></pre>","tags":["Translated"]},{"location":"graph/bellman_ford.html#retrieving-path","title":"Retrieving Path","text":"<p>Let us now consider how to modify the algorithm so that it not only finds the length of shortest paths, but also allows to reconstruct the shortest paths.</p> <p>For that, let's create another array $p[0 \\ldots n-1]$, where for each vertex we store its \"predecessor\", i.e. the penultimate vertex in the shortest path leading to it. In fact, the shortest path to any vertex $a$ is a shortest path to some vertex $p[a]$, to which we added $a$ at the end of the path.</p> <p>Note that the algorithm works on the same logic: it assumes that the shortest distance to one vertex is already calculated, and, tries to improve the shortest distance to other vertices from that vertex. Therefore, at the time of improvement we just need to remember $p[ ]$, i.e,  the vertex from which this improvement has occurred.</p> <p>Following is an implementation of the Bellman-Ford with the retrieval of shortest path to a given node $t$:</p> <pre><code>void solve()\n{\n    vector&lt;int&gt; d(n, INF);\n    d[v] = 0;\n    vector&lt;int&gt; p(n, -1);\n\n    for (;;) {\n        bool any = false;\n        for (Edge e : edges)\n            if (d[e.a] &lt; INF)\n                if (d[e.b] &gt; d[e.a] + e.cost) {\n                    d[e.b] = d[e.a] + e.cost;\n                    p[e.b] = e.a;\n                    any = true;\n                }\n        if (!any)\n            break;\n    }\n\n    if (d[t] == INF)\n        cout &lt;&lt; \"No path from \" &lt;&lt; v &lt;&lt; \" to \" &lt;&lt; t &lt;&lt; \".\";\n    else {\n        vector&lt;int&gt; path;\n        for (int cur = t; cur != -1; cur = p[cur])\n            path.push_back(cur);\n        reverse(path.begin(), path.end());\n\n        cout &lt;&lt; \"Path from \" &lt;&lt; v &lt;&lt; \" to \" &lt;&lt; t &lt;&lt; \": \";\n        for (int u : path)\n            cout &lt;&lt; u &lt;&lt; ' ';\n    }\n}\n</code></pre> <p>Here starting from the vertex $t$, we go through the predecessors till we reach starting vertex with no predecessor, and store all the vertices in the path in the list $\\rm path$. This list is a shortest path from $v$ to $t$, but in reverse order, so we call $\\rm reverse()$ function over $\\rm path$ and then output the path.</p>","tags":["Translated"]},{"location":"graph/bellman_ford.html#the-proof-of-the-algorithm","title":"The proof of the algorithm","text":"<p>First, note that for all unreachable vertices $u$ the algorithm will work correctly, the label $d[u]$ will remain equal to infinity (because the algorithm Bellman-Ford will find some way to all reachable vertices from the start vertex $v$, and relaxation for all other  remaining vertices will never happen).</p> <p>Let us now prove the following assertion: After the execution of $i_{th}$ phase, the Bellman-Ford algorithm correctly finds all shortest paths whose number of edges does not exceed $i$.</p> <p>In other words, for any vertex $a$ let us denote the $k$ number of edges in the shortest path to it (if there are several such paths, you can take any). According to this statement, the algorithm guarantees that after $k_{th}$ phase the shortest path for vertex $a$ will be found.</p> <p>Proof: Consider an arbitrary vertex $a$ to which there is a path from the starting vertex $v$, and consider a shortest path to it $(p_0=v, p_1, \\ldots, p_k=a)$. Before the first phase, the shortest path to the vertex $p_0 = v$ was found correctly. During the first phase, the edge $(p_0,p_1)$ has been checked by the algorithm, and therefore, the distance to the vertex $p_1$ was correctly calculated after the first phase. Repeating this statement $k$ times, we see that after $k_{th}$ phase the distance to the vertex $p_k = a$ gets calculated correctly, which we wanted to prove.</p> <p>The last thing to notice is that any shortest path cannot have more than $n - 1$ edges. Therefore, the algorithm sufficiently goes up to the $(n-1)_{th}$ phase. After that, it is guaranteed that no relaxation will improve the distance to some vertex.</p>","tags":["Translated"]},{"location":"graph/bellman_ford.html#the-case-of-a-negative-cycle","title":"The case of a negative cycle","text":"<p>Everywhere above we considered that there is no negative cycle in the graph (precisely, we are interested in a negative cycle that is reachable from the starting vertex $v$, and, for an unreachable cycles nothing in the above algorithm changes). In the presence of a negative cycle(s), there are further complications associated with the fact that distances to all vertices in this cycle, as well as the distances to the vertices reachable from this cycle is not defined \u2014 they should be equal to minus infinity $(- \\infty)$.</p> <p>It is easy to see that the Bellman-Ford algorithm can endlessly do the relaxation among all vertices of this cycle and the vertices reachable from it. Therefore, if you do not limit the number of phases to $n - 1$, the algorithm will run indefinitely, constantly improving the distance from these vertices.</p> <p>Hence we obtain the criterion for presence of a cycle of negative weights reachable for source vertex $v$: after $(n-1)_{th}$ phase, if we run algorithm for one more phase, and it performs at least one more relaxation, then the graph contains a negative weight cycle that is reachable from $v$; otherwise, such a cycle does not exist.</p> <p>Moreover, if such a cycle is found, the Bellman-Ford algorithm can be modified so that it retrieves this cycle as a sequence of vertices contained in it. For this, it is sufficient to remember the last vertex $x$ for which there was a relaxation in $n_{th}$ phase. This vertex will either lie on a negative weight cycle, or is reachable from it. To get the vertices that are guaranteed to lie on a negative cycle, starting from the vertex $x$, pass through to the predecessors $n$ times. In this way, we will get to the vertex $y$, which is guaranteed to lie on a negative cycle. We have to go from this vertex, through the predecessors, until we get back to the same vertex $y$ (and it will happen, because relaxation in a negative weight cycle occur in a circular manner).</p>","tags":["Translated"]},{"location":"graph/bellman_ford.html#implementation_1","title":"Implementation:","text":"<pre><code>void solve()\n{\n    vector&lt;int&gt; d(n, INF);\n    d[v] = 0;\n    vector&lt;int&gt; p(n, -1);\n    int x;\n    for (int i = 0; i &lt; n; ++i) {\n        x = -1;\n        for (Edge e : edges)\n            if (d[e.a] &lt; INF)\n                if (d[e.b] &gt; d[e.a] + e.cost) {\n                    d[e.b] = max(-INF, d[e.a] + e.cost);\n                    p[e.b] = e.a;\n                    x = e.b;\n                }\n    }\n\n    if (x == -1)\n        cout &lt;&lt; \"No negative cycle from \" &lt;&lt; v;\n    else {\n        int y = x;\n        for (int i = 0; i &lt; n; ++i)\n            y = p[y];\n\n        vector&lt;int&gt; path;\n        for (int cur = y;; cur = p[cur]) {\n            path.push_back(cur);\n            if (cur == y &amp;&amp; path.size() &gt; 1)\n                break;\n        }\n        reverse(path.begin(), path.end());\n\n        cout &lt;&lt; \"Negative cycle: \";\n        for (int u : path)\n            cout &lt;&lt; u &lt;&lt; ' ';\n    }\n}\n</code></pre> <p>Due to the presence of a negative cycle, for $n$ iterations of the algorithm, the distances may go far in the negative range (to negative numbers of the order of $-n m W$, where $W$ is the maximum absolute value of any weight in the graph). Hence in the code, we adopted additional measures against the integer overflow as follows:</p> <pre><code>d[e.b] = max(-INF, d[e.a] + e.cost);\n</code></pre> <p>The above implementation looks for a negative cycle reachable from some starting vertex $v$; however, the algorithm can be modified to just look for any negative cycle in the graph. For this we need to put all the distance $d[i]$ to zero and not infinity \u2014 as if we are looking for the shortest path from all vertices simultaneously; the validity of the detection of a negative cycle is not affected.</p> <p>For more on this topic \u2014 see separate article, Finding a negative cycle in the graph.</p>","tags":["Translated"]},{"location":"graph/bellman_ford.html#shortest-path-faster-algorithm-spfa","title":"Shortest Path Faster Algorithm (SPFA)","text":"<p>SPFA is a improvement of the Bellman-Ford algorithm which takes advantage of the fact that not all attempts at relaxation will work. The main idea is to create a queue containing only the vertices that were relaxed but that still could further relax their neighbors. And whenever you can relax some neighbor, you should put him in the queue. This algorithm can also be used to detect negative cycles as the Bellman-Ford.</p> <p>The worst case of this algorithm is equal to the $O(n m)$ of the Bellman-Ford, but in practice it works much faster and some people claim that it works even in $O(m)$ on average. However be careful, because this algorithm is deterministic and it is easy to create counterexamples that make the algorithm run in $O(n m)$.</p> <p>There are some care to be taken in the implementation, such as the fact that the algorithm continues forever if there is a negative cycle. To avoid this, it is possible to create a counter that stores how many times a vertex has been relaxed and stop the algorithm as soon as some vertex got relaxed for the $n$-th time. Note, also there is no reason to put a vertex in the queue if it is already in.</p> <pre><code>const int INF = 1000000000;\nvector&lt;vector&lt;pair&lt;int, int&gt;&gt;&gt; adj;\n\nbool spfa(int s, vector&lt;int&gt;&amp; d) {\n    int n = adj.size();\n    d.assign(n, INF);\n    vector&lt;int&gt; cnt(n, 0);\n    vector&lt;bool&gt; inqueue(n, false);\n    queue&lt;int&gt; q;\n\n    d[s] = 0;\n    q.push(s);\n    inqueue[s] = true;\n    while (!q.empty()) {\n        int v = q.front();\n        q.pop();\n        inqueue[v] = false;\n\n        for (auto edge : adj[v]) {\n            int to = edge.first;\n            int len = edge.second;\n\n            if (d[v] + len &lt; d[to]) {\n                d[to] = d[v] + len;\n                if (!inqueue[to]) {\n                    q.push(to);\n                    inqueue[to] = true;\n                    cnt[to]++;\n                    if (cnt[to] &gt; n)\n                        return false;  // negative cycle\n                }\n            }\n        }\n    }\n    return true;\n}\n</code></pre>","tags":["Translated"]},{"location":"graph/bellman_ford.html#related-problems-in-online-judges","title":"Related problems in online judges","text":"<p>A list of tasks that can be solved using the Bellman-Ford algorithm:</p> <ul> <li>E-OLYMP #1453 \"Ford-Bellman\" [difficulty: low]</li> <li>UVA #423 \"MPI Maelstrom\" [difficulty: low]</li> <li>UVA #534 \"Frogger\" [difficulty: medium]</li> <li>UVA #10099 \"The Tourist Guide\" [difficulty: medium]</li> <li>UVA #515 \"King\" [difficulty: medium]</li> <li>UVA 12519 - The Farnsworth Parabox</li> </ul> <p>See also the problem list in the article Finding the negative cycle in a graph. * CSES - High Score * CSES - Cycle Finding</p>","tags":["Translated"]},{"location":"graph/bipartite-check.html","title":"Check whether a graph is bipartite","text":"<p>A bipartite graph is a graph whose vertices can be divided into two disjoint sets so that every edge connects two vertices from different sets (i.e. there are no edges which connect vertices from the same set). These sets are usually called sides.</p> <p>You are given an undirected graph. Check whether it is bipartite, and if it is, output its sides.</p>","tags":["Translated"]},{"location":"graph/bipartite-check.html#algorithm","title":"Algorithm","text":"<p>There exists a theorem which claims that a graph is bipartite if and only if all its cycles have even length. However, in practice it's more convenient to use a different formulation of the definition: a graph is bipartite if and only if it is two-colorable.</p> <p>Let's use a series of breadth-first searches, starting from each vertex which hasn't been visited yet. In each search, assign the vertex from which we start to side 1. Each time we visit a yet unvisited neighbor of a vertex assigned to one side, we assign it to the other side. When we try to go to a neighbor of a vertex assigned to one side which has already been visited, we check that it has been assigned to the other side; if it has been assigned to the same side, we conclude that the graph is not bipartite. Once we've visited all vertices and successfully assigned them to sides, we know that the graph is bipartite and we have constructed its partitioning.</p>","tags":["Translated"]},{"location":"graph/bipartite-check.html#implementation","title":"Implementation","text":"<pre><code>int n;\nvector&lt;vector&lt;int&gt;&gt; adj;\n\nvector&lt;int&gt; side(n, -1);\nbool is_bipartite = true;\nqueue&lt;int&gt; q;\nfor (int st = 0; st &lt; n; ++st) {\n    if (side[st] == -1) {\n        q.push(st);\n        side[st] = 0;\n        while (!q.empty()) {\n            int v = q.front();\n            q.pop();\n            for (int u : adj[v]) {\n                if (side[u] == -1) {\n                    side[u] = side[v] ^ 1;\n                    q.push(u);\n                } else {\n                    is_bipartite &amp;= side[u] != side[v];\n                }\n            }\n        }\n    }\n}\n\ncout &lt;&lt; (is_bipartite ? \"YES\" : \"NO\") &lt;&lt; endl;\n</code></pre>","tags":["Translated"]},{"location":"graph/bipartite-check.html#practice-problems","title":"Practice problems:","text":"<ul> <li>SPOJ - BUGLIFE</li> <li>Codeforces - Graph Without Long Directed Paths</li> <li>Codeforces - String Coloring (easy version)</li> <li>CSES : Building Teams</li> </ul>","tags":["Translated"]},{"location":"graph/breadth-first-search.html","title":"Breadth-first search","text":"<p>Breadth first search is one of the basic and essential searching algorithms on graphs.</p> <p>As a result of how the algorithm works, the path found by breadth first search to any node is the shortest path to that node, i.e the path that contains the smallest number of edges in unweighted graphs.</p> <p>The algorithm works in $O(n + m)$ time, where $n$ is number of vertices and $m$ is the number of edges.</p>","tags":["Translated"]},{"location":"graph/breadth-first-search.html#description-of-the-algorithm","title":"Description of the algorithm","text":"<p>The algorithm takes as input an unweighted graph and the id of the source vertex $s$. The input graph can be directed or undirected, it does not matter to the algorithm.</p> <p>The algorithm can be understood as a fire spreading on the graph: at the zeroth step only the source $s$ is on fire. At each step, the fire burning at each vertex spreads to all of its neighbors. In one iteration of the algorithm, the \"ring of fire\" is expanded in width by one unit (hence the name of the algorithm).</p> <p>More precisely, the algorithm can be stated as follows: Create a queue $q$ which will contain the vertices to be processed and a Boolean array $used[]$ which indicates for each vertex, if it has been lit (or visited) or not.</p> <p>Initially, push the source $s$ to the queue and set $used[s] = true$, and for all other vertices $v$ set $used[v] = false$. Then, loop until the queue is empty and in each iteration, pop a vertex from the front of the queue. Iterate through all the edges going out of this vertex and if some of these edges go to vertices that are not already lit, set them on fire and place them in the queue.</p> <p>As a result, when the queue is empty, the \"ring of fire\" contains all vertices reachable from the source $s$, with each vertex reached in the shortest possible way. You can also calculate the lengths of the shortest paths (which just requires maintaining an array of path lengths $d[]$) as well as save information to restore all of these shortest paths (for this, it is necessary to maintain an array of \"parents\" $p[]$, which stores for each vertex the vertex from which we reached it).</p>","tags":["Translated"]},{"location":"graph/breadth-first-search.html#implementation","title":"Implementation","text":"<p>We write code for the described algorithm in C++ and Java.</p> C++Java <pre><code>vector&lt;vector&lt;int&gt;&gt; adj;  // adjacency list representation\nint n; // number of nodes\nint s; // source vertex\n\nqueue&lt;int&gt; q;\nvector&lt;bool&gt; used(n);\nvector&lt;int&gt; d(n), p(n);\n\nq.push(s);\nused[s] = true;\np[s] = -1;\nwhile (!q.empty()) {\n    int v = q.front();\n    q.pop();\n    for (int u : adj[v]) {\n        if (!used[u]) {\n            used[u] = true;\n            q.push(u);\n            d[u] = d[v] + 1;\n            p[u] = v;\n        }\n    }\n}\n</code></pre> <pre><code>ArrayList&lt;ArrayList&lt;Integer&gt;&gt; adj = new ArrayList&lt;&gt;(); // adjacency list representation\n\nint n; // number of nodes\nint s; // source vertex\n\n\nLinkedList&lt;Integer&gt; q = new LinkedList&lt;Integer&gt;();\nboolean used[] = new boolean[n];\nint d[] = new int[n];\nint p[] = new int[n];\n\nq.push(s);\nused[s] = true;\np[s] = -1;\nwhile (!q.isEmpty()) {\n    int v = q.pop();\n    for (int u : adj.get(v)) {\n        if (!used[u]) {\n            used[u] = true;\n            q.push(u);\n            d[u] = d[v] + 1;\n            p[u] = v;\n        }\n    }\n}\n</code></pre> <p>If we have to restore and display the shortest path from the source to some vertex $u$, it can be done in the following manner:</p> C++Java <pre><code>if (!used[u]) {\n    cout &lt;&lt; \"No path!\";\n} else {\n    vector&lt;int&gt; path;\n    for (int v = u; v != -1; v = p[v])\n        path.push_back(v);\n    reverse(path.begin(), path.end());\n    cout &lt;&lt; \"Path: \";\n    for (int v : path)\n        cout &lt;&lt; v &lt;&lt; \" \";\n}\n</code></pre> <pre><code>if (!used[u]) {\n    System.out.println(\"No path!\");\n} else {\n    ArrayList&lt;Integer&gt; path = new ArrayList&lt;Integer&gt;();\n    for (int v = u; v != -1; v = p[v])\n        path.add(v);\n    Collections.reverse(path);\n    for(int v : path)\n        System.out.println(v);\n}\n</code></pre>","tags":["Translated"]},{"location":"graph/breadth-first-search.html#applications-of-bfs","title":"Applications of BFS","text":"<ul> <li> <p>Find the shortest path from a source to other vertices in an unweighted graph.</p> </li> <li> <p>Find all connected components in an undirected graph in $O(n + m)$ time: To do this, we just run BFS starting from each vertex, except for vertices which have already been visited from previous runs. Thus, we perform normal BFS from each of the vertices, but do not reset the array $used[]$ each and every time we get a new connected component, and the total running time will still be $O(n + m)$ (performing multiple BFS on the graph without zeroing the array $used []$ is called a series of breadth first searches).</p> </li> <li> <p>Finding a solution to a problem or a game with the least number of moves, if each state of the game can be represented by a vertex of the graph, and the transitions from one state to the other are the edges of the graph.</p> </li> <li> <p>Finding the shortest path in a graph with weights 0 or 1: This requires just a little modification to normal breadth-first search: Instead of maintaining array $used[]$, we will now check if the distance to vertex is shorter than current found distance, then if the current edge is of zero weight, we add it to the front of the queue else we add it to the back of the queue.This modification is explained in more detail in the article 0-1 BFS.</p> </li> <li> <p>Finding the shortest cycle in a directed unweighted graph: Start a breadth-first search from each vertex. As soon as we try to go from the current vertex back to the source vertex, we have found the shortest cycle containing the source vertex. At this point we can stop the BFS, and start a new BFS from the next vertex. From all such cycles (at most one from each BFS) choose the shortest.</p> </li> <li> <p>Find all the edges that lie on any shortest path between a given pair of vertices $(a, b)$. To do this, run two breadth first searches: one from $a$ and one from $b$. Let $d_a []$ be the array containing shortest distances obtained from the first BFS (from $a$) and $d_b []$ be the array containing shortest distances obtained from the second BFS from $b$. Now for every edge $(u, v)$ it is easy to check whether that edge lies on any shortest path between $a$ and $b$: the criterion is the condition $d_a [u] + 1 + d_b [v] = d_a [b]$.</p> </li> <li> <p>Find all the vertices on any shortest path between a given pair of vertices $(a, b)$. To accomplish that, run two breadth first searches: one from $a$ and one from $b$. Let $d_a []$ be the array containing shortest distances obtained from the first BFS (from $a$) and $d_b []$ be the array containing shortest distances obtained from the second BFS (from $b$). Now for each vertex it is easy to check whether it lies on any shortest path between $a$ and $b$: the criterion is the condition $d_a [v] + d_b [v] = d_a [b]$.</p> </li> <li> <p>Find the shortest walk of even length from a source vertex $s$ to a target vertex $t$ in an unweighted graph: For this, we must construct an auxiliary graph, whose vertices are the state $(v, c)$, where $v$ - the current node, $c = 0$ or $c = 1$ - the current parity. Any edge $(u, v)$ of the original graph in this new column will turn into two edges $((u, 0), (v, 1))$ and $((u, 1), (v, 0))$. After that we run a BFS to find the shortest walk from the starting vertex $(s, 0)$ to the end vertex $(t, 0)$.Note: This item uses the term \"walk\" rather than a \"path\" for a reason, as the vertices may potentially repeat in the found walk in order to make its length even. The problem of finding the shortest path of even length is NP-Complete in directed graphs, and solvable in linear time in undirected graphs, but with a much more involved approach.</p> </li> </ul>","tags":["Translated"]},{"location":"graph/breadth-first-search.html#practice-problems","title":"Practice Problems","text":"<ul> <li>SPOJ: AKBAR</li> <li>SPOJ: NAKANJ</li> <li>SPOJ: WATER</li> <li>SPOJ: MICE AND MAZE</li> <li>Timus: Caravans</li> <li>DevSkill - Holloween Party (archived)</li> <li>DevSkill - Ohani And The Link Cut Tree (archived)</li> <li>SPOJ - Spiky Mazes</li> <li>SPOJ - Four Chips (hard)</li> <li>SPOJ - Inversion Sort</li> <li>Codeforces - Shortest Path</li> <li>SPOJ - Yet Another Multiple Problem</li> <li>UVA 11392 - Binary 3xType Multiple</li> <li>UVA 10968 - KuPellaKeS</li> <li>Codeforces - Police Stations</li> <li>Codeforces - Okabe and City</li> <li>SPOJ - Find the Treasure</li> <li>Codeforces - Bear and Forgotten Tree 2</li> <li>Codeforces - Cycle in Maze</li> <li>UVA - 11312 - Flipping Frustration</li> <li>SPOJ - Ada and Cycle</li> <li>CSES - Labyrinth</li> <li>CSES - Message Route</li> <li>CSES - Monsters</li> </ul>","tags":["Translated"]},{"location":"graph/bridge-searching-online.html","title":"Finding Bridges Online","text":"<p>We are given an undirected graph. A bridge is an edge whose removal makes the graph disconnected (or, more precisely, increases the number of connected components). Our task is to find all the bridges in the given graph.</p> <p>Informally this task can be put as follows: we have to find all the \"important\" roads on the given road map, i.e. such roads that the removal of any of them will lead to some cities being unreachable from others.</p> <p>There is already the article Finding Bridges in $O(N+M)$ which solves this task with a Depth First Search traversal. This algorithm will be much more complicated, but it has one big advantage: the algorithm described in this article works online, which means that the input graph doesn't have to be known in advance. The edges are added once at a time, and after each addition the algorithm recounts all the bridges in the current graph. In other words the algorithm is designed to work efficiently on a dynamic, changing graph.</p> <p>More rigorously the statement of the problem is as follows: Initially the graph is empty and consists of $n$ vertices. Then we receive pairs of vertices $(a, b)$, which denote an edge added to the graph. After each received edge, i.e. after adding each edge, output the current number of bridges in the graph.</p> <p>It is also possible to maintain a list of all bridges as well as explicitly support the 2-edge-connected components.</p> <p>The algorithm described below works in $O(n \\log n + m)$ time, where $m$ is the number of edges. The algorithm is based on the data structure Disjoint Set Union. However the implementation in this article takes $O(n \\log n + m \\log n)$ time, because it uses the simplified version of the DSU without Union by Rank.</p>","tags":["Translated"]},{"location":"graph/bridge-searching-online.html#algorithm","title":"Algorithm","text":"<p>First let's define a $k$-edge-connected component: it is a connected component that remains connected whenever you remove fewer than $k$ edges.</p> <p>It is very easy to see, that the bridges partition the graph into 2-edge-connected components. If we compress each of those 2-edge-connected components into vertices and only leave the bridges as edges in the compressed graph, then we obtain an acyclic graph, i.e. a forest.</p> <p>The algorithm described below maintains this forest explicitly as well as the 2-edge-connected components.</p> <p>It is clear that initially, when the graph is empty, it contains $n$ 2-edge-connected components, which by themselves are not connect.</p> <p>When adding the next edge $(a, b)$ there can occur three situations:</p> <ul> <li> <p>Both vertices $a$ and $b$ are in the same 2-edge-connected component - then this edge is not a bridge, and does not change anything in the forest structure, so we can just skip this edge.</p> <p>Thus, in this case the number of bridges does not change.</p> </li> <li> <p>The vertices $a$ and $b$ are in completely different connected components, i.e. each one is part of a different tree.     In this case, the edge $(a, b)$ becomes a new bridge, and these two trees are combined into one (and all the old bridges remain).</p> <p>Thus, in this case the number of bridges increases by one.</p> </li> <li> <p>The vertices $a$ and $b$ are in one connected component, but in different 2-edge-connected components.     In this case, this edge forms a cycle along with some of the old bridges.     All these bridges end being bridges, and the resulting cycle must be compressed into a new 2-edge-connected component.</p> <p>Thus, in this case the number of bridges decreases by one or more.</p> </li> </ul> <p>Consequently the whole task is reduced to the effective implementation of all these operations over the forest of 2-edge-connected components.</p>","tags":["Translated"]},{"location":"graph/bridge-searching-online.html#data-structures-for-storing-the-forest","title":"Data Structures for storing the forest","text":"<p>The only data structure that we need is Disjoint Set Union. In fact we will make two copies of this structure: one will be to maintain the connected components, the other to maintain the 2-edge-connected components. And in addition we store the structure of the trees in the forest of 2-edge-connected components via pointers: Each 2-edge-connected component will store the index <code>par[]</code> of its ancestor in the tree.</p> <p>We will now consistently disassemble every operation that we need to learn to implement:</p> <ul> <li> <p>Check whether the two vertices lie in the same connected / 2-edge-connected component.     It is done with the usual DSU algorithm, we just find and compare the representatives of the DSUs.</p> </li> <li> <p>Joining two trees for some edge $(a, b)$.     Since it could turn out that neither the vertex $a$ nor the vertex $b$ are the roots of their trees, the only way to connect these two trees is to re-root one of them.     For example you can re-root the tree of vertex $a$, and then attach it to another tree by setting the ancestor of $a$ to $b$.</p> <p>However the question about the effectiveness of the re-rooting operation arises: in order to re-root the tree with the root $r$ to the vertex $v$, it is necessary to visit all vertices on the path between $v$ and $r$ and redirect the pointers <code>par[]</code> in the opposite direction, and also change the references to the ancestors in the DSU that is responsible for the connected components.</p> <p>Thus, the cost of re-rooting is $O(h)$, where $h$ is the height of the tree. You can make an even worse estimate by saying that the cost is $O(\\text{size})$ where $\\text{size}$ is the number of vertices in the tree. The final complexity will not differ.</p> <p>We now apply a standard technique: we re-root the tree that contains fewer vertices. Then it is intuitively clear that the worst case is when two trees of approximately equal sizes are combined, but then the result is a tree of twice the size. This does not allow this situation to happen many times.</p> <p>In general the total cost can be written in the form of a recurrence:</p> $$ T(n) = \\max_{k = 1 \\ldots n-1} \\left\\{ T(k) + T(n - k) + O(\\min(k, n - k))\\right\\} $$ <p>$T(n)$ is the number of operations necessary to obtain a tree with $n$ vertices by means of re-rooting and unifying trees. A tree of size $n$ can be created by combining two smaller trees of size $k$ and $n - k$. This recurrence is has the solution $T(n) = O (n \\log n)$.</p> <p>Thus, the total time spent on all re-rooting operations will be $O(n \\log n)$ if we always re-root the smaller of the two trees.</p> <p>We will have to maintain the size of each connected component, but the data structure DSU makes this possible without difficulty.</p> </li> <li> <p>Searching for the cycle formed by adding a new edge $(a, b)$.     Since $a$ and $b$ are already connected in the tree we need to find the Lowest Common Ancestor of the vertices $a$ and $b$.     The cycle will consist of the paths from $b$ to the LCA, from the LCA to $a$ and the edge $a$ to $b$.</p> <p>After finding the cycle we compress all vertices of the detected cycle into one vertex. This means that we already have a complexity proportional to the cycle length, which means that we also can use any LCA algorithm proportional to the length, and don't have to use any fast one.</p> <p>Since all information about the structure of the tree is available is the ancestor array <code>par[]</code>, the only reasonable LCA algorithm is the following: mark the vertices $a$ and $b$ as visited, then we go to their ancestors <code>par[a]</code> and <code>par[b]</code> and mark them, then advance to their ancestors and so on, until we reach an already marked vertex. This vertex is the LCA that we are looking for, and we can find the vertices on the cycle by traversing the path from $a$ and $b$ to the LCA again.</p> <p>It is obvious that the complexity of this algorithm is proportional to the length of the desired cycle.</p> </li> <li> <p>Compression of the cycle by adding a new edge $(a, b)$ in a tree.</p> <p>We need to create a new 2-edge-connected component, which will consist of all vertices of the detected cycle (also the detected cycle itself could consist of some 2-edge-connected components, but this does not change anything). In addition it is necessary to compress them in such a way that the structure of the tree is not disturbed, and all pointers <code>par[]</code> and two DSUs are still correct.</p> <p>The easiest way to achieve this is to compress all the vertices of the cycle to their LCA. In fact the LCA is the highest of the vertices, i.e. its ancestor pointer <code>par[]</code> remains unchanged. For all the other vertices of the loop the ancestors do not need to be updated, since these vertices simply cease to exists. But in the DSU of the 2-edge-connected components all these vertices will simply point to the LCA.</p> <p>We will implement the DSU of the 2-edge-connected components without the Union by rank optimization, therefore we will get the complexity $O(\\log n)$ on average per query. To achieve the complexity $O(1)$ on average per query, we need to combine the vertices of the cycle according to Union by rank, and then assign <code>par[]</code> accordingly.</p> </li> </ul>","tags":["Translated"]},{"location":"graph/bridge-searching-online.html#implementation","title":"Implementation","text":"<p>Here is the final implementation of the whole algorithm.</p> <p>As mentioned before, for the sake of simplicity the DSU of the 2-edge-connected components is written without Union by rank, therefore the resulting complexity will be $O(\\log n)$ on average.</p> <p>Also in this implementation the bridges themselves are not stored, only their count <code>bridges</code>. However it will not be difficult to create a <code>set</code> of all bridges.</p> <p>Initially you call the function <code>init()</code>, which initializes the two DSUs (creating a separate set for each vertex, and setting the size equal to one), and sets the ancestors <code>par</code>.</p> <p>The main function is <code>add_edge(a, b)</code>, which processes and adds a new edge.</p> <pre><code>vector&lt;int&gt; par, dsu_2ecc, dsu_cc, dsu_cc_size;\nint bridges;\nint lca_iteration;\nvector&lt;int&gt; last_visit;\n\nvoid init(int n) {\n    par.resize(n);\n    dsu_2ecc.resize(n);\n    dsu_cc.resize(n);\n    dsu_cc_size.resize(n);\n    lca_iteration = 0;\n    last_visit.assign(n, 0);\n    for (int i=0; i&lt;n; ++i) {\n        dsu_2ecc[i] = i;\n        dsu_cc[i] = i;\n        dsu_cc_size[i] = 1;\n        par[i] = -1;\n    }\n    bridges = 0;\n}\n\nint find_2ecc(int v) {\n    if (v == -1)\n        return -1;\n    return dsu_2ecc[v] == v ? v : dsu_2ecc[v] = find_2ecc(dsu_2ecc[v]);\n}\n\nint find_cc(int v) {\n    v = find_2ecc(v);\n    return dsu_cc[v] == v ? v : dsu_cc[v] = find_cc(dsu_cc[v]);\n}\n\nvoid make_root(int v) {\n    int root = v;\n    int child = -1;\n    while (v != -1) {\n        int p = find_2ecc(par[v]);\n        par[v] = child;\n        dsu_cc[v] = root;\n        child = v;\n        v = p;\n    }\n    dsu_cc_size[root] = dsu_cc_size[child];\n}\n\nvoid merge_path (int a, int b) {\n    ++lca_iteration;\n    vector&lt;int&gt; path_a, path_b;\n    int lca = -1;\n    while (lca == -1) {\n        if (a != -1) {\n            a = find_2ecc(a);\n            path_a.push_back(a);\n            if (last_visit[a] == lca_iteration){\n                lca = a;\n                break;\n                }\n            last_visit[a] = lca_iteration;\n            a = par[a];\n        }\n        if (b != -1) {\n            b = find_2ecc(b);\n            path_b.push_back(b);\n            if (last_visit[b] == lca_iteration){\n                lca = b;\n                break;\n                }\n            last_visit[b] = lca_iteration;\n            b = par[b];\n        }\n\n    }\n\n    for (int v : path_a) {\n        dsu_2ecc[v] = lca;\n        if (v == lca)\n            break;\n        --bridges;\n    }\n    for (int v : path_b) {\n        dsu_2ecc[v] = lca;\n        if (v == lca)\n            break;\n        --bridges;\n    }\n}\n\nvoid add_edge(int a, int b) {\n    a = find_2ecc(a);\n    b = find_2ecc(b);\n    if (a == b)\n        return;\n\n    int ca = find_cc(a);\n    int cb = find_cc(b);\n\n    if (ca != cb) {\n        ++bridges;\n        if (dsu_cc_size[ca] &gt; dsu_cc_size[cb]) {\n            swap(a, b);\n            swap(ca, cb);\n        }\n        make_root(a);\n        par[a] = dsu_cc[a] = b;\n        dsu_cc_size[cb] += dsu_cc_size[a];\n    } else {\n        merge_path(a, b);\n    }\n}\n</code></pre> <p>The DSU for the 2-edge-connected components is stored in the vector <code>dsu_2ecc</code>, and the function returning the representative is <code>find_2ecc(v)</code>. This function is used many times in the rest of the code, since after the compression of several vertices into one all these vertices cease to exist, and instead only the leader has the correct ancestor <code>par</code> in the forest of 2-edge-connected components.</p> <p>The DSU for the connected components is stored in the vector <code>dsu_cc</code>, and there is also an additional vector <code>dsu_cc_size</code> to store the component sizes. The function <code>find_cc(v)</code> returns the leader of the connectivity component (which is actually the root of the tree).</p> <p>The re-rooting of a tree <code>make_root(v)</code> works as described above: if traverses from the vertex $v$ via the ancestors to the root vertex, each time redirecting the ancestor <code>par</code> in the opposite direction. The link to the representative of the connected component <code>dsu_cc</code> is also updated, so that it points to the new root vertex. After re-rooting we have to assign the new root the correct size of the connected component. Also we have to be careful that we call <code>find_2ecc()</code> to get the representatives of the 2-edge-connected component, rather than some other vertex that have already been compressed.</p> <p>The cycle finding and compression function <code>merge_path(a, b)</code> is also implemented as described above. It searches for the LCA of $a$ and $b$ be rising these nodes in parallel, until we meet a vertex for the second time. For efficiency purposes we choose a unique identifier for each LCA finding call, and mark the traversed vertices with it. This works in $O(1)$, while other approaches like using $set$ perform worse. The passed paths are stored in the vectors <code>path_a</code> and <code>path_b</code>, and we use them to walk through them a second time up to the LCA, thereby obtaining all vertices of the cycle. All the vertices of the cycle get compressed by attaching them to the LCA, hence the average complexity is $O(\\log n)$ (since we don't use Union by rank). All the edges we pass have been bridges, so we subtract 1 for each edge in the cycle.</p> <p>Finally the query function <code>add_edge(a, b)</code> determines the connected components in which the vertices $a$ and $b$ lie. If they lie in different connectivity components, then a smaller tree is re-rooted and then attached to the larger tree. Otherwise if the vertices $a$ and $b$ lie in one tree, but in different 2-edge-connected components, then the function <code>merge_path(a, b)</code> is called, which will detect the cycle and compress it into one 2-edge-connected component. </p>","tags":["Translated"]},{"location":"graph/bridge-searching.html","title":"Finding bridges in a graph in $O(N+M)$","text":"<p>We are given an undirected graph. A bridge is defined as an edge which, when removed, makes the graph disconnected (or more precisely, increases the number of connected components in the graph). The task is to find all bridges in the given graph.</p> <p>Informally, the problem is formulated as follows: given a map of cities connected with roads, find all \"important\" roads, i.e. roads which, when removed, cause disappearance of a path between some pair of cities.</p> <p>The algorithm described here is based on depth first search and has $O(N+M)$ complexity, where $N$ is the number of vertices and $M$ is the number of edges in the graph.</p> <p>Note that there is also the article Finding Bridges Online - unlike the offline algorithm described here, the online algorithm is able to maintain the list of all bridges in a changing graph (assuming that the only type of change is addition of new edges).</p>","tags":["Translated"]},{"location":"graph/bridge-searching.html#algorithm","title":"Algorithm","text":"<p>Pick an arbitrary vertex of the graph $root$ and run depth first search from it. Note the following fact (which is easy to prove):</p> <ul> <li>Let's say we are in the DFS, looking through the edges starting from vertex $v$. The current edge $(v, to)$ is a bridge if and only if none of the vertices $to$ and its descendants in the DFS traversal tree has a back-edge to vertex $v$ or any of its ancestors. Indeed, this condition means that there is no other way from $v$ to $to$ except for edge $(v, to)$.</li> </ul> <p>Now we have to learn to check this fact for each vertex efficiently. We'll use \"time of entry into node\" computed by the depth first search.</p> <p>So, let $\\mathtt{tin}[v]$ denote entry time for node $v$. We introduce an array $\\mathtt{low}$ which will let us store the earliest entry time of the node found in the DFS search that a node $v$ can reach with a single edge from itself or its descendants. $\\mathtt{low}[v]$ is the minimum of $\\mathtt{tin}[v]$, the entry times $\\mathtt{tin}[p]$ for each node $p$ that is connected to node $v$ via a back-edge $(v, p)$ and the values of $\\mathtt{low}[to]$ for each vertex $to$ which is a direct descendant of $v$ in the DFS tree:</p> $$\\mathtt{low}[v] = \\min \\left\\{      \\begin{array}{l}     \\mathtt{tin}[v] \\\\      \\mathtt{tin}[p]  &amp;\\text{ for all }p\\text{ for which }(v, p)\\text{ is a back edge} \\\\      \\mathtt{low}[to] &amp;\\text{ for all }to\\text{ for which }(v, to)\\text{ is a tree edge}     \\end{array} \\right\\}$$ <p>Now, there is a back edge from vertex $v$ or one of its descendants to one of its ancestors if and only if vertex $v$ has a child $to$ for which $\\mathtt{low}[to] \\leq \\mathtt{tin}[v]$. If $\\mathtt{low}[to] = \\mathtt{tin}[v]$, the back edge comes directly to $v$, otherwise it comes to one of the ancestors of $v$.</p> <p>Thus, the current edge $(v, to)$ in the DFS tree is a bridge if and only if $\\mathtt{low}[to] &gt; \\mathtt{tin}[v]$.</p>","tags":["Translated"]},{"location":"graph/bridge-searching.html#implementation","title":"Implementation","text":"<p>The implementation needs to distinguish three cases: when we go down the edge in DFS tree, when we find a back edge to an ancestor of the vertex and when we return to a parent of the vertex. These are the cases:</p> <ul> <li>$\\mathtt{visited}[to] = false$ - the edge is part of DFS tree;</li> <li>$\\mathtt{visited}[to] = true$ &amp;&amp; $to \\neq parent$ - the edge is back edge to one of the ancestors;</li> <li>$to = parent$ - the edge leads back to parent in DFS tree.</li> </ul> <p>To implement this, we need a depth first search function which accepts the parent vertex of the current node.</p> <p>For the cases of multiple edges, we need to be careful when ignoring the edge from the parent. To solve this issue, we can add a flag <code>parent_skipped</code> which will ensure we only skip the parent once.</p> <pre><code>void IS_BRIDGE(int v,int to); // some function to process the found bridge\nint n; // number of nodes\nvector&lt;vector&lt;int&gt;&gt; adj; // adjacency list of graph\n\nvector&lt;bool&gt; visited;\nvector&lt;int&gt; tin, low;\nint timer;\n\nvoid dfs(int v, int p = -1) {\n    visited[v] = true;\n    tin[v] = low[v] = timer++;\n    bool parent_skipped = false;\n    for (int to : adj[v]) {\n        if (to == p &amp;&amp; !parent_skipped) {\n            parent_skipped = true;\n            continue;\n        }\n        if (visited[to]) {\n            low[v] = min(low[v], tin[to]);\n        } else {\n            dfs(to, v);\n            low[v] = min(low[v], low[to]);\n            if (low[to] &gt; tin[v])\n                IS_BRIDGE(v, to);\n        }\n    }\n}\n\nvoid find_bridges() {\n    timer = 0;\n    visited.assign(n, false);\n    tin.assign(n, -1);\n    low.assign(n, -1);\n    for (int i = 0; i &lt; n; ++i) {\n        if (!visited[i])\n            dfs(i);\n    }\n}\n</code></pre> <p>Main function is <code>find_bridges</code>; it performs necessary initialization and starts depth first search in each connected component of the graph.</p> <p>Function <code>IS_BRIDGE(a, b)</code> is some function that will process the fact that edge $(a, b)$ is a bridge, for example, print it.</p> <p>Note that this implementation malfunctions if the graph has multiple edges, since it ignores them. Of course, multiple edges will never be a part of the answer, so <code>IS_BRIDGE</code> can check additionally that the reported bridge is not a multiple edge. Alternatively it's possible to pass to <code>dfs</code> the index of the edge used to enter the vertex instead of the parent vertex (and store the indices of all vertices).</p>","tags":["Translated"]},{"location":"graph/bridge-searching.html#practice-problems","title":"Practice Problems","text":"<ul> <li>UVA #796 \"Critical Links\" [difficulty: low]</li> <li>UVA #610 \"Street Directions\" [difficulty: medium]</li> <li>Case of the Computer Network (Codeforces Round #310 Div. 1 E) [difficulty: hard]</li> <li>UVA 12363 - Hedge Mazes</li> <li>UVA 315 - Network</li> <li>GYM - Computer Network (J)</li> <li>SPOJ - King Graffs Defense</li> <li>SPOJ - Critical Edges</li> <li>Codeforces - Break Up</li> <li>Codeforces - Tourist Reform</li> <li>Codeforces - Non-academic problem</li> </ul>","tags":["Translated"]},{"location":"graph/cutpoints.html","title":"Finding articulation points in a graph in $O(N+M)$","text":"<p>We are given an undirected graph. An articulation point (or cut vertex) is defined as a vertex which, when removed along with associated edges, makes the graph disconnected (or more precisely, increases the number of connected components in the graph). The task is to find all articulation points in the given graph.</p> <p>The algorithm described here is based on depth first search and has $O(N+M)$ complexity, where $N$ is the number of vertices and $M$ is the number of edges in the graph.</p>","tags":["Translated"]},{"location":"graph/cutpoints.html#algorithm","title":"Algorithm","text":"<p>Pick an arbitrary vertex of the graph $root$ and run depth first search from it. Note the following fact (which is easy to prove):</p> <ul> <li> <p>Let's say we are in the DFS, looking through the edges starting from vertex $v\\ne root$. If the current edge $(v, to)$ is such that none of the vertices $to$ or its descendants in the DFS traversal tree has a back-edge to any of ancestors of $v$, then $v$ is an articulation point. Otherwise, $v$ is not an articulation point.</p> </li> <li> <p>Let's consider the remaining case of $v=root$. This vertex will be the point of articulation if and only if this vertex has more than one child in the DFS tree.</p> </li> </ul> <p>Now we have to learn to check this fact for each vertex efficiently. We'll use \"time of entry into node\" computed by the depth first search.</p> <p>So, let $tin[v]$ denote entry time for node $v$. We introduce an array $low[v]$ which will let us check the fact for each vertex $v$. $low[v]$ is the minimum of $tin[v]$, the entry times $tin[p]$ for each node $p$ that is connected to node $v$ via a back-edge $(v, p)$ and the values of $low[to]$ for each vertex $to$ which is a direct descendant of $v$ in the DFS tree:</p> $$low[v] = \\min \\begin{cases} tin[v] \\\\ tin[p] &amp;\\text{ for all }p\\text{ for which }(v, p)\\text{ is a back edge} \\\\ low[to]&amp; \\text{ for all }to\\text{ for which }(v, to)\\text{ is a tree edge} \\end{cases}$$ <p>Now, there is a back edge from vertex $v$ or one of its descendants to one of its ancestors if and only if vertex $v$ has a child $to$ for which $low[to] &lt; tin[v]$. If $low[to] = tin[v]$, the back edge comes directly to $v$, otherwise it comes to one of the ancestors of $v$.</p> <p>Thus, the vertex $v$ in the DFS tree is an articulation point if and only if $low[to] \\geq tin[v]$.</p>","tags":["Translated"]},{"location":"graph/cutpoints.html#implementation","title":"Implementation","text":"<p>The implementation needs to distinguish three cases: when we go down the edge in DFS tree, when we find a back edge to an ancestor of the vertex and when we return to a parent of the vertex. These are the cases:</p> <ul> <li>$visited[to] = false$ - the edge is part of DFS tree;</li> <li>$visited[to] = true$ &amp;&amp; $to \\neq parent$ - the edge is back edge to one of the ancestors;</li> <li>$to = parent$ - the edge leads back to parent in DFS tree.</li> </ul> <p>To implement this, we need a depth first search function which accepts the parent vertex of the current node.</p> <pre><code>int n; // number of nodes\nvector&lt;vector&lt;int&gt;&gt; adj; // adjacency list of graph\n\nvector&lt;bool&gt; visited;\nvector&lt;int&gt; tin, low;\nint timer;\n\nvoid dfs(int v, int p = -1) {\n    visited[v] = true;\n    tin[v] = low[v] = timer++;\n    int children=0;\n    for (int to : adj[v]) {\n        if (to == p) continue;\n        if (visited[to]) {\n            low[v] = min(low[v], tin[to]);\n        } else {\n            dfs(to, v);\n            low[v] = min(low[v], low[to]);\n            if (low[to] &gt;= tin[v] &amp;&amp; p!=-1)\n                IS_CUTPOINT(v);\n            ++children;\n        }\n    }\n    if(p == -1 &amp;&amp; children &gt; 1)\n        IS_CUTPOINT(v);\n}\n\nvoid find_cutpoints() {\n    timer = 0;\n    visited.assign(n, false);\n    tin.assign(n, -1);\n    low.assign(n, -1);\n    for (int i = 0; i &lt; n; ++i) {\n        if (!visited[i])\n            dfs (i);\n    }\n}\n</code></pre> <p>Main function is <code>find_cutpoints</code>; it performs necessary initialization and starts depth first search in each connected component of the graph.</p> <p>Function <code>IS_CUTPOINT(a)</code> is some function that will process the fact that vertex $a$ is an articulation point, for example, print it (Caution that this can be called multiple times for a vertex).</p>","tags":["Translated"]},{"location":"graph/cutpoints.html#practice-problems","title":"Practice Problems","text":"<ul> <li>UVA #10199 \"Tourist Guide\" [difficulty: low]</li> <li>UVA #315 \"Network\" [difficulty: low]</li> <li>SPOJ - Submerging Islands</li> <li>Codeforces - Cutting Figure</li> </ul>","tags":["Translated"]},{"location":"graph/depth-first-search.html","title":"Depth First Search","text":"<p>Depth First Search is one of the main graph algorithms.</p> <p>Depth First Search finds the lexicographical first path in the graph from a source vertex $u$ to each vertex. Depth First Search will also find the shortest paths in a tree (because there only exists one simple path), but on general graphs this is not the case.</p> <p>The algorithm works in $O(m + n)$ time where $n$ is the number of vertices and $m$ is the number of edges.</p>","tags":["Translated"]},{"location":"graph/depth-first-search.html#description-of-the-algorithm","title":"Description of the algorithm","text":"<p>The idea behind DFS is to go as deep into the graph as possible, and backtrack once you are at a vertex without any unvisited adjacent vertices.</p> <p>It is very easy to describe / implement the algorithm recursively: We start the search at one vertex. After visiting a vertex, we further perform a DFS for each adjacent vertex that we haven't visited before. This way we visit all vertices that are reachable from the starting vertex.</p> <p>For more details check out the implementation.</p>","tags":["Translated"]},{"location":"graph/depth-first-search.html#applications-of-depth-first-search","title":"Applications of Depth First Search","text":"<ul> <li> <p>Find any path in the graph from source vertex $u$ to all vertices.</p> </li> <li> <p>Find lexicographical first path in the graph from source $u$ to all vertices.</p> </li> <li> <p>Check if a vertex in a tree is an ancestor of some other vertex:</p> <p>At the beginning and end of each search call we remember the entry and exit \"time\" of each vertex. Now you can find the answer for any pair of vertices $(i, j)$ in $O(1)$: vertex $i$ is an ancestor of vertex $j$ if and only if $\\text{entry}[i] &lt; \\text{entry}[j]$ and $\\text{exit}[i] &gt; \\text{exit}[j]$.</p> </li> <li> <p>Find the lowest common ancestor (LCA) of two vertices.</p> </li> <li> <p>Topological sorting:</p> <p>Run a series of depth first searches so as to visit each vertex exactly once in $O(n + m)$ time. The required topological ordering will be the vertices sorted in descending order of exit time.</p> </li> <li> <p>Check whether a given graph is acyclic and find cycles in a graph. (As mentioned below by counting back edges in every connected components).</p> </li> <li> <p>Find strongly connected components in a directed graph:</p> <p>First do a topological sorting of the graph. Then transpose the graph and run another series of depth first searches in the order defined by the topological sort. For each DFS call the component created by it is a strongly connected component.</p> </li> <li> <p>Find bridges in an undirected graph:</p> <p>First convert the given graph into a directed graph by running a series of depth first searches and making each edge directed as we go through it, in the direction we went. Second, find the strongly connected components in this directed graph. Bridges are the edges whose ends belong to different strongly connected components.</p> </li> </ul>","tags":["Translated"]},{"location":"graph/depth-first-search.html#classification-of-edges-of-a-graph","title":"Classification of edges of a graph","text":"<p>We can classify the edges of a graph, $G$, using the entry and exit time of the end nodes $u$ and $v$ of the edges $(u,v)$. These classifications are often used for problems like finding bridges and finding articulation points.</p> <p>We perform a DFS and classify the encountered edges using the following rules:</p> <p>If $v$ is not visited:</p> <ul> <li>Tree Edge - If $v$ is visited after $u$ then edge $(u,v)$ is called a tree edge. In other words, if $v$ is visited for the first time and $u$ is currently being visited then $(u,v)$ is called tree edge. These edges form a DFS tree and hence the name tree edges.</li> </ul> <p>If $v$ is visited before $u$:</p> <ul> <li> <p>Back edges - If $v$ is an ancestor of $u$, then the edge $(u,v)$ is a back edge. $v$ is an ancestor exactly if we already entered $v$, but not exited it yet. Back edges complete a cycle as there is a path from ancestor $v$ to descendant $u$ (in the recursion of DFS) and an edge from descendant $u$ to ancestor $v$ (back edge), thus a cycle is formed. Cycles can be detected using back edges.</p> </li> <li> <p>Forward Edges - If $v$ is a descendant of $u$, then edge $(u, v)$ is a forward edge. In other words, if we already visited and exited $v$ and $\\text{entry}[u] &lt; \\text{entry}[v]$ then the edge $(u,v)$ forms a forward edge.</p> </li> <li>Cross Edges: if $v$ is neither an ancestor or descendant of $u$, then edge $(u, v)$ is a cross edge. In other words, if we already visited and exited $v$ and $\\text{entry}[u] &gt; \\text{entry}[v]$ then $(u,v)$ is a cross edge.</li> </ul> <p>Theorem. Let $G$ be an undirected graph. Then, performing a DFS upon $G$ will classify every encountered edge as either a tree edge or back edge, i.e., forward and cross edges only exist in directed graphs.</p> <p>Suppose $(u,v)$ is an arbitrary edge of $G$ and without loss of generality, $u$ is visited before $v$, i.e., $\\text{entry}[u] &lt; \\text{entry}[v]$. Because the DFS only processes edges once, there are only two ways in which we can process the edge $(u,v)$ and thus classify it: </p> <ul> <li> <p>The first time we explore the edge $(u,v)$ is in the direction from $u$ to $v$. Because $\\text{entry}[u] &lt; \\text{entry}[v]$, the recursive nature of the DFS means that node $v$ will be fully explored and thus exited before we can \"move back up the call stack\" to exit node $u$. Thus, node $v$ must be unvisited when the DFS first explores the edge $(u,v)$ from $u$ to $v$ because otherwise the search would have explored $(u,v)$ from $v$ to $u$ before exiting node $v$, as nodes $u$ and $v$ are neighbors. Therefore, edge $(u,v)$ is a tree edge.</p> </li> <li> <p>The first time we explore the edge $(u,v)$ is in the direction from $v$ to $u$. Because we discovered node $u$ before discovering node $v$, and we only process edges once, the only way that we could explore the edge $(u,v)$ in the direction from $v$ to $u$ is if there's another path from $u$ to $v$ that does not involve the edge $(u,v)$, thus making $u$ an ancestor of $v$. The edge $(u,v)$ thus completes a cycle as it is going from the descendant, $v$, to the ancestor, $u$, which we have not exited yet. Therefore, edge $(u,v)$ is a back edge.</p> </li> </ul> <p>Since there are only two ways to process the edge $(u,v)$, with the two cases and their resulting classifications outlined above, performing a DFS upon $G$ will therefore classify every encountered edge as either a tree edge or back edge, i.e., forward and cross edges only exist in directed graphs. This completes the proof.</p>","tags":["Translated"]},{"location":"graph/depth-first-search.html#implementation","title":"Implementation","text":"<p><pre><code>vector&lt;vector&lt;int&gt;&gt; adj; // graph represented as an adjacency list\nint n; // number of vertices\n\nvector&lt;bool&gt; visited;\n\nvoid dfs(int v) {\n    visited[v] = true;\n    for (int u : adj[v]) {\n        if (!visited[u])\n            dfs(u);\n    }\n}\n</code></pre> This is the most simple implementation of Depth First Search. As described in the applications it might be useful to also compute the entry and exit times and vertex color. We will color all vertices with the color 0, if we haven't visited them, with the color 1 if we visited them, and with the color 2, if we already exited the vertex.</p> <p>Here is a generic implementation that additionally computes those:</p> <pre><code>vector&lt;vector&lt;int&gt;&gt; adj; // graph represented as an adjacency list\nint n; // number of vertices\n\nvector&lt;int&gt; color;\n\nvector&lt;int&gt; time_in, time_out;\nint dfs_timer = 0;\n\nvoid dfs(int v) {\n    time_in[v] = dfs_timer++;\n    color[v] = 1;\n    for (int u : adj[v])\n        if (color[u] == 0)\n            dfs(u);\n    color[v] = 2;\n    time_out[v] = dfs_timer++;\n}\n</code></pre>","tags":["Translated"]},{"location":"graph/depth-first-search.html#practice-problems","title":"Practice Problems","text":"<ul> <li>SPOJ: ABCPATH</li> <li>SPOJ: EAGLE1</li> <li>Codeforces: Kefa and Park</li> <li>Timus:Werewolf</li> <li>Timus:Penguin Avia</li> <li>Timus:Two Teams</li> <li>SPOJ - Ada and Island</li> <li>UVA 657 - The die is cast</li> <li>SPOJ - Sheep</li> <li>SPOJ - Path of the Rightenous Man</li> <li>SPOJ - Validate the Maze</li> <li>SPOJ - Ghosts having Fun</li> <li>Codeforces - Underground Lab</li> <li>DevSkill - Maze Tester (archived)</li> <li>DevSkill - Tourist (archived)</li> <li>Codeforces - Anton and Tree</li> <li>Codeforces - Transformation: From A to B</li> <li>Codeforces - One Way Reform</li> <li>Codeforces - Centroids</li> <li>Codeforces - Generate a String</li> <li>Codeforces - Broken Tree</li> <li>Codeforces - Dasha and Puzzle</li> <li>Codeforces - Making genome In Berland</li> <li>Codeforces - Road Improvement</li> <li>Codeforces - Garland</li> <li>Codeforces - Labeling Cities</li> <li>Codeforces - Send the Fool Futher!</li> <li>Codeforces - The tag Game</li> <li>Codeforces - Leha and Another game about graphs</li> <li>Codeforces - Shortest path problem</li> <li>Codeforces - Upgrading Tree</li> <li>Codeforces - From Y to Y</li> <li>Codeforces - Chemistry in Berland</li> <li>Codeforces - Wizards Tour</li> <li>Codeforces - Ring Road</li> <li>Codeforces - Mail Stamps</li> <li>Codeforces - Ant on the Tree</li> <li>SPOJ - Cactus</li> <li>SPOJ - Mixing Chemicals</li> </ul>","tags":["Translated"]},{"location":"graph/desopo_pape.html","title":"D\u00b4Esopo-Pape algorithm","text":"<p>Given a graph with $n$ vertices and $m$ edges with weights $w_i$ and a starting vertex $v_0$. The task is to find the shortest path from the vertex $v_0$ to every other vertex.</p> <p>The algorithm from D\u00b4Esopo-Pape will work faster than Dijkstra's algorithm and the Bellman-Ford algorithm in most cases, and will also work for negative edges. However not for negative cycles.</p>","tags":["Translated"]},{"location":"graph/desopo_pape.html#description","title":"Description","text":"<p>Let the array $d$ contain the shortest path lengths, i.e. $d_i$ is the current length of the shortest path from the vertex $v_0$ to the vertex $i$. Initially this array is filled with infinity for every vertex, except $d_{v_0} = 0$. After the algorithm finishes, this array will contain the shortest distances.</p> <p>Let the array $p$ contain the current ancestors, i.e. $p_i$ is the direct ancestor of the vertex $i$ on the current shortest path from $v_0$ to $i$. Just like the array $d$, the array $p$ changes gradually during the algorithm and at the end takes its final values.</p> <p>Now to the algorithm. At each step three sets of vertices are maintained:</p> <ul> <li>$M_0$ - vertices, for which the distance has already been calculated (although it might not be the final distance)</li> <li>$M_1$ - vertices, for which the distance currently is calculated</li> <li>$M_2$ - vertices, for which the distance has not yet been calculated</li> </ul> <p>The vertices in the set $M_1$ are stored in a bidirectional queue (deque).</p> <p>At each step of the algorithm we take a vertex from the set $M_1$ (from the front of the queue). Let $u$ be the selected vertex. We put this vertex $u$ into the set $M_0$. Then we iterate over all edges coming out of this vertex. Let $v$ be the second end of the current edge, and $w$ its weight.</p> <ul> <li>If $v$ belongs to $M_2$, then $v$ is inserted into the set $M_1$ by inserting it at the back of the queue. $d_v$ is set to $d_u + w$.</li> <li>If $v$ belongs to $M_1$, then we try to improve the value of $d_v$: $d_v = \\min(d_v, d_u + w)$. Since $v$ is already in $M_1$, we don't need to insert it into $M_1$ and the queue.</li> <li>If $v$ belongs to $M_0$, and if $d_v$ can be improved $d_v &gt; d_u + w$, then we improve $d_v$ and insert the vertex $v$ back to the set $M_1$, placing it at the beginning of the queue.</li> </ul> <p>And of course, with each update in the array $d$ we also have to update the corresponding element in the array $p$.</p>","tags":["Translated"]},{"location":"graph/desopo_pape.html#implementation","title":"Implementation","text":"<p>We will use an array $m$ to store in which set each vertex is currently.</p> <pre><code>struct Edge {\n    int to, w;\n};\n\nint n;\nvector&lt;vector&lt;Edge&gt;&gt; adj;\n\nconst int INF = 1e9;\n\nvoid shortest_paths(int v0, vector&lt;int&gt;&amp; d, vector&lt;int&gt;&amp; p) {\n    d.assign(n, INF);\n    d[v0] = 0;\n    vector&lt;int&gt; m(n, 2);\n    deque&lt;int&gt; q;\n    q.push_back(v0);\n    p.assign(n, -1);\n\n    while (!q.empty()) {\n        int u = q.front();\n        q.pop_front();\n        m[u] = 0;\n        for (Edge e : adj[u]) {\n            if (d[e.to] &gt; d[u] + e.w) {\n                d[e.to] = d[u] + e.w;\n                p[e.to] = u;\n                if (m[e.to] == 2) {\n                    m[e.to] = 1;\n                    q.push_back(e.to);\n                } else if (m[e.to] == 0) {\n                    m[e.to] = 1;\n                    q.push_front(e.to);\n                }\n            }\n        }\n    }\n}\n</code></pre>","tags":["Translated"]},{"location":"graph/desopo_pape.html#complexity","title":"Complexity","text":"<p>The algorithm usually performs quite fast - in most cases, even faster than Dijkstra's algorithm. However there exist cases for which the algorithm takes exponential time, making it unsuitable in the worst-case. See discussions on Stack Overflow and Codeforces for reference.</p>","tags":["Translated"]},{"location":"graph/dijkstra.html","title":"Dijkstra Algorithm","text":"<p>You are given a directed or undirected weighted graph with $n$ vertices and $m$ edges. The weights of all edges are non-negative. You are also given a starting vertex $s$. This article discusses finding the lengths of the shortest paths from a starting vertex $s$ to all other vertices, and output the shortest paths themselves.</p> <p>This problem is also called single-source shortest paths problem.</p>","tags":["Translated"]},{"location":"graph/dijkstra.html#algorithm","title":"Algorithm","text":"<p>Here is an algorithm described by the Dutch computer scientist Edsger W. Dijkstra in 1959.</p> <p>Let's create an array $d[]$ where for each vertex $v$ we store the current length of the shortest path from $s$ to $v$ in $d[v]$. Initially $d[s] = 0$, and for all other vertices this length equals infinity. In the implementation a sufficiently large number (which is guaranteed to be greater than any possible path length) is chosen as infinity.</p> $$d[v] = \\infty,~ v \\ne s$$ <p>In addition, we maintain a Boolean array $u[]$ which stores for each vertex $v$ whether it's marked. Initially all vertices are unmarked:</p> $$u[v] = {\\rm false}$$ <p>The Dijkstra's algorithm runs for $n$ iterations. At each iteration a vertex $v$ is chosen as unmarked vertex which has the least value $d[v]$:</p> <p>Evidently, in the first iteration the starting vertex $s$ will be selected.</p> <p>The selected vertex $v$ is marked. Next, from vertex $v$ relaxations are performed: all edges of the form $(v,\\text{to})$ are considered, and for each vertex $\\text{to}$ the algorithm tries to improve the value $d[\\text{to}]$. If the length of the current edge equals $len$, the code for relaxation is:</p> $$d[\\text{to}] = \\min (d[\\text{to}], d[v] + len)$$ <p>After all such edges are considered, the current iteration ends. Finally, after $n$ iterations, all vertices will be marked, and the algorithm terminates. We claim that the found values $d[v]$ are the lengths of shortest paths from $s$ to all vertices $v$.</p> <p>Note that if some vertices are unreachable from the starting vertex $s$, the values $d[v]$ for them will remain infinite. Obviously, the last few iterations of the algorithm will choose those vertices, but no useful work will be done for them. Therefore, the algorithm can be stopped as soon as the selected vertex has infinite distance to it.</p>","tags":["Translated"]},{"location":"graph/dijkstra.html#restoring-shortest-paths","title":"Restoring Shortest Paths","text":"<p>Usually one needs to know not only the lengths of shortest paths but also the shortest paths themselves. Let's see how to maintain sufficient information to restore the shortest path from $s$ to any vertex. We'll maintain an array of predecessors $p[]$ in which for each vertex $v \\ne s$, $p[v]$ is the penultimate vertex in the shortest path from $s$ to $v$. Here we use the fact that if we take the shortest path to some vertex $v$ and remove $v$ from this path, we'll get a path ending in at vertex $p[v]$, and this path will be the shortest for the vertex $p[v]$. This array of predecessors can be used to restore the shortest path to any vertex: starting with $v$, repeatedly take the predecessor of the current vertex until we reach the starting vertex $s$ to get the required shortest path with vertices listed in reverse order. So, the shortest path $P$ to the vertex $v$ is equal to:</p> $$P = (s, \\ldots, p[p[p[v]]], p[p[v]], p[v], v)$$ <p>Building this array of predecessors is very simple: for each successful relaxation, i.e. when for some selected vertex $v$, there is an improvement in the distance to some vertex $\\text{to}$, we update the predecessor vertex for $\\text{to}$ with vertex $v$:</p> $$p[\\text{to}] = v$$","tags":["Translated"]},{"location":"graph/dijkstra.html#proof","title":"Proof","text":"<p>The main assertion on which Dijkstra's algorithm correctness is based is the following:</p> <p>After any vertex $v$ becomes marked, the current distance to it $d[v]$ is the shortest, and will no longer change.</p> <p>The proof is done by induction. For the first iteration this statement is obvious: the only marked vertex is $s$, and the distance to is $d[s] = 0$ is indeed the length of the shortest path to $s$. Now suppose this statement is true for all previous iterations, i.e. for all already marked vertices; let's prove that it is not violated after the current iteration completes. Let $v$ be the vertex selected in the current iteration, i.e. $v$ is the vertex that the algorithm will mark. Now we have to prove that $d[v]$ is indeed equal to the length of the shortest path to it $l[v]$.</p> <p>Consider the shortest path $P$ to the vertex $v$. This path can be split into two parts: $P_1$ which consists of only marked nodes (at least the starting vertex $s$ is part of $P_1$), and the rest of the path $P_2$ (it may include a marked vertex, but it always starts with an unmarked vertex). Let's denote the first vertex of the path $P_2$ as $p$, and the last vertex of the path $P_1$ as $q$.</p> <p>First we prove our statement for the vertex $p$, i.e. let's prove that $d[p] = l[p]$. This is almost obvious: on one of the previous iterations we chose the vertex $q$ and performed relaxation from it. Since (by virtue of the choice of vertex $p$) the shortest path to $p$ is the shortest path to $q$ plus edge $(p,q)$, the relaxation from $q$ set the value of $d[p]$ to the length of the shortest path $l[p]$.</p> <p>Since the edges' weights are non-negative, the length of the shortest path $l[p]$ (which we just proved to be equal to $d[p]$) does not exceed the length $l[v]$ of the shortest path to the vertex $v$. Given that $l[v] \\le d[v]$ (because Dijkstra's algorithm could not have found a shorter way than the shortest possible one), we get the inequality:</p> $$d[p] = l[p] \\le l[v] \\le d[v]$$ <p>On the other hand, since both vertices $p$ and $v$ are unmarked, and the current iteration chose vertex $v$, not $p$, we get another inequality:</p> $$d[p] \\ge d[v]$$ <p>From these two inequalities we conclude that $d[p] = d[v]$, and then from previously found equations we get:</p> $$d[v] = l[v]$$ <p>Q.E.D.</p>","tags":["Translated"]},{"location":"graph/dijkstra.html#implementation","title":"Implementation","text":"<p>Dijkstra's algorithm performs $n$ iterations. On each iteration it selects an unmarked vertex $v$ with the lowest value $d[v]$, marks it and checks all the edges $(v, \\text{to})$ attempting to improve the value $d[\\text{to}]$.</p> <p>The running time of the algorithm consists of:</p> <ul> <li>$n$ searches for a vertex with the smallest value $d[v]$ among $O(n)$ unmarked vertices</li> <li>$m$ relaxation attempts</li> </ul> <p>For the simplest implementation of these operations on each iteration vertex search requires $O(n)$ operations, and each relaxation can be performed in $O(1)$. Hence, the resulting asymptotic behavior of the algorithm is:</p> $$O(n^2+m)$$ <p>This complexity is optimal for dense graph, i.e. when $m \\approx n^2$. However in sparse graphs, when $m$ is much smaller than the maximal number of edges $n^2$, the problem can be solved in $O(n \\log n + m)$ complexity. The algorithm and implementation can be found on the article Dijkstra on sparse graphs.</p> <pre><code>const int INF = 1000000000;\nvector&lt;vector&lt;pair&lt;int, int&gt;&gt;&gt; adj;\n\nvoid dijkstra(int s, vector&lt;int&gt; &amp; d, vector&lt;int&gt; &amp; p) {\n    int n = adj.size();\n    d.assign(n, INF);\n    p.assign(n, -1);\n    vector&lt;bool&gt; u(n, false);\n\n    d[s] = 0;\n    for (int i = 0; i &lt; n; i++) {\n        int v = -1;\n        for (int j = 0; j &lt; n; j++) {\n            if (!u[j] &amp;&amp; (v == -1 || d[j] &lt; d[v]))\n                v = j;\n        }\n\n        if (d[v] == INF)\n            break;\n\n        u[v] = true;\n        for (auto edge : adj[v]) {\n            int to = edge.first;\n            int len = edge.second;\n\n            if (d[v] + len &lt; d[to]) {\n                d[to] = d[v] + len;\n                p[to] = v;\n            }\n        }\n    }\n}\n</code></pre> <p>Here the graph $\\text{adj}$ is stored as adjacency list: for each vertex $v$ $\\text{adj}[v]$ contains the list of edges going from this vertex, i.e. the list of <code>pair&lt;int,int&gt;</code> where the first element in the pair is the vertex at the other end of the edge, and the second element is the edge weight.</p> <p>The function takes the starting vertex $s$ and two vectors that will be used as return values.</p> <p>First of all, the code initializes arrays: distances $d[]$, labels $u[]$ and predecessors $p[]$. Then it performs $n$ iterations. At each iteration the vertex $v$ is selected which has the smallest distance $d[v]$ among all the unmarked vertices. If the distance to selected vertex $v$ is equal to infinity, the algorithm stops. Otherwise the vertex is marked, and all the edges going out from this vertex are checked. If relaxation along the edge is possible (i.e. distance $d[\\text{to}]$ can be improved), the distance $d[\\text{to}]$ and predecessor $p[\\text{to}]$ are updated.</p> <p>After performing all the iterations array $d[]$ stores the lengths of the shortest paths to all vertices, and array $p[]$ stores the predecessors of all vertices (except starting vertex $s$). The path to any vertex $t$ can be restored in the following way:</p> <pre><code>vector&lt;int&gt; restore_path(int s, int t, vector&lt;int&gt; const&amp; p) {\n    vector&lt;int&gt; path;\n\n    for (int v = t; v != s; v = p[v])\n        path.push_back(v);\n    path.push_back(s);\n\n    reverse(path.begin(), path.end());\n    return path;\n}\n</code></pre>","tags":["Translated"]},{"location":"graph/dijkstra.html#references","title":"References","text":"<ul> <li>Edsger Dijkstra. A note on two problems in connexion with graphs [1959]</li> <li>Thomas Cormen, Charles Leiserson, Ronald Rivest, Clifford Stein. Introduction to Algorithms [2005]</li> </ul>","tags":["Translated"]},{"location":"graph/dijkstra.html#practice-problems","title":"Practice Problems","text":"<ul> <li>Timus - Ivan's Car [Difficulty:Medium]</li> <li>Timus - Sightseeing Trip</li> <li>SPOJ - SHPATH [Difficulty:Easy]</li> <li>Codeforces - Dijkstra? [Difficulty:Easy]</li> <li>Codeforces - Shortest Path</li> <li>Codeforces - Jzzhu and Cities</li> <li>Codeforces - The Classic Problem</li> <li>Codeforces - President and Roads</li> <li>Codeforces - Complete The Graph</li> <li>TopCoder - SkiResorts</li> <li>TopCoder - MaliciousPath</li> <li>SPOJ - Ada and Trip</li> <li>LA - 3850 - Here We Go(relians) Again</li> <li>GYM - Destination Unknown (D)</li> <li>UVA 12950 - Even Obsession</li> <li>GYM - Journey to Grece (A)</li> <li>UVA 13030 - Brain Fry</li> <li>UVA 1027 - Toll</li> <li>UVA 11377 - Airport Setup</li> <li>Codeforces - Dynamic Shortest Path</li> <li>UVA 11813 - Shopping</li> <li>UVA 11833 - Route Change</li> <li>SPOJ - Easy Dijkstra Problem</li> <li>LA - 2819 - Cave Raider</li> <li>UVA 12144 - Almost Shortest Path</li> <li>UVA 12047 - Highest Paid Toll</li> <li>UVA 11514 - Batman</li> <li>Codeforces - Team Rocket Rises Again</li> <li>UVA - 11338 - Minefield</li> <li>UVA 11374 - Airport Express</li> <li>UVA 11097 - Poor My Problem</li> <li>UVA 13172 - The music teacher</li> <li>Codeforces - Dirty Arkady's Kitchen</li> <li>SPOJ - Delivery Route</li> <li>SPOJ - Costly Chess</li> <li>CSES - Shortest Routes 1</li> <li>CSES - Flight Discount</li> <li>CSES - Flight Routes</li> </ul>","tags":["Translated"]},{"location":"graph/dijkstra_sparse.html","title":"Dijkstra on sparse graphs","text":"<p>For the statement of the problem, the algorithm with implementation and proof can be found on the article Dijkstra's algorithm.</p>","tags":["Translated"]},{"location":"graph/dijkstra_sparse.html#algorithm","title":"Algorithm","text":"<p>We recall in the derivation of the complexity of Dijkstra's algorithm we used two factors: the time of finding the unmarked vertex with the smallest distance $d[v]$, and the time of the relaxation, i.e. the time of changing the values $d[\\text{to}]$.</p> <p>In the simplest implementation these operations require $O(n)$ and $O(1)$ time. Therefore, since we perform the first operation $O(n)$ times, and the second one $O(m)$ times, we obtained the complexity $O(n^2 + m)$.</p> <p>It is clear, that this complexity is optimal for a dense graph, i.e. when $m \\approx n^2$. However in sparse graphs, when $m$ is much smaller than the maximal number of edges $n^2$, the complexity gets less optimal because of the first term. Thus it is necessary to improve the execution time of the first operation (and of course without greatly affecting the second operation by much).</p> <p>To accomplish that we can use a variation of multiple auxiliary data structures. The most efficient is the Fibonacci heap, which allows the first operation to run in $O(\\log n)$, and the second operation in $O(1)$. Therefore we will get the complexity $O(n \\log n + m)$ for Dijkstra's algorithm, which is also the theoretical minimum for the shortest path search problem. Therefore this algorithm works optimal, and Fibonacci heaps are the optimal data structure. There doesn't exist any data structure, that can perform both operations in $O(1)$, because this would also allow to sort a list of random numbers in linear time, which is impossible. Interestingly there exists an algorithm by Thorup that finds the shortest path in $O(m)$ time, however only works for integer weights, and uses a completely different idea. So this doesn't lead to any contradictions. Fibonacci heaps provide the optimal complexity for this task. However they are quite complex to implement, and also have a quite large hidden constant.</p> <p>As a compromise you can use data structures, that perform both types of operations (extracting a minimum and updating an item) in $O(\\log n)$. Then the complexity of Dijkstra's algorithm is $O(n \\log n + m \\log n) = O(m \\log n)$.</p> <p>C++ provides two such data structures: <code>set</code> and <code>priority_queue</code>. The first is based on red-black trees, and the second one on heaps. Therefore <code>priority_queue</code> has a smaller hidden constant, but also has a drawback: it doesn't support the operation of removing an element. Because of this we need to do a \"workaround\", that actually leads to a slightly worse factor $\\log m$ instead of $\\log n$ (although in terms of complexity they are identical).</p>","tags":["Translated"]},{"location":"graph/dijkstra_sparse.html#implementation","title":"Implementation","text":"","tags":["Translated"]},{"location":"graph/dijkstra_sparse.html#set","title":"set","text":"<p>Let us start with the container <code>set</code>. Since we need to store vertices ordered by their values $d[]$, it is convenient to store actual pairs: the distance and the index of the vertex. As a result in a <code>set</code> pairs are automatically sorted by their distances.</p> <pre><code>const int INF = 1000000000;\nvector&lt;vector&lt;pair&lt;int, int&gt;&gt;&gt; adj;\n\nvoid dijkstra(int s, vector&lt;int&gt; &amp; d, vector&lt;int&gt; &amp; p) {\n    int n = adj.size();\n    d.assign(n, INF);\n    p.assign(n, -1);\n\n    d[s] = 0;\n    set&lt;pair&lt;int, int&gt;&gt; q;\n    q.insert({0, s});\n    while (!q.empty()) {\n        int v = q.begin()-&gt;second;\n        q.erase(q.begin());\n\n        for (auto edge : adj[v]) {\n            int to = edge.first;\n            int len = edge.second;\n\n            if (d[v] + len &lt; d[to]) {\n                q.erase({d[to], to});\n                d[to] = d[v] + len;\n                p[to] = v;\n                q.insert({d[to], to});\n            }\n        }\n    }\n}\n</code></pre> <p>We don't need the array $u[]$ from the normal Dijkstra's algorithm implementation any more. We will use the <code>set</code> to store that information, and also find the vertex with the shortest distance with it. It kinda acts like a queue. The main loops executes until there are no more vertices in the set/queue. A vertex with the smallest distance gets extracted, and for each successful relaxation we first remove the old pair, and then after the relaxation add the new pair into the queue.</p>","tags":["Translated"]},{"location":"graph/dijkstra_sparse.html#priority_queue","title":"priority_queue","text":"<p>The main difference to the implementation with <code>set</code> is that in many languages, including C++, we cannot remove elements from the <code>priority_queue</code> (although heaps can support that operation in theory). Therefore we have to use a workaround: We simply don't delete the old pair from the queue. As a result a vertex can appear multiple times with different distance in the queue at the same time. Among these pairs we are only interested in the pairs where the first element is equal to the corresponding value in $d[]$, all the other pairs are old. Therefore we need to make a small modification: at the beginning of each iteration, after extracting the next pair, we check if it is an important pair or if it is already an old and handled pair. This check is important, otherwise the complexity can increase up to $O(n m)$.</p> <p>By default a <code>priority_queue</code> sorts elements in descending order. To make it sort the elements in ascending order, we can either store the negated distances in it, or pass it a different sorting function. We will do the second option.</p> <pre><code>const int INF = 1000000000;\nvector&lt;vector&lt;pair&lt;int, int&gt;&gt;&gt; adj;\n\nvoid dijkstra(int s, vector&lt;int&gt; &amp; d, vector&lt;int&gt; &amp; p) {\n    int n = adj.size();\n    d.assign(n, INF);\n    p.assign(n, -1);\n\n    d[s] = 0;\n    using pii = pair&lt;int, int&gt;;\n    priority_queue&lt;pii, vector&lt;pii&gt;, greater&lt;pii&gt;&gt; q;\n    q.push({0, s});\n    while (!q.empty()) {\n        int v = q.top().second;\n        int d_v = q.top().first;\n        q.pop();\n        if (d_v != d[v])\n            continue;\n\n        for (auto edge : adj[v]) {\n            int to = edge.first;\n            int len = edge.second;\n\n            if (d[v] + len &lt; d[to]) {\n                d[to] = d[v] + len;\n                p[to] = v;\n                q.push({d[to], to});\n            }\n        }\n    }\n}\n</code></pre> <p>In practice the <code>priority_queue</code> version is a little bit faster than the version with <code>set</code>.</p> <p>Interestingly, a 2007 technical report concluded the variant of the algorithm not using decrease-key operations ran faster than the decrease-key variant, with a greater performance gap for sparse graphs.</p>","tags":["Translated"]},{"location":"graph/dijkstra_sparse.html#getting-rid-of-pairs","title":"Getting rid of pairs","text":"<p>You can improve the performance a little bit more if you don't store pairs in the containers, but only the vertex indices. In this case we must overload the comparison operator: it must compare two vertices using the distances stored in $d[]$.</p> <p>As a result of the relaxation, the distance of some vertices will change. However the data structure will not resort itself automatically. In fact changing distances of vertices in the queue, might destroy the data structure. As before, we need to remove the vertex before we relax it, and then insert it again afterwards.</p> <p>Since we only can remove from <code>set</code>, this optimization is only applicable for the <code>set</code> method, and doesn't work with <code>priority_queue</code> implementation. In practice this significantly increases the performance, especially when larger data types are used to store distances, like <code>long long</code> or <code>double</code>.</p>","tags":["Translated"]},{"location":"graph/dinic.html","title":"Maximum flow - Dinic's algorithm","text":"<p>Dinic's algorithm solves the maximum flow problem in $O(V^2E)$. The maximum flow problem is defined in this article Maximum flow - Ford-Fulkerson and Edmonds-Karp. This algorithm was discovered by Yefim Dinitz in 1970.</p>","tags":["Translated"]},{"location":"graph/dinic.html#definitions","title":"Definitions","text":"<p>A residual network $G^R$ of network $G$ is a network which contains two edges for each edge $(v, u)\\in G$:</p> <ul> <li>$(v, u)$ with capacity $c_{vu}^R = c_{vu} - f_{vu}$</li> <li>$(u, v)$ with capacity $c_{uv}^R = f_{vu}$</li> </ul> <p>A blocking flow of some network is such a flow that every path from $s$ to $t$ contains at least one edge which is saturated by this flow. Note that a blocking flow is not necessarily maximal.</p> <p>A layered network of a network $G$ is a network built in the following way. Firstly, for each vertex $v$ we calculate $level[v]$ - the shortest path (unweighted) from $s$ to this vertex using only edges with positive capacity. Then we keep only those edges $(v, u)$ for which $level[v] + 1 = level[u]$. Obviously, this network is acyclic.</p>","tags":["Translated"]},{"location":"graph/dinic.html#algorithm","title":"Algorithm","text":"<p>The algorithm consists of several phases. On each phase we construct the layered network of the residual network of $G$. Then we find an arbitrary blocking flow in the layered network and add it to the current flow.</p>","tags":["Translated"]},{"location":"graph/dinic.html#proof-of-correctness","title":"Proof of correctness","text":"<p>Let's show that if the algorithm terminates, it finds the maximum flow.</p> <p>If the algorithm terminated, it couldn't find a blocking flow in the layered network. It means that the layered network doesn't have any path from $s$ to $t$.  It means that the residual network doesn't have any path from $s$ to $t$. It means that the flow is maximum.</p>","tags":["Translated"]},{"location":"graph/dinic.html#number-of-phases","title":"Number of phases","text":"<p>The algorithm terminates in less than $V$ phases. To prove this, we must firstly prove two lemmas.</p> <p>Lemma 1. The distances from $s$ to each vertex don't decrease after each iteration, i. e. $level_{i+1}[v] \\ge level_i[v]$.</p> <p>Proof. Fix a phase $i$ and a vertex $v$. Consider any shortest path $P$ from $s$ to $v$ in $G_{i+1}^R$. The length of $P$ equals $level_{i+1}[v]$. Note that $G_{i+1}^R$ can only contain edges from $G_i^R$ and back edges for edges from $G_i^R$. If $P$ has no back edges for $G_i^R$, then $level_{i+1}[v] \\ge level_i[v]$ because $P$ is also a path in $G_i^R$. Now, suppose that $P$ has at least one back edge. Let the first such edge be $(u, w)$.Then $level_{i+1}[u] \\ge level_i[u]$ (because of the first case). The edge $(u, w)$ doesn't belong to $G_i^R$, so the edge $(w, u)$ was affected by the blocking flow on the previous iteration. It means that $level_i[u] = level_i[w] + 1$. Also, $level_{i+1}[w] = level_{i+1}[u] + 1$. From these two equations and $level_{i+1}[u] \\ge level_i[u]$ we obtain $level_{i+1}[w] \\ge level_i[w] + 2$. Now we can use the same idea for the rest of the path.</p> <p>Lemma 2. $level_{i+1}[t] &gt; level_i[t]$</p> <p>Proof. From the previous lemma, $level_{i+1}[t] \\ge level_i[t]$. Suppose that $level_{i+1}[t] = level_i[t]$. Note that $G_{i+1}^R$ can only contain edges from $G_i^R$ and back edges for edges from $G_i^R$. It means that there is a shortest path in $G_i^R$ which wasn't blocked by the blocking flow. It's a contradiction.</p> <p>From these two lemmas we conclude that there are less than $V$ phases because $level[t]$ increases, but it can't be greater than $V - 1$.</p>","tags":["Translated"]},{"location":"graph/dinic.html#finding-blocking-flow","title":"Finding blocking flow","text":"<p>In order to find the blocking flow on each iteration, we may simply try pushing flow with DFS from $s$ to $t$ in the layered network while it can be pushed. In order to do it more quickly, we must remove the edges which can't be used to push anymore. To do this we can keep a pointer in each vertex which points to the next edge which can be used.</p> <p>A single DFS run takes $O(k+V)$ time, where $k$ is the number of pointer advances on this run. Summed up over all runs, number of pointer advances can not exceed $E$. On the other hand, total number of runs won't exceed $E$, as every run saturates at least one edge. In this way, total running time of finding a blocking flow is $O(VE)$.</p>","tags":["Translated"]},{"location":"graph/dinic.html#complexity","title":"Complexity","text":"<p>There are less than $V$ phases, so the total complexity is $O(V^2E)$.</p>","tags":["Translated"]},{"location":"graph/dinic.html#unit-networks","title":"Unit networks","text":"<p>A unit network is a network in which for any vertex except $s$ and $t$ either incoming or outgoing edge is unique and has unit capacity. That's exactly the case with the network we build to solve the maximum matching problem with flows.</p> <p>On unit networks Dinic's algorithm works in $O(E\\sqrt{V})$. Let's prove this.</p> <p>Firstly, each phase now works in $O(E)$ because each edge will be considered at most once.</p> <p>Secondly, suppose there have already been $\\sqrt{V}$ phases. Then all the augmenting paths with the length $\\le\\sqrt{V}$ have been found. Let $f$ be the current flow, $f'$ be the maximum flow. Consider their difference $f' - f$. It is a flow in $G^R$ of value $|f'| - |f|$ and on each edge it is either $0$ or $1$. It can be decomposed into $|f'| - |f|$ paths from $s$ to $t$ and possibly cycles. As the network is unit, they can't have common vertices, so the total number of vertices is $\\ge (|f'| - |f|)\\sqrt{V}$, but it is also $\\le V$, so in another $\\sqrt{V}$ iterations we will definitely find the maximum flow.</p>","tags":["Translated"]},{"location":"graph/dinic.html#unit-capacities-networks","title":"Unit capacities networks","text":"<p>In a more generic settings when all edges have unit capacities, but the number of incoming and outgoing edges is unbounded, the paths can't have common edges rather than common vertices. In a similar way it allows to prove the bound of $\\sqrt E$ on the number of iterations, hence the running time of Dinic algorithm on such networks is at most $O(E \\sqrt E)$.</p> <p>Finally, it is also possible to prove that the number of phases on unit capacity networks doesn't exceed $O(V^{2/3})$, providing an alternative estimate of $O(EV^{2/3})$ on the networks with particularly large number of edges.</p>","tags":["Translated"]},{"location":"graph/dinic.html#implementation","title":"Implementation","text":"<pre><code>struct FlowEdge {\n    int v, u;\n    long long cap, flow = 0;\n    FlowEdge(int v, int u, long long cap) : v(v), u(u), cap(cap) {}\n};\n\nstruct Dinic {\n    const long long flow_inf = 1e18;\n    vector&lt;FlowEdge&gt; edges;\n    vector&lt;vector&lt;int&gt;&gt; adj;\n    int n, m = 0;\n    int s, t;\n    vector&lt;int&gt; level, ptr;\n    queue&lt;int&gt; q;\n\n    Dinic(int n, int s, int t) : n(n), s(s), t(t) {\n        adj.resize(n);\n        level.resize(n);\n        ptr.resize(n);\n    }\n\n    void add_edge(int v, int u, long long cap) {\n        edges.emplace_back(v, u, cap);\n        edges.emplace_back(u, v, 0);\n        adj[v].push_back(m);\n        adj[u].push_back(m + 1);\n        m += 2;\n    }\n\n    bool bfs() {\n        while (!q.empty()) {\n            int v = q.front();\n            q.pop();\n            for (int id : adj[v]) {\n                if (edges[id].cap == edges[id].flow)\n                    continue;\n                if (level[edges[id].u] != -1)\n                    continue;\n                level[edges[id].u] = level[v] + 1;\n                q.push(edges[id].u);\n            }\n        }\n        return level[t] != -1;\n    }\n\n    long long dfs(int v, long long pushed) {\n        if (pushed == 0)\n            return 0;\n        if (v == t)\n            return pushed;\n        for (int&amp; cid = ptr[v]; cid &lt; (int)adj[v].size(); cid++) {\n            int id = adj[v][cid];\n            int u = edges[id].u;\n            if (level[v] + 1 != level[u])\n                continue;\n            long long tr = dfs(u, min(pushed, edges[id].cap - edges[id].flow));\n            if (tr == 0)\n                continue;\n            edges[id].flow += tr;\n            edges[id ^ 1].flow -= tr;\n            return tr;\n        }\n        return 0;\n    }\n\n    long long flow() {\n        long long f = 0;\n        while (true) {\n            fill(level.begin(), level.end(), -1);\n            level[s] = 0;\n            q.push(s);\n            if (!bfs())\n                break;\n            fill(ptr.begin(), ptr.end(), 0);\n            while (long long pushed = dfs(s, flow_inf)) {\n                f += pushed;\n            }\n        }\n        return f;\n    }\n};\n</code></pre>","tags":["Translated"]},{"location":"graph/dinic.html#practice-problems","title":"Practice Problems","text":"<ul> <li>SPOJ: FASTFLOW</li> </ul>","tags":["Translated"]},{"location":"graph/edge_vertex_connectivity.html","title":"Edge connectivity / Vertex connectivity","text":"","tags":["Translated"]},{"location":"graph/edge_vertex_connectivity.html#definition","title":"Definition","text":"<p>Given an undirected graph $G$ with $n$ vertices and $m$ edges. Both the edge connectivity and the vertex connectivity are characteristics describing the graph.</p>","tags":["Translated"]},{"location":"graph/edge_vertex_connectivity.html#edge-connectivity","title":"Edge connectivity","text":"<p>The edge connectivity $\\lambda$ of the graph $G$ is the minimum number of edges that need to be deleted, such that the graph $G$ gets disconnected.</p> <p>For example an already disconnected graph has an edge connectivity of $0$, a connected graph with at least one bridge has an edge connectivity of $1$, and a connected graph with no bridges has an edge connectivity of at least $2$.</p> <p>We say that a set $S$ of edges separates the vertices $s$ and $t$, if, after removing all edges in $S$ from the graph $G$, the vertices $s$ and $t$ end up in different connected components.</p> <p>It is clear, that the edge connectivity of a graph is equal to the minimum size of such a set separating two vertices $s$ and $t$, taken among all possible pairs $(s, t)$.</p>","tags":["Translated"]},{"location":"graph/edge_vertex_connectivity.html#vertex-connectivity","title":"Vertex connectivity","text":"<p>The vertex connectivity $\\kappa$ of the graph $G$ is the minimum number of vertices that need to be deleted, such that the graph $G$ gets disconnected.</p> <p>For example an already disconnected graph has the vertex connectivity $0$, and a connected graph with an articulation point has the vertex connectivity $1$. We define that a complete graph has the vertex connectivity $n-1$. For all other graphs the vertex connectivity doesn't exceed $n-2$, because you can find a pair of vertices which are not connected by an edge, and remove all other $n-2$ vertices.</p> <p>We say that a set $T$ of vertices separates the vertices $s$ and $t$, if, after removing all vertices in $T$ from the graph $G$, the vertices end up in different connected components.</p> <p>It is clear, that the vertex connectivity of a graph is equal to the minimal size of such a set separating two vertices $s$ and $t$, taken among all possible pairs $(s, t)$.</p>","tags":["Translated"]},{"location":"graph/edge_vertex_connectivity.html#properties","title":"Properties","text":"","tags":["Translated"]},{"location":"graph/edge_vertex_connectivity.html#the-whitney-inequalities","title":"The Whitney inequalities","text":"<p>The Whitney inequalities (1932) gives a relation between the edge connectivity $\\lambda$, the vertex connectivity $\\kappa$, and the minimum degree of any vertex in the graph $\\delta$:</p> $$\\kappa \\le \\lambda \\le \\delta$$ <p>Intuitively if we have a set of edges of size $\\lambda$, which make the graph disconnected, we can choose one of each end point, and create a set of vertices, that also disconnect the graph. And this set has size $\\le \\lambda$.</p> <p>And if we pick the vertex and the minimal degree $\\delta$, and remove all edges connected to it, then we also end up with a disconnected graph. Therefore the second inequality $\\lambda \\le \\delta$.</p> <p>It is interesting to note, that the Whitney inequalities cannot be improved: i.e. for any triple of numbers satisfying this inequality there exists at least one corresponding graph. One such graph can be constructed in the following way: The graph will consists of $2(\\delta + 1)$ vertices, the first $\\delta + 1$ vertices form a clique (all pairs of vertices are connected via an edge), and the second $\\delta + 1$ vertices form a second clique. In addition we connect the two cliques with $\\lambda$ edges, such that it uses $\\lambda$ different vertices in the first clique, and only $\\kappa$ vertices in the second clique. The resulting graph will have the three characteristics.</p>","tags":["Translated"]},{"location":"graph/edge_vertex_connectivity.html#the-ford-fulkerson-theorem","title":"The Ford-Fulkerson theorem","text":"<p>The Ford-Fulkerson theorem implies, that the biggest number of edge-disjoint paths connecting two vertices, is equal to the smallest number of edges separating these vertices.</p>","tags":["Translated"]},{"location":"graph/edge_vertex_connectivity.html#computing-the-values","title":"Computing the values","text":"","tags":["Translated"]},{"location":"graph/edge_vertex_connectivity.html#edge-connectivity-using-maximum-flow","title":"Edge connectivity using maximum flow","text":"<p>This method is based on the Ford-Fulkerson theorem.</p> <p>We iterate over all pairs of vertices $(s, t)$ and between each pair we find the largest number of disjoint paths between them. This value can be found using a maximum flow algorithm: we use $s$ as the source, $t$ as the sink, and assign each edge a capacity of $1$. Then the maximum flow is the number of disjoint paths.</p> <p>The complexity for the algorithm using Edmonds-Karp is $O(V^2 V E^2) = O(V^3 E^2)$.  But we should note, that this includes a hidden factor, since it is practically impossible to create a graph such that the maximum flow algorithm will be slow for all sources and sinks. Especially the algorithm will run pretty fast for random graphs.</p>","tags":["Translated"]},{"location":"graph/edge_vertex_connectivity.html#special-algorithm-for-edge-connectivity","title":"Special algorithm for edge connectivity","text":"<p>The task of finding the edge connectivity is equal to the task of finding the global minimum cut.</p> <p>Special algorithms have been developed for this task. One of them is the Stoer-Wagner algorithm, which works in $O(V^3)$ or $O(V E)$ time.</p>","tags":["Translated"]},{"location":"graph/edge_vertex_connectivity.html#vertex-connectivity_1","title":"Vertex connectivity","text":"<p>Again we iterate over all pairs of vertices $s$ and $t$, and for each pair we find the minimum number of vertices that separates $s$ and $t$.</p> <p>By doing this, we can apply the same maximum flow approach as described in the previous sections.</p> <p>We split each vertex $x$ with $x \\neq s$ and $x \\neq t$ into two vertices $x_1$ and $x_2$. We connect these to vertices with a directed edge $(x_1, x_2)$ with the capacity $1$, and replace all edges $(u, v)$ by the two directed edges $(u_2, v_1)$ and $(v_2, u_1)$, both with the capacity of 1. The by the construction the value of the maximum flow will be equal to the minimum number of vertices that are needed to separate $s$ and $t$.</p> <p>This approach has the same complexity as the flow approach for finding the edge connectivity.</p>","tags":["Translated"]},{"location":"graph/edmonds_karp.html","title":"Maximum flow - Ford-Fulkerson and Edmonds-Karp","text":"<p>The Edmonds-Karp algorithm is an implementation of the Ford-Fulkerson method for computing a maximal flow in a flow network.</p>","tags":["Translated"]},{"location":"graph/edmonds_karp.html#flow-network","title":"Flow network","text":"<p>First let's define what a flow network, a flow, and a maximum flow is.</p> <p>A network is a directed graph $G$ with vertices $V$ and edges $E$ combined with a function $c$, which assigns each edge $e \\in E$ a non-negative integer value, the capacity of $e$. Such a network is called a flow network, if we additionally label two vertices, one as source and one as sink.</p> <p>A flow in a flow network is function $f$, that again assigns each edge $e$ a non-negative integer value, namely the flow. The function has to fulfill the following two conditions:</p> <p>The flow of an edge cannot exceed the capacity.</p> $$f(e) \\le c(e)$$ <p>And the sum of the incoming flow of a vertex $u$ has to be equal to the sum of the outgoing flow of $u$ except in the source and sink vertices.</p> $$\\sum_{(v, u) \\in E} f((v, u)) = \\sum_{(u, v) \\in E} f((u, v))$$ <p>The source vertex $s$ only has an outgoing flow, and the sink vertex $t$ has only incoming flow.</p> <p>It is easy to see that the following equation holds:</p> $$\\sum_{(s, u) \\in E} f((s, u)) = \\sum_{(u, t) \\in E} f((u, t))$$ <p>A good analogy for a flow network is the following visualization: We represent edges as water pipes, the capacity of an edge is the maximal amount of water that can flow through the pipe per second, and the flow of an edge is the amount of water that currently flows through the pipe per second. This motivates the first flow condition. There cannot flow more water through a pipe than its capacity. The vertices act as junctions, where water comes out of some pipes, and then, these vertices distribute the water in some way to other pipes. This also motivates the second flow condition. All the incoming water has to be distributed to the other pipes in each junction. It cannot magically disappear or appear. The source $s$ is origin of all the water, and the water can only drain in the sink $t$.</p> <p>The following image shows a flow network. The first value of each edge represents the flow, which is initially 0, and the second value represents the capacity.</p> <p>The value of the flow of a network is the sum of all the flows that get produced in the source $s$, or equivalently to the sum of all the flows that are consumed by the sink $t$. A maximal flow is a flow with the maximal possible value. Finding this maximal flow of a flow network is the problem that we want to solve.</p> <p>In the visualization with water pipes, the problem can be formulated in the following way: how much water can we push through the pipes from the source to the sink?</p> <p>The following image shows the maximal flow in the flow network.</p>","tags":["Translated"]},{"location":"graph/edmonds_karp.html#ford-fulkerson-method","title":"Ford-Fulkerson method","text":"<p>Let's define one more thing. A residual capacity of a directed edge is the capacity minus the flow. It should be noted that if there is a flow along some directed edge $(u, v)$, then the reversed edge has capacity 0 and we can define the flow of it as $f((v, u)) = -f((u, v))$. This also defines the residual capacity for all the reversed edges. We can create a residual network from all these edges, which is just a network with the same vertices and edges, but we use the residual capacities as capacities.</p> <p>The Ford-Fulkerson method works as follows. First, we set the flow of each edge to zero. Then we look for an augmenting path from $s$ to $t$. An augmenting path is a simple path in the residual graph where residual capacity is positive for all the edges along that path. If such a path is found, then we can increase the flow along these edges. We keep on searching for augmenting paths and increasing the flow. Once an augmenting path doesn't exist anymore, the flow is maximal.</p> <p>Let us specify in more detail, what increasing the flow along an augmenting path means. Let $C$ be the smallest residual capacity of the edges in the path. Then we increase the flow in the following way: we update $f((u, v)) ~\\text{+=}~ C$ and $f((v, u)) ~\\text{-=}~ C$ for every edge $(u, v)$ in the path.</p> <p>Here is an example to demonstrate the method. We use the same flow network as above. Initially we start with a flow of 0.</p> <p>We can find the path $s - A - B - t$ with the residual capacities 7, 5, and 8. Their minimum is 5, therefore we can increase the flow along this path by 5. This gives a flow of 5 for the network.</p> <p>Again we look for an augmenting path, this time we find $s - D - A - C - t$ with the residual capacities 4, 3, 3, and 5. Therefore we can increase the flow by 3 and we get a flow of 8 for the network.</p> <p>This time we find the path $s - D - C - B - t$ with the residual capacities 1, 2, 3, and 3, and hence, we increase the flow by 1.</p> <p>This time we find the augmenting path $s - A - D - C - t$ with the residual capacities 2, 3, 1, and 2. We can increase the flow by 1. But this path is very interesting. It includes the reversed edge $(A, D)$. In the original flow network, we are not allowed to send any flow from $A$ to $D$. But because we already have a flow of 3 from $D$ to $A$, this is possible. The intuition of it is the following: Instead of sending a flow of 3 from $D$ to $A$, we only send 2 and compensate this by sending an additional flow of 1 from $s$ to $A$, which allows us to send an additional flow of 1 along the path $D - C - t$.</p> <p>Now, it is impossible to find an augmenting path between $s$ and $t$, therefore this flow of $10$ is the maximal possible. We have found the maximal flow.</p> <p>It should be noted, that the Ford-Fulkerson method doesn't specify a method of finding the augmenting path. Possible approaches are using DFS or BFS which both work in $O(E)$. If all the capacities of the network are integers, then for each augmenting path the flow of the network increases by at least 1 (for more details see Integral flow theorem). Therefore, the complexity of Ford-Fulkerson is $O(E F)$, where $F$ is the maximal flow of the network. In the case of rational capacities, the algorithm will also terminate, but the complexity is not bounded. In the case of irrational capacities, the algorithm might never terminate, and might not even converge to the maximal flow.</p>","tags":["Translated"]},{"location":"graph/edmonds_karp.html#edmonds-karp-algorithm","title":"Edmonds-Karp algorithm","text":"<p>Edmonds-Karp algorithm is just an implementation of the Ford-Fulkerson method that uses BFS for finding augmenting paths. The algorithm was first published by Yefim Dinitz in 1970, and later independently published by Jack Edmonds and Richard Karp in 1972.</p> <p>The complexity can be given independently of the maximal flow. The algorithm runs in $O(V E^2)$ time, even for irrational capacities. The intuition is, that every time we find an augmenting path one of the edges becomes saturated, and the distance from the edge to $s$ will be longer if it appears later again in an augmenting path. The length of the simple paths is bounded by $V$.</p>","tags":["Translated"]},{"location":"graph/edmonds_karp.html#implementation","title":"Implementation","text":"<p>The matrix <code>capacity</code> stores the capacity for every pair of vertices. <code>adj</code> is the adjacency list of the undirected graph, since we have also to use the reversed of directed edges when we are looking for augmenting paths.</p> <p>The function <code>maxflow</code> will return the value of the maximal flow. During the algorithm, the matrix <code>capacity</code> will actually store the residual capacity of the network. The value of the flow in each edge will actually not be stored, but it is easy to extend the implementation - by using an additional matrix - to also store the flow and return it.</p> <pre><code>int n;\nvector&lt;vector&lt;int&gt;&gt; capacity;\nvector&lt;vector&lt;int&gt;&gt; adj;\n\nint bfs(int s, int t, vector&lt;int&gt;&amp; parent) {\n    fill(parent.begin(), parent.end(), -1);\n    parent[s] = -2;\n    queue&lt;pair&lt;int, int&gt;&gt; q;\n    q.push({s, INF});\n\n    while (!q.empty()) {\n        int cur = q.front().first;\n        int flow = q.front().second;\n        q.pop();\n\n        for (int next : adj[cur]) {\n            if (parent[next] == -1 &amp;&amp; capacity[cur][next]) {\n                parent[next] = cur;\n                int new_flow = min(flow, capacity[cur][next]);\n                if (next == t)\n                    return new_flow;\n                q.push({next, new_flow});\n            }\n        }\n    }\n\n    return 0;\n}\n\nint maxflow(int s, int t) {\n    int flow = 0;\n    vector&lt;int&gt; parent(n);\n    int new_flow;\n\n    while (new_flow = bfs(s, t, parent)) {\n        flow += new_flow;\n        int cur = t;\n        while (cur != s) {\n            int prev = parent[cur];\n            capacity[prev][cur] -= new_flow;\n            capacity[cur][prev] += new_flow;\n            cur = prev;\n        }\n    }\n\n    return flow;\n}\n</code></pre>","tags":["Translated"]},{"location":"graph/edmonds_karp.html#integral-theorem","title":"Integral flow theorem","text":"<p>The theorem says, that if every capacity in the network is an integer, then the size of the maximum flow is an integer, and there is a maximum flow such that the flow in each edge is an integer as well. In particular, Ford-Fulkerson method finds such a flow.</p>","tags":["Translated"]},{"location":"graph/edmonds_karp.html#max-flow-min-cut-theorem","title":"Max-flow min-cut theorem","text":"<p>A $s$-$t$-cut is a partition of the vertices of a flow network into two sets, such that a set includes the source $s$ and the other one includes the sink $t$. The capacity of a $s$-$t$-cut is defined as the sum of capacities of the edges from the source side to the sink side.</p> <p>Obviously, we cannot send more flow from $s$ to $t$ than the capacity of any $s$-$t$-cut. Therefore, the maximum flow is bounded by the minimum cut capacity.</p> <p>The max-flow min-cut theorem goes even further. It says that the capacity of the maximum flow has to be equal to the capacity of the minimum cut.</p> <p>In the following image, you can see the minimum cut of the flow network we used earlier. It shows that the capacity of the cut $\\{s, A, D\\}$ and $\\{B, C, t\\}$ is $5 + 3 + 2 = 10$, which is equal to the maximum flow that we found. Other cuts will have a bigger capacity, like the capacity between $\\{s, A\\}$ and $\\{B, C, D, t\\}$ is $4 + 3 + 5 = 12$.</p> <p>A minimum cut can be found after performing a maximum flow computation using the Ford-Fulkerson method. One possible minimum cut is the following: the set of all the vertices that can be reached from $s$ in the residual graph (using edges with positive residual capacity), and the set of all the other vertices. This partition can be easily found using DFS starting at $s$.</p>","tags":["Translated"]},{"location":"graph/edmonds_karp.html#practice-problems","title":"Practice Problems","text":"<ul> <li>Codeforces - Array and Operations</li> <li>Codeforces - Red-Blue Graph</li> <li>CSES - Download Speed</li> <li>CSES - Police Chase</li> <li>CSES - School Dance</li> <li>CSES - Distinct Routes</li> </ul>","tags":["Translated"]},{"location":"graph/euler_path.html","title":"Finding the Eulerian path in $O(M)$","text":"<p>A Eulerian path is a path in a graph that passes through all of its edges exactly once. A Eulerian cycle is a Eulerian path that is a cycle.</p> <p>The problem is to find the Eulerian path in an undirected multigraph with loops.</p>","tags":["Translated"]},{"location":"graph/euler_path.html#algorithm","title":"Algorithm","text":"<p>First we can check if there is an Eulerian path. We can use the following theorem. An Eulerian cycle exists if and only if the degrees of all vertices are even. And an Eulerian path exists if and only if the number of vertices with odd degrees is two (or zero, in the case of the existence of a Eulerian cycle). In addition, of course, the graph must be sufficiently connected (i.e., if you remove all isolated vertices from it, you should get a connected graph).</p> <p>To find the Eulerian path / Eulerian cycle we can use the following strategy: We find all simple cycles and combine them into one - this will be the Eulerian cycle. If the graph is such that the Eulerian path is not a cycle, then add the missing edge, find the Eulerian cycle, then remove the extra edge.</p> <p>Looking for all cycles and combining them can be done with a simple recursive procedure:</p> <pre><code>procedure FindEulerPath(V)\n  1. iterate through all the edges outgoing from vertex V;\n       remove this edge from the graph,\n       and call FindEulerPath from the second end of this edge;\n  2. add vertex V to the answer.\n</code></pre> <p>The complexity of this algorithm is obviously linear with respect to the number of edges.</p> <p>But we can write the same algorithm in the non-recursive version:</p> <pre><code>stack St;\nput start vertex in St;\nuntil St is empty\n  let V be the value at the top of St;\n  if degree(V) = 0, then\n    add V to the answer;\n    remove V from the top of St;\n  otherwise\n    find any edge coming out of V;\n    remove it from the graph;\n    put the second end of this edge in St;\n</code></pre> <p>It is easy to check the equivalence of these two forms of the algorithm. However, the second form is obviously faster, and the code will be much more efficient.</p>","tags":["Translated"]},{"location":"graph/euler_path.html#the-domino-problem","title":"The Domino problem","text":"<p>We give here a classical Eulerian cycle problem - the Domino problem.</p> <p>There are $N$ dominoes, as it is known, on both ends of the Domino one number is written(usually from 1 to 6, but in our case it is not important). You want to put all the dominoes in a row so that the numbers on any two adjacent dominoes, written on their common side, coincide. Dominoes are allowed to turn.</p> <p>Reformulate the problem. Let the numbers written on the bottoms be the vertices of the graph, and the dominoes be the edges of this graph (each Domino with numbers $(a,b)$ are the edges $(a,b)$ and $(b, a)$). Then our problem is reduced to the problem of finding the Eulerian path in this graph.</p>","tags":["Translated"]},{"location":"graph/euler_path.html#implementation","title":"Implementation","text":"<p>The program below searches for and outputs a Eulerian loop or path in a graph, or outputs $-1$ if it does not exist.</p> <p>First, the program checks the degree of vertices: if there are no vertices with an odd degree, then the graph has an Euler cycle, if there are $2$ vertices with an odd degree, then in the graph there is only an Euler path (but no Euler cycle), if there are more than $2$ such vertices, then in the graph there is no Euler cycle or Euler path. To find the Euler path (not a cycle), let's do this: if $V1$ and $V2$ are two vertices of odd degree, then just add an edge $(V1, V2)$, in the resulting graph we find the Euler cycle (it will obviously exist), and then remove the \"fictitious\" edge $(V1, V2)$ from the answer. We will look for the Euler cycle exactly as described above (non-recursive version), and at the same time at the end of this algorithm we will check whether the graph was connected or not (if the graph was not connected, then at the end of the algorithm some edges will remain in the graph, and in this case we need to print $-1$). Finally, the program takes into account that there can be isolated vertices in the graph.</p> <p>Notice that we use an adjacency matrix in this problem. Also this implementation handles finding the next with brute-force, which requires to iterate over the complete row in the matrix over and over. A better way would be to store the graph as an adjacency list, and remove edges in $O(1)$ and mark the reversed edges in separate list. This way we can achieve an $O(N)$ algorithm.</p> <pre><code>int main() {\n    int n;\n    vector&lt;vector&lt;int&gt;&gt; g(n, vector&lt;int&gt;(n));\n    // reading the graph in the adjacency matrix\n\n    vector&lt;int&gt; deg(n);\n    for (int i = 0; i &lt; n; ++i) {\n        for (int j = 0; j &lt; n; ++j)\n            deg[i] += g[i][j];\n    }\n\n    int first = 0;\n    while (first &lt; n &amp;&amp; !deg[first])\n        ++first;\n    if (first == n) {\n        cout &lt;&lt; -1;\n        return 0;\n    }\n\n    int v1 = -1, v2 = -1;\n    bool bad = false;\n    for (int i = 0; i &lt; n; ++i) {\n        if (deg[i] &amp; 1) {\n            if (v1 == -1)\n                v1 = i;\n            else if (v2 == -1)\n                v2 = i;\n            else\n                bad = true;\n        }\n    }\n\n    if (v1 != -1)\n        ++g[v1][v2], ++g[v2][v1];\n\n    stack&lt;int&gt; st;\n    st.push(first);\n    vector&lt;int&gt; res;\n    while (!st.empty()) {\n        int v = st.top();\n        int i;\n        for (i = 0; i &lt; n; ++i)\n            if (g[v][i])\n                break;\n        if (i == n) {\n            res.push_back(v);\n            st.pop();\n        } else {\n            --g[v][i];\n            --g[i][v];\n            st.push(i);\n        }\n    }\n\n    if (v1 != -1) {\n        for (size_t i = 0; i + 1 &lt; res.size(); ++i) {\n            if ((res[i] == v1 &amp;&amp; res[i + 1] == v2) ||\n                (res[i] == v2 &amp;&amp; res[i + 1] == v1)) {\n                vector&lt;int&gt; res2;\n                for (size_t j = i + 1; j &lt; res.size(); ++j)\n                    res2.push_back(res[j]);\n                for (size_t j = 1; j &lt;= i; ++j)\n                    res2.push_back(res[j]);\n                res = res2;\n                break;\n            }\n        }\n    }\n\n    for (int i = 0; i &lt; n; ++i) {\n        for (int j = 0; j &lt; n; ++j) {\n            if (g[i][j])\n                bad = true;\n        }\n    }\n\n    if (bad) {\n        cout &lt;&lt; -1;\n    } else {\n        for (int x : res)\n            cout &lt;&lt; x &lt;&lt; \" \";\n    }\n}\n</code></pre>","tags":["Translated"]},{"location":"graph/euler_path.html#practice-problems","title":"Practice problems:","text":"<ul> <li>CSES : Mail Delivery</li> <li>CSES : Teleporters Path</li> </ul>","tags":["Translated"]},{"location":"graph/finding-cycle.html","title":"Checking a graph for acyclicity and finding a cycle in $O(M)$","text":"<p>Consider a directed or undirected graph without loops and multiple edges. We have to check whether it is acyclic, and if it is not, then find any cycle.</p> <p>We can solve this problem by using Depth First Search in $O(M)$ where $M$ is number of edges.</p>","tags":["Translated"]},{"location":"graph/finding-cycle.html#algorithm","title":"Algorithm","text":"<p>We will run a series of DFS in the graph. Initially all vertices are colored white (0). From each unvisited (white) vertex, start the DFS, mark it gray (1) while entering and mark it black (2) on exit. If DFS moves to a gray vertex, then we have found a cycle (if the graph is undirected, the edge to parent is not considered). The cycle itself can be reconstructed using parent array.</p>","tags":["Translated"]},{"location":"graph/finding-cycle.html#implementation","title":"Implementation","text":"<p>Here is an implementation for directed graph.</p> <pre><code>int n;\nvector&lt;vector&lt;int&gt;&gt; adj;\nvector&lt;char&gt; color;\nvector&lt;int&gt; parent;\nint cycle_start, cycle_end;\n\nbool dfs(int v) {\n    color[v] = 1;\n    for (int u : adj[v]) {\n        if (color[u] == 0) {\n            parent[u] = v;\n            if (dfs(u))\n                return true;\n        } else if (color[u] == 1) {\n            cycle_end = v;\n            cycle_start = u;\n            return true;\n        }\n    }\n    color[v] = 2;\n    return false;\n}\n\nvoid find_cycle() {\n    color.assign(n, 0);\n    parent.assign(n, -1);\n    cycle_start = -1;\n\n    for (int v = 0; v &lt; n; v++) {\n        if (color[v] == 0 &amp;&amp; dfs(v))\n            break;\n    }\n\n    if (cycle_start == -1) {\n        cout &lt;&lt; \"Acyclic\" &lt;&lt; endl;\n    } else {\n        vector&lt;int&gt; cycle;\n        cycle.push_back(cycle_start);\n        for (int v = cycle_end; v != cycle_start; v = parent[v])\n            cycle.push_back(v);\n        cycle.push_back(cycle_start);\n        reverse(cycle.begin(), cycle.end());\n\n        cout &lt;&lt; \"Cycle found: \";\n        for (int v : cycle)\n            cout &lt;&lt; v &lt;&lt; \" \";\n        cout &lt;&lt; endl;\n    }\n}\n</code></pre> <p>Here is an implementation for undirected graph. Note that in the undirected version, if a vertex <code>v</code> gets colored black, it will never be visited again by the DFS. This is because we already explored all connected edges of <code>v</code> when we first visited it. The connected component containing <code>v</code> (after removing the edge between <code>v</code> and its parent) must be a tree, if the DFS has completed processing <code>v</code> without finding a cycle. So we don't even need to distinguish between gray and black states. Thus we can turn the char vector <code>color</code> into a boolean vector <code>visited</code>.</p> <pre><code>int n;\nvector&lt;vector&lt;int&gt;&gt; adj;\nvector&lt;bool&gt; visited;\nvector&lt;int&gt; parent;\nint cycle_start, cycle_end;\n\nbool dfs(int v, int par) { // passing vertex and its parent vertex\n    visited[v] = true;\n    for (int u : adj[v]) {\n        if(u == par) continue; // skipping edge to parent vertex\n        if (visited[u]) {\n            cycle_end = v;\n            cycle_start = u;\n            return true;\n        }\n        parent[u] = v;\n        if (dfs(u, parent[u]))\n            return true;\n    }\n    return false;\n}\n\nvoid find_cycle() {\n    visited.assign(n, false);\n    parent.assign(n, -1);\n    cycle_start = -1;\n\n    for (int v = 0; v &lt; n; v++) {\n        if (!visited[v] &amp;&amp; dfs(v, parent[v]))\n            break;\n    }\n\n    if (cycle_start == -1) {\n        cout &lt;&lt; \"Acyclic\" &lt;&lt; endl;\n    } else {\n        vector&lt;int&gt; cycle;\n        cycle.push_back(cycle_start);\n        for (int v = cycle_end; v != cycle_start; v = parent[v])\n            cycle.push_back(v);\n        cycle.push_back(cycle_start);\n\n        cout &lt;&lt; \"Cycle found: \";\n        for (int v : cycle)\n            cout &lt;&lt; v &lt;&lt; \" \";\n        cout &lt;&lt; endl;\n    }\n}\n</code></pre>","tags":["Translated"]},{"location":"graph/finding-cycle.html#practice-problems","title":"Practice problems:","text":"<ul> <li>AtCoder : Reachability in Functional Graph</li> <li>CSES : Round Trip</li> <li>CSES : Round Trip II</li> </ul>","tags":["Translated"]},{"location":"graph/finding-negative-cycle-in-graph.html","title":"Finding a negative cycle in the graph","text":"<p>You are given a directed weighted graph $G$ with $N$ vertices and $M$ edges. Find any cycle of negative weight in it, if such a cycle exists.</p> <p>In another formulation of the problem you have to find all pairs of vertices which have a path of arbitrarily small weight between them.</p> <p>It is convenient to use different algorithms to solve these two variations of the problem, so we'll discuss both of them here.</p>","tags":["Translated"]},{"location":"graph/finding-negative-cycle-in-graph.html#using-bellman-ford-algorithm","title":"Using Bellman-Ford algorithm","text":"<p>Bellman-Ford algorithm allows you to check whether there exists a cycle of negative weight in the graph, and if it does, find one of these cycles.</p> <p>The details of the algorithm are described in the article on the Bellman-Ford algorithm. Here we'll describe only its application to this problem.</p> <p>The standard implementation of Bellman-Ford looks for a negative cycle reachable from some starting vertex $v$\u200a; however, the algorithm can be modified to just look for any negative cycle in the graph.  For this we need to put all the distance \u200a$d[i]$\u200a to zero and not infinity \u2014 as if we are looking for the shortest path from all vertices simultaneously; the validity of the detection of a negative cycle is not affected.</p> <p>Do $N$ iterations of Bellman-Ford algorithm. If there were no changes on the last iteration, there is no cycle of negative weight in the graph. Otherwise take a vertex the distance to which has changed, and go from it via its ancestors until a cycle is found. This cycle will be the desired cycle of negative weight.</p>","tags":["Translated"]},{"location":"graph/finding-negative-cycle-in-graph.html#implementation","title":"Implementation","text":"<pre><code>struct Edge {\n    int a, b, cost;\n};\n\nint n;\nvector&lt;Edge&gt; edges;\nconst int INF = 1000000000;\n\nvoid solve() {\n    vector&lt;int&gt; d(n, 0);\n    vector&lt;int&gt; p(n, -1);\n    int x;\n\n    for (int i = 0; i &lt; n; ++i) {\n        x = -1;\n        for (Edge e : edges) {\n            if (d[e.a] + e.cost &lt; d[e.b]) {\n                d[e.b] = max(-INF, d[e.a] + e.cost);\n                p[e.b] = e.a;\n                x = e.b;\n            }\n        }\n    }\n\n    if (x == -1) {\n        cout &lt;&lt; \"No negative cycle found.\";\n    } else {\n        for (int i = 0; i &lt; n; ++i)\n            x = p[x];\n\n        vector&lt;int&gt; cycle;\n        for (int v = x;; v = p[v]) {\n            cycle.push_back(v);\n            if (v == x &amp;&amp; cycle.size() &gt; 1)\n                break;\n        }\n        reverse(cycle.begin(), cycle.end());\n\n        cout &lt;&lt; \"Negative cycle: \";\n        for (int v : cycle)\n            cout &lt;&lt; v &lt;&lt; ' ';\n        cout &lt;&lt; endl;\n    }\n}\n</code></pre>","tags":["Translated"]},{"location":"graph/finding-negative-cycle-in-graph.html#using-floyd-warshall-algorithm","title":"Using Floyd-Warshall algorithm","text":"<p>The Floyd-Warshall algorithm allows to solve the second variation of the problem - finding all pairs of vertices $(i, j)$ which don't have a shortest path between them (i.e. a path of arbitrarily small weight exists).</p> <p>Again, the details can be found in the Floyd-Warshall article, and here we describe only its application.</p> <p>Run Floyd-Warshall algorithm on the graph. Initially $d[v][v] = 0$ for each $v$. But after running the algorithm $d[v][v]$ will be smaller than $0$ if there exists a negative length path from $v$ to $v$. We can use this to also find all pairs of vertices that don't have a shortest path between them. We iterate over all pairs of vertices $(i, j)$ and for each pair we check whether they have a shortest path between them. To do this try all possibilities for an intermediate vertex $t$. $(i, j)$ doesn't have a shortest path, if one of the intermediate vertices $t$ has $d[t][t] &lt; 0$ (i.e. $t$ is part of a cycle of negative weight), $t$ can be reached from $i$ and $j$ can be reached from $t$. Then the path from $i$ to $j$ can have arbitrarily small weight. We will denote this with <code>-INF</code>.</p>","tags":["Translated"]},{"location":"graph/finding-negative-cycle-in-graph.html#implementation_1","title":"Implementation","text":"<pre><code>for (int i = 0; i &lt; n; ++i) {\n    for (int j = 0; j &lt; n; ++j) {\n        for (int t = 0; t &lt; n; ++t) {\n            if (d[i][t] &lt; INF &amp;&amp; d[t][t] &lt; 0 &amp;&amp; d[t][j] &lt; INF)\n                d[i][j] = - INF; \n        }\n    }\n}\n</code></pre>","tags":["Translated"]},{"location":"graph/finding-negative-cycle-in-graph.html#practice-problems","title":"Practice Problems","text":"<ul> <li>UVA: Wormholes</li> <li>SPOJ: Alice in Amsterdam, I mean Wonderland</li> <li>SPOJ: Johnsons Algorithm</li> </ul>","tags":["Translated"]},{"location":"graph/fixed_length_paths.html","title":"Number of paths of fixed length / Shortest paths of fixed length","text":"<p>The following article describes solutions to these two problems built on the same idea: reduce the problem to the construction of matrix and compute the solution with the usual matrix multiplication or with a modified multiplication.</p>","tags":["Translated"]},{"location":"graph/fixed_length_paths.html#number-of-paths-of-a-fixed-length","title":"Number of paths of a fixed length","text":"<p>We are given a directed, unweighted graph $G$ with $n$ vertices and we are given an integer $k$. The task is the following: for each pair of vertices $(i, j)$ we have to find the number of paths of length $k$ between these vertices. Paths don't have to be simple, i.e. vertices and edges can be visited any number of times in a single path.</p> <p>We assume that the graph is specified with an adjacency matrix, i.e. the matrix $G[][]$ of size $n \\times n$, where each element $G[i][j]$ equal to $1$ if the vertex $i$ is connected with $j$ by an edge, and $0$ is they are not connected by an edge. The following algorithm works also in the case of multiple edges: if some pair of vertices $(i, j)$ is connected with $m$ edges, then we can record this in the adjacency matrix by setting $G[i][j] = m$. Also the algorithm works if the graph contains loops (a loop is an edge that connect a vertex with itself).</p> <p>It is obvious that the constructed adjacency matrix is the answer to the problem for the case $k = 1$. It contains the number of paths of length $1$ between each pair of vertices.</p> <p>We will build the solution iteratively: Let's assume we know the answer for some $k$. Here we describe a method how we can construct the answer for $k + 1$. Denote by $C_k$ the matrix for the case $k$, and by $C_{k+1}$ the matrix we want to construct. With the following formula we can compute every entry of $C_{k+1}$:</p> $$C_{k+1}[i][j] = \\sum_{p = 1}^{n} C_k[i][p] \\cdot G[p][j]$$ <p>It is easy to see that the formula computes nothing other than the product of the matrices $C_k$ and $G$:</p> $$C_{k+1} = C_k \\cdot G$$ <p>Thus the solution of the problem can be represented as follows:</p> $$C_k = \\underbrace{G \\cdot G \\cdots G}_{k \\text{ times}} = G^k$$ <p>It remains to note that the matrix products can be raised to a high power efficiently using Binary exponentiation. This gives a solution with $O(n^3 \\log k)$ complexity.</p>","tags":["Translated"]},{"location":"graph/fixed_length_paths.html#shortest-paths-of-a-fixed-length","title":"Shortest paths of a fixed length","text":"<p>We are given a directed weighted graph $G$ with $n$ vertices and an integer $k$. For each pair of vertices $(i, j)$ we have to find the length of the shortest path between $i$ and $j$ that consists of exactly $k$ edges.</p> <p>We assume that the graph is specified by an adjacency matrix, i.e. via the matrix $G[][]$ of size $n \\times n$ where each element $G[i][j]$ contains the length of the edges from the vertex $i$ to the vertex $j$. If there is no edge between two vertices, then the corresponding element of the matrix will be assigned to infinity $\\infty$.</p> <p>It is obvious that in this form the adjacency matrix is the answer to the problem for $k = 1$. It contains the lengths of shortest paths between each pair of vertices, or $\\infty$ if a path consisting of one edge doesn't exist.</p> <p>Again we can build the solution to the problem iteratively: Let's assume we know the answer for some $k$. We show how we can compute the answer for $k+1$. Let us denote $L_k$ the matrix for $k$ and $L_{k+1}$ the matrix we want to build. Then the following formula computes each entry of $L_{k+1}$:</p> $$L_{k+1}[i][j] = \\min_{p = 1 \\ldots n} \\left(L_k[i][p] + G[p][j]\\right)$$ <p>When looking closer at this formula, we can draw an analogy with the matrix multiplication: in fact the matrix $L_k$ is multiplied by the matrix $G$, the only difference is that instead in the multiplication operation we take the minimum instead of the sum, and the sum instead of the multiplication as the inner operation.</p> $$L_{k+1} = L_k \\odot G,$$ <p>where the operation $\\odot$ is defined as follows:</p> $$A \\odot B = C~~\\Longleftrightarrow~~C_{i j} = \\min_{p = 1 \\ldots n}\\left(A_{i p} + B_{p j}\\right)$$ <p>Thus the solution of the task can be represented using the modified multiplication:</p> $$L_k = \\underbrace{G \\odot \\ldots \\odot G}_{k~\\text{times}} = G^{\\odot k}$$ <p>It remains to note that we also can compute this exponentiation efficiently with Binary exponentiation, because the modified multiplication is obviously associative. So also this solution has $O(n^3 \\log k)$ complexity.</p>","tags":["Translated"]},{"location":"graph/fixed_length_paths.html#generalization-of-the-problems-for-paths-with-length-up-to-k","title":"Generalization of the problems for paths with length up to $k$","text":"<p>The above solutions solve the problems for a fixed $k$. However the solutions can be adapted for solving problems for which the paths are allowed to contain no more than $k$ edges.</p> <p>This can be done by slightly modifying the input graph.</p> <p>We duplicate each vertex: for each vertex $v$ we create one more vertex $v'$ and add the edge $(v, v')$ and the loop $(v', v')$. The number of paths between $i$ and $j$ with at most $k$ edges is the same number as the number of paths between $i$ and $j'$ with exactly $k + 1$ edges, since there is a bijection that maps every path $[p_0 = i,~p_1,~\\ldots,~p_{m-1},~p_m = j]$ of length $m \\le k$ to the path $[p_0 = i,~p_1,~\\ldots,~p_{m-1},~p_m = j, j', \\ldots, j']$ of length $k + 1$.</p> <p>The same trick can be applied to compute the shortest paths with at most $k$ edges. We again duplicate each vertex and add the two mentioned edges with weight $0$.</p>","tags":["Translated"]},{"location":"graph/flow_with_demands.html","title":"Flows with demands","text":"<p>In a normal flow network the flow of an edge is only limited by the capacity $c(e)$ from above and by 0 from below. In this article we will discuss flow networks, where we additionally require the flow of each edge to have a certain amount, i.e. we bound the flow from below by a demand function $d(e)$:</p> $$ d(e) \\le f(e) \\le c(e)$$ <p>So next each edge has a minimal flow value, that we have to pass along the edge.</p> <p>This is a generalization of the normal flow problem, since setting $d(e) = 0$ for all edges $e$ gives a normal flow network. Notice, that in the normal flow network it is extremely trivial to find a valid flow, just setting $f(e) = 0$ is already a valid one. However if the flow of each edge has to satisfy a demand, than suddenly finding a valid flow is already pretty complicated.</p> <p>We will consider two problems:</p> <ol> <li>finding an arbitrary flow that satisfies all constraints</li> <li>finding a minimal flow that satisfies all constraints</li> </ol>","tags":["Translated"]},{"location":"graph/flow_with_demands.html#finding-an-arbitrary-flow","title":"Finding an arbitrary flow","text":"<p>We make the following changes in the network. We add a new source $s'$ and a new sink $t'$, a new edge from the source $s'$ to every other vertex, a new edge for every vertex to the sink $t'$, and one edge from $t$ to $s$. Additionally we define the new capacity function $c'$ as:</p> <ul> <li>$c'((s', v)) = \\sum_{u \\in V} d((u, v))$ for each edge $(s', v)$.</li> <li>$c'((v, t')) = \\sum_{w \\in V} d((v, w))$ for each edge $(v, t')$.</li> <li>$c'((u, v)) = c((u, v)) - d((u, v))$ for each edge $(u, v)$ in the old network.</li> <li>$c'((t, s)) = \\infty$</li> </ul> <p>If the new network has a saturating flow (a flow where each edge outgoing from $s'$ is completely filled, which is equivalent to every edge incoming to $t'$ is completely filled), then the network with demands has a valid flow, and the actual flow can be easily reconstructed from the new network. Otherwise there doesn't exist a flow that satisfies all conditions. Since a saturating flow has to be a maximum flow, it can be found by any maximum flow algorithm, like the Edmonds-Karp algorithm or the Push-relabel algorithm.</p> <p>The correctness of these transformations is more difficult to understand. We can think of it in the following way: Each edge $e = (u, v)$ with $d(e) &gt; 0$ is originally replaced by two edges: one with the capacity $d(i)$ , and the other with $c(i) - d(i)$. We want to find a flow that saturates the first edge (i.e. the flow along this edge must be equal to its capacity). The second edge is less important - the flow along it can be anything, assuming that it doesn't exceed its capacity. Consider each edge that has to be saturated, and we perform the following operation: we draw the edge from the new source $s'$ to its end $v$, draw the edge from its start $u$ to the new sink $t'$, remove the edge itself, and from the old sink $t$ to the old source $s$ we draw an edge of infinite capacity. By these actions we simulate the fact that this edge is saturated - from $v$ there will be an additionally $d(e)$ flow outgoing (we simulate it with a new source that feeds the right amount of flow to $v$), and $u$ will also push $d(e)$ additional flow (but instead along the old edge, this flow will go directly to the new sink $t'$). A flow with the value $d(e)$, that originally flowed along the path $s - \\dots - u - v - \\dots t$ can now take the new path $s' - v - \\dots - t - s - \\dots - u - t'$. The only thing that got simplified in the definition of the new network, is that if procedure created multiple edges between the same pair of vertices, then they are combined to one single edge with the summed capacity.</p>","tags":["Translated"]},{"location":"graph/flow_with_demands.html#minimal-flow","title":"Minimal flow","text":"<p>Note that along the edge $(t, s)$ (from the old sink to the old source) with the capacity $\\infty$ flows the entire flow of the corresponding old network. I.e. the capacity of this edge effects the flow value of the old network. By giving this edge a sufficient large capacity (i.e. $\\infty$), the flow of the old network is unlimited. By limiting this edge by smaller capacities, the flow value will decrease. However if we limit this edge by a too small value, than the network will not have a saturated solution, e.g. the corresponding solution for the original network will not satisfy the demand of the edges. Obviously here can use a binary search to find the lowest value with which all constraints are still satisfied. This gives the minimal flow of the original network.</p>","tags":["Translated"]},{"location":"graph/hld.html","title":"Heavy-light decomposition","text":"<p>Heavy-light decomposition is a fairly general technique that allows us to effectively solve many problems that come down to queries on a tree .</p>","tags":["Translated"]},{"location":"graph/hld.html#description","title":"Description","text":"<p>Let there be a tree $G$ of $n$ vertices, with an arbitrary root.</p> <p>The essence of this tree decomposition is to split the tree into several paths so that we can reach the root vertex from any $v$ by traversing at most $\\log n$ paths. In addition, none of these paths should intersect with another.</p> <p>It is clear that if we find such a decomposition for any tree, it will allow us to reduce certain single queries of the form \u201ccalculate something on the path from $a$ to $b$\u201d to several queries of the type \u201dcalculate something on the segment $[l, r]$ of the $k^{th}$ path\u201d.</p>","tags":["Translated"]},{"location":"graph/hld.html#construction-algorithm","title":"Construction algorithm","text":"<p>We calculate for each vertex $v$ the size of its subtree  $s(v)$, i.e. the number of vertices in the subtree of the vertex $v$ including itself.</p> <p>Next, consider all the edges leading to the children of a vertex $v$. We call an edge  heavy if it leads to a vertex $c$ such that:</p> $$ s(c) \\ge \\frac{s(v)}{2} \\iff \\text{edge }(v, c)\\text{ is heavy} $$ <p>All other edges are labeled light.</p> <p>It is obvious that at most one heavy edge can emanate from one vertex downward, because otherwise the vertex $v$ would have at least two children of size $\\ge \\frac{s(v)}{2}$, and therefore the size of subtree of $v$ would be too big, $s(v) \\ge 1 + 2 \\frac{s(v)}{2} &gt; s(v)$, which leads to a contradiction.</p> <p>Now we will decompose the tree into disjoint paths. Consider all the vertices from which no heavy edges come down. We will go up from each such vertex until we reach the root of the tree or go through a light edge. As a result, we will get several paths which are made up of zero or more heavy edges plus one light edge. The path which has an end at the root is an exception to this and will not have a light edge. Let these be called heavy paths - these are the desired paths of heavy-light decomposition.</p>","tags":["Translated"]},{"location":"graph/hld.html#proof-of-correctness","title":"Proof of correctness","text":"<p>First, we note that the heavy paths obtained by the algorithm will be disjoint . In fact, if two such paths have a common edge, it would imply that there are two heavy edges coming out of one vertex, which is impossible.</p> <p>Secondly, we will show that going down from the root of the tree to an arbitrary vertex, we will change no more than $\\log n$ heavy paths along the way . Moving down a light edge reduces the size of the current subtree to half or lower:</p> $$ s(c) &lt; \\frac{s(v)}{2} \\iff \\text{edge }(v, c)\\text{ is light} $$ <p>Thus, we can go through at most $\\log n$ light edges before subtree size reduces to one.</p> <p>Since we can move from one heavy path to another only through a light edge (each heavy path, except the one starting at the root, has one light edge), we cannot change heavy paths more than $\\log n$ times along the path from the root to any vertex, as required.</p> <p>The following image illustrates the decomposition of a sample tree. The heavy edges are thicker than the light edges. The heavy paths are marked by dotted boundaries.</p>","tags":["Translated"]},{"location":"graph/hld.html#sample-problems","title":"Sample problems","text":"<p>When solving problems, it is sometimes more convenient to consider the heavy-light decomposition as a set of vertex disjoint paths (rather than edge disjoint paths). To do this, it suffices to exclude the last edge from each heavy path if it is a light edge, then no properties are violated, but now each vertex belongs to exactly one heavy path.</p> <p>Below we will look at some typical tasks that can be solved with the help of heavy-light decomposition.</p> <p>Separately, it is worth paying attention to the problem of the sum of numbers on the path, since this is an example of a problem that can be solved by simpler techniques.</p>","tags":["Translated"]},{"location":"graph/hld.html#maximum-value-on-the-path-between-two-vertices","title":"Maximum value on the path between two vertices","text":"<p>Given a tree, each vertex is assigned a value. There are queries of the form $(a, b)$, where $a$ and $b$ are two vertices in the tree, and it is required to find the maximum value on the path between the vertices $a$ and $b$.</p> <p>We construct in advance a heavy-light decomposition of the tree. Over each heavy path we will construct a segment tree, which will allow us to search for a vertex with the maximum assigned value in the specified segment of the specified heavy path in $\\mathcal{O}(\\log n)$.  Although the number of heavy paths in heavy-light decomposition can reach $n - 1$, the total size of all paths is bounded by $\\mathcal{O}(n)$, therefore the total size of the segment trees will also be linear.</p> <p>In order to answer a query $(a, b)$, we find the lowest common ancestor of $a$ and $b$ as $l$, by any preferred method. Now the task has been reduced to two queries $(a, l)$ and $(b, l)$, for each of which we can do the following: find the heavy path that the lower vertex lies in, make a query on this path, move to the top of this path, again determine which heavy path we are on and make a query on it, and so on, until we get to the path containing $l$.</p> <p>One should be careful with the case when, for example, $a$ and $l$ are on the same heavy path - then the maximum query on this path should be done not on any prefix, but on the internal section between $a$ and $l$.</p> <p>Responding to the subqueries $(a, l)$ and $(b, l)$ each requires going through $\\mathcal{O}(\\log n)$ heavy paths and for each path a maximum query is made on some section of the path, which again requires $\\mathcal{O}(\\log n)$ operations in the segment tree. Hence, one query $(a, b)$ takes $\\mathcal{O}(\\log^2 n)$ time.</p> <p>If you additionally calculate and store maximums of all prefixes for each heavy path, then you get a $\\mathcal{O}(\\log n)$ solution because all maximum queries are on prefixes except at most once when we reach the ancestor $l$.</p>","tags":["Translated"]},{"location":"graph/hld.html#sum-of-the-numbers-on-the-path-between-two-vertices","title":"Sum of the numbers on the path between two vertices","text":"<p>Given a tree, each vertex is assigned a value. There are queries of the form $(a, b)$, where $a$ and $b$ are two vertices in the tree, and it is required to find the sum of the values on the path between the vertices $a$ and $b$. A variant of this task is possible where additionally there are update operations that change the number assigned to one or more vertices.</p> <p>This task can be solved similar to the previous problem of maximums with the help of heavy-light decomposition by building segment trees on heavy paths. Prefix sums can be used instead if there are no updates. However, this problem can be solved by simpler techniques too.</p> <p>If there are no updates, then it is possible to find out the sum on the path between two vertices in parallel with the LCA search of two vertices by binary lifting \u2014 for this, along with the $2^k$-th ancestors of each vertex it is also necessary to store the sum on the paths up to those ancestors during the preprocessing.</p> <p>There is a fundamentally different approach to this problem - to consider the Euler tour of the tree, and build a segment tree on it. This algorithm is considered in an article about a similar problem. Again, if there are no updates, storing prefix sums is enough and a segment tree is not required.</p> <p>Both of these methods provide relatively simple solutions taking $\\mathcal{O}(\\log n)$ for one query.</p>","tags":["Translated"]},{"location":"graph/hld.html#repainting-the-edges-of-the-path-between-two-vertices","title":"Repainting the edges of the path between two vertices","text":"<p>Given a tree, each edge is initially painted white. There are updates of the form $(a, b, c)$, where $a$ and $b$ are two vertices and $c$ is a color, which instructs that all the edges on the path from $a$ to $b$ must be repainted with color $c$. After all repaintings, it is required to report how many edges of each color were obtained.</p> <p>Similar to the above problems, the solution is to simply apply heavy-light decomposition and make a segment tree over each heavy path.</p> <p>Each repainting on the path $(a, b)$ will turn into two updates $(a, l)$ and $(b, l)$, where $l$ is the lowest common ancestor of the vertices $a$ and $b$.  $\\mathcal{O}(\\log n)$ per path for $\\mathcal{O}(\\log n)$ paths leads to a complexity of $\\mathcal{O}(\\log^2 n)$ per update.</p>","tags":["Translated"]},{"location":"graph/hld.html#implementation","title":"Implementation","text":"<p>Certain parts of the above discussed approach can be modified to make implementation easier without losing efficiency.</p> <ul> <li>The definition of heavy edge can be changed to the edge leading to the child with largest subtree, with ties broken arbitrarily. This may result is some light edges being converted to heavy, which means some heavy paths will combine to form a single path, but all heavy paths will remain disjoint. It is also still guaranteed that going down a light edge reduces subtree size to half or less.</li> <li>Instead of a building segment tree over every heavy path, a single segment tree can be used with disjoint segments allocated to each heavy path.</li> <li>It has been mentioned that answering queries requires calculation of the LCA. While LCA can be calculated separately, it is also possible to integrate LCA calculation in the process of answering queries.</li> </ul> <p>To perform heavy-light decomposition:</p> <pre><code>vector&lt;int&gt; parent, depth, heavy, head, pos;\nint cur_pos;\n\nint dfs(int v, vector&lt;vector&lt;int&gt;&gt; const&amp; adj) {\n    int size = 1;\n    int max_c_size = 0;\n    for (int c : adj[v]) {\n        if (c != parent[v]) {\n            parent[c] = v, depth[c] = depth[v] + 1;\n            int c_size = dfs(c, adj);\n            size += c_size;\n            if (c_size &gt; max_c_size)\n                max_c_size = c_size, heavy[v] = c;\n        }\n    }\n    return size;\n}\n\nvoid decompose(int v, int h, vector&lt;vector&lt;int&gt;&gt; const&amp; adj) {\n    head[v] = h, pos[v] = cur_pos++;\n    if (heavy[v] != -1)\n        decompose(heavy[v], h, adj);\n    for (int c : adj[v]) {\n        if (c != parent[v] &amp;&amp; c != heavy[v])\n            decompose(c, c, adj);\n    }\n}\n\nvoid init(vector&lt;vector&lt;int&gt;&gt; const&amp; adj) {\n    int n = adj.size();\n    parent = vector&lt;int&gt;(n);\n    depth = vector&lt;int&gt;(n);\n    heavy = vector&lt;int&gt;(n, -1);\n    head = vector&lt;int&gt;(n);\n    pos = vector&lt;int&gt;(n);\n    cur_pos = 0;\n\n    dfs(0, adj);\n    decompose(0, 0, adj);\n}\n</code></pre> <p>The adjacency list of the tree must be passed to the <code>init</code> function, and decomposition is performed assuming vertex <code>0</code> as root.</p> <p>The <code>dfs</code> function is used to calculate <code>heavy[v]</code>, the child at the other end of the heavy edge from <code>v</code>, for every vertex <code>v</code>. Additionally <code>dfs</code> also stores the parent and depth of each vertex, which will be useful later during queries.</p> <p>The <code>decompose</code> function assigns for each vertex <code>v</code> the values <code>head[v]</code> and <code>pos[v]</code>, which are respectively the head of the heavy path <code>v</code> belongs to and the position of <code>v</code> on the single segment tree that covers all vertices.</p> <p>To answer queries on paths, for example the maximum query discussed, we can do something like this:</p> <pre><code>int query(int a, int b) {\n    int res = 0;\n    for (; head[a] != head[b]; b = parent[head[b]]) {\n        if (depth[head[a]] &gt; depth[head[b]])\n            swap(a, b);\n        int cur_heavy_path_max = segment_tree_query(pos[head[b]], pos[b]);\n        res = max(res, cur_heavy_path_max);\n    }\n    if (depth[a] &gt; depth[b])\n        swap(a, b);\n    int last_heavy_path_max = segment_tree_query(pos[a], pos[b]);\n    res = max(res, last_heavy_path_max);\n    return res;\n}\n</code></pre>","tags":["Translated"]},{"location":"graph/hld.html#practice-problems","title":"Practice problems","text":"<ul> <li>SPOJ - QTREE - Query on a tree</li> <li>CSES - Path Queries II</li> <li>Codeforces - Subway Lines</li> <li>Codeforces - Tree Queries</li> <li>Codeforces - Tree or not Tree</li> <li>Codeforces - The Tree</li> </ul>","tags":["Translated"]},{"location":"graph/hungarian-algorithm.html","title":"Hungarian algorithm for solving the assignment problem","text":"","tags":["Translated"]},{"location":"graph/hungarian-algorithm.html#statement-of-the-assignment-problem","title":"Statement of the assignment problem","text":"<p>There are several standard formulations of the assignment problem (all of which are essentially equivalent). Here are some of them:</p> <ul> <li> <p>There are $n$ jobs and $n$ workers. Each worker specifies the amount of money they expect for a particular job. Each worker can be assigned to only one job. The objective is to assign jobs to workers in a way that minimizes the total cost.</p> </li> <li> <p>Given an $n \\times n$ matrix $A$, the task is to select one number from each row such that exactly one number is chosen from each column, and the sum of the selected numbers is minimized.</p> </li> <li> <p>Given an $n \\times n$ matrix $A$, the task is to find a permutation $p$ of length $n$ such that the value $\\sum A[i]\\left[p[i]\\right]$ is minimized.</p> </li> <li> <p>Consider a complete bipartite graph with $n$ vertices per part, where each edge is assigned a weight. The objective is to find a perfect matching with the minimum total weight.</p> </li> </ul> <p>It is important to note that all the above scenarios are \"square\" problems, meaning both dimensions are always equal to $n$. In practice, similar \"rectangular\" formulations are often encountered, where $n$ is not equal to $m$, and the task is to select $\\min(n,m)$ elements. However, it can be observed that a \"rectangular\" problem can always be transformed into a \"square\" problem by adding rows or columns with zero or infinite values, respectively.</p> <p>We also note that by analogy with the search for a minimum solution, one can also pose the problem of finding a maximum solution. However, these two problems are equivalent to each other: it is enough to multiply all the weights by $-1$.</p>","tags":["Translated"]},{"location":"graph/hungarian-algorithm.html#hungarian-algorithm","title":"Hungarian algorithm","text":"","tags":["Translated"]},{"location":"graph/hungarian-algorithm.html#historical-reference","title":"Historical reference","text":"<p>The algorithm was developed and published by Harold Kuhn in 1955. Kuhn himself gave it the name \"Hungarian\" because it was based on the earlier work by Hungarian mathematicians D\u00e9nes K\u0151nig and Jen\u0151 Egerv\u00e1ry. In 1957, James Munkres showed that this algorithm runs in (strictly) polynomial time, independently from the cost. Therefore, in literature, this algorithm is known not only as the \"Hungarian\", but also as the \"Kuhn-Mankres algorithm\" or \"Mankres algorithm\". However, it was recently discovered in 2006 that the same algorithm was invented a century before Kuhn by the German mathematician Carl Gustav Jacobi. His work, About the research of the order of a system of arbitrary ordinary differential equations, which was published posthumously in 1890, contained, among other findings, a polynomial algorithm for solving the assignment problem. Unfortunately, since the publication was in Latin, it went unnoticed among mathematicians.</p> <p>It is also worth noting that Kuhn's original algorithm had an asymptotic complexity of $\\mathcal{O}(n^4)$, and only later Jack Edmonds and Richard Karp (and independently Tomizawa) showed how to improve it to an asymptotic complexity of $\\mathcal{O}(n^3)$.</p>","tags":["Translated"]},{"location":"graph/hungarian-algorithm.html#the-mathcalon4-algorithm","title":"The $\\mathcal{O}(n^4)$ algorithm","text":"<p>To avoid ambiguity, we note right away that we are mainly concerned with the assignment problem in a matrix formulation (i.e., given a matrix $A$, you need to select $n$ cells from it that are in different rows and columns). We index arrays starting with $1$, i.e., for example, a matrix $A$ has indices $A[1 \\dots n][1 \\dots n]$.</p> <p>We will also assume that all numbers in matrix A are non-negative (if this is not the case, you can always make the matrix non-negative by adding some constant to all numbers).</p> <p>Let's call a potential two arbitrary arrays of numbers $u[1 \\ldots n]$ and $v[1 \\ldots n]$, such that the following condition is satisfied:</p> $$u[i]+v[j]\\leq A[i][j],\\quad i=1\\dots n,\\ j=1\\dots n$$ <p>(As you can see, $u[i]$ corresponds to the $i$-th row, and $v[j]$ corresponds to the $j$-th column of the matrix).</p> <p>Let's call the value $f$ of the potential the sum of its elements:</p> $$f=\\sum_{i=1}^{n} u[i] + \\sum_{j=1}^{n} v[j].$$ <p>On one hand, it is easy to see that the cost of the desired solution $sol$ is not less than the value of any potential.</p> <p>Lemma. $sol\\geq f.$</p> Proof <p>The desired solution of the problem consists of $n$ cells of the matrix $A$, so $u[i]+v[j]\\leq A[i][j]$ for each of them. Since all the elements in $sol$ are in different rows and columns, summing these inequalities over all the selected $A[i][j]$, you get $f$ on the left side of the inequality, and $sol$ on the right side.</p> <p>On the other hand, it turns out that there is always a solution and a potential that turns this inequality into equality. The Hungarian algorithm described below will be a constructive proof of this fact. For now, let's just pay attention to the fact that if any solution has a cost equal to any potential, then this solution is optimal.</p> <p>Let's fix some potential. Let's call an edge $(i,j)$ rigid if $u[i]+v[j]=A[i][j].$</p> <p>Recall an alternative formulation of the assignment problem, using a bipartite graph. Denote with $H$ a bipartite graph composed only of rigid edges. The Hungarian algorithm will maintain, for the current potential, the maximum-number-of-edges matching $M$ of the graph $H$. As soon as $M$ contains $n$ edges, then the solution to the problem will be just $M$ (after all, it will be a solution whose cost coincides with the value of a potential).</p> <p>Let's proceed directly to the description of the algorithm.</p> <p>Step 1. At the beginning, the potential is assumed to be zero ($u[i]=v[i]=0$ for all $i$), and the matching $M$ is assumed to be empty.</p> <p>Step 2. Further, at each step of the algorithm, we try, without changing the potential, to increase the cardinality of the current matching $M$ by one (recall that the matching is searched in the graph of rigid edges $H$). To do this, the usual Kuhn Algorithm for finding the maximum matching in bipartite graphs is used. Let us recall the algorithm here. All edges of the matching $M$ are oriented in the direction from the right part to the left one, and all other edges of the graph $H$ are oriented in the opposite direction.</p> <p>Recall (from the terminology of searching for matchings) that a vertex is called saturated if an edge of the current matching is adjacent to it. A vertex that is not adjacent to any edge of the current matching is called unsaturated. A path of odd length, in which the first edge does not belong to the matching, and for all subsequent edges there is an alternating belonging to the matching (belongs/does not belong) - is called an augmenting path. From all unsaturated vertices in the left part, a depth-first or breadth-first traversal is started. If, as a result of the search, it was possible to reach an unsaturated vertex of the right part, we have found an augmenting path from the left part to the right one. If we include odd edges of the path and remove the even ones in the matching (i.e. include the first edge in the matching, exclude the second, include the third, etc.), then we will increase the matching cardinality by one.</p> <p>If there was no augmenting path, then the current matching $M$ is maximal in the graph $H$.</p> <p>Step 3. If at the current step, it is not possible to increase the cardinality of the current matching, then a recalculation of the potential is performed in such a way that, at the next steps, there will be more opportunities to increase the matching.</p> <p>Denote by $Z_1$ the set of vertices of the left part that were visited during the last traversal of Kuhn's algorithm, and through $Z_2$ the set of visited vertices of the right part.</p> <p>Let's calculate the value $\\Delta$:</p> $$\\Delta = \\min_{i\\in Z_1,\\ j\\notin Z_2} A[i][j]-u[i]-v[j].$$ <p>Lemma. $\\Delta &gt; 0.$</p> Proof <p>Suppose $\\Delta=0$. Then there exists a rigid edge $(i,j)$ with $i\\in Z_1$ and $j\\notin Z_2$. It follows that the edge $(i,j)$ must be oriented from the right part to the left one, i.e. $(i,j)$ must be included in the matching $M$. However, this is impossible, because we could not get to the saturated vertex $i$ except by going along the edge from j to i. So $\\Delta &gt; 0$.</p> <p>Now let's recalculate the potential in this way:</p> <ul> <li> <p>for all vertices $i\\in Z_1$, do $u[i] \\gets u[i]+\\Delta$,</p> </li> <li> <p>for all vertices $j\\in Z_2$, do $v[j] \\gets v[j]-\\Delta$.</p> </li> </ul> <p>Lemma. The resulting potential is still a correct potential.</p> Proof <p>We will show that, after recalculation, $u[i]+v[j]\\leq A[i][j]$ for all $i,j$. For all the elements of $A$ with $i\\in Z_1$ and $j\\in Z_2$, the sum $u[i]+v[j]$ does not change, so the inequality remains true. For all the elements with $i\\notin Z_1$ and $j\\in Z_2$, the sum $u[i]+v[j]$ decreases by $\\Delta$, so the inequality is still true. For the other elements whose $i\\in Z_1$ and $j\\notin Z_2$, the sum increases, but the inequality is still preserved, since the value $\\Delta$ is, by definition, the maximum increase that does not change the inequality.</p> <p>Lemma. The old matching $M$ of rigid edges is valid, i.e. all edges of the matching will remain rigid.</p> Proof <p>For some rigid edge $(i,j)$ to stop being rigid as a result of a change in potential, it is necessary that equality $u[i] + v[j] = A[i][j]$ turns into inequality $u[i] + v[j] &lt; A[i][j]$. However, this can happen only when $i \\notin Z_1$ and $j \\in Z_2$. But $i \\notin Z_1$ implies that the edge $(i,j)$ could not be a matching edge.</p> <p>Lemma. After each recalculation of the potential, the number of vertices reachable by the traversal, i.e. $|Z_1|+|Z_2|$, strictly increases.</p> Proof <p>First, note that any vertex that was reachable before recalculation, is still reachable. Indeed, if some vertex is reachable, then there is some path from reachable vertices to it, starting from the unsaturated vertex of the left part; since for edges of the form $(i,j),\\ i\\in Z_1,\\ j\\in Z_2$ the sum $u[i]+v[j]$ does not change, this entire path will be preserved after changing the potential. Secondly, we show that after a recalculation, at least one new vertex will be reachable. This follows from the definition of $\\Delta$: the edge $(i,j)$ which $\\Delta$ refers to will become rigid, so vertex $j$ will be reachable from vertex $i$.</p> <p>Due to the last lemma, no more than $n$ potential recalculations can occur before an augmenting path is found and the matching cardinality of $M$ is increased. Thus, sooner or later, a potential that corresponds to a perfect matching $M^*$ will be found, and $M^*$ will be the answer to the problem. If we talk about the complexity of the algorithm, then it is $\\mathcal{O}(n^4)$: in total there should be at most $n$ increases in matching, before each of which there are no more than $n$ potential recalculations, each of which is performed in time $\\mathcal{O}(n^2)$.</p> <p>We will not give the implementation for the $\\mathcal{O}(n^4)$ algorithm here, since it will turn out to be no shorter than the implementation for the $\\mathcal{O}(n^3)$ one, described below.</p>","tags":["Translated"]},{"location":"graph/hungarian-algorithm.html#the-mathcalon3-algorithm","title":"The $\\mathcal{O}(n^3)$ algorithm","text":"<p>Now let's learn how to implement the same algorithm in $\\mathcal{O}(n^3)$ (for rectangular problems $n \\times m$, $\\mathcal{O}(n^2m)$).</p> <p>The key idea is to consider matrix rows one by one, and not all at once. Thus, the algorithm described above will take the following form:</p> <ol> <li> <p>Consider the next row of the matrix $A$.</p> </li> <li> <p>While there is no increasing path starting in this row, recalculate the potential.</p> </li> <li> <p>As soon as an augmenting path is found, propagate the matching along it (thus including the last edge in the matching), and restart from step 1 (to consider the next line).</p> </li> </ol> <p>To achieve the required complexity, it is necessary to implement steps 2-3, which are performed for each row of the matrix, in time $\\mathcal{O}(n^2)$ (for rectangular problems in $\\mathcal{O}(nm)$).</p> <p>To do this, recall two facts proved above:</p> <ul> <li> <p>With a change in the potential, the vertices that were reachable by Kuhn's traversal will remain reachable.</p> </li> <li> <p>In total, only $\\mathcal{O}(n)$ recalculations of the potential could occur before an augmenting path was found.</p> </li> </ul> <p>From this follow these key ideas that allow us to achieve the required complexity:</p> <ul> <li> <p>To check for the presence of an augmenting path, there is no need to start the Kuhn traversal again after each potential recalculation. Instead, you can make the Kuhn traversal in an iterative form: after each recalculation of the potential, look at the added rigid edges and, if their left ends were reachable, mark their right ends reachable as well and continue the traversal from them.</p> </li> <li> <p>Developing this idea further, we can present the algorithm as follows: at each step of the loop, the potential is recalculated. Subsequently, a column that has become reachable is identified (which will always exist as new reachable vertices emerge after every potential recalculation). If the column is unsaturated, an augmenting chain is discovered. Conversely, if the column is saturated, the matching row also becomes reachable.</p> </li> <li> <p>To quickly recalculate the potential (faster than the $\\mathcal{O}(n^2)$ naive version), you need to maintain auxiliary minima for each of the columns:</p> <p>$minv[j]=\\min_{i\\in Z_1} A[i][j]-u[i]-v[j].$</p> <p>It's easy to see that the desired value $\\Delta$ is expressed in terms of them as follows:</p> <p>$\\Delta=\\min_{j\\notin Z_2} minv[j].$</p> <p>Thus, finding $\\Delta$ can now be done in $\\mathcal{O}(n)$.</p> <p>It is necessary to update the array $minv$ when new visited rows appear. This can be done in $\\mathcal{O}(n)$ for the added row (which adds up over all rows to $\\mathcal{O}(n^2)$). It is also necessary to update the array $minv$ when recalculating the potential, which is also done in time $\\mathcal{O}(n)$ ($minv$ changes only for columns that have not yet been reached: namely, it decreases by $\\Delta$).</p> </li> </ul> <p>Thus, the algorithm takes the following form: in the outer loop, we consider matrix rows one by one. Each row is processed in time $\\mathcal{O}(n^2)$, since only $\\mathcal{O}(n)$ potential recalculations could occur (each in time $\\mathcal{O}(n)$), and the array $minv$ is maintained in time $\\mathcal{O}(n^2)$; Kuhn's algorithm will work in time $\\mathcal{O}(n^2)$ (since it is presented in the form of $\\mathcal{O}(n)$ iterations, each of which visits a new column).</p> <p>The resulting complexity is $\\mathcal{O}(n^3)$ or, if the problem is rectangular, $\\mathcal{O}(n^2m)$.</p>","tags":["Translated"]},{"location":"graph/hungarian-algorithm.html#implementation-of-the-hungarian-algorithm","title":"Implementation of the Hungarian algorithm","text":"<p>The implementation below was developed by Andrey Lopatin several years ago. It is distinguished by amazing conciseness: the entire algorithm consists of 30 lines of code.</p> <p>The implementation finds a solution for the rectangular matrix $A[1\\dots n][1\\dots m]$, where $n\\leq m$. The matrix is \u200b1-based for convenience and code brevity: this implementation introduces a dummy zero row and zero column, which allows us to write many cycles in a general form, without additional checks.</p> <p>Arrays $u[0 \\ldots n]$ and $v[0 \\ldots m]$ store potential. Initially, they are set to zero, which is consistent with a matrix of zero rows (Note that it is unimportant for this implementation whether or not the matrix $A$ contains negative numbers).</p> <p>The array $p[0 \\ldots m]$ contains a matching: for each column $j = 1 \\ldots m$, it stores the number $p[j]$ of the selected row (or $0$ if nothing has been selected yet). For the convenience of implementation, $p[0]$ is assumed to be equal to the number of the current row.</p> <p>The array $minv[1 \\ldots m]$ contains, for each column $j$, the auxiliary minima necessary for a quick recalculation of the potential, as described above.</p> <p>The array $way[1 \\ldots m]$ contains information about where these minimums are reached so that we can later reconstruct the augmenting path. Note that, to reconstruct the path, it is sufficient to store only column values, since the row numbers can be taken from the matching (i.e., from the array $p$). Thus, $way[j]$, for each column $j$, contains the number of the previous column in the path (or $0$ if there is none).</p> <p>The algorithm itself is an outer loop through the rows of the matrix, inside which the $i$-th row of the matrix is \u200b\u200bconsidered. The first do-while loop runs until a free column $j0$ is found. Each iteration of the loop marks visited a new column with the number $j0$ (calculated at the last iteration; and initially equal to zero - i.e. we start from a dummy column), as well as a new row $i0$ - adjacent to it in the matching (i.e. $p[j0]$; and initially when $j0=0$ the $i$-th row is taken). Due to the appearance of a new visited row $i0$, you need to recalculate the array $minv$ and $\\Delta$ accordingly. If $\\Delta$ is updated, then the column $j1$ becomes the minimum that has been reached (note that with such an implementation $\\Delta$ could turn out to be equal to zero, which means that the potential cannot be changed at the current step: there is already a new reachable column). After that, the potential and the $minv$ array are recalculated. At the end of the \"do-while\" loop, we found an augmenting path ending in a column $j0$ that can be \"unrolled\" using the ancestor array $way$.</p> <p>The constant INF is \"infinity\", i.e. some number, obviously greater than all possible numbers in the input matrix $A$.</p> <pre><code>vector&lt;int&gt; u (n+1), v (m+1), p (m+1), way (m+1);\nfor (int i=1; i&lt;=n; ++i) {\n    p[0] = i;\n    int j0 = 0;\n    vector&lt;int&gt; minv (m+1, INF);\n    vector&lt;bool&gt; used (m+1, false);\n    do {\n        used[j0] = true;\n        int i0 = p[j0],  delta = INF,  j1;\n        for (int j=1; j&lt;=m; ++j)\n            if (!used[j]) {\n                int cur = A[i0][j]-u[i0]-v[j];\n                if (cur &lt; minv[j])\n                    minv[j] = cur,  way[j] = j0;\n                if (minv[j] &lt; delta)\n                    delta = minv[j],  j1 = j;\n            }\n        for (int j=0; j&lt;=m; ++j)\n            if (used[j])\n                u[p[j]] += delta,  v[j] -= delta;\n            else\n                minv[j] -= delta;\n        j0 = j1;\n    } while (p[j0] != 0);\n    do {\n        int j1 = way[j0];\n        p[j0] = p[j1];\n        j0 = j1;\n    } while (j0);\n}\n</code></pre> <p>To restore the answer in a more familiar form, i.e. finding for each row $i = 1 \\ldots n$ the number $ans[i]$ of the column selected in it, can be done as follows:</p> <pre><code>vector&lt;int&gt; ans (n+1);\nfor (int j=1; j&lt;=m; ++j)\n    ans[p[j]] = j;\n</code></pre> <p>The cost of the matching can simply be taken as the potential of the zero column (taken with the opposite sign). Indeed, as you can see from the code, $-v[0]$ contains the sum of all the values of $\\Delta$\u200b\u200b, i.e. total change in potential. Although several values \u200b\u200b\u200b\u200bof $u[i]$ and $v[j]$ could change at once, the total change in the potential is exactly equal to $\\Delta$, since until there is an augmenting path, the number of reachable rows is exactly one more than the number of the reachable columns (only the current row $i$ does not have a \"pair\" in the form of a visited column):</p> <pre><code>int cost = -v[0];\n</code></pre>","tags":["Translated"]},{"location":"graph/hungarian-algorithm.html#connection-to-the-successive-shortest-path-algorithm","title":"Connection to the Successive Shortest Path Algorithm","text":"<p>The Hungarian algorithm can be seen as the Successive Shortest Path Algorithm, adapted for the assignment problem. Without going into the details, let's provide an intuition regarding the connection between them.</p> <p>The Successive Path algorithm uses a modified version of Johnson's algorithm as reweighting technique. This one is divided into four steps:</p> <ul> <li>Use the Bellman-Ford algorithm, starting from the sink $s$ and, for each node, find the minimum weight $h(v)$ of a path from $s$ to $v$.</li> </ul> <p>For every step of the main algorithm:</p> <ul> <li>Reweight the edges of the original graph in this way: $w(u,v) \\gets w(u,v)+h(u)-h(v)$.</li> <li>Use Dijkstra's algorithm to find the shortest-paths subgraph of the original network.</li> <li>Update potentials for the next iteration.</li> </ul> <p>Given this description, we can observe that there is a strong analogy between $h(v)$ and potentials: it can be checked that they are equal up to a constant offset. In addition, it can be shown that, after reweighting, the set of all zero-weight edges represents the shortest-path subgraph where the main algorithm tries to increase the flow. This also happens in the Hungarian algorithm: we create a subgraph made of rigid edges (the ones for which the quantity $A[i][j]-u[i]-v[j]$ is zero), and we try to increase the size of the matching.</p> <p>In step 4, all the $h(v)$ are updated: every time we modify the flow network, we should guarantee that the distances from the source are correct (otherwise, in the next iteration, Dijkstra's algorithm might fail). This sounds like the update performed on the potentials, but in this case, they are not equally incremented.</p> <p>To deepen the understanding of potentials, refer to this article.</p>","tags":["Translated"]},{"location":"graph/hungarian-algorithm.html#task-examples","title":"Task examples","text":"<p>Here are a few examples related to the assignment problem, from very trivial to less obvious tasks:</p> <ul> <li> <p>Given a bipartite graph, it is required to find in it the maximum matching with the minimum weight (i.e., first of all, the size of the matching is maximized, and secondly, its cost is minimized).   To solve it, we simply build an assignment problem, putting the number \"infinity\" in place of the missing edges. After that, we solve the problem with the Hungarian algorithm, and remove edges of infinite weight from the answer (they could enter the answer if the problem does not have a solution in the form of a perfect matching).</p> </li> <li> <p>Given a bipartite graph, it is required to find in it the maximum matching with the maximum weight.   The solution is again obvious, all weights must be multiplied by minus one.</p> </li> <li> <p>The task of detecting moving objects in images: two images were taken, as a result of which two sets of coordinates were obtained. It is required to correlate the objects in the first and second images, i.e. determine for each point of the second image, which point of the first image it corresponded to. In this case, it is required to minimize the sum of distances between the compared points (i.e., we are looking for a solution in which the objects have taken the shortest path in total).   To solve, we simply build and solve an assignment problem, where the weights of the edges are the Euclidean distances between points.</p> </li> <li> <p>The task of detecting moving objects by locators: there are two locators that can't determine the position of an object in space, but only its direction. Both locators (located at different points) received information in the form of $n$ such directions. It is required to determine the position of objects, i.e. determine the expected positions of objects and their corresponding pairs of directions in such a way that the sum of distances from objects to direction rays is minimized.   Solution: again, we simply build and solve the assignment problem, where the vertices of the left part are the $n$ directions from the first locator, the vertices of the right part are the $n$ directions from the second locator, and the weights of the edges are the distances between the corresponding rays.</p> </li> <li> <p>Covering a directed acyclic graph with paths: given a directed acyclic graph, it is required to find the smallest number of paths (if equal, with the smallest total weight) so that each vertex of the graph lies in exactly one path.   The solution is to build the corresponding bipartite graph from the given graph and find the maximum matching of the minimum weight in it. See separate article for more details.</p> </li> <li> <p>Tree coloring book. Given a tree in which each vertex, except for leaves, has exactly $k-1$ children. It is required to choose for each vertex one of the $k$ colors available so that no two adjacent vertices have the same color. In addition, for each vertex and each color, the cost of painting this vertex with this color is known, and it is required to minimize the total cost.   To solve this problem, we use dynamic programming. Namely, let's learn how to calculate the value $d[v][c]$, where $v$ is the vertex number, $c$ is the color number, and the value $d[v][c]$ itself is the minimum cost needed to color all the vertices in the subtree rooted at $v$, and the vertex $v$ itself with color $c$. To calculate such a value $d[v][c]$, it is necessary to distribute the remaining $k-1$ colors among the children of the vertex $v$, and for this, it is necessary to build and solve the assignment problem (in which the vertices of the left part are colors, the vertices of the right part are children, and the weights of the edges are the corresponding values of $d$).   Thus, each value $d[v][c]$ is calculated using the solution of the assignment problem, which ultimately gives the asymptotic $\\mathcal{O}(nk^4)$.</p> </li> <li> <p>If, in the assignment problem, the weights are not on the edges, but on the vertices, and only on the vertices of the same part, then it's not necessary to use the Hungarian algorithm: just sort the vertices by weight and run the usual Kuhn algorithm (for more details, see a separate article).</p> </li> <li> <p>Consider the following special case. Let each vertex of the left part be assigned some number $\\alpha[i]$, and each vertex of the right part $\\beta[j]$. Let the weight of any edge $(i,j)$ be equal to $\\alpha[i]\\cdot \\beta[j]$ (the numbers $\\alpha[i]$ and $\\beta[j]$ are known). Solve the assignment problem.   To solve it without the Hungarian algorithm, we first consider the case when both parts have two vertices. In this case, as you can easily see, it is better to connect the vertices in the reverse order: connect the vertex with the smaller $\\alpha[i]$ to the vertex with the larger $\\beta[j]$. This rule can be easily generalized to an arbitrary number of vertices: you need to sort the vertices of the first part in increasing order of $\\alpha[i]$ values, the second part in decreasing order of $\\beta[j]$ values, and connect the vertices in pairs in that order. Thus, we obtain a solution with complexity of $\\mathcal{O}(n\\log n)$.</p> </li> <li> <p>The Problem of Potentials. Given a matrix $A[1 \\ldots n][1 \\ldots m]$, it is required to find two arrays $u[1 \\ldots n]$ and $v[1 \\ldots m]$ such that, for any $i$ and $j$, $u[i] + v[j] \\leq a[i][j]$ and the sum of elements of arrays $u$ and $v$ is maximum.   Knowing the Hungarian algorithm, the solution to this problem will not be difficult: the Hungarian algorithm just finds such a potential $u, v$ that satisfies the condition of the problem. On the other hand, without knowledge of the Hungarian algorithm, it seems almost impossible to solve such a problem.</p> <p>Remark</p> <p>This task is also called the dual problem of the assignment problem: minimizing the total cost of the assignment is equivalent to maximizing the sum of the potentials.</p> </li> </ul>","tags":["Translated"]},{"location":"graph/hungarian-algorithm.html#literature","title":"Literature","text":"<ul> <li> <p>Ravindra Ahuja, Thomas Magnanti, James Orlin. Network Flows [1993]</p> </li> <li> <p>Harold Kuhn. The Hungarian Method for the Assignment Problem [1955]</p> </li> <li> <p>James Munkres. Algorithms for Assignment and Transportation Problems [1957]</p> </li> </ul>","tags":["Translated"]},{"location":"graph/hungarian-algorithm.html#practice-problems","title":"Practice Problems","text":"<ul> <li> <p>UVA - Crime Wave - The Sequel</p> </li> <li> <p>UVA - Warehouse</p> </li> <li> <p>SGU - Beloved Sons</p> </li> <li> <p>UVA - The Great Wall Game</p> </li> <li> <p>UVA - Jogging Trails</p> </li> </ul>","tags":["Translated"]},{"location":"graph/kirchhoff-theorem.html","title":"Kirchhoff's theorem. Finding the number of spanning trees","text":"<p>Problem: You are given a connected undirected graph (with possible multiple edges) represented using an adjacency matrix. Find the number of different spanning trees of this graph.</p> <p>The following formula was proven by Kirchhoff in 1847.</p>","tags":["Translated"]},{"location":"graph/kirchhoff-theorem.html#kirchhoffs-matrix-tree-theorem","title":"Kirchhoff's matrix tree theorem","text":"<p>Let $A$ be the adjacency matrix of the graph: $A_{u,v}$ is the number of edges between $u$ and $v$. Let $D$ be the degree matrix of the graph: a diagonal matrix with $D_{u,u}$ being the degree of vertex $u$ (including multiple edges and loops - edges which connect vertex $u$ with itself).</p> <p>The Laplacian matrix of the graph is defined as $L = D - A$. According to Kirchhoff's theorem, all cofactors of this matrix are equal to each other, and they are equal to the number of spanning trees of the graph. The $(i,j)$ cofactor of a matrix is the product of $(-1)^{i + j}$ with the determinant of the matrix that you get after removing the $i$-th row and $j$-th column. So you can, for example, delete the last row and last column of the matrix $L$, and the absolute value of the determinant of the resulting matrix will give you the number of spanning trees.</p> <p>The determinant of the matrix can be found in $O(N^3)$ by using the Gaussian method.</p> <p>The proof of this theorem is quite difficult and is not presented here; for an outline of the proof and variations of the theorem for graphs without multiple edges and for directed graphs refer to Wikipedia.</p>","tags":["Translated"]},{"location":"graph/kirchhoff-theorem.html#relation-to-kirchhoffs-circuit-laws","title":"Relation to Kirchhoff's circuit laws","text":"<p>Kirchhoff's matrix tree theorem and Kirchhoff's laws for electrical circuit are related in a beautiful way. It is possible to show (using Ohm's law and Kirchhoff's first law) that resistance $R_{ij}$ between two points of the circuit $i$ and $j$ is</p> $$R_{ij} = \\frac{ \\left| L^{(i,j)} \\right| }{ | L^j | }.$$ <p>Here the matrix $L$ is obtained from the matrix of inverse resistances $A$ ($A_{i,j}$ is inverse of the resistance of the conductor between points $i$ and $j$) using the procedure described in Kirchhoff's matrix tree theorem. $T^j$ is the matrix with row and column $j$ removed, $T^{(i,j)}$ is the matrix with two rows and two columns $i$ and $j$ removed.</p> <p>Kirchhoff's theorem gives this formula geometric meaning.</p>","tags":["Translated"]},{"location":"graph/kirchhoff-theorem.html#practice-problems","title":"Practice Problems","text":"<ul> <li>CODECHEF: Roads in Stars</li> <li>SPOJ: Maze</li> <li>CODECHEF: Complement Spanning Trees</li> </ul>","tags":["Translated"]},{"location":"graph/kuhn_maximum_bipartite_matching.html","title":"Kuhn's Algorithm for Maximum Bipartite Matching","text":"","tags":["Translated"]},{"location":"graph/kuhn_maximum_bipartite_matching.html#problem","title":"Problem","text":"<p>You are given a bipartite graph $G$ containing $n$ vertices and $m$ edges. Find the maximum matching, i.e., select as many edges as possible so  that no selected edge shares a vertex with any other selected edge.</p>","tags":["Translated"]},{"location":"graph/kuhn_maximum_bipartite_matching.html#algorithm-description","title":"Algorithm Description","text":"","tags":["Translated"]},{"location":"graph/kuhn_maximum_bipartite_matching.html#required-definitions","title":"Required Definitions","text":"<ul> <li> <p>A matching $M$ is a set of pairwise non-adjacent edges of a graph (in other words, no more than one edge from the set should be incident to any vertex of the graph $M$).  The cardinality of a matching is the number of edges in it. All those vertices that have an adjacent edge from the matching (i.e., which have degree exactly one in the subgraph formed by $M$) are called saturated  by this matching.</p> </li> <li> <p>A maximal matching is a matching $M$ of a graph $G$ that is not a subset of any other matching.</p> </li> <li> <p>A maximum matching (also known as maximum-cardinality matching) is a matching that contains the largest possible number of edges. Every maximum matching is a maximal matching.</p> </li> <li> <p>A path of length $k$ here means a simple path (i.e. not containing repeated vertices or edges) containing $k$ edges, unless specified otherwise.</p> </li> <li> <p>An alternating path (in a bipartite graph, with respect to some matching) is a path in which the edges alternately belong / do not belong to the matching.</p> </li> <li> <p>An augmenting path (in a bipartite graph, with respect to some matching) is an alternating path whose initial and final vertices are unsaturated, i.e.,  they do not belong in the matching. </p> </li> <li> <p>The symmetric difference (also known as the disjunctive union) of sets $A$ and $B$, represented by $A \\oplus B$, is the set of all elements that belong to exactly one of $A$ or $B$, but not to both.  That is, $A \\oplus B = (A - B) \\cup (B - A) = (A \\cup B) - (A \\cap B)$.</p> </li> </ul>","tags":["Translated"]},{"location":"graph/kuhn_maximum_bipartite_matching.html#berges-lemma","title":"Berge's lemma","text":"<p>This lemma was proven by the French mathematician Claude Berge in 1957, although it already was observed by the Danish mathematician Julius Petersen in 1891 and  the Hungarian mathematician Den\u00e9s K\u0151nig in 1931.</p>","tags":["Translated"]},{"location":"graph/kuhn_maximum_bipartite_matching.html#formulation","title":"Formulation","text":"<p>A matching $M$ is maximum $\\Leftrightarrow$ there is no augmenting path relative to the matching $M$.</p>","tags":["Translated"]},{"location":"graph/kuhn_maximum_bipartite_matching.html#proof","title":"Proof","text":"<p>Both sides of the bi-implication will be proven by contradiction.</p> <ol> <li> <p>A matching $M$ is maximum $\\Rightarrow$ there is no augmenting path relative to the matching $M$.</p> <p>Let there be an augmenting path $P$ relative to the given maximum matching $M$. This augmenting path $P$ will necessarily be of odd length, having one more edge not in $M$ than the number of edges it has that are also in $M$.  We create a new matching $M'$ by including all edges in the original matching $M$ except those also in the $P$, and the edges in $P$ that are not in $M$.  This is a valid matching because the initial and final vertices of $P$ are unsaturated by $M$, and the rest of the vertices are saturated only by the matching $P \\cap M$. This new matching $M'$ will have one more edge than $M$, and so $M$ could not have been maximum. </p> <p>Formally, given an augmenting path $P$ w.r.t. some maximum matching $M$, the matching $M' = P \\oplus M$ is such that $|M'| = |M| + 1$, a contradiction.</p> </li> <li> <p>A matching $M$ is maximum $\\Leftarrow$ there is no augmenting path relative to the matching $M$.</p> <p>Let there be a matching $M'$ of greater cardinality than $M$. We consider the symmetric difference $Q = M \\oplus M'$. The subgraph $Q$ is no longer necessarily a matching.  Any vertex in $Q$ has a maximum degree of $2$, which means that all connected components in it are one of the three - </p> <ul> <li>an isolated vertex</li> <li>a (simple) path whose edges are alternately from $M$ and $M'$</li> <li>a cycle of even length whose edges are alternately from $M$ and $M'$</li> </ul> <p>Since $M'$ has a cardinality greater than $M$, $Q$ has more edges from $M'$ than $M$. By the Pigeonhole principle, at least one connected component will be a path having  more edges from $M'$ than $M$. Because any such path is alternating, it will have initial and final vertices unsaturated by $M$, making it an augmenting path for $M$,  which contradicts the premise. \u2002 $\\blacksquare$</p> </li> </ol>","tags":["Translated"]},{"location":"graph/kuhn_maximum_bipartite_matching.html#kuhns-algorithm","title":"Kuhn's algorithm","text":"<p>Kuhn's algorithm is a direct application of Berge's lemma. It is essentially described as follows: </p> <p>First, we take an empty matching. Then, while the algorithm is able to find an augmenting path, we update the matching by alternating it along this path and repeat the process of finding the augmenting path.  As soon as it is not possible to find such a path, we stop the process - the current matching is the maximum. </p> <p>It remains to detail the way to find augmenting paths. Kuhn's algorithm simply searches for any of these paths using depth-first or breadth-first traversal. The algorithm  looks through all the vertices of the graph in turn, starting each traversal from it, trying to find an augmenting path starting at this vertex.</p> <p>The algorithm is more convenient to describe if we assume that the input graph is already split into two parts (although, in fact, the algorithm can be implemented in such a way  that the input graph is not explicitly split into two parts).</p> <p>The algorithm looks at all the vertices $v$ of the first part of the graph: $v = 1 \\ldots n_1$. If the current vertex $v$ is already saturated with the current matching  (i.e., some edge adjacent to it has already been selected), then skip this vertex. Otherwise, the algorithm tries to saturate this vertex, for which it starts  a search for an augmenting path starting from this vertex.</p> <p>The search for an augmenting path is carried out using a special depth-first or breadth-first traversal (usually depth-first traversal is used for ease of implementation).  Initially, the depth-first traversal is at the current unsaturated vertex $v$ of the first part. Let's look through all edges from this vertex. Let the current edge be an edge  $(v, to)$. If the vertex $to$ is not yet saturated with matching, then we have succeeded in finding an augmenting path: it consists of a single edge $(v, to)$;  in this case, we simply include this edge in the matching and stop searching for the augmenting path from the vertex $v$. Otherwise, if $to$ is already saturated with some edge  $(to, p)$,  then will go along this edge: thus we will try to find an augmenting path passing through the edges $(v, to),(to, p), \\ldots$.  To do this, simply go to the vertex $p$ in our traversal - now we try to find an augmenting path from this vertex.</p> <p>So, this traversal, launched from the vertex $v$, will either find an augmenting path, and thereby saturate the vertex $v$, or it will not find such an augmenting path (and, therefore, this vertex $v$ cannot be saturated).</p> <p>After all the vertices $v = 1 \\ldots n_1$ have been scanned, the current matching will be maximum.</p>","tags":["Translated"]},{"location":"graph/kuhn_maximum_bipartite_matching.html#running-time","title":"Running time","text":"<p>Kuhn's algorithm can be thought of as a series of $n$ depth/breadth-first traversal runs on the entire graph. Therefore, the whole algorithm is executed in time $O(nm)$, which in the worst case is $O(n^3)$.</p> <p>However, this estimate can be improved slightly. It turns out that for Kuhn's algorithm, it is important which part of the graph is chosen as the first and which as the second.  Indeed, in the implementation described above, the depth/breadth-first traversal starts only from the vertices of the first part, so the entire algorithm is executed in  time $O(n_1m)$, where $n_1$ is the number of vertices of the first part. In the worst case, this is $O(n_1 ^ 2 n_2)$ (where $n_2$ is the number of vertices of the second part).  This shows that it is more profitable when the first part contains fewer vertices than the second. On very unbalanced graphs (when $n_1$ and $n_2$ are very different),  this translates into a significant difference in runtimes.</p>","tags":["Translated"]},{"location":"graph/kuhn_maximum_bipartite_matching.html#implementation","title":"Implementation","text":"","tags":["Translated"]},{"location":"graph/kuhn_maximum_bipartite_matching.html#standard-implementation","title":"Standard implementation","text":"<p>Let us present here an implementation of the above algorithm based on depth-first traversal and accepting a bipartite graph in the form of a graph explicitly split into two parts. This implementation is very concise, and perhaps it should be remembered in this form.</p> <p>Here $n$ is the number of vertices in the first part, $k$ - in the second part, $g[v]$ is the list of edges from the top of the first part (i.e. the list of numbers of the  vertices to which these edges lead from $v$). The vertices in both parts are numbered independently, i.e. vertices in the first part are numbered $1 \\ldots n$, and those in the  second are numbered $1 \\ldots k$.</p> <p>Then there are two auxiliary arrays: $\\rm mt$ and $\\rm used$. The first - $\\rm mt$ - contains information about the current matching. For convenience of programming,  this information is contained only for the vertices of the second part: $\\textrm{mt[} i \\rm]$ - this is the number of the vertex of the first part connected by an edge with the vertex $i$ of  the second part (or $-1$, if no matching edge comes out of it). The second array is $\\rm used$: the usual array of \"visits\" to the vertices in the depth-first traversal  (it is needed just so that the depth-first traversal does not enter the same vertex twice).</p> <p>A function $\\textrm{try_kuhn}$ is a depth-first traversal. It returns $\\rm true$ if it was able to find an augmenting path from the vertex $v$, and it is considered that this  function has already performed the alternation of matching along the found chain.</p> <p>Inside the function, all the edges outgoing from the vertex $v$ of the first part are scanned, and then the following is checked: if this edge leads to an unsaturated vertex  $to$, or if this vertex $to$ is saturated, but it is possible to find an increasing chain by recursively starting from $\\textrm{mt[}to \\rm ]$, then we say that we have found an  augmenting path, and before returning from the function with the result $\\rm true$, we alternate the current edge: we redirect the edge adjacent to $to$ to the vertex $v$.</p> <p>The main program first indicates that the current matching is empty (the list $\\rm mt$ is filled with numbers $-1$). Then the vertex $v$ of the first part is searched by $\\textrm{try_kuhn}$,  and a depth-first traversal is started from it, having previously zeroed the array $\\rm used$.</p> <p>It is worth noting that the size of the matching is easy to get as the number of calls $\\textrm{try_kuhn}$ in the main program that returned the result $\\rm true$. The desired  maximum matching itself is contained in the array $\\rm mt$.</p> <pre><code>int n, k;\nvector&lt;vector&lt;int&gt;&gt; g;\nvector&lt;int&gt; mt;\nvector&lt;bool&gt; used;\n\nbool try_kuhn(int v) {\n    if (used[v])\n        return false;\n    used[v] = true;\n    for (int to : g[v]) {\n        if (mt[to] == -1 || try_kuhn(mt[to])) {\n            mt[to] = v;\n            return true;\n        }\n    }\n    return false;\n}\n\nint main() {\n    //... reading the graph ...\n\n    mt.assign(k, -1);\n    for (int v = 0; v &lt; n; ++v) {\n        used.assign(n, false);\n        try_kuhn(v);\n    }\n\n    for (int i = 0; i &lt; k; ++i)\n        if (mt[i] != -1)\n            printf(\"%d %d\\n\", mt[i] + 1, i + 1);\n}\n</code></pre> <p>We repeat once again that Kuhn's algorithm is easy to implement in such a way that it works on graphs that are known to be bipartite, but their explicit splitting into two parts  has not been given. In this case, it will be necessary to abandon the convenient division into two parts, and store all the information for all vertices of the graph. For this,  an array of lists $g$ is now specified not only for the vertices of the first part, but for all the vertices of the graph (of course, now the vertices of both parts are numbered  in a common numbering - from $1$ to $n$). Arrays $\\rm mt$ and are $\\rm used$ are now also defined for the vertices of both parts, and, accordingly, they need to be kept in this state.</p>","tags":["Translated"]},{"location":"graph/kuhn_maximum_bipartite_matching.html#improved-implementation","title":"Improved implementation","text":"<p>Let us modify the algorithm as follows. Before the main loop of the algorithm, we will find an arbitrary matching by some simple algorithm (a simple heuristic algorithm),  and only then we will execute a loop with calls to the $\\textrm{try_kuhn}()$ function, which will improve this matching. As a result, the algorithm will work noticeably faster on  random graphs - because in most graphs, you can easily find a matching of a sufficiently large size using heuristics, and then improve the found matching to the maximum using  the usual Kuhn's algorithm. Thus, we will save on launching a depth-first traversal from those vertices that we have already included using the heuristic into the current matching.</p> <p>For example, you can simply iterate over all the vertices of the first part, and for each of them, find an arbitrary edge that can be added to the matching, and add it.  Even such a simple heuristic can speed up Kuhn's algorithm several times.</p> <p>Please note that the main loop will have to be slightly modified. Since when calling the function $\\textrm{try_kuhn}$ in the main loop, it is assumed that the current vertex is  not yet included in the matching, you need to add an appropriate check.</p> <p>In the implementation, only the code in the $\\textrm{main}()$ function will change:</p> <pre><code>int main() {\n    // ... reading the graph ...\n\n    mt.assign(k, -1);\n    vector&lt;bool&gt; used1(n, false);\n    for (int v = 0; v &lt; n; ++v) {\n        for (int to : g[v]) {\n            if (mt[to] == -1) {\n                mt[to] = v;\n                used1[v] = true;\n                break;\n            }\n        }\n    }\n    for (int v = 0; v &lt; n; ++v) {\n        if (used1[v])\n            continue;\n        used.assign(n, false);\n        try_kuhn(v);\n    }\n\n    for (int i = 0; i &lt; k; ++i)\n        if (mt[i] != -1)\n            printf(\"%d %d\\n\", mt[i] + 1, i + 1);\n}\n</code></pre> <p>Another good heuristic is as follows. At each step, it will search for the vertex of the smallest degree (but not isolated), select any edge from it and add it to the matching, then remove both these vertices with all incident edges from the graph. Such greed works very well on random graphs; in many cases it even builds the maximum matching (although  there is a test case against it, on which it will find a matching that is much smaller than the maximum).</p>","tags":["Translated"]},{"location":"graph/kuhn_maximum_bipartite_matching.html#notes","title":"Notes","text":"<ul> <li>Kuhn's algorithm is a subroutine in the Hungarian algorithm, also known as the Kuhn-Munkres algorithm.</li> <li>Kuhn's algorithm runs in $O(nm)$ time. It is generally simple to implement, however, more efficient algorithms exist for the maximum bipartite matching problem - such as the      Hopcroft-Karp-Karzanov algorithm, which runs in $O(\\sqrt{n}m)$ time.</li> <li>The minimum vertex cover problem is NP-hard for general graphs.  However, K\u0151nig's theorem gives that, for bipartite graphs, the cardinality of the maximum matching equals the cardinality of the minimum vertex cover.  Hence, we can use maximum bipartite matching algorithms to solve the minimum vertex cover problem in polynomial time for bipartite graphs.</li> </ul>","tags":["Translated"]},{"location":"graph/kuhn_maximum_bipartite_matching.html#practice-problems","title":"Practice Problems","text":"<ul> <li>Kattis - Gopher II</li> <li>Kattis - Borders</li> </ul>","tags":["Translated"]},{"location":"graph/lca.html","title":"Lowest Common Ancestor - $O(\\sqrt{N})$ and $O(\\log N)$ with $O(N)$ preprocessing","text":"<p>Given a tree $G$. Given queries of the form $(v_1, v_2)$, for each query you need to find the lowest common ancestor (or least common ancestor), i.e. a vertex $v$ that lies on the path from the root to $v_1$ and the path from the root to $v_2$, and the vertex should be the lowest. In other words, the desired vertex $v$ is the most bottom ancestor of $v_1$ and $v_2$. It is obvious that their lowest common ancestor lies on a shortest path from $v_1$ and $v_2$. Also, if $v_1$ is the ancestor of $v_2$, $v_1$ is their lowest common ancestor.</p>","tags":["Translated"]},{"location":"graph/lca.html#the-idea-of-the-algorithm","title":"The Idea of the Algorithm","text":"<p>Before answering the queries, we need to preprocess the tree. We make a DFS traversal starting at the root and we build a list $\\text{euler}$ which stores the order of the vertices that we visit (a vertex is added to the list when we first visit it, and after the return of the DFS traversals to its children). This is also called an Euler tour of the tree. It is clear that the size of this list will be $O(N)$. We also need to build an array $\\text{first}[0..N-1]$ which stores for each vertex $i$ its first occurrence in $\\text{euler}$. That is, the first position in $\\text{euler}$ such that $\\text{euler}[\\text{first}[i]] = i$. Also by using the DFS we can find the height of each node (distance from root to it) and store it in the array $\\text{height}[0..N-1]$.</p> <p>So how can we answer queries using the Euler tour and the additional two arrays? Suppose the query is a pair of $v_1$ and $v_2$. Consider the vertices that we visit in the Euler tour between the first visit of $v_1$ and the first visit of $v_2$. It is easy to see, that the $\\text{LCA}(v_1, v_2)$ is the vertex with the lowest height on this path. We already noticed, that the LCA has to be part of the shortest path between $v_1$ and $v_2$. Clearly it also has to be the vertex with the smallest height. And in the Euler tour we essentially use the shortest path, except that we additionally visit all subtrees that we find on the path. But all vertices in these subtrees are lower in the tree than the LCA and therefore have a larger height. So the $\\text{LCA}(v_1, v_2)$ can be uniquely determined by finding the vertex with the smallest height in the Euler tour between $\\text{first}(v_1)$ and $\\text{first}(v_2)$.</p> <p>Let's illustrate this idea. Consider the following graph and the Euler tour with the corresponding heights:</p> $$\\begin{array}{|l|c|c|c|c|c|c|c|c|c|c|c|c|c|} \\hline \\text{Vertices:}   &amp; 1 &amp; 2 &amp; 5 &amp; 2 &amp; 6 &amp; 2 &amp; 1 &amp; 3 &amp; 1 &amp; 4 &amp; 7 &amp; 4 &amp; 1 \\\\ \\hline \\text{Heights:} &amp; 1 &amp; 2 &amp; 3 &amp; 2 &amp; 3 &amp; 2 &amp; 1 &amp; 2 &amp; 1 &amp; 2 &amp; 3 &amp; 2 &amp; 1 \\\\ \\hline \\end{array}$$ <p>The tour starting at vertex $6$ and ending at $4$ we visit the vertices $[6, 2, 1, 3, 1, 4]$. Among those vertices the vertex $1$ has the lowest height, therefore $\\text{LCA(6, 4) = 1}$.</p> <p>To recap: to answer a query we just need to find the vertex with smallest height in the array $\\text{euler}$ in the range from $\\text{first}[v_1]$ to $\\text{first}[v_2]$. Thus, the LCA problem is reduced to the RMQ problem (finding the minimum in an range problem).</p> <p>Using Sqrt-Decomposition, it is possible to obtain a solution answering each query in $O(\\sqrt{N})$ with preprocessing in $O(N)$ time.</p> <p>Using a Segment Tree you can answer each query in $O(\\log N)$ with preprocessing in $O(N)$ time.</p> <p>Since there will almost never be any update to the stored values, a Sparse Table might be a better choice, allowing $O(1)$ query answering with $O(N\\log N)$ build time.</p>","tags":["Translated"]},{"location":"graph/lca.html#implementation","title":"Implementation","text":"<p>In the following implementation of the LCA algorithm a Segment Tree is used.</p> <pre><code>struct LCA {\n    vector&lt;int&gt; height, euler, first, segtree;\n    vector&lt;bool&gt; visited;\n    int n;\n\n    LCA(vector&lt;vector&lt;int&gt;&gt; &amp;adj, int root = 0) {\n        n = adj.size();\n        height.resize(n);\n        first.resize(n);\n        euler.reserve(n * 2);\n        visited.assign(n, false);\n        dfs(adj, root);\n        int m = euler.size();\n        segtree.resize(m * 4);\n        build(1, 0, m - 1);\n    }\n\n    void dfs(vector&lt;vector&lt;int&gt;&gt; &amp;adj, int node, int h = 0) {\n        visited[node] = true;\n        height[node] = h;\n        first[node] = euler.size();\n        euler.push_back(node);\n        for (auto to : adj[node]) {\n            if (!visited[to]) {\n                dfs(adj, to, h + 1);\n                euler.push_back(node);\n            }\n        }\n    }\n\n    void build(int node, int b, int e) {\n        if (b == e) {\n            segtree[node] = euler[b];\n        } else {\n            int mid = (b + e) / 2;\n            build(node &lt;&lt; 1, b, mid);\n            build(node &lt;&lt; 1 | 1, mid + 1, e);\n            int l = segtree[node &lt;&lt; 1], r = segtree[node &lt;&lt; 1 | 1];\n            segtree[node] = (height[l] &lt; height[r]) ? l : r;\n        }\n    }\n\n    int query(int node, int b, int e, int L, int R) {\n        if (b &gt; R || e &lt; L)\n            return -1;\n        if (b &gt;= L &amp;&amp; e &lt;= R)\n            return segtree[node];\n        int mid = (b + e) &gt;&gt; 1;\n\n        int left = query(node &lt;&lt; 1, b, mid, L, R);\n        int right = query(node &lt;&lt; 1 | 1, mid + 1, e, L, R);\n        if (left == -1) return right;\n        if (right == -1) return left;\n        return height[left] &lt; height[right] ? left : right;\n    }\n\n    int lca(int u, int v) {\n        int left = first[u], right = first[v];\n        if (left &gt; right)\n            swap(left, right);\n        return query(1, 0, euler.size() - 1, left, right);\n    }\n};\n</code></pre>","tags":["Translated"]},{"location":"graph/lca.html#practice-problems","title":"Practice Problems","text":"<ul> <li>SPOJ: LCA</li> <li>SPOJ: DISQUERY</li> <li>TIMUS: 1471. Distance in the Tree</li> <li>CODEFORCES: Design Tutorial: Inverse the Problem</li> <li>CODECHEF: Lowest Common Ancestor</li> <li>SPOJ - Lowest Common Ancestor</li> <li>SPOJ - Ada and Orange Tree</li> <li>DevSkill - Motoku (archived)</li> <li>UVA 12655 - Trucks</li> <li>Codechef - Pishty and Tree</li> <li>UVA - 12533 - Joining Couples</li> <li>Codechef - So close yet So Far</li> <li>Codeforces - Drivers Dissatisfaction</li> <li>UVA 11354 - Bond</li> <li>SPOJ - Querry on a tree II</li> <li>Codeforces - Best Edge Weight</li> <li>Codeforces - Misha, Grisha and Underground</li> <li>SPOJ - Nlogonian Tickets</li> <li>Codeforces - Rowena Rawenclaws Diadem</li> </ul>","tags":["Translated"]},{"location":"graph/lca_binary_lifting.html","title":"Lowest Common Ancestor - Binary Lifting","text":"<p>Let $G$ be a tree. For every query of the form <code>(u, v)</code> we want to find the lowest common ancestor of the nodes <code>u</code> and <code>v</code>, i.e. we want to find a node <code>w</code> that lies on the path from <code>u</code> to the root node, that lies on the path from <code>v</code> to the root node, and if there are multiple nodes we pick the one that is farthest away from the root node. In other words the desired node <code>w</code> is the lowest ancestor of <code>u</code> and <code>v</code>. In particular if <code>u</code> is an ancestor of <code>v</code>, then <code>u</code> is their lowest common ancestor.</p> <p>The algorithm described in this article will need $O(N \\log N)$ for preprocessing the tree, and then $O(\\log N)$ for each LCA query.</p>","tags":["Translated"]},{"location":"graph/lca_binary_lifting.html#algorithm","title":"Algorithm","text":"<p>For each node we will precompute its ancestor above him, its ancestor two nodes above, its ancestor four above, etc. Let's store them in the array <code>up</code>, i.e. <code>up[i][j]</code> is the <code>2^j</code>-th ancestor above the node <code>i</code> with <code>i=1...N</code>, <code>j=0...ceil(log(N))</code>. These information allow us to jump from any node to any ancestor above it in $O(\\log N)$ time. We can compute this array using a DFS traversal of the tree.</p> <p>For each node we will also remember the time of the first visit of this node (i.e. the time when the DFS discovers the node), and the time when we left it (i.e. after we visited all children and exit the DFS function). We can use this information to determine in constant time if a node is an ancestor of another node.</p> <p>Suppose now we received a query <code>(u, v)</code>. We can immediately check whether one node is the ancestor of the other. In this case this node is already the LCA. If <code>u</code> is not the ancestor of <code>v</code>, and <code>v</code> not the ancestor of <code>u</code>, we climb the ancestors of <code>u</code> until we find the highest (i.e. closest to the root) node, which is not an ancestor of <code>v</code> (i.e. a node <code>x</code>, such that <code>x</code> is not an ancestor of <code>v</code>, but <code>up[x][0]</code> is). We can find this node <code>x</code> in $O(\\log N)$ time using the array <code>up</code>.</p> <p>We will describe this process in more detail. Let <code>L = ceil(log(N))</code>. Suppose first that <code>i = L</code>. If <code>up[u][i]</code> is not an ancestor of <code>v</code>, then we can assign <code>u = up[u][i]</code> and decrement <code>i</code>. If <code>up[u][i]</code> is an ancestor, then we just decrement <code>i</code>. Clearly after doing this for all non-negative <code>i</code> the node <code>u</code> will be the desired node - i.e. <code>u</code> is still not an ancestor of <code>v</code>, but <code>up[u][0]</code> is.</p> <p>Now, obviously, the answer to LCA will be <code>up[u][0]</code> - i.e., the smallest node among the ancestors of the node <code>u</code>, which is also an ancestor of <code>v</code>.</p> <p>So answering a LCA query will iterate <code>i</code> from <code>ceil(log(N))</code> to <code>0</code> and checks in each iteration if one node is the ancestor of the other. Consequently each query can be answered in $O(\\log N)$.</p>","tags":["Translated"]},{"location":"graph/lca_binary_lifting.html#implementation","title":"Implementation","text":"<pre><code>int n, l;\nvector&lt;vector&lt;int&gt;&gt; adj;\n\nint timer;\nvector&lt;int&gt; tin, tout;\nvector&lt;vector&lt;int&gt;&gt; up;\n\nvoid dfs(int v, int p)\n{\n    tin[v] = ++timer;\n    up[v][0] = p;\n    for (int i = 1; i &lt;= l; ++i)\n        up[v][i] = up[up[v][i-1]][i-1];\n\n    for (int u : adj[v]) {\n        if (u != p)\n            dfs(u, v);\n    }\n\n    tout[v] = ++timer;\n}\n\nbool is_ancestor(int u, int v)\n{\n    return tin[u] &lt;= tin[v] &amp;&amp; tout[u] &gt;= tout[v];\n}\n\nint lca(int u, int v)\n{\n    if (is_ancestor(u, v))\n        return u;\n    if (is_ancestor(v, u))\n        return v;\n    for (int i = l; i &gt;= 0; --i) {\n        if (!is_ancestor(up[u][i], v))\n            u = up[u][i];\n    }\n    return up[u][0];\n}\n\nvoid preprocess(int root) {\n    tin.resize(n);\n    tout.resize(n);\n    timer = 0;\n    l = ceil(log2(n));\n    up.assign(n, vector&lt;int&gt;(l + 1));\n    dfs(root, root);\n}\n</code></pre>","tags":["Translated"]},{"location":"graph/lca_binary_lifting.html#practice-problems","title":"Practice Problems","text":"<ul> <li>LeetCode -  Kth Ancestor of a Tree Node</li> <li>Codechef - Longest Good Segment</li> <li>HackerEarth - Optimal Connectivity</li> </ul>","tags":["Translated"]},{"location":"graph/lca_farachcoltonbender.html","title":"Lowest Common Ancestor - Farach-Colton and Bender Algorithm","text":"<p>Let $G$ be a tree. For every query of the form $(u, v)$ we want to find the lowest common ancestor of the nodes $u$ and $v$, i.e. we want to find a node $w$ that lies on the path from $u$ to the root node, that lies on the path from $v$ to the root node, and if there are multiple nodes we pick the one that is farthest away from the root node. In other words the desired node $w$ is the lowest ancestor of $u$ and $v$. In particular if $u$ is an ancestor of $v$, then $u$ is their lowest common ancestor.</p> <p>The algorithm which will be described in this article was developed by Farach-Colton and Bender. It is asymptotically optimal.</p>","tags":["Translated"]},{"location":"graph/lca_farachcoltonbender.html#algorithm","title":"Algorithm","text":"<p>We use the classical reduction of the LCA problem to the RMQ problem. We traverse all nodes of the tree with DFS and keep an array with all visited nodes and the heights of these nodes.  The LCA of two nodes $u$ and $v$ is the node between the occurrences of $u$ and $v$ in the tour, that has the smallest height.</p> <p>In the following picture you can see a possible Euler-Tour of a graph and in the list below you can see the visited nodes and their heights.</p> $$\\begin{array}{|l|c|c|c|c|c|c|c|c|c|c|c|c|c|} \\hline \\text{Nodes:}   &amp; 1 &amp; 2 &amp; 5 &amp; 2 &amp; 6 &amp; 2 &amp; 1 &amp; 3 &amp; 1 &amp; 4 &amp; 7 &amp; 4 &amp; 1 \\\\ \\hline \\text{Heights:} &amp; 1 &amp; 2 &amp; 3 &amp; 2 &amp; 3 &amp; 2 &amp; 1 &amp; 2 &amp; 1 &amp; 2 &amp; 3 &amp; 2 &amp; 1 \\\\ \\hline \\end{array}$$ <p>You can read more about this reduction in the article Lowest Common Ancestor. In that article the minimum of a range was either found by sqrt-decomposition in $O(\\sqrt{N})$ or in $O(\\log N)$ using a Segment tree. In this article we look at how we can solve the given range minimum queries in $O(1)$ time, while still only taking $O(N)$ time for preprocessing.</p> <p>Note that the reduced RMQ problem is very specific: any two adjacent elements in the array differ exactly by one (since the elements of the array are nothing more than the heights of the nodes visited in order of traversal, and we either go to a descendant, in which case the next element is one bigger, or go back to the ancestor, in which case the next element is one lower). The Farach-Colton and Bender algorithm describes a solution for exactly this specialized RMQ problem.</p> <p>Let's denote with $A$ the array on which we want to perform the range minimum queries. And $N$ will be the size of $A$.</p> <p>There is an easy data structure that we can use for solving the RMQ problem with $O(N \\log N)$ preprocessing and $O(1)$ for each query: the Sparse Table. We create a table $T$ where each element $T[i][j]$ is equal to the minimum of $A$ in the interval $[i, i + 2^j - 1]$. Obviously $0 \\leq j \\leq \\lceil \\log N \\rceil$, and therefore the size of the Sparse Table will be $O(N \\log N)$. You can build the table easily in $O(N \\log N)$ by noting that $T[i][j] = \\min(T[i][j-1], T[i+2^{j-1}][j-1])$.</p> <p>How can we answer a query RMQ in $O(1)$ using this data structure? Let the received query be $[l, r]$, then the answer is $\\min(T[l][\\text{sz}], T[r-2^{\\text{sz}}+1][\\text{sz}])$, where $\\text{sz}$ is the biggest exponent such that $2^{\\text{sz}}$ is not bigger than the range length $r-l+1$.  Indeed we can take the range $[l, r]$ and cover it two segments of length $2^{\\text{sz}}$ - one starting in $l$ and the other ending in $r$. These segments overlap, but this doesn't interfere with our computation. To really achieve the time complexity of $O(1)$ per query, we need to know the values of $\\text{sz}$ for all possible lengths from $1$ to $N$. But this can be easily precomputed.</p> <p>Now we want to improve the complexity of the preprocessing down to $O(N)$.</p> <p>We divide the array $A$ into blocks of size $K = 0.5 \\log N$ with $\\log$ being the logarithm to base 2. For each block we calculate the minimum element and store them in an array $B$. $B$ has the size $\\frac{N}{K}$. We construct a sparse table from the array $B$. The size and the time complexity of it will be:</p> $$\\frac{N}{K}\\log\\left(\\frac{N}{K}\\right) = \\frac{2N}{\\log(N)} \\log\\left(\\frac{2N}{\\log(N)}\\right) =$$ $$= \\frac{2N}{\\log(N)} \\left(1 + \\log\\left(\\frac{N}{\\log(N)}\\right)\\right) \\leq \\frac{2N}{\\log(N)} + 2N = O(N)$$ <p>Now we only have to learn how to quickly answer range minimum queries within each block. In fact if the received range minimum query is $[l, r]$ and $l$ and $r$ are in different blocks then the answer is the minimum of the following three values: the minimum of the suffix of block of $l$ starting at $l$, the minimum of the prefix of block of $r$ ending at $r$, and the minimum of the blocks between those. The minimum of the blocks in between can be answered in $O(1)$ using the Sparse Table. So this leaves us only the range minimum queries inside blocks.</p> <p>Here we will exploit the property of the array. Remember that the values in the array - which are just height values in the tree - will always differ by one. If we remove the first element of a block, and subtract it from every other item in the block, every block can be identified by a sequence of length $K - 1$ consisting of the number $+1$ and $-1$. Because these blocks are so small, there are only a few different sequences that can occur. The number of possible sequences is:</p> $$2^{K-1} = 2^{0.5 \\log(N) - 1} = 0.5 \\left(2^{\\log(N)}\\right)^{0.5} = 0.5 \\sqrt{N}$$ <p>Thus the number of different blocks is $O(\\sqrt{N})$, and therefore we can precompute the results of range minimum queries inside all different blocks in $O(\\sqrt{N} K^2) = O(\\sqrt{N} \\log^2(N)) = O(N)$ time. For the implementation we can characterize a block by a bitmask of length $K-1$ (which will fit in a standard int) and store the index of the minimum in an array $\\text{block}[\\text{mask}][l][r]$ of size $O(\\sqrt{N} \\log^2(N))$.</p> <p>So we learned how to precompute range minimum queries within each block, as well as range minimum queries over a range of blocks, all in $O(N)$. With these precomputations we can answer each query in $O(1)$, by using at most four precomputed values: the minimum of the block containing <code>l</code>, the minimum of the block containing <code>r</code>, and the two minima of the overlapping segments of the blocks between them.</p>","tags":["Translated"]},{"location":"graph/lca_farachcoltonbender.html#implementation","title":"Implementation","text":"<pre><code>int n;\nvector&lt;vector&lt;int&gt;&gt; adj;\n\nint block_size, block_cnt;\nvector&lt;int&gt; first_visit;\nvector&lt;int&gt; euler_tour;\nvector&lt;int&gt; height;\nvector&lt;int&gt; log_2;\nvector&lt;vector&lt;int&gt;&gt; st;\nvector&lt;vector&lt;vector&lt;int&gt;&gt;&gt; blocks;\nvector&lt;int&gt; block_mask;\n\nvoid dfs(int v, int p, int h) {\n    first_visit[v] = euler_tour.size();\n    euler_tour.push_back(v);\n    height[v] = h;\n\n    for (int u : adj[v]) {\n        if (u == p)\n            continue;\n        dfs(u, v, h + 1);\n        euler_tour.push_back(v);\n    }\n}\n\nint min_by_h(int i, int j) {\n    return height[euler_tour[i]] &lt; height[euler_tour[j]] ? i : j;\n}\n\nvoid precompute_lca(int root) {\n    // get euler tour &amp; indices of first occurrences\n    first_visit.assign(n, -1);\n    height.assign(n, 0);\n    euler_tour.reserve(2 * n);\n    dfs(root, -1, 0);\n\n    // precompute all log values\n    int m = euler_tour.size();\n    log_2.reserve(m + 1);\n    log_2.push_back(-1);\n    for (int i = 1; i &lt;= m; i++)\n        log_2.push_back(log_2[i / 2] + 1);\n\n    block_size = max(1, log_2[m] / 2);\n    block_cnt = (m + block_size - 1) / block_size;\n\n    // precompute minimum of each block and build sparse table\n    st.assign(block_cnt, vector&lt;int&gt;(log_2[block_cnt] + 1));\n    for (int i = 0, j = 0, b = 0; i &lt; m; i++, j++) {\n        if (j == block_size)\n            j = 0, b++;\n        if (j == 0 || min_by_h(i, st[b][0]) == i)\n            st[b][0] = i;\n    }\n    for (int l = 1; l &lt;= log_2[block_cnt]; l++) {\n        for (int i = 0; i &lt; block_cnt; i++) {\n            int ni = i + (1 &lt;&lt; (l - 1));\n            if (ni &gt;= block_cnt)\n                st[i][l] = st[i][l-1];\n            else\n                st[i][l] = min_by_h(st[i][l-1], st[ni][l-1]);\n        }\n    }\n\n    // precompute mask for each block\n    block_mask.assign(block_cnt, 0);\n    for (int i = 0, j = 0, b = 0; i &lt; m; i++, j++) {\n        if (j == block_size)\n            j = 0, b++;\n        if (j &gt; 0 &amp;&amp; (i &gt;= m || min_by_h(i - 1, i) == i - 1))\n            block_mask[b] += 1 &lt;&lt; (j - 1);\n    }\n\n    // precompute RMQ for each unique block\n    int possibilities = 1 &lt;&lt; (block_size - 1);\n    blocks.resize(possibilities);\n    for (int b = 0; b &lt; block_cnt; b++) {\n        int mask = block_mask[b];\n        if (!blocks[mask].empty())\n            continue;\n        blocks[mask].assign(block_size, vector&lt;int&gt;(block_size));\n        for (int l = 0; l &lt; block_size; l++) {\n            blocks[mask][l][l] = l;\n            for (int r = l + 1; r &lt; block_size; r++) {\n                blocks[mask][l][r] = blocks[mask][l][r - 1];\n                if (b * block_size + r &lt; m)\n                    blocks[mask][l][r] = min_by_h(b * block_size + blocks[mask][l][r], \n                            b * block_size + r) - b * block_size;\n            }\n        }\n    }\n}\n\nint lca_in_block(int b, int l, int r) {\n    return blocks[block_mask[b]][l][r] + b * block_size;\n}\n\nint lca(int v, int u) {\n    int l = first_visit[v];\n    int r = first_visit[u];\n    if (l &gt; r)\n        swap(l, r);\n    int bl = l / block_size;\n    int br = r / block_size;\n    if (bl == br)\n        return euler_tour[lca_in_block(bl, l % block_size, r % block_size)];\n    int ans1 = lca_in_block(bl, l % block_size, block_size - 1);\n    int ans2 = lca_in_block(br, 0, r % block_size);\n    int ans = min_by_h(ans1, ans2);\n    if (bl + 1 &lt; br) {\n        int l = log_2[br - bl - 1];\n        int ans3 = st[bl+1][l];\n        int ans4 = st[br - (1 &lt;&lt; l)][l];\n        ans = min_by_h(ans, min_by_h(ans3, ans4));\n    }\n    return euler_tour[ans];\n}\n</code></pre>","tags":["Translated"]},{"location":"graph/lca_tarjan.html","title":"Lowest Common Ancestor - Tarjan's off-line algorithm","text":"<p>We have a tree $G$ with $n$ nodes and we have $m$ queries of the form $(u, v)$. For each query $(u, v)$ we want to find the lowest common ancestor of the vertices $u$ and $v$, i.e. the node that is an ancestor of both $u$ and $v$ and has the greatest depth in the tree. The node $v$ is also an ancestor of $v$, so the LCA can also be one of the two nodes.</p> <p>In this article we will solve the problem off-line, i.e. we assume that all queries are known in advance, and we therefore answer the queries in any order we like. The following algorithm allows to answer all $m$ queries in $O(n + m)$ total time, i.e. for sufficiently large $m$ in $O(1)$ for each query.</p>","tags":["Translated"]},{"location":"graph/lca_tarjan.html#algorithm","title":"Algorithm","text":"<p>The algorithm is named after Robert Tarjan, who discovered it in 1979 and also made many other contributions to the Disjoint Set Union data structure, which will be heavily used in this algorithm.</p> <p>The algorithm answers all queries with one DFS traversal of the tree. Namely a query $(u, v)$ is answered at node $u$, if node $v$ has already been visited previously, or vice versa.</p> <p>So let's assume we are currently at node $v$, we have already made recursive DFS calls, and also already visited the second node $u$ from the query $(u, v)$. Let's learn how to find the LCA of these two nodes.</p> <p>Note that $\\text{LCA}(u, v)$ is either the node $v$ or one of its ancestors. So we need to find the lowest node among the ancestors of $v$ (including $v$), for which the node $u$ is a descendant.  Also note that for a fixed $v$ the visited nodes of the tree split into a set of disjoint sets.  Each ancestor $p$ of node $v$ has his own set containing this node and all subtrees with roots in those of its children who are not part of the path from $v$ to the root of the tree. The set which contains the node $u$ determines the $\\text{LCA}(u, v)$: the LCA is the representative of the set, namely the node on lies on the path between $v$ and the root of the tree.</p> <p>We only need to learn to efficiently maintain all these sets. For this purpose we apply the data structure DSU. To be able to apply Union by rank, we store the real representative (the value on the path between $v$ and the root of the tree) of each set in the array <code>ancestor</code>.</p> <p>Let's discuss the implementation of the DFS. Let's assume we are currently visiting the node $v$. We place the node in a new set in the DSU, <code>ancestor[v] = v</code>. As usual we process all children of $v$. For this we must first recursively call DFS from that node, and then add this node with all its subtree to the set of $v$. This can be done with the function <code>union_sets</code> and the following assignment <code>ancestor[find_set(v)] = v</code> (this is necessary, because <code>union_sets</code> might change the representative of the set).</p> <p>Finally after processing all children we can answer all queries of the form $(u, v)$ for which $u$ has been already visited. The answer to the query, i.e. the LCA of $u$ and $v$, will be the node <code>ancestor[find_set(u)]</code>. It is easy to see that a query will only be answered once.</p> <p>Let's us determine the time complexity of this algorithm.  Firstly we have $O(n)$ because of the DFS. Secondly  we have the function calls of <code>union_sets</code> which happen $n$ times, resulting also in $O(n)$. And thirdly we have the calls of <code>find_set</code> for every query, which gives $O(m)$. So in total the time complexity is $O(n + m)$, which means that for sufficiently large $m$ this corresponds to $O(1)$ for answering one query.</p>","tags":["Translated"]},{"location":"graph/lca_tarjan.html#implementation","title":"Implementation","text":"<p>Here is an implementation of this algorithm. The implementation of DSU has been not included, as it can be used without any modifications.</p> <pre><code>vector&lt;vector&lt;int&gt;&gt; adj;\nvector&lt;vector&lt;int&gt;&gt; queries;\nvector&lt;int&gt; ancestor;\nvector&lt;bool&gt; visited;\n\nvoid dfs(int v)\n{\n    visited[v] = true;\n    ancestor[v] = v;\n    for (int u : adj[v]) {\n        if (!visited[u]) {\n            dfs(u);\n            union_sets(v, u);\n            ancestor[find_set(v)] = v;\n        }\n    }\n    for (int other_node : queries[v]) {\n        if (visited[other_node])\n            cout &lt;&lt; \"LCA of \" &lt;&lt; v &lt;&lt; \" and \" &lt;&lt; other_node\n                 &lt;&lt; \" is \" &lt;&lt; ancestor[find_set(other_node)] &lt;&lt; \".\\n\";\n    }\n}\n\nvoid compute_LCAs() {\n    // initialize n, adj and DSU\n    // for (each query (u, v)) {\n    //    queries[u].push_back(v);\n    //    queries[v].push_back(u);\n    // }\n\n    ancestor.resize(n);\n    visited.assign(n, false);\n    dfs(0);\n}\n</code></pre>","tags":["Translated"]},{"location":"graph/min_cost_flow.html","title":"Minimum-cost flow - Successive shortest path algorithm","text":"<p>Given a network $G$ consisting of $n$ vertices and $m$ edges. For each edge (generally speaking, oriented edges, but see below), the capacity (a non-negative integer) and the cost per unit of flow along this edge (some integer) are given. Also the source $s$ and the sink $t$ are marked.</p> <p>For a given value $K$, we have to find a flow of this quantity, and among all flows of this quantity we have to choose the flow with the lowest cost. This task is called minimum-cost flow problem.</p> <p>Sometimes the task is given a little differently: you want to find the maximum flow, and among all maximal flows we want to find the one with the least cost. This is called the minimum-cost maximum-flow problem.</p> <p>Both these problems can be solved effectively with the algorithm of successive shortest paths.</p>","tags":["Translated"]},{"location":"graph/min_cost_flow.html#algorithm","title":"Algorithm","text":"<p>This algorithm is very similar to the Edmonds-Karp for computing the maximum flow.</p>","tags":["Translated"]},{"location":"graph/min_cost_flow.html#simplest-case","title":"Simplest case","text":"<p>First we only consider the simplest case, where the graph is oriented, and there is at most one edge between any pair of vertices (e.g. if $(i, j)$ is an edge in the graph, then $(j, i)$ cannot be part in it as well).</p> <p>Let $U_{i j}$ be the capacity of an edge $(i, j)$ if this edge exists. And let $C_{i j}$ be the cost per unit of flow along this edge $(i, j)$. And finally let $F_{i, j}$ be the flow along the edge $(i, j)$. Initially all flow values are zero.</p> <p>We modify the network as follows: for each edge $(i, j)$ we add the reverse edge $(j, i)$ to the network with the capacity $U_{j i} = 0$ and the cost $C_{j i} = -C_{i j}$. Since, according to our restrictions, the edge $(j, i)$ was not in the network before, we still have a network that is not a multigraph (graph with multiple edges). In addition we will always keep the condition $F_{j i} = -F_{i j}$ true during the steps of the algorithm.</p> <p>We define the residual network for some fixed flow $F$ as follow (just like in the Ford-Fulkerson algorithm): the residual network contains only unsaturated edges (i.e. edges in which $F_{i j} &lt; U_{i j}$), and the residual capacity of each such edge is $R_{i j} = U_{i j} - F_{i j}$.</p> <p>Now we can talk about the algorithms to compute the minimum-cost flow. At each iteration of the algorithm we find the shortest path in the residual graph from $s$ to $t$. In contrast to Edmonds-Karp, we look for the shortest path in terms of the cost of the path instead of the number of edges. If there doesn't exists a path anymore, then the algorithm terminates, and the stream $F$ is the desired one. If a path was found, we increase the flow along it as much as possible (i.e. we find the minimal residual capacity $R$ of the path, and increase the flow by it, and reduce the back edges by the same amount). If at some point the flow reaches the value $K$, then we stop the algorithm (note that in the last iteration of the algorithm it is necessary to increase the flow by only such an amount so that the final flow value doesn't surpass $K$).</p> <p>It is not difficult to see, that if we set $K$ to infinity, then the algorithm will find the minimum-cost maximum-flow. So both variations of the problem can be solved by the same algorithm.</p>","tags":["Translated"]},{"location":"graph/min_cost_flow.html#undirected-graphs-multigraphs","title":"Undirected graphs / multigraphs","text":"<p>The case of an undirected graph or a multigraph doesn't differ conceptually from the algorithm above. The algorithm will also work on these graphs. However it becomes a little more difficult to implement it.</p> <p>An undirected edge $(i, j)$ is actually the same as two oriented edges $(i, j)$ and $(j, i)$ with the same capacity and values. Since the above-described minimum-cost flow algorithm generates a back edge for each directed edge, so it splits the undirected edge into $4$ directed edges, and we actually get a multigraph.</p> <p>How do we deal with multiple edges? First the flow for each of the multiple edges must be kept separately. Secondly, when searching for the shortest path, it is necessary to take into account that it is important which of the multiple edges is used in the path. Thus instead of the usual ancestor array we additionally must store the edge number from which we came from along with the ancestor. Thirdly, as the flow increases along a certain edge, it is necessary to reduce the flow along the back edge. Since we have multiple edges, we have to store the edge number for the reversed edge for each edge.</p> <p>There are no other obstructions with undirected graphs or multigraphs.</p>","tags":["Translated"]},{"location":"graph/min_cost_flow.html#complexity","title":"Complexity","text":"<p>The algorithm here is generally exponential in the size of the input. To be more specific, in the worst case it may push only as much as $1$ unit of flow on each iteration, taking $O(F)$ iterations to find a minimum-cost flow of size $F$, making a total runtime to be $O(F \\cdot T)$, where $T$ is the time required to find the shortest path from source to sink.</p> <p>If Bellman-Ford algorithm is used for this, it makes the running time $O(F mn)$. It is also possible to modify Dijkstra's algorithm, so that it needs $O(nm)$ pre-processing as an initial step and then works in $O(m \\log n)$ per iteration, making the overall running time to be $O(mn + F m \\log n)$. Here is a generator of a graph, on which such algorithm would require $O(2^{n/2} n^2 \\log n)$ time.</p> <p>The modified Dijkstra's algorithm uses so-called potentials from Johnson's algorithm. It is possible to combine the ideas of this algorithm and Dinic's algorithm to reduce the number of iterations from $F$ to $\\min(F, nC)$, where $C$ is the maximum cost found among edges. You may read further about potentials and their combination with Dinic algorithm here.</p>","tags":["Translated"]},{"location":"graph/min_cost_flow.html#implementation","title":"Implementation","text":"<p>Here is an implementation using the SPFA algorithm for the simplest case.</p> <pre><code>struct Edge\n{\n    int from, to, capacity, cost;\n};\n\nvector&lt;vector&lt;int&gt;&gt; adj, cost, capacity;\n\nconst int INF = 1e9;\n\nvoid shortest_paths(int n, int v0, vector&lt;int&gt;&amp; d, vector&lt;int&gt;&amp; p) {\n    d.assign(n, INF);\n    d[v0] = 0;\n    vector&lt;bool&gt; inq(n, false);\n    queue&lt;int&gt; q;\n    q.push(v0);\n    p.assign(n, -1);\n\n    while (!q.empty()) {\n        int u = q.front();\n        q.pop();\n        inq[u] = false;\n        for (int v : adj[u]) {\n            if (capacity[u][v] &gt; 0 &amp;&amp; d[v] &gt; d[u] + cost[u][v]) {\n                d[v] = d[u] + cost[u][v];\n                p[v] = u;\n                if (!inq[v]) {\n                    inq[v] = true;\n                    q.push(v);\n                }\n            }\n        }\n    }\n}\n\nint min_cost_flow(int N, vector&lt;Edge&gt; edges, int K, int s, int t) {\n    adj.assign(N, vector&lt;int&gt;());\n    cost.assign(N, vector&lt;int&gt;(N, 0));\n    capacity.assign(N, vector&lt;int&gt;(N, 0));\n    for (Edge e : edges) {\n        adj[e.from].push_back(e.to);\n        adj[e.to].push_back(e.from);\n        cost[e.from][e.to] = e.cost;\n        cost[e.to][e.from] = -e.cost;\n        capacity[e.from][e.to] = e.capacity;\n    }\n\n    int flow = 0;\n    int cost = 0;\n    vector&lt;int&gt; d, p;\n    while (flow &lt; K) {\n        shortest_paths(N, s, d, p);\n        if (d[t] == INF)\n            break;\n\n        // find max flow on that path\n        int f = K - flow;\n        int cur = t;\n        while (cur != s) {\n            f = min(f, capacity[p[cur]][cur]);\n            cur = p[cur];\n        }\n\n        // apply flow\n        flow += f;\n        cost += f * d[t];\n        cur = t;\n        while (cur != s) {\n            capacity[p[cur]][cur] -= f;\n            capacity[cur][p[cur]] += f;\n            cur = p[cur];\n        }\n    }\n\n    if (flow &lt; K)\n        return -1;\n    else\n        return cost;\n}\n</code></pre>","tags":["Translated"]},{"location":"graph/min_cost_flow.html#practice-problems","title":"Practice Problems","text":"<ul> <li>CSES - Task Assignment</li> <li>CSES - Grid Puzzle II</li> <li>AtCoder - Dream Team</li> </ul>","tags":["Translated"]},{"location":"graph/mpm.html","title":"Maximum flow - MPM algorithm","text":"<p>MPM (Malhotra, Pramodh-Kumar and Maheshwari) algorithm solves the maximum flow problem in $O(V^3)$. This algorithm is similar to Dinic's algorithm.</p>","tags":["Original"]},{"location":"graph/mpm.html#algorithm","title":"Algorithm","text":"<p>Like Dinic's algorithm, MPM runs in phases, during each phase we find the blocking flow in the layered network of the residual network of $G$. The main difference from Dinic's is how we find the blocking flow. Consider the layered network $L$. For each node we define its' inner potential and outer potential as:</p> $$\\begin{align} p_{in}(v) &amp;= \\sum\\limits_{(u, v)\\in L}(c(u, v) - f(u, v)) \\\\\\\\ p_{out}(v) &amp;= \\sum\\limits_{(v, u)\\in L}(c(v, u) - f(v, u)) \\end{align}$$ <p>Also we set $p_{in}(s) = p_{out}(t) = \\infty$. Given $p_{in}$ and $p_{out}$ we define the potential as $p(v) = min(p_{in}(v), p_{out}(v))$. We call a node $r$ a reference node if $p(r) = min\\{p(v)\\}$. Consider a reference node $r$. We claim that the flow can be increased by $p(r)$ in such a way that $p(r)$ becomes $0$. It is true because $L$ is acyclic, so we can push the flow out of $r$ by outgoing edges and it will reach $t$ because each node has enough outer potential to push the flow out when it reaches it. Similarly, we can pull the flow from $s$. The construction of the blocked flow is based on this fact. On each iteration we find a reference node and push the flow from $s$ to $t$ through $r$. This process can be simulated by BFS. All completely saturated arcs can be deleted from $L$ as they won't be used later in this phase anyway. Likewise, all the nodes different from $s$ and $t$ without outgoing or incoming arcs can be deleted.</p> <p>Each phase works in $O(V^2)$ because there are at most $V$ iterations (because at least the chosen reference node is deleted), and on each iteration we delete all the edges we passed through except at most $V$. Summing, we get $O(V^2 + E) = O(V^2)$. Since there are less than $V$ phases (see the proof here), MPM works in $O(V^3)$ total.</p>","tags":["Original"]},{"location":"graph/mpm.html#implementation","title":"Implementation","text":"<pre><code>struct MPM{\n    struct FlowEdge{\n        int v, u;\n        long long cap, flow;\n        FlowEdge(){}\n        FlowEdge(int _v, int _u, long long _cap, long long _flow)\n            : v(_v), u(_u), cap(_cap), flow(_flow){}\n        FlowEdge(int _v, int _u, long long _cap)\n            : v(_v), u(_u), cap(_cap), flow(0ll){}\n    };\n    const long long flow_inf = 1e18;\n    vector&lt;FlowEdge&gt; edges;\n    vector&lt;char&gt; alive;\n    vector&lt;long long&gt; pin, pout;\n    vector&lt;list&lt;int&gt; &gt; in, out;\n    vector&lt;vector&lt;int&gt; &gt; adj;\n    vector&lt;long long&gt; ex;\n    int n, m = 0;\n    int s, t;\n    vector&lt;int&gt; level;\n    vector&lt;int&gt; q;\n    int qh, qt;\n    void resize(int _n){\n        n = _n;\n        ex.resize(n);\n        q.resize(n);\n        pin.resize(n);\n        pout.resize(n);\n        adj.resize(n);\n        level.resize(n);\n        in.resize(n);\n        out.resize(n);\n    }\n    MPM(){}\n    MPM(int _n, int _s, int _t){resize(_n); s = _s; t = _t;}\n    void add_edge(int v, int u, long long cap){\n        edges.push_back(FlowEdge(v, u, cap));\n        edges.push_back(FlowEdge(u, v, 0));\n        adj[v].push_back(m);\n        adj[u].push_back(m + 1);\n        m += 2;\n    }\n    bool bfs(){\n        while(qh &lt; qt){\n            int v = q[qh++];\n            for(int id : adj[v]){\n                if(edges[id].cap - edges[id].flow &lt; 1)continue;\n                if(level[edges[id].u] != -1)continue;\n                level[edges[id].u] = level[v] + 1;\n                q[qt++] = edges[id].u;\n            }\n        }\n        return level[t] != -1;\n    }\n    long long pot(int v){\n        return min(pin[v], pout[v]);\n    }\n    void remove_node(int v){\n        for(int i : in[v]){\n            int u = edges[i].v;\n            auto it = find(out[u].begin(), out[u].end(), i);\n            out[u].erase(it);\n            pout[u] -= edges[i].cap - edges[i].flow;\n        }\n        for(int i : out[v]){\n            int u = edges[i].u;\n            auto it = find(in[u].begin(), in[u].end(), i);\n            in[u].erase(it);\n            pin[u] -= edges[i].cap - edges[i].flow;\n        }\n    }\n    void push(int from, int to, long long f, bool forw){\n        qh = qt = 0;\n        ex.assign(n, 0);\n        ex[from] = f;\n        q[qt++] = from;\n        while(qh &lt; qt){\n            int v = q[qh++];\n            if(v == to)\n                break;\n            long long must = ex[v];\n            auto it = forw ? out[v].begin() : in[v].begin();\n            while(true){\n                int u = forw ? edges[*it].u : edges[*it].v;\n                long long pushed = min(must, edges[*it].cap - edges[*it].flow);\n                if(pushed == 0)break;\n                if(forw){\n                    pout[v] -= pushed;\n                    pin[u] -= pushed;\n                }\n                else{\n                    pin[v] -= pushed;\n                    pout[u] -= pushed;\n                }\n                if(ex[u] == 0)\n                    q[qt++] = u;\n                ex[u] += pushed;\n                edges[*it].flow += pushed;\n                edges[(*it)^1].flow -= pushed;\n                must -= pushed;\n                if(edges[*it].cap - edges[*it].flow == 0){\n                    auto jt = it;\n                    ++jt;\n                    if(forw){\n                        in[u].erase(find(in[u].begin(), in[u].end(), *it));\n                        out[v].erase(it);\n                    }\n                    else{\n                        out[u].erase(find(out[u].begin(), out[u].end(), *it));\n                        in[v].erase(it);\n                    }\n                    it = jt;\n                }\n                else break;\n                if(!must)break;\n            }\n        }\n    }\n    long long flow(){\n        long long ans = 0;\n        while(true){\n            pin.assign(n, 0);\n            pout.assign(n, 0);\n            level.assign(n, -1);\n            alive.assign(n, true);\n            level[s] = 0;\n            qh = 0; qt = 1;\n            q[0] = s;\n            if(!bfs())\n                break;\n            for(int i = 0; i &lt; n; i++){\n                out[i].clear();\n                in[i].clear();\n            }\n            for(int i = 0; i &lt; m; i++){\n                if(edges[i].cap - edges[i].flow == 0)\n                    continue;\n                int v = edges[i].v, u = edges[i].u;\n                if(level[v] + 1 == level[u] &amp;&amp; (level[u] &lt; level[t] || u == t)){\n                    in[u].push_back(i);\n                    out[v].push_back(i);\n                    pin[u] += edges[i].cap - edges[i].flow;\n                    pout[v] += edges[i].cap - edges[i].flow;\n                }\n            }\n            pin[s] = pout[t] = flow_inf;\n            while(true){\n                int v = -1;\n                for(int i = 0; i &lt; n; i++){\n                    if(!alive[i])continue;\n                    if(v == -1 || pot(i) &lt; pot(v))\n                        v = i;\n                }\n                if(v == -1)\n                    break;\n                if(pot(v) == 0){\n                    alive[v] = false;\n                    remove_node(v);\n                    continue;\n                }\n                long long f = pot(v);\n                ans += f;\n                push(v, s, f, false);\n                push(v, t, f, true);\n                alive[v] = false;\n                remove_node(v);\n            }\n        }\n        return ans;\n    }\n};\n</code></pre>","tags":["Original"]},{"location":"graph/mst_kruskal.html","title":"Minimum spanning tree - Kruskal's algorithm","text":"<p>Given a weighted undirected graph. We want to find a subtree of this graph which connects all vertices (i.e. it is a spanning tree) and has the least weight (i.e. the sum of weights of all the edges is minimum) of all possible spanning trees. This spanning tree is called a minimum spanning tree.</p> <p>In the left image you can see a weighted undirected graph, and in the right image you can see the corresponding minimum spanning tree.</p> <p> </p> <p>This article will discuss few important facts associated with minimum spanning trees, and then will give the simplest implementation of Kruskal's algorithm for finding minimum spanning tree.</p>","tags":["Translated"]},{"location":"graph/mst_kruskal.html#properties-of-the-minimum-spanning-tree","title":"Properties of the minimum spanning tree","text":"<ul> <li>A minimum spanning tree of a graph is unique, if the weight of all the edges are distinct. Otherwise, there may be multiple minimum spanning trees.   (Specific algorithms typically output one of the possible minimum spanning trees).</li> <li>Minimum spanning tree is also the tree with minimum product of weights of edges.   (It can be easily proved by replacing the weights of all edges with their logarithms)</li> <li>In a minimum spanning tree of a graph, the maximum weight of an edge is the minimum possible from all possible spanning trees of that graph.   (This follows from the validity of Kruskal's algorithm).</li> <li>The maximum spanning tree (spanning tree with the sum of weights of edges being maximum) of a graph can be obtained similarly to that of the minimum spanning tree, by changing the signs of the weights of all the edges to their opposite and then applying any of the minimum spanning tree algorithm.</li> </ul>","tags":["Translated"]},{"location":"graph/mst_kruskal.html#kruskals-algorithm","title":"Kruskal's algorithm","text":"<p>This algorithm was described by Joseph Bernard Kruskal, Jr. in 1956.</p> <p>Kruskal's algorithm initially places all the nodes of the original graph isolated from each other, to form a forest of single node trees, and then gradually merges these trees, combining at each iteration any two of all the trees with some edge of the original graph. Before the execution of the algorithm, all edges are sorted by weight (in non-decreasing order). Then begins the process of unification: pick all edges from the first to the last (in sorted order), and if the ends of the currently picked edge belong to different subtrees, these subtrees are combined, and the edge is added to the answer. After iterating through all the edges, all the vertices will belong to the same sub-tree, and we will get the answer.</p>","tags":["Translated"]},{"location":"graph/mst_kruskal.html#the-simplest-implementation","title":"The simplest implementation","text":"<p>The following code directly implements the algorithm described above, and is having $O(M \\log M + N^2)$ time complexity. Sorting edges requires $O(M \\log N)$ (which is the same as $O(M \\log M)$) operations. Information regarding the subtree to which a vertex belongs is maintained with the help of an array <code>tree_id[]</code> - for each vertex <code>v</code>, <code>tree_id[v]</code> stores the number of the tree , to which <code>v</code> belongs. For each edge, whether it belongs to the ends of different trees, can be determined in $O(1)$. Finally, the union of the two trees is carried out in $O(N)$ by a simple pass through <code>tree_id[]</code> array. Given that the total number of merge operations is $N-1$, we obtain the asymptotic behavior of $O(M \\log N + N^2)$.</p> <pre><code>struct Edge {\n    int u, v, weight;\n    bool operator&lt;(Edge const&amp; other) {\n        return weight &lt; other.weight;\n    }\n};\n\nint n;\nvector&lt;Edge&gt; edges;\n\nint cost = 0;\nvector&lt;int&gt; tree_id(n);\nvector&lt;Edge&gt; result;\nfor (int i = 0; i &lt; n; i++)\n    tree_id[i] = i;\n\nsort(edges.begin(), edges.end());\n\nfor (Edge e : edges) {\n    if (tree_id[e.u] != tree_id[e.v]) {\n        cost += e.weight;\n        result.push_back(e);\n\n        int old_id = tree_id[e.u], new_id = tree_id[e.v];\n        for (int i = 0; i &lt; n; i++) {\n            if (tree_id[i] == old_id)\n                tree_id[i] = new_id;\n        }\n    }\n}\n</code></pre>","tags":["Translated"]},{"location":"graph/mst_kruskal.html#proof-of-correctness","title":"Proof of correctness","text":"<p>Why does Kruskal's algorithm give us the correct result?</p> <p>If the original graph was connected, then also the resulting graph will be connected. Because otherwise there would be two components that could be connected with at least one edge. Though this is impossible, because Kruskal would have chosen one of these edges, since the ids of the components are different. Also the resulting graph doesn't contain any cycles, since we forbid this explicitly in the algorithm. Therefore the algorithm generates a spanning tree.</p> <p>So why does this algorithm give us a minimum spanning tree?</p> <p>We can show the proposal \"if $F$ is a set of edges chosen by the algorithm at any stage in the algorithm, then there exists a MST that contains all edges of $F$\" using induction.</p> <p>The proposal is obviously true at the beginning, the empty set is a subset of any MST.</p> <p>Now let's assume $F$ is some edge set at any stage of the algorithm, $T$ is a MST containing $F$ and $e$ is the new edge we want to add using Kruskal.</p> <p>If $e$ generates a cycle, then we don't add it, and so the proposal is still true after this step.</p> <p>In case that $T$ already contains $e$, the proposal is also true after this step.</p> <p>In case $T$ doesn't contain the edge $e$, then $T + e$ will contain a cycle $C$. This cycle will contain at least one edge $f$, that is not in $F$. The set of edges $T - f + e$ will also be a spanning tree.  Notice that the weight of $f$ cannot be smaller than the weight of $e$, because otherwise Kruskal would have chosen $f$ earlier. It also cannot have a bigger weight, since that would make the total weight of $T - f + e$ smaller than the total weight of $T$, which is impossible since $T$ is already a MST. This means that the weight of $e$ has to be the same as the weight of $f$. Therefore $T - f + e$ is also a MST, and it contains all edges from $F + e$. So also here the proposal is still fulfilled after the step.</p> <p>This proves the proposal. Which means that after iterating over all edges the resulting edge set will be connected, and will be contained in a MST, which means that it has to be a MST already.</p>","tags":["Translated"]},{"location":"graph/mst_kruskal.html#improved-implementation","title":"Improved implementation","text":"<p>We can use the Disjoint Set Union (DSU) data structure to write a faster implementation of the Kruskal's algorithm with the time complexity of about $O(M \\log N)$. This article details such an approach.</p>","tags":["Translated"]},{"location":"graph/mst_kruskal.html#practice-problems","title":"Practice Problems","text":"<ul> <li>SPOJ - Koicost</li> <li>SPOJ - MaryBMW</li> <li>Codechef - Fullmetal Alchemist</li> <li>Codeforces - Edges in MST</li> <li>UVA 12176 - Bring Your Own Horse</li> <li>UVA 10600 - ACM Contest and Blackout</li> <li>UVA 10724 - Road Construction</li> <li>Hackerrank - Roads in HackerLand</li> <li>UVA 11710 - Expensive subway</li> <li>Codechef - Chefland and Electricity</li> <li>UVA 10307 - Killing Aliens in Borg Maze</li> <li>Codeforces - Flea</li> <li>Codeforces - Igon in Museum</li> <li>Codeforces - Hongcow Builds a Nation</li> <li>UVA - 908 - Re-connecting Computer Sites</li> <li>UVA 1208 - Oreon</li> <li>UVA 1235 - Anti Brute Force Lock</li> <li>UVA 10034 - Freckles</li> <li>UVA 11228 - Transportation system</li> <li>UVA 11631 - Dark roads</li> <li>UVA 11733 - Airports</li> <li>UVA 11747 - Heavy Cycle Edges</li> <li>SPOJ - Blinet</li> <li>SPOJ - Help the Old King</li> <li>Codeforces - Hierarchy</li> <li>SPOJ - Modems</li> <li>CSES - Road Reparation</li> <li>CSES - Road Construction</li> </ul>","tags":["Translated"]},{"location":"graph/mst_kruskal_with_dsu.html","title":"Minimum spanning tree - Kruskal with Disjoint Set Union","text":"<p>For an explanation of the MST problem and the Kruskal algorithm, first see the main article on Kruskal's algorithm.</p> <p>In this article we will consider the data structure \"Disjoint Set Union\" for implementing Kruskal's algorithm, which will allow the algorithm to achieve the time complexity of $O(M \\log N)$.</p>","tags":["Translated"]},{"location":"graph/mst_kruskal_with_dsu.html#description","title":"Description","text":"<p>Just as in the simple version of the Kruskal algorithm, we sort all the edges of the graph in non-decreasing order of weights. Then put each vertex in its own tree (i.e. its set) via calls to the <code>make_set</code> function - it will take a total of $O(N)$. We iterate through all the edges (in sorted order) and for each edge determine whether the ends belong to different trees (with two <code>find_set</code> calls in $O(1)$ each). Finally, we need to perform the union of the two trees (sets), for which the DSU <code>union_sets</code> function will be called - also in $O(1)$. So we get the total time complexity of $O(M \\log N + N + M)$ = $O(M \\log N)$.</p>","tags":["Translated"]},{"location":"graph/mst_kruskal_with_dsu.html#implementation","title":"Implementation","text":"<p>Here is an implementation of Kruskal's algorithm with Union by Rank.</p> <pre><code>vector&lt;int&gt; parent, rank;\n\nvoid make_set(int v) {\n    parent[v] = v;\n    rank[v] = 0;\n}\n\nint find_set(int v) {\n    if (v == parent[v])\n        return v;\n    return parent[v] = find_set(parent[v]);\n}\n\nvoid union_sets(int a, int b) {\n    a = find_set(a);\n    b = find_set(b);\n    if (a != b) {\n        if (rank[a] &lt; rank[b])\n            swap(a, b);\n        parent[b] = a;\n        if (rank[a] == rank[b])\n            rank[a]++;\n    }\n}\n\nstruct Edge {\n    int u, v, weight;\n    bool operator&lt;(Edge const&amp; other) {\n        return weight &lt; other.weight;\n    }\n};\n\nint n;\nvector&lt;Edge&gt; edges;\n\nint cost = 0;\nvector&lt;Edge&gt; result;\nparent.resize(n);\nrank.resize(n);\nfor (int i = 0; i &lt; n; i++)\n    make_set(i);\n\nsort(edges.begin(), edges.end());\n\nfor (Edge e : edges) {\n    if (find_set(e.u) != find_set(e.v)) {\n        cost += e.weight;\n        result.push_back(e);\n        union_sets(e.u, e.v);\n    }\n}\n</code></pre> <p>Notice: since the MST will contain exactly $N-1$ edges, we can stop the for loop once we found that many.</p>","tags":["Translated"]},{"location":"graph/mst_kruskal_with_dsu.html#practice-problems","title":"Practice Problems","text":"<p>See main article on Kruskal's algorithm for the list of practice problems on this topic.</p>","tags":["Translated"]},{"location":"graph/mst_prim.html","title":"Minimum spanning tree - Prim's algorithm","text":"<p>Given a weighted, undirected graph $G$ with $n$ vertices and $m$ edges. You want to find a spanning tree of this graph which connects all vertices and has the least weight (i.e. the sum of weights of edges is minimal). A spanning tree is a set of edges such that any vertex can reach any other by exactly one simple path. The spanning tree with the least weight is called a minimum spanning tree.</p> <p>In the left image you can see a weighted undirected graph, and in the right image you can see the corresponding minimum spanning tree.</p> <p>It is easy to see that any spanning tree will necessarily contain $n-1$ edges.</p> <p>This problem appears quite naturally in a lot of problems. For instance in the following problem: there are $n$ cities and for each pair of cities we are given the cost to build a road between them (or we know that is physically impossible to build a road between them). We have to build roads, such that we can get from each city to every other city, and the cost for building all roads is minimal.</p>","tags":["Translated"]},{"location":"graph/mst_prim.html#prims-algorithm","title":"Prim's Algorithm","text":"<p>This algorithm was originally discovered by the Czech mathematician Vojt\u011bch Jarn\u00edk in 1930. However this algorithm is mostly known as Prim's algorithm after the American mathematician Robert Clay Prim, who rediscovered and republished it in 1957. Additionally Edsger Dijkstra published this algorithm in 1959.</p>","tags":["Translated"]},{"location":"graph/mst_prim.html#algorithm-description","title":"Algorithm description","text":"<p>Here we describe the algorithm in its simplest form. The minimum spanning tree is built gradually by adding edges one at a time. At first the spanning tree consists only of a single vertex (chosen arbitrarily). Then the minimum weight edge outgoing from this vertex is selected and added to the spanning tree. After that the spanning tree already consists of two vertices. Now select and add the edge with the minimum weight that has one end in an already selected vertex (i.e. a vertex that is already part of the spanning tree), and the other end in an unselected vertex. And so on, i.e. every time we select and add the edge with minimal weight that connects one selected vertex with one unselected vertex. The process is repeated until the spanning tree contains all vertices (or equivalently until we have $n - 1$ edges).</p> <p>In the end the constructed spanning tree will be minimal. If the graph was originally not connected, then there doesn't exist a spanning tree, so the number of selected edges will be less than $n - 1$.</p>","tags":["Translated"]},{"location":"graph/mst_prim.html#proof","title":"Proof","text":"<p>Let the graph $G$ be connected, i.e. the answer exists. We denote by $T$ the resulting graph found by Prim's algorithm, and by $S$ the minimum spanning tree. Obviously $T$ is indeed a spanning tree and a subgraph of $G$. We only need to show that the weights of $S$ and $T$ coincide.</p> <p>Consider the first time in the algorithm when we add an edge to $T$ that is not part of $S$. Let us denote this edge with $e$, its ends by $a$ and $b$, and the set of already selected vertices as $V$ ($a \\in V$ and $b \\notin V$, or vice versa).</p> <p>In the minimal spanning tree $S$ the vertices $a$ and $b$ are connected by some path $P$. On this path we can find an edge $f$ such that one end of $f$ lies in $V$ and the other end doesn't. Since the algorithm chose $e$ instead of $f$, it means that the weight of $f$ is greater or equal to the weight of $e$.</p> <p>We add the edge $e$ to the minimum spanning tree $S$ and remove the edge $f$. By adding $e$ we created a cycle, and since $f$ was also part of the only cycle, by removing it the resulting graph is again free of cycles. And because we only removed an edge from a cycle, the resulting graph is still connected.</p> <p>The resulting spanning tree cannot have a larger total weight, since the weight of $e$ was not larger than the weight of $f$, and it also cannot have a smaller weight since $S$ was a minimum spanning tree. This means that by replacing the edge $f$ with $e$ we generated a different minimum spanning tree. And $e$ has to have the same weight as $f$.</p> <p>Thus all the edges we pick in Prim's algorithm have the same weights as the edges of any minimum spanning tree, which means that Prim's algorithm really generates a minimum spanning tree.</p>","tags":["Translated"]},{"location":"graph/mst_prim.html#implementation","title":"Implementation","text":"<p>The complexity of the algorithm depends on how we search for the next minimal edge among the appropriate edges. There are multiple approaches leading to different complexities and different implementations.</p>","tags":["Translated"]},{"location":"graph/mst_prim.html#trivial-implementations-on-m-and-on2-m-log-n","title":"Trivial implementations: $O(n m)$ and $O(n^2 + m \\log n)$","text":"<p>If we search the edge by iterating over all possible edges, then it takes $O(m)$ time to find the edge with the minimal weight. The total complexity will be $O(n m)$. In the worst case this is $O(n^3)$, really slow.</p> <p>This algorithm can be improved if we only look at one edge from each already selected vertex. For example we can sort the edges from each vertex in ascending order of their weights, and store a pointer to the first valid edge (i.e. an edge that goes to an non-selected vertex). Then after finding and selecting the minimal edge, we update the pointers. This give a complexity of $O(n^2 + m)$, and for sorting the edges an additional $O(m \\log n)$, which gives the complexity $O(n^2 \\log n)$ in the worst case.</p> <p>Below we consider two slightly different algorithms, one for dense and one for sparse graphs, both with a better complexity.</p>","tags":["Translated"]},{"location":"graph/mst_prim.html#dense-graphs-on2","title":"Dense graphs: $O(n^2)$","text":"<p>We approach this problem from a different angle: for every not yet selected vertex we will store the minimum edge to an already selected vertex.</p> <p>Then during a step we only have to look at these minimum weight edges, which will have a complexity of $O(n)$.</p> <p>After adding an edge some minimum edge pointers have to be recalculated. Note that the weights only can decrease, i.e. the minimal weight edge of every not yet selected vertex might stay the same, or it will be updated by an edge to the newly selected vertex. Therefore this phase can also be done in $O(n)$.</p> <p>Thus we received a version of Prim's algorithm with the complexity $O(n^2)$.</p> <p>In particular this implementation is very convenient for the Euclidean Minimum Spanning Tree problem: we have $n$ points on a plane and the distance between each pair of points is the Euclidean distance between them, and we want to find a minimum spanning tree for this complete graph. This task can be solved by the described algorithm in $O(n^2)$ time and $O(n)$ memory, which is not possible with Kruskal's algorithm.</p> <pre><code>int n;\nvector&lt;vector&lt;int&gt;&gt; adj; // adjacency matrix of graph\nconst int INF = 1000000000; // weight INF means there is no edge\n\nstruct Edge {\n    int w = INF, to = -1;\n};\n\nvoid prim() {\n    int total_weight = 0;\n    vector&lt;bool&gt; selected(n, false);\n    vector&lt;Edge&gt; min_e(n);\n    min_e[0].w = 0;\n\n    for (int i=0; i&lt;n; ++i) {\n        int v = -1;\n        for (int j = 0; j &lt; n; ++j) {\n            if (!selected[j] &amp;&amp; (v == -1 || min_e[j].w &lt; min_e[v].w))\n                v = j;\n        }\n\n        if (min_e[v].w == INF) {\n            cout &lt;&lt; \"No MST!\" &lt;&lt; endl;\n            exit(0);\n        }\n\n        selected[v] = true;\n        total_weight += min_e[v].w;\n        if (min_e[v].to != -1)\n            cout &lt;&lt; v &lt;&lt; \" \" &lt;&lt; min_e[v].to &lt;&lt; endl;\n\n        for (int to = 0; to &lt; n; ++to) {\n            if (adj[v][to] &lt; min_e[to].w)\n                min_e[to] = {adj[v][to], v};\n        }\n    }\n\n    cout &lt;&lt; total_weight &lt;&lt; endl;\n}\n</code></pre> <p>The adjacency matrix <code>adj[][]</code> of size $n \\times n$ stores the weights of the edges, and it uses the weight <code>INF</code> if there doesn't exist an edge between two vertices. The algorithm uses two arrays: the flag <code>selected[]</code>, which indicates which vertices we already have selected, and the array <code>min_e[]</code> which stores the edge with minimal weight to a selected vertex for each not-yet-selected vertex (it stores the weight and the end vertex). The algorithm does $n$ steps, in each iteration the vertex with the smallest edge weight is selected, and the <code>min_e[]</code> of all other vertices gets updated.</p>","tags":["Translated"]},{"location":"graph/mst_prim.html#sparse-graphs-om-log-n","title":"Sparse graphs: $O(m \\log n)$","text":"<p>In the above described algorithm it is possible to interpret the operations of finding the minimum and modifying some values as set operations. These two classical operations are supported by many data structure, for example by <code>set</code> in C++ (which are implemented via red-black trees).</p> <p>The main algorithm remains the same, but now we can find the minimum edge in $O(\\log n)$ time. On the other hand recomputing the pointers will now take $O(n \\log n)$ time, which is worse than in the previous algorithm.</p> <p>But when we consider that we only need to update $O(m)$ times in total, and perform $O(n)$ searches for the minimal edge, then the total complexity will be $O(m \\log n)$. For sparse graphs this is better than the above algorithm, but for dense graphs this will be slower.</p> <pre><code>const int INF = 1000000000;\n\nstruct Edge {\n    int w = INF, to = -1;\n    bool operator&lt;(Edge const&amp; other) const {\n        return make_pair(w, to) &lt; make_pair(other.w, other.to);\n    }\n};\n\nint n;\nvector&lt;vector&lt;Edge&gt;&gt; adj;\n\nvoid prim() {\n    int total_weight = 0;\n    vector&lt;Edge&gt; min_e(n);\n    min_e[0].w = 0;\n    set&lt;Edge&gt; q;\n    q.insert({0, 0});\n    vector&lt;bool&gt; selected(n, false);\n    for (int i = 0; i &lt; n; ++i) {\n        if (q.empty()) {\n            cout &lt;&lt; \"No MST!\" &lt;&lt; endl;\n            exit(0);\n        }\n\n        int v = q.begin()-&gt;to;\n        selected[v] = true;\n        total_weight += q.begin()-&gt;w;\n        q.erase(q.begin());\n\n        if (min_e[v].to != -1)\n            cout &lt;&lt; v &lt;&lt; \" \" &lt;&lt; min_e[v].to &lt;&lt; endl;\n\n        for (Edge e : adj[v]) {\n            if (!selected[e.to] &amp;&amp; e.w &lt; min_e[e.to].w) {\n                q.erase({min_e[e.to].w, e.to});\n                min_e[e.to] = {e.w, v};\n                q.insert({e.w, e.to});\n            }\n        }\n    }\n\n    cout &lt;&lt; total_weight &lt;&lt; endl;\n}\n</code></pre> <p>Here the graph is represented via a adjacency list <code>adj[]</code>, where <code>adj[v]</code> contains all edges (in form of weight and target pairs) for the vertex <code>v</code>. <code>min_e[v]</code> will store the weight of the smallest edge from vertex <code>v</code> to an already selected vertex (again in the form of a weight and target pair). In addition the queue <code>q</code> is filled with all not yet selected vertices in the order of increasing weights <code>min_e</code>. The algorithm does <code>n</code> steps, on each of which it selects the vertex <code>v</code> with the smallest weight <code>min_e</code> (by extracting it from the beginning of the queue), and then looks through all the edges from this vertex and updates the values in <code>min_e</code> (during an update we also need to also remove the old edge from the queue <code>q</code> and put in the new edge).</p>","tags":["Translated"]},{"location":"graph/pruefer_code.html","title":"Pr\u00fcfer code","text":"<p>In this article we will look at the so-called Pr\u00fcfer code (or Pr\u00fcfer sequence), which is a way of encoding a labeled tree into a sequence of numbers in a unique way.</p> <p>With the help of the Pr\u00fcfer code we will prove Cayley's formula (which specified the number of spanning trees in a complete graph). Also we show the solution to the problem of counting the number of ways of adding edges to a graph to make it connected.</p> <p>Note, we will not consider trees consisting of a single vertex - this is a special case in which multiple statements clash.</p>","tags":["Translated"]},{"location":"graph/pruefer_code.html#prufer-code_1","title":"Pr\u00fcfer code","text":"<p>The Pr\u00fcfer code is a way of encoding a labeled tree with $n$ vertices using a sequence of $n - 2$ integers in the interval $[0; n-1]$. This encoding also acts as a bijection between all spanning trees of a complete graph and the numerical sequences.</p> <p>Although using the Pr\u00fcfer code for storing and operating on tree is impractical due the specification of the representation, the Pr\u00fcfer codes are used frequently: mostly in solving combinatorial problems.</p> <p>The inventor - Heinz Pr\u00fcfer - proposed this code in 1918 as a proof for Cayley's formula.</p>","tags":["Translated"]},{"location":"graph/pruefer_code.html#building-the-prufer-code-for-a-given-tree","title":"Building the Pr\u00fcfer code for a given tree","text":"<p>The Pr\u00fcfer code is constructed as follows. We will repeat the following procedure $n - 2$ times: we select the leaf of the tree with the smallest number, remove it from the tree, and write down the number of the vertex that was connected to it. After $n - 2$ iterations there will only remain $2$ vertices, and the algorithm ends.</p> <p>Thus the Pr\u00fcfer code for a given tree is a sequence of $n - 2$ numbers, where each number is the number of the connected vertex, i.e. this number is in the interval $[0, n-1]$.</p> <p>The algorithm for computing the Pr\u00fcfer code can be implemented easily with $O(n \\log n)$ time complexity, simply by using a data structure to extract the minimum (for instance <code>set</code> or <code>priority_queue</code> in C++), which contains a list of all the current leafs.</p> <pre><code>vector&lt;vector&lt;int&gt;&gt; adj;\n\nvector&lt;int&gt; pruefer_code() {\n    int n = adj.size();\n    set&lt;int&gt; leafs;\n    vector&lt;int&gt; degree(n);\n    vector&lt;bool&gt; killed(n, false);\n    for (int i = 0; i &lt; n; i++) {\n        degree[i] = adj[i].size();\n        if (degree[i] == 1)\n            leafs.insert(i);\n    }\n\n    vector&lt;int&gt; code(n - 2);\n    for (int i = 0; i &lt; n - 2; i++) {\n        int leaf = *leafs.begin();\n        leafs.erase(leafs.begin());\n        killed[leaf] = true;\n\n        int v;\n        for (int u : adj[leaf]) {\n            if (!killed[u])\n                v = u;\n        }\n\n        code[i] = v;\n        if (--degree[v] == 1)\n            leafs.insert(v);\n    }\n\n    return code;\n}\n</code></pre> <p>However the construction can also be implemented in linear time. Such an approach is described in the next section.</p>","tags":["Translated"]},{"location":"graph/pruefer_code.html#building-the-prufer-code-for-a-given-tree-in-linear-time","title":"Building the Pr\u00fcfer code for a given tree in linear time","text":"<p>The essence of the algorithm is to use a moving pointer, which will always point to the current leaf vertex that we want to remove.</p> <p>At first glance this seems impossible, because during the process of constructing the Pr\u00fcfer code the leaf number can increase and decrease. However after a closer look, this is actually not true. The number of leafs will not increase. Either the number decreases by one (we remove one leaf vertex and don't gain a new one), or it stay the same (we remove one leaf vertex and gain another one). In the first case there is no other way than searching for the next smallest leaf vertex. In the second case, however, we can decide in $O(1)$ time, if we can continue using the vertex that became a new leaf vertex, or if we have to search for the next smallest leaf vertex. And in quite a lot of times we can continue with the new leaf vertex.</p> <p>To do this we will use a variable $\\text{ptr}$, which will indicate that in the set of vertices between $0$ and $\\text{ptr}$ is at most one leaf vertex, namely the current one. All other vertices in that range are either already removed from the tree, or have still more than one adjacent vertices. At the same time we say, that we haven't removed any leaf vertices bigger than $\\text{ptr}$ yet.</p> <p>This variable is already very helpful in the first case. After removing the current leaf node, we know that there cannot be a leaf node between $0$ and $\\text{ptr}$, therefore we can start the search for the next one directly at $\\text{ptr} + 1$, and we don't have to start the search back at vertex $0$. And in the second case, we can further distinguish two cases: Either the newly gained leaf vertex is smaller than $\\text{ptr}$, then this must be the next leaf vertex, since we know that there are no other vertices smaller than $\\text{ptr}$. Or the newly gained leaf vertex is bigger. But then we also know that it has to be bigger than $\\text{ptr}$, and can start the search again at $\\text{ptr} + 1$.</p> <p>Even though we might have to perform multiple linear searches for the next leaf vertex, the pointer $\\text{ptr}$ only increases and therefore the time complexity in total is $O(n)$.</p> <pre><code>vector&lt;vector&lt;int&gt;&gt; adj;\nvector&lt;int&gt; parent;\n\nvoid dfs(int v) {\n    for (int u : adj[v]) {\n        if (u != parent[v]) {\n            parent[u] = v;\n            dfs(u);\n        }\n    }\n}\n\nvector&lt;int&gt; pruefer_code() {\n    int n = adj.size();\n    parent.resize(n);\n    parent[n-1] = -1;\n    dfs(n-1);\n\n    int ptr = -1;\n    vector&lt;int&gt; degree(n);\n    for (int i = 0; i &lt; n; i++) {\n        degree[i] = adj[i].size();\n        if (degree[i] == 1 &amp;&amp; ptr == -1)\n            ptr = i;\n    }\n\n    vector&lt;int&gt; code(n - 2);\n    int leaf = ptr;\n    for (int i = 0; i &lt; n - 2; i++) {\n        int next = parent[leaf];\n        code[i] = next;\n        if (--degree[next] == 1 &amp;&amp; next &lt; ptr) {\n            leaf = next;\n        } else {\n            ptr++;\n            while (degree[ptr] != 1)\n                ptr++;\n            leaf = ptr;\n        }\n    }\n\n    return code;\n}\n</code></pre> <p>In the code we first find for each its ancestor <code>parent[i]</code>, i.e. the ancestor that this vertex will have once we remove it from the tree. We can find this ancestor by rooting the tree at the vertex $n-1$. This is possible because the vertex $n-1$ will never be removed from the tree. We also compute the degree for each vertex. <code>ptr</code> is the pointer that indicates the minimum size of the remaining leaf vertices (except the current one <code>leaf</code>). We will either assign the current leaf vertex with <code>next</code>, if this one is also a leaf vertex and it is smaller than <code>ptr</code>, or we start a linear search for the smallest leaf vertex by increasing the pointer.</p> <p>It can be easily seen, that this code has the complexity $O(n)$.</p>","tags":["Translated"]},{"location":"graph/pruefer_code.html#some-properties-of-the-prufer-code","title":"Some properties of the Pr\u00fcfer code","text":"<ul> <li>After constructing the Pr\u00fcfer code two vertices will remain.   One of them is the highest vertex $n-1$, but nothing else can be said about the other one.</li> <li>Each vertex appears in the Pr\u00fcfer code exactly a fixed number of times - its degree minus one.   This can be easily checked, since the degree will get smaller every time we record its label in the code, and we remove it once the degree is $1$.   For the two remaining vertices this fact is also true.</li> </ul>","tags":["Translated"]},{"location":"graph/pruefer_code.html#restoring-the-tree-using-the-prufer-code","title":"Restoring the tree using the Pr\u00fcfer code","text":"<p>To restore the tree it suffice to only focus on the property discussed in the last section. We already know the degree of all the vertices in the desired tree. Therefore we can find all leaf vertices, and also the first leaf that was removed in the first step (it has to be the smallest leaf). This leaf vertex was connected to the vertex corresponding to the number in the first cell of the Pr\u00fcfer code.</p> <p>Thus we found the first edge removed by when then the Pr\u00fcfer code was generated. We can add this edge to the answer and reduce the degrees at both ends of the edge.</p> <p>We will repeat this operation until we have used all numbers of the Pr\u00fcfer code: we look for the minimum vertex with degree equal to $1$, connect it with the next vertex from the Pr\u00fcfer code, and reduce the degree.</p> <p>In the end we only have two vertices left with degree equal to $1$. These are the vertices that didn't got removed by the Pr\u00fcfer code process. We connect them to get the last edge of the tree. One of them will always be the vertex $n-1$.</p> <p>This algorithm can be implemented easily in $O(n \\log n)$: we use a data structure that supports extracting the minimum (for example <code>set&lt;&gt;</code> or <code>priority_queue&lt;&gt;</code> in C++) to store all the leaf vertices.</p> <p>The following implementation returns the list of edges corresponding to the tree.</p> <pre><code>vector&lt;pair&lt;int, int&gt;&gt; pruefer_decode(vector&lt;int&gt; const&amp; code) {\n    int n = code.size() + 2;\n    vector&lt;int&gt; degree(n, 1);\n    for (int i : code)\n        degree[i]++;\n\n    set&lt;int&gt; leaves;\n    for (int i = 0; i &lt; n; i++) {\n        if (degree[i] == 1)\n            leaves.insert(i);\n    }\n\n    vector&lt;pair&lt;int, int&gt;&gt; edges;\n    for (int v : code) {\n        int leaf = *leaves.begin();\n        leaves.erase(leaves.begin());\n\n        edges.emplace_back(leaf, v);\n        if (--degree[v] == 1)\n            leaves.insert(v);\n    }\n    edges.emplace_back(*leaves.begin(), n-1);\n    return edges;\n}\n</code></pre>","tags":["Translated"]},{"location":"graph/pruefer_code.html#restoring-the-tree-using-the-prufer-code-in-linear-time","title":"Restoring the tree using the Pr\u00fcfer code in linear time","text":"<p>To obtain the tree in linear time we can apply the same technique used to obtain the Pr\u00fcfer code in linear time.</p> <p>We don't need a data structure to extract the minimum. Instead we can notice that, after processing the current edge, only one vertex becomes a leaf. Therefore we can either continue with this vertex, or we find a smaller one with a linear search by moving a pointer.</p> <pre><code>vector&lt;pair&lt;int, int&gt;&gt; pruefer_decode(vector&lt;int&gt; const&amp; code) {\n    int n = code.size() + 2;\n    vector&lt;int&gt; degree(n, 1);\n    for (int i : code)\n        degree[i]++;\n\n    int ptr = 0;\n    while (degree[ptr] != 1)\n        ptr++;\n    int leaf = ptr;\n\n    vector&lt;pair&lt;int, int&gt;&gt; edges;\n    for (int v : code) {\n        edges.emplace_back(leaf, v);\n        if (--degree[v] == 1 &amp;&amp; v &lt; ptr) {\n            leaf = v;\n        } else {\n            ptr++;\n            while (degree[ptr] != 1)\n                ptr++;\n            leaf = ptr;\n        }\n    }\n    edges.emplace_back(leaf, n-1);\n    return edges;\n}\n</code></pre>","tags":["Translated"]},{"location":"graph/pruefer_code.html#bijection-between-trees-and-prufer-codes","title":"Bijection between trees and Pr\u00fcfer codes","text":"<p>For each tree there exists a Pr\u00fcfer code corresponding to it. And for each Pr\u00fcfer code we can restore the original tree.</p> <p>It follows that also every Pr\u00fcfer code (i.e. a sequence of $n-2$ numbers in the range $[0; n - 1]$) corresponds to a tree.</p> <p>Therefore all trees and all Pr\u00fcfer codes form a bijection (a one-to-one correspondence).</p>","tags":["Translated"]},{"location":"graph/pruefer_code.html#cayleys-formula","title":"Cayley's formula","text":"<p>Cayley's formula states that the number of spanning trees in a complete labeled graph with $n$ vertices is equal to:</p> $$n^{n-2}$$ <p>There are multiple proofs for this formula. Using the Pr\u00fcfer code concept this statement comes without any surprise.</p> <p>In fact any Pr\u00fcfer code with $n-2$ numbers from the interval $[0; n-1]$ corresponds to some tree with $n$ vertices. So we have $n^{n-2}$ different such Pr\u00fcfer codes. Since each such tree is a spanning tree of a complete graph with $n$ vertices, the number of such spanning trees is also $n^{n-2}$.</p>","tags":["Translated"]},{"location":"graph/pruefer_code.html#number-of-ways-to-make-a-graph-connected","title":"Number of ways to make a graph connected","text":"<p>The concept of Pr\u00fcfer codes are even more powerful. It allows to create a lot more general formulas than Cayley's formula.</p> <p>In this problem we are given a graph with $n$ vertices and $m$ edges. The graph currently has $k$ components. We want to compute the number of ways of adding $k-1$ edges so that the graph becomes connected (obviously $k-1$ is the minimum number necessary to make the graph connected).</p> <p>Let us derive a formula for solving this problem.</p> <p>We use $s_1, \\dots, s_k$ for the sizes of the connected components in the graph. We cannot add edges within a connected component. Therefore it turns out that this problem is very similar to the search for the number of spanning trees of a complete graph with $k$ vertices. The only difference is that each vertex has actually the size $s_i$: each edge connecting the vertex $i$, actually multiplies the answer by $s_i$.</p> <p>Thus in order to calculate the number of possible ways it is important to count how often each of the $k$ vertices is used in the connecting tree. To obtain a formula for the problem it is necessary to sum the answer over all possible degrees.</p> <p>Let $d_1, \\dots, d_k$ be the degrees of the vertices in the tree after connecting the vertices. The sum of the degrees is twice the number of edges:</p> $$\\sum_{i=1}^k d_i = 2k - 2$$ <p>If the vertex $i$ has degree $d_i$, then it appears $d_i - 1$ times in the Pr\u00fcfer code. The Pr\u00fcfer code for a tree with $k$ vertices has length $k-2$. So the number of ways to choose a code with $k-2$ numbers where the number $i$ appears exactly $d_i - 1$ times is equal to the multinomial coefficient</p> $$\\binom{k-2}{d_1-1, d_2-1, \\dots, d_k-1} = \\frac{(k-2)!}{(d_1-1)! (d_2-1)! \\cdots (d_k-1)!}.$$ <p>The fact that each edge adjacent to the vertex $i$ multiplies the answer by $s_i$ we receive the answer, assuming that the degrees of the vertices are $d_1, \\dots, d_k$:</p> $$s_1^{d_1} \\cdot s_2^{d_2} \\cdots s_k^{d_k} \\cdot \\binom{k-2}{d_1-1, d_2-1, \\dots, d_k-1}$$ <p>To get the final answer we need to sum this for all possible ways to choose the degrees:</p> $$\\sum_{\\substack{d_i \\ge 1 \\\\\\\\ \\sum_{i=1}^k d_i = 2k -2}} s_1^{d_1} \\cdot s_2^{d_2} \\cdots s_k^{d_k} \\cdot \\binom{k-2}{d_1-1, d_2-1, \\dots, d_k-1}$$ <p>Currently this looks like a really horrible answer, however we can use the multinomial theorem, which says:</p> $$(x_1 + \\dots + x_m)^p = \\sum_{\\substack{c_i \\ge 0 \\\\\\\\ \\sum_{i=1}^m c_i = p}} x_1^{c_1} \\cdot x_2^{c_2} \\cdots x_m^{c_m} \\cdot \\binom{p}{c_1, c_2, \\dots c_m}$$ <p>This look already pretty similar. To use it we only need to substitute with $e_i = d_i - 1$:</p> $$\\sum_{\\substack{e_i \\ge 0 \\\\\\\\ \\sum_{i=1}^k e_i = k - 2}} s_1^{e_1+1} \\cdot s_2^{e_2+1} \\cdots s_k^{e_k+1} \\cdot \\binom{k-2}{e_1, e_2, \\dots, e_k}$$ <p>After applying the multinomial theorem we get the answer to the problem:</p> $$s_1 \\cdot s_2 \\cdots s_k \\cdot (s_1 + s_2 + \\dots + s_k)^{k-2} = s_1 \\cdot s_2 \\cdots s_k \\cdot n^{k-2}$$ <p>By accident this formula also holds for $k = 1$.</p>","tags":["Translated"]},{"location":"graph/pruefer_code.html#practice-problems","title":"Practice problems","text":"<ul> <li>UVA #10843 - Anne's game</li> <li>Timus #1069 - Prufer Code</li> <li>Codeforces - Clues</li> <li>Topcoder - TheCitiesAndRoadsDivTwo</li> </ul>","tags":["Translated"]},{"location":"graph/push-relabel-faster.html","title":"Maximum flow - Push-relabel method improved","text":"<p>We will modify the push-relabel method to achieve a better runtime.</p>","tags":["Translated"]},{"location":"graph/push-relabel-faster.html#description","title":"Description","text":"<p>The modification is extremely simple: In the previous article we chosen a vertex with excess without any particular rule. But it turns out, that if we always choose the vertices with the greatest height, and apply push and relabel operations on them, then the complexity will become better. Moreover, to select the vertices with the greatest height we actually don't need any data structures, we simply store the vertices with the greatest height in a list, and recalculate the list once all of them are processed (then vertices with already lower height will be added to the list), or whenever a new vertex with excess and a greater height appears (after relabeling a vertex).</p> <p>Despite the simplicity, this modification reduces the complexity by a lot. To be precise, the complexity of the resulting algorithm is $O(V E + V^2 \\sqrt{E})$, which in the worst case is $O(V^3)$.</p> <p>This modification was proposed by Cheriyan and Maheshwari in 1989.</p>","tags":["Translated"]},{"location":"graph/push-relabel-faster.html#implementation","title":"Implementation","text":"<pre><code>const int inf = 1000000000;\n\nint n;\nvector&lt;vector&lt;int&gt;&gt; capacity, flow;\nvector&lt;int&gt; height, excess;\n\nvoid push(int u, int v)\n{\n    int d = min(excess[u], capacity[u][v] - flow[u][v]);\n    flow[u][v] += d;\n    flow[v][u] -= d;\n    excess[u] -= d;\n    excess[v] += d;\n}\n\nvoid relabel(int u)\n{\n    int d = inf;\n    for (int i = 0; i &lt; n; i++) {\n        if (capacity[u][i] - flow[u][i] &gt; 0)\n            d = min(d, height[i]);\n    }\n    if (d &lt; inf)\n        height[u] = d + 1;\n}\n\nvector&lt;int&gt; find_max_height_vertices(int s, int t) {\n    vector&lt;int&gt; max_height;\n    for (int i = 0; i &lt; n; i++) {\n        if (i != s &amp;&amp; i != t &amp;&amp; excess[i] &gt; 0) {\n            if (!max_height.empty() &amp;&amp; height[i] &gt; height[max_height[0]])\n                max_height.clear();\n            if (max_height.empty() || height[i] == height[max_height[0]])\n                max_height.push_back(i);\n        }\n    }\n    return max_height;\n}\n\nint max_flow(int s, int t)\n{\n    height.assign(n, 0);\n    height[s] = n;\n    flow.assign(n, vector&lt;int&gt;(n, 0));\n    excess.assign(n, 0);\n    excess[s] = inf;\n    for (int i = 0; i &lt; n; i++) {\n        if (i != s)\n            push(s, i);\n    }\n\n    vector&lt;int&gt; current;\n    while (!(current = find_max_height_vertices(s, t)).empty()) {\n        for (int i : current) {\n            bool pushed = false;\n            for (int j = 0; j &lt; n &amp;&amp; excess[i]; j++) {\n                if (capacity[i][j] - flow[i][j] &gt; 0 &amp;&amp; height[i] == height[j] + 1) {\n                    push(i, j);\n                    pushed = true;\n                }\n            }\n            if (!pushed) {\n                relabel(i);\n                break;\n            }\n        }\n    }\n\n    return excess[t];\n}\n</code></pre>","tags":["Translated"]},{"location":"graph/push-relabel.html","title":"Maximum flow - Push-relabel algorithm","text":"<p>The push-relabel algorithm (or also known as preflow-push algorithm) is an algorithm for computing the maximum flow of a flow network. The exact definition of the problem that we want to solve can be found in the article Maximum flow - Ford-Fulkerson and Edmonds-Karp.</p> <p>In this article we will consider solving the problem by pushing a preflow through the network, which will run in $O(V^4)$, or more precisely in $O(V^2 E)$, time. The algorithm was designed by Andrew Goldberg and Robert Tarjan in 1985.</p>","tags":["Translated"]},{"location":"graph/push-relabel.html#definitions","title":"Definitions","text":"<p>During the algorithm we will have to handle a preflow - i.e. a function $f$ that is similar to the flow function, but does not necessarily satisfies the flow conservation constraint. For it only the constraints</p> $$0 \\le f(e) \\le c(e)$$ <p>and</p> $$\\sum_{(v, u) \\in E} f((v, u)) \\ge \\sum_{(u, v) \\in E} f((u, v))$$ <p>have to hold.</p> <p>So it is possible for some vertex to receive more flow than it distributes. We say that this vertex has some excess flow, and define the amount of it with the excess function $x(u) =\\sum_{(v, u) \\in E} f((v, u)) - \\sum_{(u, v) \\in E} f((u, v))$.</p> <p>In the same way as with the flow function, we can define the residual capacities and the residual graph with the preflow function.</p> <p>The algorithm will start off with an initial preflow (some vertices having excess), and during the execution the preflow will be handled and modified. Giving away some details already, the algorithm will pick a vertex with excess, and push the excess to neighboring vertices. It will repeat this until all vertices, except the source and the sink, are free from excess. It is easy to see, that a preflow without excess is a valid flow. This makes the algorithm terminate with an actual flow.</p> <p>There are still two problem, we have to deal with. First, how do we guarantee that this actually terminates? And secondly, how do we guarantee that this will actually give us a maximum flow, and not just any random flow?</p> <p>To solve these problems we need the help of another function, namely the labeling functions $h$, often also called height function, which assigns each vertex an integer. We call a labeling is valid, if $h(s) = |V|$, $h(t) = 0$, and $h(u) \\le h(v) + 1$ if there is an edge $(u, v)$ in the residual graph - i.e. the edge $(u, v)$ has a positive capacity in the residual graph. In other words, if it is possible to increase the flow from $u$ to $v$, then the height of $v$ can be at most one smaller than the height of $u$, but it can be equal or even higher.</p> <p>It is important to note, that if there exists a valid labeling function, then there doesn't exist an augmenting path from $s$ to $t$ in the residual graph. Because such a path will have a length of at most $|V| - 1$ edges, and each edge can decrease the height only by at most by one, which is impossible if the first height is $h(s) = |V|$ and the last height is $h(t) = 0$.</p> <p>Using this labeling function we can state the strategy of the push-relabel algorithm: We start with a valid preflow and a valid labeling function. In each step we push some excess between vertices, and update the labels of vertices. We have to make sure, that after each step the preflow and the labeling are still valid. If then the algorithm determines, the preflow is a valid flow. And because we also have a valid labeling, there doesn't exists a path between $s$ and $t$ in the residual graph, which means that the flow is actually a maximum flow.</p> <p>If we compare the Ford-Fulkerson algorithm with the push-relabel algorithm it seems like the algorithms are the duals of each other. The Ford-Fulkerson algorithm keeps a valid flow at all time and improves it until there doesn't exists an augmenting path any more, while in the push-relabel algorithm there doesn't exists an augmenting path at any time, and we will improve the preflow until it is a valid flow.</p>","tags":["Translated"]},{"location":"graph/push-relabel.html#algorithm","title":"Algorithm","text":"<p>First we have to initialize the graph with a valid preflow and labeling function.</p> <p>Using the empty preflow - like it is done in the Ford-Fulkerson algorithm - is not possible, because then there will be an augmenting path and this implies that there doesn't exists a valid labeling. Therefore we will initialize each edges outgoing from $s$ with its maximal capacity: $f((s, u)) = c((s, u))$. And all other edges with zero. In this case there exists a valid labeling, namely $h(s) = |V|$ for the source vertex and $h(u) = 0$ for all other.</p> <p>Now let's describe the two operations in more detail.</p> <p>With the <code>push</code> operation we try to push as much excess flow from one vertex $u$ to a neighboring vertex $v$. We have one rule: we are only allowed to push flow from $u$ to $v$ if $h(u) = h(v) + 1$. In layman's terms, the excess flow has to flow downwards, but not too steeply. Of course we only can push $\\min(x(u), c((u, v)) - f((u, v)))$ flow.</p> <p>If a vertex has excess, but it is not possible to push the excess to any adjacent vertex, then we need to increase the height of this vertex. We call this operation <code>relabel</code>. We will increase it by as much as it is possible, while still maintaining validity of the labeling.</p> <p>To recap, the algorithm in a nutshell is: We initialize a valid preflow and a valid labeling. While we can perform push or relabel operations, we perform them. Afterwards the preflow is actually a flow and we return it.</p>","tags":["Translated"]},{"location":"graph/push-relabel.html#complexity","title":"Complexity","text":"<p>It is easy to show, that the maximal label of a vertex is $2|V| - 1$. At this point all remaining excess can and will be pushed back to the source. This gives at most $O(V^2)$ relabel operations.</p> <p>It can also be showed, that there will be at most $O(V E)$ saturating pushes (a push where the total capacity of the edge is used) and at most $O(V^2 E)$ non-saturating pushes (a push where the capacity of an edge is not fully used) performed. If we pick a data structure that allows us to find the next vertex with excess in $O(1)$ time, then the total complexity of the algorithm is $O(V^2 E)$.</p>","tags":["Translated"]},{"location":"graph/push-relabel.html#implementation","title":"Implementation","text":"<pre><code>const int inf = 1000000000;\n\nint n;\nvector&lt;vector&lt;int&gt;&gt; capacity, flow;\nvector&lt;int&gt; height, excess, seen;\nqueue&lt;int&gt; excess_vertices;\n\nvoid push(int u, int v) {\n    int d = min(excess[u], capacity[u][v] - flow[u][v]);\n    flow[u][v] += d;\n    flow[v][u] -= d;\n    excess[u] -= d;\n    excess[v] += d;\n    if (d &amp;&amp; excess[v] == d)\n        excess_vertices.push(v);\n}\n\nvoid relabel(int u) {\n    int d = inf;\n    for (int i = 0; i &lt; n; i++) {\n        if (capacity[u][i] - flow[u][i] &gt; 0)\n            d = min(d, height[i]);\n    }\n    if (d &lt; inf)\n        height[u] = d + 1;\n}\n\nvoid discharge(int u) {\n    while (excess[u] &gt; 0) {\n        if (seen[u] &lt; n) {\n            int v = seen[u];\n            if (capacity[u][v] - flow[u][v] &gt; 0 &amp;&amp; height[u] &gt; height[v])\n                push(u, v);\n            else \n                seen[u]++;\n        } else {\n            relabel(u);\n            seen[u] = 0;\n        }\n    }\n}\n\nint max_flow(int s, int t) {\n    height.assign(n, 0);\n    height[s] = n;\n    flow.assign(n, vector&lt;int&gt;(n, 0));\n    excess.assign(n, 0);\n    excess[s] = inf;\n    for (int i = 0; i &lt; n; i++) {\n        if (i != s)\n            push(s, i);\n    }\n    seen.assign(n, 0);\n\n    while (!excess_vertices.empty()) {\n        int u = excess_vertices.front();\n        excess_vertices.pop();\n        if (u != s &amp;&amp; u != t)\n            discharge(u);\n    }\n\n    int max_flow = 0;\n    for (int i = 0; i &lt; n; i++)\n        max_flow += flow[i][t];\n    return max_flow;\n}\n</code></pre> <p>Here we use the queue <code>excess_vertices</code> to store all vertices that currently have excess. In that way we can pick the next vertex for a push or a relabel operation in constant time.</p> <p>And to make sure that we don't spend too much time finding the adjacent vertex to whom we can push, we use a data structure called current-arc. Basically we will iterate over the edges in a circular order and always store the last edge that we used. This way, for a certain labeling value, we will switch the current edge only $O(n)$ time. And since the relabeling already takes $O(n)$ time, we don't make the complexity worse.</p>","tags":["Translated"]},{"location":"graph/rmq_linear.html","title":"Solve RMQ (Range Minimum Query) by finding LCA (Lowest Common Ancestor)","text":"<p>Given an array <code>A[0..N-1]</code>. For each query of the form <code>[L, R]</code> we want to find the minimum in the array <code>A</code> starting from position <code>L</code> and ending with position <code>R</code>. We will assume that the array <code>A</code> doesn't change in the process, i.e. this article describes a solution to the static RMQ problem</p> <p>Here is a description of an asymptotically optimal solution. It stands apart from other solutions for the RMQ problem, since it is very different from them: it reduces the RMQ problem to the LCA problem, and then uses the Farach-Colton and Bender algorithm, which reduces the LCA problem back to a specialized RMQ problem and solves that.</p>","tags":["Translated"]},{"location":"graph/rmq_linear.html#algorithm","title":"Algorithm","text":"<p>We construct a Cartesian tree from the array <code>A</code>. A Cartesian tree of an array <code>A</code> is a binary tree with the min-heap property (the value of parent node has to be smaller or equal than the value of its children) such that the in-order traversal of the tree visits the nodes in the same order as they are in the array <code>A</code>.</p> <p>In other words, a Cartesian tree is a recursive data structure. The array <code>A</code> will be partitioned into 3 parts: the prefix of the array up to the minimum, the minimum, and the remaining suffix. The root of the tree will be a node corresponding to the minimum element of the array <code>A</code>, the left subtree will be the Cartesian tree of the prefix, and the right subtree will be a Cartesian tree of the suffix.</p> <p>In the following image you can see one array of length 10 and the corresponding Cartesian tree.</p> <p>The range minimum query <code>[l, r]</code> is equivalent to the lowest common ancestor query <code>[l', r']</code>, where <code>l'</code> is the node corresponding to the element <code>A[l]</code> and <code>r'</code> the node corresponding to the element <code>A[r]</code>. Indeed the node corresponding to the smallest element in the range has to be an ancestor of all nodes in the range, therefor also from <code>l'</code> and <code>r'</code>. This automatically follows from the min-heap property. And is also has to be the lowest ancestor, because otherwise <code>l'</code> and <code>r'</code> would be both in the left or in the right subtree, which generates a contradiction since in such a case the minimum wouldn't even be in the range.</p> <p>In the following image you can see the LCA queries for the RMQ queries <code>[1, 3]</code> and <code>[5, 9]</code>. In the first query the LCA of the nodes <code>A[1]</code> and <code>A[3]</code> is the node corresponding to <code>A[2]</code> which has the value 2, and in the second query the LCA of <code>A[5]</code> and <code>A[9]</code> is the node corresponding to <code>A[8]</code> which has the value 3.</p> <p>Such a tree can be built in $O(N)$ time and the Farach-Colton and Benders algorithm can preprocess the tree in $O(N)$ and find the LCA in $O(1)$.</p>","tags":["Translated"]},{"location":"graph/rmq_linear.html#construction-of-a-cartesian-tree","title":"Construction of a Cartesian tree","text":"<p>We will build the Cartesian tree by adding the elements one after another. In each step we maintain a valid Cartesian tree of all the processed elements. It is easy to see, that adding an element <code>s[i]</code> can only change the nodes in the most right path - starting at the root and repeatedly taking the right child - of the tree. The subtree of the node with the smallest, but greater or equal than <code>s[i]</code>, value becomes the left subtree of <code>s[i]</code>, and the tree with root <code>s[i]</code> will become the new right subtree of the node with the biggest, but smaller than <code>s[i]</code> value.</p> <p>This can be implemented by using a stack to store the indices of the most right nodes.</p> <pre><code>vector&lt;int&gt; parent(n, -1);\nstack&lt;int&gt; s;\nfor (int i = 0; i &lt; n; i++) {\n    int last = -1;\n    while (!s.empty() &amp;&amp; A[s.top()] &gt;= A[i]) {\n        last = s.top();\n        s.pop();\n    }\n    if (!s.empty())\n        parent[i] = s.top();\n    if (last &gt;= 0)\n        parent[last] = i;\n    s.push(i);\n}\n</code></pre>","tags":["Translated"]},{"location":"graph/search-for-connected-components.html","title":"Search for connected components in a graph","text":"<p>Given an undirected graph $G$ with $n$ nodes and $m$ edges. We are required to find in it all the connected components, i.e, several groups of vertices such that within a group each vertex can be reached from another and no path exists between different groups.</p>","tags":["Translated"]},{"location":"graph/search-for-connected-components.html#an-algorithm-for-solving-the-problem","title":"An algorithm for solving the problem","text":"<ul> <li> <p>To solve the problem, we can use Depth First Search or Breadth First Search.</p> </li> <li> <p>In fact, we will be doing a series of rounds of DFS: The first round will start from first node and all the nodes in the first connected component will be traversed (found). Then we find the first unvisited node of the remaining nodes, and run Depth First Search on it, thus finding a second connected component. And so on, until all the nodes are visited.</p> </li> <li> <p>The total asymptotic running time of this algorithm is $O(n + m)$ : In fact, this algorithm will not run on the same vertex twice, which means that each edge will be seen exactly two times (at one end and at the other end).</p> </li> </ul>","tags":["Translated"]},{"location":"graph/search-for-connected-components.html#implementation","title":"Implementation","text":"<pre><code>int n;\nvector&lt;vector&lt;int&gt;&gt; adj;\nvector&lt;bool&gt; used;\nvector&lt;int&gt; comp;\n\nvoid dfs(int v) {\n    used[v] = true ;\n    comp.push_back(v);\n    for (int u : adj[v]) {\n        if (!used[u])\n            dfs(u);\n    }\n}\n\nvoid find_comps() {\n    fill(used.begin(), used.end(), 0);\n    for (int v = 0; v &lt; n; ++v) {\n        if (!used[v]) {\n            comp.clear();\n            dfs(v);\n            cout &lt;&lt; \"Component:\" ;\n            for (int u : comp)\n                cout &lt;&lt; ' ' &lt;&lt; u;\n            cout &lt;&lt; endl ;\n        }\n    }\n}\n</code></pre> <ul> <li> <p>The most important function that is used is <code>find_comps()</code> which finds and displays connected components of the graph.</p> </li> <li> <p>The graph is stored in adjacency list representation, i.e <code>adj[v]</code> contains a list of vertices that have edges from the vertex <code>v</code>.</p> </li> <li> <p>Vector <code>comp</code> contains a list of nodes in the current connected component.</p> </li> </ul>","tags":["Translated"]},{"location":"graph/search-for-connected-components.html#iterative-implementation-of-the-code","title":"Iterative implementation of the code","text":"<p>Deeply recursive functions are in general bad. Every single recursive call will require a little bit of memory in the stack, and per default programs only have a limited amount of stack space. So when you do a recursive DFS over a connected graph with millions of nodes, you might run into stack overflows.</p> <p>It is always possible to translate a recursive program into an iterative program, by manually maintaining a stack data structure. Since this data structure is allocated on the heap, no stack overflow will occur.</p> <pre><code>int n;\nvector&lt;vector&lt;int&gt;&gt; adj;\nvector&lt;bool&gt; used;\nvector&lt;int&gt; comp;\n\nvoid dfs(int v) {\n    stack&lt;int&gt; st;\n    st.push(v);\n\n    while (!st.empty()) {\n        int curr = st.top();\n        st.pop();\n        if (!used[curr]) {\n            used[curr] = true;\n            comp.push_back(curr);\n            for (int i = adj[curr].size() - 1; i &gt;= 0; i--) {\n                st.push(adj[curr][i]);\n            }\n        }\n    }\n}\n\nvoid find_comps() {\n    fill(used.begin(), used.end(), 0);\n    for (int v = 0; v &lt; n ; ++v) {\n        if (!used[v]) {\n            comp.clear();\n            dfs(v);\n            cout &lt;&lt; \"Component:\" ;\n            for (int u : comp)\n                cout &lt;&lt; ' ' &lt;&lt; u;\n            cout &lt;&lt; endl ;\n        }\n    }\n}\n</code></pre>","tags":["Translated"]},{"location":"graph/search-for-connected-components.html#practice-problems","title":"Practice Problems","text":"<ul> <li>SPOJ: CT23E</li> <li>CODECHEF: GERALD07</li> <li>CSES : Building Roads</li> </ul>","tags":["Translated"]},{"location":"graph/second_best_mst.html","title":"Second Best Minimum Spanning Tree","text":"<p>A Minimum Spanning Tree $T$ is a tree for the given graph $G$ which spans over all vertices of the given graph and has the minimum weight sum of all the edges, from all the possible spanning trees. A second best MST $T'$ is a spanning tree, that has the second minimum weight sum of all the edges, from all the possible spanning trees of the graph $G$.</p>","tags":["Original"]},{"location":"graph/second_best_mst.html#observation","title":"Observation","text":"<p>Let $T$ be the Minimum Spanning Tree of a graph $G$. It can be observed, that the second best Minimum Spanning Tree differs from $T$ by only one edge replacement. (For a proof of this statement refer to problem 23-1 here).</p> <p>So we need to find an edge $e_{new}$ which is in not in $T$, and replace it with an edge in $T$ (let it be $e_{old}$) such that the new graph $T' = (T \\cup \\{e_{new}\\}) \\setminus \\{e_{old}\\}$ is a spanning tree and the weight difference ($e_{new} - e_{old}$) is minimum.</p>","tags":["Original"]},{"location":"graph/second_best_mst.html#using-kruskals-algorithm","title":"Using Kruskal's Algorithm","text":"<p>We can use Kruskal's algorithm to find the MST first, and then just try to remove a single edge from it and replace it with another.</p> <ol> <li>Sort the edges in $O(E \\log E)$, then find a MST using Kruskal in $O(E)$.</li> <li>For each edge in the MST (we will have $V-1$ edges in it) temporarily exclude it from the edge list so that it cannot be chosen.</li> <li>Then, again try to find a MST in $O(E)$ using the remaining edges.</li> <li>Do this for all the edges in MST, and take the best of all.</li> </ol> <p>Note: we don\u2019t need to sort the edges again in for Step 3.</p> <p>So, the overall time complexity will be $O(E \\log V + E + V E)$ = $O(V E)$.</p>","tags":["Original"]},{"location":"graph/second_best_mst.html#modeling-into-a-lowest-common-ancestor-lca-problem","title":"Modeling into a Lowest Common Ancestor (LCA) problem","text":"<p>In the previous approach we tried all possibilities of removing one edge of the MST. Here we will do the exact opposite. We try to add every edge that is not already in the MST.</p> <ol> <li>Sort the edges in $O(E \\log E)$, then find a MST using Kruskal in $O(E)$.</li> <li>For each edge $e$ not already in the MST, temporarily add it to the MST, creating a cycle. The cycle will pass through the LCA.</li> <li>Find the edge $k$ with maximal weight in the cycle that is not equal to $e$, by following the parents of the nodes of edge $e$, up to the LCA.</li> <li>Remove $k$ temporarily, creating a new spanning tree.</li> <li>Compute the weight difference $\\delta = weight(e) - weight(k)$, and remember it together with the changed edge.</li> <li>Repeat step 2 for all other edges, and return the spanning tree with the smallest weight difference to the MST.</li> </ol> <p>The time complexity of the algorithm depends on how we compute the $k$s, which are the maximum weight edges in step 2 of this algorithm. One way to compute them efficiently in $O(E \\log V)$ is to transform the problem into a Lowest Common Ancestor (LCA) problem.</p> <p>We will preprocess the LCA by rooting the MST and will also compute the maximum edge weights for each node on the paths to their ancestors.  This can be done using Binary Lifting for LCA.</p> <p>The final time complexity of this approach is $O(E \\log V)$.</p> <p>For example:</p>   *In the image left is the MST and right is the second best MST.*  <p>In the given graph suppose we root the MST at the blue vertex on the top, and then run our algorithm by start picking the edges not in MST. Let the edge picked first be the edge $(u, v)$ with weight 36. Adding this edge to the tree forms a cycle 36 - 7 - 2 - 34.</p> <p>Now we will find the maximum weight edge in this cycle by finding the $\\text{LCA}(u, v) = p$. We compute the maximum weight edge on the paths from $u$ to $p$ and from $v$ to $p$. Note: the $\\text{LCA}(u, v)$ can also be equal to $u$ or $v$ in some case. In this example we will get the edge with weight 34 as maximum edge weight in the cycle. By removing the edge we get a new spanning tree, that has a weight difference of only 2.</p> <p>After doing this also with all other edges that are not part of the initial MST, we can see that this spanning tree was also the second best spanning tree overall. Choosing the edge with weight 14 will increase the weight of the tree by 7, choosing the edge with weight 27 increases it by 14, choosing the edge with weight 28 increases it by 21, and choosing the edge with weight 39 will increase the tree by 5.</p>","tags":["Original"]},{"location":"graph/second_best_mst.html#implementation","title":"Implementation","text":"<pre><code>struct edge {\n    int s, e, w, id;\n    bool operator&lt;(const struct edge&amp; other) { return w &lt; other.w; }\n};\ntypedef struct edge Edge;\n\nconst int N = 2e5 + 5;\nlong long res = 0, ans = 1e18;\nint n, m, a, b, w, id, l = 21;\nvector&lt;Edge&gt; edges;\nvector&lt;int&gt; h(N, 0), parent(N, -1), size(N, 0), present(N, 0);\nvector&lt;vector&lt;pair&lt;int, int&gt;&gt;&gt; adj(N), dp(N, vector&lt;pair&lt;int, int&gt;&gt;(l));\nvector&lt;vector&lt;int&gt;&gt; up(N, vector&lt;int&gt;(l, -1));\n\npair&lt;int, int&gt; combine(pair&lt;int, int&gt; a, pair&lt;int, int&gt; b) {\n    vector&lt;int&gt; v = {a.first, a.second, b.first, b.second};\n    int topTwo = -3, topOne = -2;\n    for (int c : v) {\n        if (c &gt; topOne) {\n            topTwo = topOne;\n            topOne = c;\n        } else if (c &gt; topTwo &amp;&amp; c &lt; topOne) {\n            topTwo = c;\n        }\n    }\n    return {topOne, topTwo};\n}\n\nvoid dfs(int u, int par, int d) {\n    h[u] = 1 + h[par];\n    up[u][0] = par;\n    dp[u][0] = {d, -1};\n    for (auto v : adj[u]) {\n        if (v.first != par) {\n            dfs(v.first, u, v.second);\n        }\n    }\n}\n\npair&lt;int, int&gt; lca(int u, int v) {\n    pair&lt;int, int&gt; ans = {-2, -3};\n    if (h[u] &lt; h[v]) {\n        swap(u, v);\n    }\n    for (int i = l - 1; i &gt;= 0; i--) {\n        if (h[u] - h[v] &gt;= (1 &lt;&lt; i)) {\n            ans = combine(ans, dp[u][i]);\n            u = up[u][i];\n        }\n    }\n    if (u == v) {\n        return ans;\n    }\n    for (int i = l - 1; i &gt;= 0; i--) {\n        if (up[u][i] != -1 &amp;&amp; up[v][i] != -1 &amp;&amp; up[u][i] != up[v][i]) {\n            ans = combine(ans, combine(dp[u][i], dp[v][i]));\n            u = up[u][i];\n            v = up[v][i];\n        }\n    }\n    ans = combine(ans, combine(dp[u][0], dp[v][0]));\n    return ans;\n}\n\nint main(void) {\n    cin &gt;&gt; n &gt;&gt; m;\n    for (int i = 1; i &lt;= n; i++) {\n        parent[i] = i;\n        size[i] = 1;\n    }\n    for (int i = 1; i &lt;= m; i++) {\n        cin &gt;&gt; a &gt;&gt; b &gt;&gt; w; // 1-indexed\n        edges.push_back({a, b, w, i - 1});\n    }\n    sort(edges.begin(), edges.end());\n    for (int i = 0; i &lt;= m - 1; i++) {\n        a = edges[i].s;\n        b = edges[i].e;\n        w = edges[i].w;\n        id = edges[i].id;\n        if (unite_set(a, b)) { \n            adj[a].emplace_back(b, w);\n            adj[b].emplace_back(a, w);\n            present[id] = 1;\n            res += w;\n        }\n    }\n    dfs(1, 0, 0);\n    for (int i = 1; i &lt;= l - 1; i++) {\n        for (int j = 1; j &lt;= n; ++j) {\n            if (up[j][i - 1] != -1) {\n                int v = up[j][i - 1];\n                up[j][i] = up[v][i - 1];\n                dp[j][i] = combine(dp[j][i - 1], dp[v][i - 1]);\n            }\n        }\n    }\n    for (int i = 0; i &lt;= m - 1; i++) {\n        id = edges[i].id;\n        w = edges[i].w;\n        if (!present[id]) {\n            auto rem = lca(edges[i].s, edges[i].e);\n            if (rem.first != w) {\n                if (ans &gt; res + w - rem.first) {\n                    ans = res + w - rem.first;\n                }\n            } else if (rem.second != -1) {\n                if (ans &gt; res + w - rem.second) {\n                    ans = res + w - rem.second;\n                }\n            }\n        }\n    }\n    cout &lt;&lt; ans &lt;&lt; \"\\n\";\n    return 0;\n}\n</code></pre>","tags":["Original"]},{"location":"graph/second_best_mst.html#references","title":"References","text":"<ol> <li>Competitive Programming-3, by Steven Halim</li> <li>web.mit.edu</li> </ol>","tags":["Original"]},{"location":"graph/second_best_mst.html#problems","title":"Problems","text":"<ul> <li>Codeforces - Minimum spanning tree for each edge</li> </ul>","tags":["Original"]},{"location":"graph/strong-orientation.html","title":"Strong Orientation","text":"<p>A strong orientation of an undirected graph is an assignment of a direction to each edge that makes it a strongly connected graph. That is, after the orientation we should be able to visit any vertex from any vertex by following the directed edges.</p>","tags":["Original"]},{"location":"graph/strong-orientation.html#solution","title":"Solution","text":"<p>Of course, this cannot be done to every graph. Consider a bridge in a graph. We have to assign a direction to it and by doing so we make this bridge \"crossable\" in only one direction. That means we can't go from one of the bridge's ends to the other, so we can't make the graph strongly connected.</p> <p>Now consider a DFS through a bridgeless connected graph. Clearly, we will visit each vertex. And since there are no bridges, we can remove any DFS tree edge and still be able to go from below the edge to above the edge by using a path that contains at least one back edge. From this follows that from any vertex we can go to the root of the DFS tree. Also, from the root of the DFS tree we can visit any vertex we choose. We found a strong orientation!</p> <p>In other words, to strongly orient a bridgeless connected graph, run a DFS on it and let the DFS tree edges point away from the DFS root and all other edges from the descendant to the ancestor in the DFS tree.</p> <p>The result that bridgeless connected graphs are exactly the graphs that have strong orientations is called Robbins' theorem.</p>","tags":["Original"]},{"location":"graph/strong-orientation.html#problem-extension","title":"Problem extension","text":"<p>Let's consider the problem of finding a graph orientation so that the number of SCCs is minimal.</p> <p>Of course, each graph component can be considered separately. Now, since only bridgeless graphs are strongly orientable, let's remove all bridges temporarily. We end up with some number of bridgeless components (exactly how many components there were at the beginning + how many bridges there were)  and we know that we can strongly orient each of them.</p> <p>We were only allowed to orient edges, not remove them, but it turns out we can orient the bridges arbitrarily. Of course, the easiest way to orient them is to run the algorithm described above without modifications on each original connected component.</p>","tags":["Original"]},{"location":"graph/strong-orientation.html#implementation","title":"Implementation","text":"<p>Here, the input is n \u2014 the number of vertices, m \u2014 the number of edges, then m lines describing the edges.</p> <p>The output is the minimal number of SCCs on the first line and on the second line a string of m characters, either <code>&gt;</code> \u2014 telling us that the corresponding edge from the input is oriented from the left to the right vertex (as in the input), or <code>&lt;</code> \u2014 the opposite.</p> <p>This is a bridge search algorithm modified to also orient the edges, you can as well orient the edges as a first step and count the SCCs on the oriented graph as a second.</p> <pre><code>vector&lt;vector&lt;pair&lt;int, int&gt;&gt;&gt; adj; // adjacency list - vertex and edge pairs\nvector&lt;pair&lt;int, int&gt;&gt; edges;\n\nvector&lt;int&gt; tin, low;\nint bridge_cnt;\nstring orient;\nvector&lt;bool&gt; edge_used;\nvoid find_bridges(int v) {\n    static int time = 0;\n    low[v] = tin[v] = time++;\n    for (auto p : adj[v]) {\n        if (edge_used[p.second]) continue;\n        edge_used[p.second] = true;\n        orient[p.second] = v == edges[p.second].first ? '&gt;' : '&lt;';\n        int nv = p.first;\n        if (tin[nv] == -1) { // if nv is not visited yet\n            find_bridges(nv);\n            low[v] = min(low[v], low[nv]);\n            if (low[nv] &gt; tin[v]) {\n                // a bridge between v and nv\n                bridge_cnt++;\n            }\n        } else {\n            low[v] = min(low[v], tin[nv]);\n        }\n    }\n}\n\nint main() {\n    int n, m;\n    scanf(\"%d %d\", &amp;n, &amp;m);\n    adj.resize(n);\n    tin.resize(n, -1);\n    low.resize(n, -1);\n    orient.resize(m);\n    edges.resize(m);\n    edge_used.resize(m);\n    for (int i = 0; i &lt; m; i++) {\n        int a, b;\n        scanf(\"%d %d\", &amp;a, &amp;b);\n        a--; b--;\n        adj[a].push_back({b, i});\n        adj[b].push_back({a, i});\n        edges[i] = {a, b};\n    }\n    int comp_cnt = 0;\n    for (int v = 0; v &lt; n; v++) {\n        if (tin[v] == -1) {\n            comp_cnt++;\n            find_bridges(v);\n        }\n    }\n    printf(\"%d\\n%s\\n\", comp_cnt + bridge_cnt, orient.c_str());\n}\n</code></pre>","tags":["Original"]},{"location":"graph/strong-orientation.html#practice-problems","title":"Practice Problems","text":"<ul> <li>26th Polish OI - Osiedla</li> </ul>","tags":["Original"]},{"location":"graph/strongly-connected-components.html","title":"Strongly connected components and the condensation graph","text":"","tags":["Translated"]},{"location":"graph/strongly-connected-components.html#definitions","title":"Definitions","text":"<p>Let $G=(V,E)$ be a directed graph with vertices $V$ and edges $E \\subseteq V \\times V$. We denote with $n=|V|$ the number of vertices and with $m=|E|$ the number of edges in $G$. It is easy to extend all definitions in this article to multigraphs, but we will not focus on that.</p> <p>A subset of vertices $C \\subseteq V$ is called a strongly connected component if the following conditions hold:</p> <ul> <li>for all $u,v\\in C$, if $u \\neq v$ there exists a path from $u$ to $v$ and a path from $v$ to $u$, and</li> <li>$C$ is maximal, in the sense that no vertex can be added without violating the above condition.</li> </ul> <p>We denote with $\\text{SCC}(G)$ the set of strongly connected components of $G$. These strongly connected components do not intersect with each other, and cover all vertices in the graph. Thus, the set $\\text{SCC}(G)$ is a partition of $V$. </p> <p>Consider this graph $G_\\text{example}$, in which the strongly connected components are highlighted:</p> <p>Here we have $\\text{SCC}(G_\\text{example})=\\{\\{0,7\\},\\{1,2,3,5,6\\},\\{4,9\\},\\{8\\}\\}.$ We can confirm that within each strongly connected component, all vertices are reachable from each other.</p> <p>We define the condensation graph $G^{\\text{SCC}}=(V^{\\text{SCC}}, E^{\\text{SCC}})$ as follows:</p> <ul> <li>the vertices of $G^{\\text{SCC}}$ are the strongly connected components of $G$; i.e., $V^{\\text{SCC}} = \\text{SCC}(G)$, and</li> <li>for all vertices $C_i,C_j$ of the condensation graph, there is an edge from $C_i$ to $C_j$ if and only if $C_i \\neq C_j$ and there exist $a\\in C_i$ and $b\\in C_j$ such that there is an edge from $a$ to $b$ in $G$.</li> </ul> <p>The condensation graph of $G_\\text{example}$ looks as follows:</p> <p>The most important property of the condensation graph is that it is acyclic. Indeed, there are no 'self-loops' in the condensation graph by definition, and if there were a cycle going through two or more vertices (strongly connected components) in the condensation graph, then due to reachability, the union of these strongly connected components would have to be one strongly connected component itself: contradiction.</p> <p>The algorithm described in the next section finds all strongly connected components in a given graph. After that, the condensation graph can be constructed.</p>","tags":["Translated"]},{"location":"graph/strongly-connected-components.html#description-of-the-algorithm","title":"Description of the algorithm","text":"<p>The described algorithm was independently suggested by Kosaraju and Sharir around 1980. It is based on two series of depth first search, with a runtime of $O(n + m)$.</p> <p>In the first step of the algorithm, we perform a sequence of depth first searches (<code>dfs</code>), visiting the entire graph. That is, as long as there are still unvisited vertices, we take one of them, and initiate a depth first search from that vertex. For each vertex, we keep track of the exit time $t_\\text{out}[v]$. This is the 'timestamp' at which the execution of <code>dfs</code> on vertex $v$ finishes, i.e., the moment at which all vertices reachable from $v$ have been visited and the algorithm is back at $v$. The timestamp counter should not be reset between consecutive calls to <code>dfs</code>. The exit times play a key role in the algorithm, which will become clear when we discuss the following theorem.</p> <p>First, we define the exit time $t_\\text{out}[C]$ of a strongly connected component $C$ as the maximum of the values $t_\\text{out}[v]$ for all $v \\in C.$ Furthermore, in the proof of the theorem, we will mention the entry time $t_{\\text{in}}[v]$ for each vertex $v\\in G$. The number $t_{\\text{in}}[v]$ represents the 'timestamp' at which the recursive function <code>dfs</code> is called on vertex $v$ in the first step of the algorithm. For a strongly connected component $C$, we define $t_{\\text{in}}[C]$ to be the minimum of the values $t_{\\text{in}}[v]$ for all $v \\in C$.</p> <p>Theorem. Let $C$ and $C'$ be two different strongly connected components, and let there be an edge from $C$ to $C'$ in the condensation graph. Then, $t_\\text{out}[C] &gt; t_\\text{out}[C']$.</p> <p>Proof. There are two different cases, depending on which component will first be reached by depth first search:</p> <ul> <li> <p>Case 1: the component $C$ was reached first (i.e., $t_{\\text{in}}[C] &lt; t_{\\text{in}}[C']$). In this case, depth first search visits some vertex $v \\in C$ at some moment at which all other vertices of the components $C$ and $C'$ are not visited yet. Since there is an edge from $C$ to $C'$ in the condensation graph, not only are all other vertices in $C$ reachable from $v$ in $G$, but all vertices in $C'$ are reachable as well. This means that this <code>dfs</code> execution, which is running from vertex $v$, will also visit all other vertices of the components $C$ and $C'$ in the future, so these vertices will be descendants of $v$ in the depth first search tree. This implies that for each vertex $u \\in (C \\cup C')\\setminus \\{v\\},$ we have that $t_\\text{out}[v] &gt; t_\\text{out}[u]$. Therefore, $t_\\text{out}[C] &gt; t_\\text{out}[C']$, which completes this case of the proof.</p> </li> <li> <p>Case 2: the component $C'$ was reached first (i.e., $t_{\\text{in}}[C] &gt; t_{\\text{in}}[C']$). In this case, depth first search visits some vertex $v \\in C'$ at some moment at which all other vertices of the components $C$ and $C'$ are not visited yet. Since there is an edge from $C$ to $C'$ in the condensation graph, $C$ is not reachable from $C'$, by the acyclicity property. Hence, the <code>dfs</code> execution that is running from vertex $v$ will not reach any vertices of $C$, but it will visit all vertices of $C'$. The vertices of $C$ will be visited by some <code>dfs</code> execution later during this step of the algorithm, so indeed we have $t_\\text{out}[C] &gt; t_\\text{out}[C']$. This completes the proof.</p> </li> </ul> <p>The proved theorem is very important for finding strongly connected components. It means that any edge in the condensation graph goes from a component with a larger value of $t_\\text{out}$ to a component with a smaller value.</p> <p>If we sort all vertices $v \\in V$ in decreasing order of their exit time $t_\\text{out}[v]$, then the first vertex $u$ will belong to the \"root\" strongly connected component, which has no incoming edges in the condensation graph. Now we want to run some type of search from this vertex $u$ so that it will visit all vertices in its strongly connected component, but not other vertices. By repeatedly doing so, we can gradually find all strongly connected components: we remove all vertices belonging to the first found component, then we find the next remaining vertex with the largest value of $t_\\text{out}$, and run this search from it, and so on. In the end, we will have found all strongly connected components. In order to find a search method that behaves like we want, we consider the following theorem:</p> <p>Theorem. Let $G^T$ denote the transpose graph of $G$, obtained by reversing the edge directions in $G$. Then, $\\text{SCC}(G)=\\text{SCC}(G^T)$. Furthermore, the condensation graph of $G^T$ is the transpose of the condensation graph of $G$.</p> <p>The proof is omitted (but straightforward). As a consequence of this theorem, there will be no edges from the \"root\" component to the other components in the condensation graph of $G^T$. Thus, in order to visit the whole \"root\" strongly connected component, containing vertex $v$, we can just run a depth first search from vertex $v$ in the transpose graph $G^T$! This will visit precisely all vertices of this strongly connected component. As was mentioned before, we can then remove these vertices from the graph. Then, we find the next vertex with a maximal value of $t_\\text{out}[v]$, and run the search in the transpose graph starting from that vertex to find the next strongly connected component. Repeating this, we find all strongly connected components.</p> <p>Thus, in summary, we discussed the following algorithm to find strongly connected components:</p> <ul> <li> <p>Step 1. Run a sequence of depth first searches on $G$, which will yield some list (e.g. <code>order</code>) of vertices, sorted on increasing exit time $t_\\text{out}$.</p> </li> <li> <p>Step 2. Build the transpose graph $G^T$, and run a series of depth first searches on the vertices in reverse order (i.e., in decreasing order of exit times). Each depth first search will yield one strongly connected component.</p> </li> <li> <p>Step 3 (optional). Build the condensation graph.</p> </li> </ul> <p>The runtime complexity of the algorithm is $O(n + m)$, because depth first search is performed twice. Building the condensation graph is also $O(n+m).$</p> <p>Finally, it is appropriate to mention topological sort here. In step 1, we find the vertices in the order of increasing exit time. If $G$ is acyclic, this corresponds to a (reversed) topological sort of $G$. In step 2, the algorithm finds strongly connected components in decreasing order of their exit times. Thus, it finds components - vertices of the condensation graph - in an order corresponding to a topological sort of the condensation graph.</p>","tags":["Translated"]},{"location":"graph/strongly-connected-components.html#implementation","title":"Implementation","text":"<pre><code>vector&lt;bool&gt; visited; // keeps track of which vertices are already visited\n\n// runs depth first search starting at vertex v.\n// each visited vertex is appended to the output vector when dfs leaves it.\nvoid dfs(int v, vector&lt;vector&lt;int&gt;&gt; const&amp; adj, vector&lt;int&gt; &amp;output) {\n    visited[v] = true;\n    for (auto u : adj[v])\n        if (!visited[u])\n            dfs(u, adj, output);\n    output.push_back(v);\n}\n\n// input: adj -- adjacency list of G\n// output: components -- the strongy connected components in G\n// output: adj_cond -- adjacency list of G^SCC (by root vertices)\nvoid strongly_connected_components(vector&lt;vector&lt;int&gt;&gt; const&amp; adj,\n                                  vector&lt;vector&lt;int&gt;&gt; &amp;components,\n                                  vector&lt;vector&lt;int&gt;&gt; &amp;adj_cond) {\n    int n = adj.size();\n    components.clear(), adj_cond.clear();\n\n    vector&lt;int&gt; order; // will be a sorted list of G's vertices by exit time\n\n    visited.assign(n, false);\n\n    // first series of depth first searches\n    for (int i = 0; i &lt; n; i++)\n        if (!visited[i])\n            dfs(i, adj, order);\n\n    // create adjacency list of G^T\n    vector&lt;vector&lt;int&gt;&gt; adj_rev(n);\n    for (int v = 0; v &lt; n; v++)\n        for (int u : adj[v])\n            adj_rev[u].push_back(v);\n\n    visited.assign(n, false);\n    reverse(order.begin(), order.end());\n\n    vector&lt;int&gt; roots(n, 0); // gives the root vertex of a vertex's SCC\n\n    // second series of depth first searches\n    for (auto v : order)\n        if (!visited[v]) {\n            std::vector&lt;int&gt; component;\n            dfs(v, adj_rev, component);\n            components.push_back(component);\n            int root = *min_element(begin(component), end(component));\n            for (auto u : component)\n                roots[u] = root;\n        }\n\n    // add edges to condensation graph\n    adj_cond.assign(n, {});\n    for (int v = 0; v &lt; n; v++)\n        for (auto u : adj[v])\n            if (roots[v] != roots[u])\n                adj_cond[roots[v]].push_back(roots[u]);\n}\n</code></pre> <p>The function <code>dfs</code> implements depth first search. It takes as input an adjacency list and a starting vertex. It also takes a reference to the vector <code>output</code>: each visited vertex will be appended to <code>output</code> when <code>dfs</code> leaves that vertex.</p> <p>Note that we use the function <code>dfs</code> both in the first and second step of the algorithm. In the first step, we pass in the adjacency list of $G$, and during consecutive calls to <code>dfs</code>, we keep passing in the same 'output vector' <code>order</code>, so that eventually we obtain a list of vertices in increasing order of exit times. In the second step, we pass in the adjacency list of $G^T$, and in each call, we pass in an empty 'output vector' <code>component</code>, which will give us one strongly connected component at a time.</p> <p>When building the adjacency list of the condensation graph, we select the root of each component as the first vertex in its list of vertices (this is an arbitrary choice). This root vertex represents its entire SCC. For each vertex <code>v</code>, the value <code>roots[v]</code> indicates the root vertex of the SCC which <code>v</code> belongs to.</p> <p>Our condensation graph is now given by the vertices <code>components</code> (one strongly connected component corresponds to one vertex in the condensation graph), and the adjacency list is given by <code>adj_cond</code>, using only the root vertices of the strongly connected components. Notice that we generate one edge from $C$ to $C'$ in $G^\\text{SCC}$ for each edge from some $a\\in C$ to some $b\\in C'$ in $G$ (if $C\\neq C'$). This implies that in our implementation, we can have multiple edges between two components in the condensation graph.</p>","tags":["Translated"]},{"location":"graph/strongly-connected-components.html#literature","title":"Literature","text":"<ul> <li>Thomas Cormen, Charles Leiserson, Ronald Rivest, Clifford Stein. Introduction to Algorithms [2005].</li> <li>M. Sharir. A strong-connectivity algorithm and its applications in data-flow analysis [1979].</li> </ul>","tags":["Translated"]},{"location":"graph/strongly-connected-components.html#practice-problems","title":"Practice Problems","text":"<ul> <li>SPOJ - Good Travels</li> <li>SPOJ - Lego</li> <li>Codechef - Chef and Round Run</li> <li>UVA - 11838 - Come and Go</li> <li>UVA 247 - Calling Circles</li> <li>UVA 13057 - Prove Them All</li> <li>UVA 12645 - Water Supply</li> <li>UVA 11770 - Lighting Away</li> <li>UVA 12926 - Trouble in Terrorist Town</li> <li>UVA 11324 - The Largest Clique</li> <li>UVA 11709 - Trust groups</li> <li>UVA 12745 - Wishmaster</li> <li>SPOJ - True Friends</li> <li>SPOJ - Capital City</li> <li>Codeforces - Scheme</li> <li>SPOJ - Ada and Panels</li> <li>CSES - Flight Routes Check</li> <li>CSES - Planets and Kingdoms</li> <li>CSES - Coin Collector</li> <li>Codeforces - Checkposts</li> </ul>","tags":["Translated"]},{"location":"graph/topological-sort.html","title":"Topological Sorting","text":"<p>You are given a directed graph with $n$ vertices and $m$ edges. You have to find an order of the vertices, so that every edge leads from the vertex with a smaller index to a vertex with a larger one.</p> <p>In other words, you want to find a permutation of the vertices (topological order) which corresponds to the order defined by all edges of the graph.</p> <p>Here is one given graph together with its topological order:</p> <p>Topological order can be non-unique (for example, if there exist three vertices $a$, $b$, $c$ for which there exist paths from $a$ to $b$ and from $a$ to $c$ but not paths from $b$ to $c$ or from $c$ to $b$). The example graph also has multiple topological orders, a second topological order is the following:</p> <p>A Topological order may not exist at all. It only exists, if the directed graph contains no cycles. Otherwise, there is a contradiction: if there is a cycle containing the vertices $a$ and $b$, then $a$ needs to have a smaller index than $b$ (since you can reach $b$ from $a$) and also a bigger one (as you can reach $a$ from $b$). The algorithm described in this article also shows by construction, that every acyclic directed graph contains at least one topological order.</p> <p>A common problem in which topological sorting occurs is the following. There are $n$ variables with unknown values. For some variables, we know that one of them is less than the other. You have to check whether these constraints are contradictory, and if not, output the variables in ascending order (if several answers are possible, output any of them). It is easy to notice that this is exactly the problem of finding the topological order of a graph with $n$ vertices.</p>","tags":["Translated"]},{"location":"graph/topological-sort.html#the-algorithm","title":"The Algorithm","text":"<p>To solve this problem, we will use depth-first search.</p> <p>Let's assume that the graph is acyclic. What does the depth-first search do?</p> <p>When starting from some vertex $v$, DFS tries to traverse along all edges outgoing from $v$. It stops at the edges for which the ends have been already been visited previously, and traverses along the rest of the edges and continues recursively at their ends.</p> <p>Thus, by the time of the function call $\\text{dfs}(v)$ has finished, all vertices that are reachable from $v$ have been either directly (via one edge) or indirectly visited by the search.</p> <p>Let's append the vertex $v$ to a list, when we finish $\\text{dfs}(v)$. Since all reachable vertices have already been visited, they will already be in the list when we append $v$. Let's do this for every vertex in the graph, with one or multiple depth-first search runs. For every directed edge $v \\rightarrow u$ in the graph, $u$ will appear earlier in this list than $v$, because $u$ is reachable from $v$. So if we just label the vertices in this list with $n-1, n-2, \\dots, 1, 0$, we have found a topological order of the graph. In other words, the list represents the reversed topological order.</p> <p>These explanations can also be presented in terms of exit times of the DFS algorithm. The exit time for vertex $v$ is the time at which the function call $\\text{dfs}(v)$ finished (the times can be numbered from $0$ to $n-1$). It is easy to understand that exit time of any vertex $v$ is always greater than the exit time of any vertex reachable from it (since they were visited either before the call $\\text{dfs}(v)$ or during it). Thus, the desired topological ordering are the vertices in descending order of their exit times.</p>","tags":["Translated"]},{"location":"graph/topological-sort.html#implementation","title":"Implementation","text":"<p>Here is an implementation which assumes that the graph is acyclic, i.e. the desired topological ordering exists. If necessary, you can easily check that the graph is acyclic, as described in the article on depth-first search.</p> <pre><code>int n; // number of vertices\nvector&lt;vector&lt;int&gt;&gt; adj; // adjacency list of graph\nvector&lt;bool&gt; visited;\nvector&lt;int&gt; ans;\n\nvoid dfs(int v) {\n    visited[v] = true;\n    for (int u : adj[v]) {\n        if (!visited[u]) {\n            dfs(u);\n        }\n    }\n    ans.push_back(v);\n}\n\nvoid topological_sort() {\n    visited.assign(n, false);\n    ans.clear();\n    for (int i = 0; i &lt; n; ++i) {\n        if (!visited[i]) {\n            dfs(i);\n        }\n    }\n    reverse(ans.begin(), ans.end());\n}\n</code></pre> <p>The main function of the solution is <code>topological_sort</code>, which initializes DFS variables, launches DFS and receives the answer in the vector <code>ans</code>. It is worth noting that when the graph is not acyclic, <code>topological_sort</code> result would still be somewhat meaningful in a sense that if a vertex $u$ is reachable from vertex $v$, but not vice versa, the vertex $v$ will always come first in the resulting array. This property of the provided implementation is used in Kosaraju's algorithm to extract strongly connected components and their topological sorting in a directed graph with cycles.</p>","tags":["Translated"]},{"location":"graph/topological-sort.html#practice-problems","title":"Practice Problems","text":"<ul> <li>SPOJ TOPOSORT - Topological Sorting [difficulty: easy]</li> <li>UVA 10305 - Ordering Tasks [difficulty: easy]</li> <li>UVA 124 - Following Orders [difficulty: easy]</li> <li>UVA 200 - Rare Order [difficulty: easy]</li> <li>Codeforces 510C - Fox and Names [difficulty: easy]</li> <li>SPOJ RPLA - Answer the boss!</li> <li>CSES - Course Schedule</li> <li>CSES - Longest Flight Route</li> <li>CSES - Game Routes</li> </ul>","tags":["Translated"]},{"location":"graph/tree_painting.html","title":"Paint the edges of the tree","text":"<p>This is a fairly common task. Given a tree $G$ with $N$ vertices. There are two types of queries: the first one is to paint an edge, the second one is to query the number of colored edges between two vertices.</p> <p>Here we will describe a fairly simple solution (using a segment tree) that will answer each query in $O(\\log N)$ time. The preprocessing step will take $O(N)$ time.</p>","tags":["Translated"]},{"location":"graph/tree_painting.html#algorithm","title":"Algorithm","text":"<p>First, we need to find the LCA to reduce each query of the second kind $(i,j)$ into two queries $(l,i)$ and $(l,j)$, where $l$ is the LCA of $i$ and $j$. The answer of the query $(i,j)$ will be the sum of both subqueries. Both these queries have a special structure, the first vertex is an ancestor of the second one. For the rest of the article we will only talk about these special kind of queries.</p> <p>We will start by describing the preprocessing step. Run a depth-first search from the root of the tree and record the Euler tour of this depth-first search (each vertex is added to the list when the search visits it first and every time we return from one of its children). The same technique can be used in the LCA preprocessing.</p> <p>This list will contain each edge (in the sense that if $i$ and $j$ are the ends of the edge, then there will be a place in the list where $i$ and $j$ are neighbors in the list), and it appear exactly two times: in the forward direction (from $i$ to $j$, where vertex $i$ is closer to the root than vertex $j$) and in the opposite direction (from $j$ to $i$).</p> <p>We will build two lists for these edges. The first one will store the color of all edges in the forward direction, and the second one the color of all edges in the opposite direction. We will use $1$ if the edge is colored, and $0$ otherwise. Over these two lists we will build each a segment tree (for sum with a single modification), let's call them $T1$ and $T2$.</p> <p>Let us answer a query of the form $(i,j)$, where $i$ is the ancestor of $j$. We need to determine how many edges are painted on the path between $i$ and $j$. Let's find $i$ and $j$ in the Euler tour for the first time, let it be the positions $p$ and $q$ (this can be done in $O(1)$ if we calculate these positions in advance during preprocessing). Then the answer to the query is the sum $T1[p..q-1]$ minus the sum $T2[p..q-1]$.</p> <p>Why? Consider the segment $[p;q]$ in the Euler tour. It contains all edges of the path we need from $i$ to $j$ but also contains a set of edges that lie on other paths from $i$. However there is one big difference between the edges we need and the rest of the edges: the edges we need will be listed only once in the forward direction, and all the other edges appear twice: once in the forward and once in the opposite direction. Hence, the difference $T1[p..q-1] - T2[p..q-1]$ will give us the correct answer (minus one is necessary because otherwise, we will capture an extra edge going out from vertex $j$). The sum query in the segment tree is executed in $O(\\log N)$.</p> <p>Answering the first type of query (painting an edge) is even easier - we just need to update $T1$ and $T2$, namely to perform a single update of the element that corresponds to our edge (finding the edge in the list, again, is possible in $O(1)$, if you perform this search during preprocessing). A single modification in the segment tree is performed in $O(\\log N)$.</p>","tags":["Translated"]},{"location":"graph/tree_painting.html#implementation","title":"Implementation","text":"<p>Here is the full implementation of the solution, including LCA computation:</p> <pre><code>const int INF = 1000 * 1000 * 1000;\n\ntypedef vector&lt;vector&lt;int&gt;&gt; graph;\n\nvector&lt;int&gt; dfs_list;\nvector&lt;int&gt; edges_list;\nvector&lt;int&gt; h;\n\nvoid dfs(int v, const graph&amp; g, const graph&amp; edge_ids, int cur_h = 1) {\n    h[v] = cur_h;\n    dfs_list.push_back(v);\n    for (size_t i = 0; i &lt; g[v].size(); ++i) {\n        if (h[g[v][i]] == -1) {\n            edges_list.push_back(edge_ids[v][i]);\n            dfs(g[v][i], g, edge_ids, cur_h + 1);\n            edges_list.push_back(edge_ids[v][i]);\n            dfs_list.push_back(v);\n        }\n    }\n}\n\nvector&lt;int&gt; lca_tree;\nvector&lt;int&gt; first;\n\nvoid lca_tree_build(int i, int l, int r) {\n    if (l == r) {\n        lca_tree[i] = dfs_list[l];\n    } else {\n        int m = (l + r) &gt;&gt; 1;\n        lca_tree_build(i + i, l, m);\n        lca_tree_build(i + i + 1, m + 1, r);\n        int lt = lca_tree[i + i], rt = lca_tree[i + i + 1];\n        lca_tree[i] = h[lt] &lt; h[rt] ? lt : rt;\n    }\n}\n\nvoid lca_prepare(int n) {\n    lca_tree.assign(dfs_list.size() * 8, -1);\n    lca_tree_build(1, 0, (int)dfs_list.size() - 1);\n\n    first.assign(n, -1);\n    for (int i = 0; i &lt; (int)dfs_list.size(); ++i) {\n        int v = dfs_list[i];\n        if (first[v] == -1)\n            first[v] = i;\n    }\n}\n\nint lca_tree_query(int i, int tl, int tr, int l, int r) {\n    if (tl == l &amp;&amp; tr == r)\n        return lca_tree[i];\n    int m = (tl + tr) &gt;&gt; 1;\n    if (r &lt;= m)\n        return lca_tree_query(i + i, tl, m, l, r);\n    if (l &gt; m)\n        return lca_tree_query(i + i + 1, m + 1, tr, l, r);\n    int lt = lca_tree_query(i + i, tl, m, l, m);\n    int rt = lca_tree_query(i + i + 1, m + 1, tr, m + 1, r);\n    return h[lt] &lt; h[rt] ? lt : rt;\n}\n\nint lca(int a, int b) {\n    if (first[a] &gt; first[b])\n        swap(a, b);\n    return lca_tree_query(1, 0, (int)dfs_list.size() - 1, first[a], first[b]);\n}\n\nvector&lt;int&gt; first1, first2;\nvector&lt;char&gt; edge_used;\nvector&lt;int&gt; tree1, tree2;\n\nvoid query_prepare(int n) {\n    first1.resize(n - 1, -1);\n    first2.resize(n - 1, -1);\n    for (int i = 0; i &lt; (int)edges_list.size(); ++i) {\n        int j = edges_list[i];\n        if (first1[j] == -1)\n            first1[j] = i;\n        else\n            first2[j] = i;\n    }\n\n    edge_used.resize(n - 1);\n    tree1.resize(edges_list.size() * 8);\n    tree2.resize(edges_list.size() * 8);\n}\n\nvoid sum_tree_update(vector&lt;int&gt;&amp; tree, int i, int l, int r, int j, int delta) {\n    tree[i] += delta;\n    if (l &lt; r) {\n        int m = (l + r) &gt;&gt; 1;\n        if (j &lt;= m)\n            sum_tree_update(tree, i + i, l, m, j, delta);\n        else\n            sum_tree_update(tree, i + i + 1, m + 1, r, j, delta);\n    }\n}\n\nint sum_tree_query(const vector&lt;int&gt;&amp; tree, int i, int tl, int tr, int l, int r) {\n    if (l &gt; r || tl &gt; tr)\n        return 0;\n    if (tl == l &amp;&amp; tr == r)\n        return tree[i];\n    int m = (tl + tr) &gt;&gt; 1;\n    if (r &lt;= m)\n        return sum_tree_query(tree, i + i, tl, m, l, r);\n    if (l &gt; m)\n        return sum_tree_query(tree, i + i + 1, m + 1, tr, l, r);\n    return sum_tree_query(tree, i + i, tl, m, l, m) +\n           sum_tree_query(tree, i + i + 1, m + 1, tr, m + 1, r);\n}\n\nint query(int v1, int v2) {\n    return sum_tree_query(tree1, 1, 0, (int)edges_list.size() - 1, first[v1], first[v2] - 1) -\n           sum_tree_query(tree2, 1, 0, (int)edges_list.size() - 1, first[v1], first[v2] - 1);\n}\n\nint main() {\n    // reading the graph\n    int n;\n    scanf(\"%d\", &amp;n);\n    graph g(n), edge_ids(n);\n    for (int i = 0; i &lt; n - 1; ++i) {\n        int v1, v2;\n        scanf(\"%d%d\", &amp;v1, &amp;v2);\n        --v1, --v2;\n        g[v1].push_back(v2);\n        g[v2].push_back(v1);\n        edge_ids[v1].push_back(i);\n        edge_ids[v2].push_back(i);\n    }\n\n    h.assign(n, -1);\n    dfs(0, g, edge_ids);\n    lca_prepare(n);\n    query_prepare(n);\n\n    for (;;) {\n        if () {\n            // request for painting edge x;\n            // if start = true, then the edge is painted, otherwise the painting\n            // is removed\n            edge_used[x] = start;\n            sum_tree_update(tree1, 1, 0, (int)edges_list.size() - 1, first1[x],\n                            start ? 1 : -1);\n            sum_tree_update(tree2, 1, 0, (int)edges_list.size() - 1, first2[x],\n                            start ? 1 : -1);\n        } else {\n            // query the number of colored edges on the path between v1 and v2\n            int l = lca(v1, v2);\n            int result = query(l, v1) + query(l, v2);\n            // result - the answer to the request\n        }\n    }\n}\n</code></pre>","tags":["Translated"]},{"location":"linear_algebra/determinant-gauss.html","title":"Calculating the determinant of a matrix by Gauss","text":"<p>Problem: Given a matrix $A$ of size $N \\times N$. Compute its determinant.</p>","tags":["Translated"]},{"location":"linear_algebra/determinant-gauss.html#algorithm","title":"Algorithm","text":"<p>We use the ideas of Gauss method for solving systems of linear equations</p> <p>We will perform the same steps as in the solution of systems of linear equations, excluding only the division of the current line to $a_{ij}$. These operations will not change the absolute value of the determinant of the matrix. When we exchange two lines of the matrix, however, the sign of the determinant can change.</p> <p>After applying Gauss on the matrix, we receive a diagonal matrix, whose determinant is just the product of the elements on the diagonal. The sign, as previously mentioned, can be determined by the number of exchanged rows (if odd, then the sign of the determinant should be reversed). Thus, we can use the Gauss algorithm to compute the determinant of the matrix in complexity $O(N^3)$.</p> <p>It should be noted that if at some point, we do not find non-zero cell in current column, the algorithm should stop and returns 0.</p>","tags":["Translated"]},{"location":"linear_algebra/determinant-gauss.html#implementation","title":"Implementation","text":"<pre><code>const double EPS = 1E-9;\nint n;\nvector &lt; vector&lt;double&gt; &gt; a (n, vector&lt;double&gt; (n));\n\ndouble det = 1;\nfor (int i=0; i&lt;n; ++i) {\n    int k = i;\n    for (int j=i+1; j&lt;n; ++j)\n        if (abs (a[j][i]) &gt; abs (a[k][i]))\n            k = j;\n    if (abs (a[k][i]) &lt; EPS) {\n        det = 0;\n        break;\n    }\n    swap (a[i], a[k]);\n    if (i != k)\n        det = -det;\n    det *= a[i][i];\n    for (int j=i+1; j&lt;n; ++j)\n        a[i][j] /= a[i][i];\n    for (int j=0; j&lt;n; ++j)\n        if (j != i &amp;&amp; abs (a[j][i]) &gt; EPS)\n            for (int k=i+1; k&lt;n; ++k)\n                a[j][k] -= a[i][k] * a[j][i];\n}\n\ncout &lt;&lt; det;\n</code></pre>","tags":["Translated"]},{"location":"linear_algebra/determinant-gauss.html#practice-problems","title":"Practice Problems","text":"<ul> <li>Codeforces - Wizards and Bets</li> </ul>","tags":["Translated"]},{"location":"linear_algebra/determinant-kraut.html","title":"Calculating the determinant using Kraut method in $O(N^3)$","text":"<p>In this article, we'll describe how to find the determinant of the matrix using Kraut method, which works in $O(N^3)$.</p> <p>The Kraut algorithm finds decomposition of matrix $A$ as $A = L U$ where $L$ is lower triangular and $U$ is upper triangular matrix. Without loss of generality, we can assume that all the diagonal elements of $L$ are equal to 1. Once we know these matrices, it is easy to calculate the determinant of $A$: it is equal to the product of all the elements on the main diagonal of the matrix $U$.</p> <p>There is a theorem stating that any invertible matrix has a LU-decomposition, and it is unique, if and only if all its principle minors are non-zero. We consider only such decomposition in which the diagonal of matrix $L$ consists of ones.</p> <p>Let $A$ be the matrix and $N$ - its size. We will find the elements of the matrices $L$ and $U$ using the following steps:</p> <ol> <li>Let $L_{i i} = 1$ for $i = 1, 2, ..., N$.</li> <li> <p>For each $j = 1, 2, ..., N$ perform:</p> <ul> <li> <p>For $i = 1, 2, ..., j$ find values </p> $$U_{ij} = A_{ij} - \\sum_{k=1}^{i-1} L_{ik} \\cdot U_{kj}$$ </li> <li> <p>Next, for $i = j+1, j+2, ..., N$ find values</p> $$L_{ij} = \\frac{1}{U_{jj}} \\left(A_{ij} - \\sum_{k=1}^{j-1} L_{ik} \\cdot U_{kj} \\right).$$ </li> </ul> </li> </ol>","tags":["Original"]},{"location":"linear_algebra/determinant-kraut.html#implementation","title":"Implementation","text":"<pre><code>static BigInteger det (BigDecimal a [][], int n) {\n    try {\n\n    for (int i=0; i&lt;n; i++) {\n        boolean nonzero = false;\n        for (int j=0; j&lt;n; j++)\n            if (a[i][j].compareTo (new BigDecimal (BigInteger.ZERO)) &gt; 0)\n                nonzero = true;\n        if (!nonzero)\n            return BigInteger.ZERO;\n    }\n\n    BigDecimal scaling [] = new BigDecimal [n];\n    for (int i=0; i&lt;n; i++) {\n        BigDecimal big = new BigDecimal (BigInteger.ZERO);\n        for (int j=0; j&lt;n; j++)\n            if (a[i][j].abs().compareTo (big) &gt; 0)\n                big = a[i][j].abs();\n        scaling[i] = (new BigDecimal (BigInteger.ONE)) .divide\n            (big, 100, BigDecimal.ROUND_HALF_EVEN);\n    }\n\n    int sign = 1;\n\n    for (int j=0; j&lt;n; j++) {\n        for (int i=0; i&lt;j; i++) {\n            BigDecimal sum = a[i][j];\n            for (int k=0; k&lt;i; k++)\n                sum = sum.subtract (a[i][k].multiply (a[k][j]));\n            a[i][j] = sum;\n        }\n\n        BigDecimal big = new BigDecimal (BigInteger.ZERO);\n        int imax = -1;\n        for (int i=j; i&lt;n; i++) {\n            BigDecimal sum = a[i][j];\n            for (int k=0; k&lt;j; k++)\n                sum = sum.subtract (a[i][k].multiply (a[k][j]));\n            a[i][j] = sum;\n            BigDecimal cur = sum.abs();\n            cur = cur.multiply (scaling[i]);\n            if (cur.compareTo (big) &gt;= 0) {\n                big = cur;\n                imax = i;\n            }\n        }\n\n        if (j != imax) {\n            for (int k=0; k&lt;n; k++) {\n                BigDecimal t = a[j][k];\n                a[j][k] = a[imax][k];\n                a[imax][k] = t;\n            }\n\n            BigDecimal t = scaling[imax];\n            scaling[imax] = scaling[j];\n            scaling[j] = t;\n\n            sign = -sign;\n        }\n\n        if (j != n-1)\n            for (int i=j+1; i&lt;n; i++)\n                a[i][j] = a[i][j].divide\n                    (a[j][j], 100, BigDecimal.ROUND_HALF_EVEN);\n\n    }\n\n    BigDecimal result = new BigDecimal (1);\n    if (sign == -1)\n        result = result.negate();\n    for (int i=0; i&lt;n; i++)\n        result = result.multiply (a[i][i]);\n\n    return result.divide\n        (BigDecimal.valueOf(1), 0, BigDecimal.ROUND_HALF_EVEN).toBigInteger();\n    }\n    catch (Exception e) {\n        return BigInteger.ZERO;\n    }\n}\n</code></pre>","tags":["Original"]},{"location":"linear_algebra/linear-system-gauss.html","title":"Gauss method for solving system of linear equations","text":"<p>Given a system of $n$ linear algebraic equations (SLAE) with $m$ unknowns. You are asked to solve the system: to determine if it has no solution, exactly one solution or infinite number of solutions. And in case it has at least one solution, find any of them.</p> <p>Formally, the problem is formulated as follows: solve the system:</p> $$\\begin{align} a_{11} x_1 + a_{12} x_2 + &amp;\\dots + a_{1m} x_m = b_1 \\\\ a_{21} x_1 + a_{22} x_2 + &amp;\\dots + a_{2m} x_m = b_2\\\\ &amp;\\vdots \\\\ a_{n1} x_1 + a_{n2} x_2 + &amp;\\dots + a_{nm} x_m = b_n \\end{align}$$ <p>where the coefficients $a_{ij}$ (for $i$ from 1 to $n$, $j$ from 1 to $m$) and $b_i$ ($i$ from 1 to $n$) are known and variables $x_i$ ($i$ from 1 to $m$) are unknowns.</p> <p>This problem also has a simple matrix representation:</p> $$Ax = b,$$ <p>where $A$ is a matrix of size $n \\times m$ of coefficients $a_{ij}$ and $b$ is the column vector of size $n$.</p> <p>It is worth noting that the method presented in this article can also be used to solve the equation modulo any number p, i.e.:</p> $$\\begin{align} a_{11} x_1 + a_{12} x_2 + &amp;\\dots + a_{1m} x_m \\equiv b_1 \\pmod p \\\\ a_{21} x_1 + a_{22} x_2 + &amp;\\dots + a_{2m} x_m \\equiv b_2 \\pmod p \\\\ &amp;\\vdots \\\\ a_{n1} x_1 + a_{n2} x_2 + &amp;\\dots + a_{nm} x_m \\equiv b_n \\pmod p \\end{align}$$","tags":["Translated"]},{"location":"linear_algebra/linear-system-gauss.html#gauss","title":"Gauss","text":"<p>Strictly speaking, the method described below should be called \"Gauss-Jordan\", or Gauss-Jordan elimination, because it is a variation of the Gauss method, described by Jordan in 1887.</p>","tags":["Translated"]},{"location":"linear_algebra/linear-system-gauss.html#overview","title":"Overview","text":"<p>The algorithm is a <code>sequential elimination</code> of the variables in each equation, until each equation will have only one remaining variable. If $n = m$, you can think of it as transforming the matrix $A$ to identity matrix, and solve the equation in this obvious case, where solution is unique and is equal to coefficient $b_i$.</p> <p>Gaussian elimination is based on two simple transformations:   </p> <ul> <li>It is possible to exchange two equations</li> <li>Any equation can be replaced by a linear combination of that row (with non-zero coefficient), and some other rows (with arbitrary coefficients).</li> </ul> <p>In the first step, Gauss-Jordan algorithm divides the first row by $a_{11}$. Then, the algorithm adds the first row to the remaining rows such that the coefficients in the first column becomes all zeros. To achieve this, on the i-th row, we must add the first row multiplied by $- a_{i1}$. Note that, this operation must also be performed on vector $b$. In a sense, it behaves as if vector $b$ was the $m+1$-th column of matrix $A$.</p> <p>As a result, after the first step, the first column of matrix $A$ will consists of $1$ on the first row, and $0$ in other rows.</p> <p>Similarly, we perform the second step of the algorithm, where we consider the second column of second row. First, the row is divided by $a_{22}$, then it is subtracted from other rows so that all the second column becomes $0$ (except for the second row).</p> <p>We continue this process for all columns of matrix $A$. If $n = m$, then $A$ will become identity matrix.</p>","tags":["Translated"]},{"location":"linear_algebra/linear-system-gauss.html#search-for-the-pivoting-element","title":"Search for the pivoting element","text":"<p>The described scheme left out many details. At the $i$th step, if $a_{ii}$ is zero, we cannot apply directly the described method. Instead, we must first <code>select a pivoting row</code>: find one row of the matrix where the $i$th column is non-zero, and then swap the two rows.</p> <p>Note that, here we swap rows but not columns. This is because if you swap columns, then when you find a solution, you must remember to swap back to correct places. Thus, swapping rows is much easier to do.</p> <p>In many implementations, when $a_{ii} \\neq 0$, you can see people still swap the $i$th row with some pivoting row, using some heuristics such as choosing the pivoting row with maximum absolute value of $a_{ji}$. This heuristic is used to reduce the value range of the matrix in later steps. Without this heuristic, even for matrices of size about $20$, the error will be too big and can cause overflow for floating points data types of C++.</p>","tags":["Translated"]},{"location":"linear_algebra/linear-system-gauss.html#degenerate-cases","title":"Degenerate cases","text":"<p>In the case where $m = n$ and the system is non-degenerate (i.e. it has non-zero determinant, and has unique solution), the algorithm described above will transform $A$ into identity matrix.</p> <p>Now we consider the <code>general case</code>, where $n$ and $m$ are not necessarily equal, and the system can be degenerate. In these cases, the pivoting element in $i$th step may not be found. This means that on the $i$th column, starting from the current line, all contains zeros. In this case, either there is no possible value of variable $x_i$ (meaning the SLAE has no solution), or $x_i$ is an independent variable and can take arbitrary value. When implementing Gauss-Jordan, you should continue the work for subsequent variables and just skip the $i$th column (this is equivalent to removing the $i$th column of the matrix).</p> <p>So, some of the variables in the process can be found to be independent. When the number of variables, $m$ is greater than the number of equations, $n$, then at least $m - n$ independent variables will be found.</p> <p>In general, if you find at least one independent variable, it can take any arbitrary value, while the other (dependent) variables are expressed through it.  This means that when we work in the field of real numbers, the system potentially has infinitely many solutions. But you should remember that when there are independent variables, SLAE can have no solution at all. This happens when the remaining untreated equations have at least one non-zero constant term. You can check this by assigning zeros to all independent variables, calculate other variables, and then plug in to the original SLAE to check if they satisfy it.</p>","tags":["Translated"]},{"location":"linear_algebra/linear-system-gauss.html#implementation","title":"Implementation","text":"<p>Following is an implementation of Gauss-Jordan. Choosing the pivot row is done with heuristic: choosing maximum value in the current column.</p> <p>The input to the function <code>gauss</code> is the system matrix $a$. The last column of this matrix is vector $b$.</p> <p>The function returns the number of solutions of the system $(0, 1,\\textrm{or } \\infty)$. If at least one solution exists, then it is returned in the vector $ans$.</p> <pre><code>const double EPS = 1e-9;\nconst int INF = 2; // it doesn't actually have to be infinity or a big number\n\nint gauss (vector &lt; vector&lt;double&gt; &gt; a, vector&lt;double&gt; &amp; ans) {\n    int n = (int) a.size();\n    int m = (int) a[0].size() - 1;\n\n    vector&lt;int&gt; where (m, -1);\n    for (int col=0, row=0; col&lt;m &amp;&amp; row&lt;n; ++col) {\n        int sel = row;\n        for (int i=row; i&lt;n; ++i)\n            if (abs (a[i][col]) &gt; abs (a[sel][col]))\n                sel = i;\n        if (abs (a[sel][col]) &lt; EPS)\n            continue;\n        for (int i=col; i&lt;=m; ++i)\n            swap (a[sel][i], a[row][i]);\n        where[col] = row;\n\n        for (int i=0; i&lt;n; ++i)\n            if (i != row) {\n                double c = a[i][col] / a[row][col];\n                for (int j=col; j&lt;=m; ++j)\n                    a[i][j] -= a[row][j] * c;\n            }\n        ++row;\n    }\n\n    ans.assign (m, 0);\n    for (int i=0; i&lt;m; ++i)\n        if (where[i] != -1)\n            ans[i] = a[where[i]][m] / a[where[i]][i];\n    for (int i=0; i&lt;n; ++i) {\n        double sum = 0;\n        for (int j=0; j&lt;m; ++j)\n            sum += ans[j] * a[i][j];\n        if (abs (sum - a[i][m]) &gt; EPS)\n            return 0;\n    }\n\n    for (int i=0; i&lt;m; ++i)\n        if (where[i] == -1)\n            return INF;\n    return 1;\n}\n</code></pre> <p>Implementation notes:</p> <ul> <li>The function uses two pointers - the current column $col$ and the current row $row$.</li> <li>For each variable $x_i$, the value $where(i)$ is the line where this column is not zero. This vector is needed because some variables can be independent.</li> <li>In this implementation, the current $i$th line is not divided by $a_{ii}$ as described above, so in the end the matrix is not identity matrix (though apparently dividing the $i$th line can help reducing errors).</li> <li>After finding a solution, it is inserted back into the matrix - to check whether the system has at least one solution or not. If the test solution is successful, then the function returns 1 or $\\inf$, depending on whether there is at least one independent variable.</li> </ul>","tags":["Translated"]},{"location":"linear_algebra/linear-system-gauss.html#complexity","title":"Complexity","text":"<p>Now we should estimate the complexity of this algorithm. The algorithm consists of $m$ phases, in each phase:</p> <ul> <li>Search and reshuffle the pivoting row. This takes $O(n + m)$ when using heuristic mentioned above.</li> <li>If the pivot element in the current column is found - then we must add this equation to all other equations, which takes time $O(nm)$.</li> </ul> <p>So, the final complexity of the algorithm is $O(\\min (n, m) . nm)$. In case $n = m$, the complexity is simply $O(n^3)$.</p> <p>Note that when the SLAE is not on real numbers, but is in the modulo two, then the system can be solved much faster, which is described below.</p>","tags":["Translated"]},{"location":"linear_algebra/linear-system-gauss.html#acceleration-of-the-algorithm","title":"Acceleration of the algorithm","text":"<p>The previous implementation can be sped up by two times, by dividing the algorithm into two phases: forward and reverse:</p> <ul> <li>Forward phase: Similar to the previous implementation, but the current row is only added to the rows after it. As a result, we obtain a triangular matrix instead of diagonal.</li> <li>Reverse phase: When the matrix is triangular, we first calculate the value of the last variable. Then plug this value to find the value of next variable. Then plug these two values to find the next variables...</li> </ul> <p>Reverse phase only takes $O(nm)$, which is much faster than forward phase. In forward phase, we reduce the number of operations by half, thus reducing the running time of the implementation.</p>","tags":["Translated"]},{"location":"linear_algebra/linear-system-gauss.html#solving-modular-slae","title":"Solving modular SLAE","text":"<p>For solving SLAE in some module, we can still use the described algorithm. However, in case the module is equal to two, we can perform Gauss-Jordan elimination much more effectively using bitwise operations and C++ bitset data types:</p> <pre><code>int gauss (vector &lt; bitset&lt;N&gt; &gt; a, int n, int m, bitset&lt;N&gt; &amp; ans) {\n    vector&lt;int&gt; where (m, -1);\n    for (int col=0, row=0; col&lt;m &amp;&amp; row&lt;n; ++col) {\n        for (int i=row; i&lt;n; ++i)\n            if (a[i][col]) {\n                swap (a[i], a[row]);\n                break;\n            }\n        if (! a[row][col])\n            continue;\n        where[col] = row;\n\n        for (int i=0; i&lt;n; ++i)\n            if (i != row &amp;&amp; a[i][col])\n                a[i] ^= a[row];\n        ++row;\n    }\n        // The rest of implementation is the same as above\n}\n</code></pre> <p>Since we use bit compress, the implementation is not only shorter, but also 32 times faster.</p>","tags":["Translated"]},{"location":"linear_algebra/linear-system-gauss.html#a-little-note-about-different-heuristics-of-choosing-pivoting-row","title":"A little note about different heuristics of choosing pivoting row","text":"<p>There is no general rule for what heuristics to use.</p> <p>The heuristics used in previous implementation works quite well in practice. It also turns out to give almost the same answers as \"full pivoting\" - where the pivoting row is search amongst all elements of the whose submatrix (from the current row and current column).</p> <p>Though, you should note that both heuristics is dependent on how much the original equations was scaled. For example, if one of the equation was multiplied by $10^6$, then this equation is almost certain to be chosen as pivot in first step. This seems rather strange, so it seems logical to change to a more complicated heuristics, called <code>implicit pivoting</code>.</p> <p>Implicit pivoting compares elements as if both lines were normalized, so that the maximum element would be unity. To implement this technique, one need to maintain maximum in each row (or maintain each line so that maximum is unity, but this can lead to increase in the accumulated error).</p>","tags":["Translated"]},{"location":"linear_algebra/linear-system-gauss.html#improve-the-solution","title":"Improve the solution","text":"<p>Despite various heuristics, Gauss-Jordan algorithm can still lead to large errors in special matrices even of size $50 - 100$.</p> <p>Therefore, the resulting Gauss-Jordan solution must sometimes be improved by applying a simple numerical method - for example, the method of simple iteration.</p> <p>Thus, the solution turns into two-step: First, Gauss-Jordan algorithm is applied, and then a numerical method taking initial solution as solution in the first step.</p>","tags":["Translated"]},{"location":"linear_algebra/linear-system-gauss.html#practice-problems","title":"Practice Problems","text":"<ul> <li>Spoj - Xor Maximization</li> <li>Codechef - Knight Moving</li> <li>Lightoj - Graph Coloring</li> <li>UVA 12910 - Snakes and Ladders</li> <li>TIMUS1042 Central Heating</li> <li>TIMUS1766 Humpty Dumpty</li> <li>TIMUS1266 Kirchhoff's Law</li> <li>Codeforces - No game no life</li> </ul>","tags":["Translated"]},{"location":"linear_algebra/rank-matrix.html","title":"Finding the rank of a matrix","text":"<p>The rank of a matrix is the largest number of linearly independent rows/columns of the matrix. The rank is not only defined  for square matrices.</p> <p>The rank of a matrix can also be defined as the largest order of any non-zero minor in the matrix.</p> <p>Let the matrix be rectangular and have size $N \\times M$. Note that if the matrix is square and its determinant is non-zero, then the rank is $N$ ($=M$); otherwise it will be less. Generally, the rank of a matrix does not exceed $\\min (N, M)$.</p>","tags":["Translated"]},{"location":"linear_algebra/rank-matrix.html#algorithm","title":"Algorithm","text":"<p>You can search for the rank using Gaussian elimination. We will perform the same operations as when solving the system or finding its determinant. But if at any step in the $i$-th column there are no rows with an non-empty entry among those that we didn't selected already, then we skip this step. Otherwise, if we have found a row with a non-zero element in the $i$-th column during the $i$-th step, then we mark this row as a selected one, increase the rank by one (initially the rank is set equal to $0$), and perform the usual operations of taking this row away from the rest.</p>","tags":["Translated"]},{"location":"linear_algebra/rank-matrix.html#complexity","title":"Complexity","text":"<p>This algorithm runs in $\\mathcal{O}(n^3)$.</p>","tags":["Translated"]},{"location":"linear_algebra/rank-matrix.html#implementation","title":"Implementation","text":"<pre><code>const double EPS = 1E-9;\n\nint compute_rank(vector&lt;vector&lt;double&gt;&gt; A) {\n    int n = A.size();\n    int m = A[0].size();\n\n    int rank = 0;\n    vector&lt;bool&gt; row_selected(n, false);\n    for (int i = 0; i &lt; m; ++i) {\n        int j;\n        for (j = 0; j &lt; n; ++j) {\n            if (!row_selected[j] &amp;&amp; abs(A[j][i]) &gt; EPS)\n                break;\n        }\n\n        if (j != n) {\n            ++rank;\n            row_selected[j] = true;\n            for (int p = i + 1; p &lt; m; ++p)\n                A[j][p] /= A[j][i];\n            for (int k = 0; k &lt; n; ++k) {\n                if (k != j &amp;&amp; abs(A[k][i]) &gt; EPS) {\n                    for (int p = i + 1; p &lt; m; ++p)\n                        A[k][p] -= A[j][p] * A[k][i];\n                }\n            }\n        }\n    }\n    return rank;\n}\n</code></pre>","tags":["Translated"]},{"location":"linear_algebra/rank-matrix.html#problems","title":"Problems","text":"<ul> <li>TIMUS1041 Nikifor</li> </ul>","tags":["Translated"]},{"location":"num_methods/binary_search.html","title":"Binary search","text":"<p>Binary search is a method that allows for quicker search of something by splitting the search interval into two. Its most common application is searching values in sorted arrays, however the splitting idea is crucial in many other typical tasks.</p>","tags":["Original"]},{"location":"num_methods/binary_search.html#search-in-sorted-arrays","title":"Search in sorted arrays","text":"<p>The most typical problem that leads to the binary search is as follows. You're given a sorted array $A_0 \\leq A_1 \\leq \\dots \\leq A_{n-1}$, check if $k$ is present within the sequence. The simplest solution would be to check every element one by one and compare it with $k$ (a so-called linear search). This approach works in $O(n)$, but doesn't utilize the fact that the array is sorted.</p> Binary search of the value $7$ in an array.  The image by AlwaysAngry is distributed under CC BY-SA 4.0 license.  <p>Now assume that we know two indices $L &lt; R$ such that $A_L \\leq k \\leq A_R$. Because the array is sorted, we can deduce that $k$ either occurs among $A_L, A_{L+1}, \\dots, A_R$ or doesn't occur in the array at all. If we pick an arbitrary index $M$ such that $L &lt; M &lt; R$ and check whether $k$ is less or greater than $A_M$. We have two possible cases:</p> <ol> <li>$A_L \\leq k \\leq A_M$. In this case, we reduce the problem from $[L, R]$ to $[L, M]$;</li> <li>$A_M \\leq k \\leq A_R$. In this case, we reduce the problem from $[L, R]$ to $[M, R]$.</li> </ol> <p>When it is impossible to pick  $M$, that is, when $R = L + 1$, we directly compare $k$ with $A_L$ and $A_R$. Otherwise we would want to pick $M$ in such manner that it reduces the active segment to a single element as quickly as possible in the worst case.</p> <p>Since in the worst case we will always reduce to larger segment of $[L, M]$ and $[M, R]$. Thus, in the worst case scenario the reduction would be from $R-L$ to $\\max(M-L, R-M)$. To minimize this value, we should pick $M \\approx \\frac{L+R}{2}$, then</p> $$ M-L \\approx \\frac{R-L}{2} \\approx R-M. $$ <p>In other words, from the worst-case scenario perspective it is optimal to always pick $M$ in the middle of $[L, R]$ and split it in half. Thus, the active segment halves on each step until it becomes of size $1$. So, if the process needs $h$ steps, in the end it reduces the difference between $R$ and $L$ from $R-L$ to $\\frac{R-L}{2^h} \\approx 1$, giving us the equation $2^h \\approx R-L$.</p> <p>Taking $\\log_2$ on both sides, we get $h \\approx \\log_2(R-L) \\in O(\\log n)$.</p> <p>Logarithmic number of steps is drastically better than that of linear search. For example, for $n \\approx 2^{20} \\approx 10^6$ you'd need to make approximately a million operations for linear search, but only around $20$ operations with the binary search.</p>","tags":["Original"]},{"location":"num_methods/binary_search.html#lower-bound-and-upper-bound","title":"Lower bound and upper bound","text":"<p>It is often convenient to find the position of the first element that is greater or equal than $k$ (called the lower bound of $k$ in the array) or the position of the first element that is greater than $k$ (called the upper bound of $k$) rather than the exact position of the element.</p> <p>Together, lower and upper bounds produce a possibly empty half-interval of the array elements that are equal to $k$. To check whether $k$ is present in the array it's enough to find its lower bound and check if the corresponding element equates to $k$.</p>","tags":["Original"]},{"location":"num_methods/binary_search.html#implementation","title":"Implementation","text":"<p>The explanation above provides a rough description of the algorithm. For the implementation details, we'd need to be more precise.</p> <p>We will maintain a pair $L &lt; R$ such that $A_L \\leq k &lt; A_R$. Meaning that the active search interval is $[L, R)$. We use half-interval here instead of a segment $[L, R]$ as it turns out to require less corner case work.</p> <p>When $R = L+1$, we can deduce from definitions above that $R$ is the upper bound of $k$. It is convenient to initialize $R$ with past-the-end index, that is $R=n$ and $L$ with before-the-beginning index, that is $L=-1$. It is fine as long as we never evaluate $A_L$ and $A_R$ in our algorithm directly, formally treating it as $A_L = -\\infty$ and $A_R = +\\infty$.</p> <p>Finally, to be specific about the value of $M$ we pick, we will stick with $M = \\lfloor \\frac{L+R}{2} \\rfloor$.</p> <p>Then the implementation could look like this:</p> <pre><code>... // a sorted array is stored as a[0], a[1], ..., a[n-1]\nint l = -1, r = n;\nwhile (r - l &gt; 1) {\n    int m = (l + r) / 2;\n    if (k &lt; a[m]) {\n        r = m; // a[l] &lt;= k &lt; a[m] &lt;= a[r]\n    } else {\n        l = m; // a[l] &lt;= a[m] &lt;= k &lt; a[r]\n    }\n}\n</code></pre> <p>During the execution of the algorithm, we never evaluate neither $A_L$ nor $A_R$, as $L &lt; M &lt; R$. In the end, $L$ will be the index of the last element that is not greater than $k$ (or $-1$ if there is no such element) and $R$ will be the index of the first element larger than $k$ (or $n$ if there is no such element).</p> <p>Note. Calculating <code>m</code> as <code>m = (r + l) / 2</code> can lead to overflow if <code>l</code> and <code>r</code> are two positive integers, and this error lived about 9 years in JDK as described in the blogpost. Some alternative approaches include e.g. writing <code>m = l + (r - l) / 2</code> which always works for positive integer <code>l</code> and <code>r</code>, but might still overflow if <code>l</code> is a negative number. If you use C++20, it offers an alternative solution in the form of <code>m = std::midpoint(l, r)</code> which always works correctly.</p>","tags":["Original"]},{"location":"num_methods/binary_search.html#search-on-arbitrary-predicate","title":"Search on arbitrary predicate","text":"<p>Let $f : \\{0,1,\\dots, n-1\\} \\to \\{0, 1\\}$ be a boolean function defined on $0,1,\\dots,n-1$ such that it is monotonously increasing, that is</p> $$ f(0) \\leq f(1) \\leq \\dots \\leq f(n-1). $$ <p>The binary search, the way it is described above, finds the partition of the array by the predicate $f(M)$, holding the boolean value of $k &lt; A_M$ expression. It is possible to use arbitrary monotonous predicate instead of $k &lt; A_M$. It is particularly useful when the computation of $f(k)$ requires too much time to actually compute it for every possible value. In other words, binary search finds the unique index $L$ such that $f(L) = 0$ and $f(R)=f(L+1)=1$ if such a transition point exists, or gives us $L = n-1$ if $f(0) = \\dots = f(n-1) = 0$ or $L = -1$ if $f(0) = \\dots = f(n-1) = 1$.</p> <p>Proof of correctness supposing a transition point exists, that is $f(0)=0$ and $f(n-1)=1$: The implementation maintains the loop invariant $f(l)=0, f(r)=1$. When $r - l &gt; 1$, the choice of $m$ means $r-l$ will always decrease. The loop terminates when $r - l = 1$, giving us our desired transition point.</p> <pre><code>... // f(i) is a boolean function such that f(0) &lt;= ... &lt;= f(n-1)\nint l = -1, r = n;\nwhile (r - l &gt; 1) {\n    int m = (l + r) / 2;\n    if (f(m)) {\n        r = m; // 0 = f(l) &lt; f(m) = 1\n    } else {\n        l = m; // 0 = f(m) &lt; f(r) = 1\n    }\n}\n</code></pre>","tags":["Original"]},{"location":"num_methods/binary_search.html#binary-search-on-the-answer","title":"Binary search on the answer","text":"<p>Such situation often occurs when we're asked to compute some value, but we're only capable of checking whether this value is at least $i$. For example, you're given an array $a_1,\\dots,a_n$ and you're asked to find the maximum floored average sum</p> $$ \\left \\lfloor \\frac{a_l + a_{l+1} + \\dots + a_r}{r-l+1} \\right\\rfloor $$ <p>among all possible pairs of $l,r$ such that $r-l \\geq x$. One of simple ways to solve this problem is to check whether the answer is at least $\\lambda$, that is if there is a pair $l, r$ such that the following is true:</p> $$ \\frac{a_l + a_{l+1} + \\dots + a_r}{r-l+1} \\geq \\lambda. $$ <p>Equivalently, it rewrites as</p> $$ (a_l - \\lambda) + (a_{l+1} - \\lambda) + \\dots + (a_r - \\lambda) \\geq 0, $$ <p>so now we need to check whether there is a subarray of a new array $a_i - \\lambda$ of length at least $x+1$ with non-negative sum, which is doable with some prefix sums.</p>","tags":["Original"]},{"location":"num_methods/binary_search.html#continuous-search","title":"Continuous search","text":"<p>Let $f : \\mathbb R \\to \\mathbb R$ be a real-valued function that is continuous on a segment $[L, R]$.</p> <p>Without loss of generality assume that $f(L) \\leq f(R)$. From intermediate value theorem it follows that for any $y \\in [f(L), f(R)]$ there is $x \\in [L, R]$ such that $f(x) = y$. Note that, unlike previous paragraphs, the function is not required to be monotonous.</p> <p>The value $x$ could be approximated up to $\\pm\\delta$ in $O\\left(\\log \\frac{R-L}{\\delta}\\right)$ time for any specific value of $\\delta$. The idea is essentially the same, if we take $M \\in (L, R)$ then we would be able to reduce the search interval to either $[L, M]$ or $[M, R]$ depending on whether $f(M)$ is larger than $y$. One common example here would be finding roots of odd-degree polynomials.</p> <p>For example, let $f(x)=x^3 + ax^2 + bx + c$. Then $f(L) \\to -\\infty$ and $f(R) \\to +\\infty$ with $L \\to -\\infty$ and $R \\to +\\infty$. Which means that it is always possible to find sufficiently small $L$ and sufficiently large $R$ such that $f(L) &lt; 0$ and $f(R) &gt; 0$. Then, it is possible to find with binary search arbitrarily small interval containing $x$ such that $f(x)=0$.</p>","tags":["Original"]},{"location":"num_methods/binary_search.html#search-with-powers-of-2","title":"Search with powers of 2","text":"<p>Another noteworthy way to do binary search is, instead of maintaining an active segment, to maintain the current pointer $i$ and the current power $k$. The pointer starts at $i=L$ and then on each iteration one tests the predicate at point $i+2^k$. If the predicate is still $0$, the pointer is advanced from $i$ to $i+2^k$, otherwise it stays the same, then the power $k$ is decreased by $1$.</p> <p>This paradigm is widely used in tasks around trees, such as finding lowest common ancestor of two vertices or finding an ancestor of a specific vertex that has a certain height. It could also be adapted to e.g. find the $k$-th non-zero element in a Fenwick tree.</p>","tags":["Original"]},{"location":"num_methods/binary_search.html#practice-problems","title":"Practice Problems","text":"<ul> <li>LeetCode -  Find First and Last Position of Element in Sorted Array</li> <li>LeetCode -  Search Insert Position</li> <li>LeetCode -  First Bad Version</li> <li>LeetCode -  Valid Perfect Square</li> <li>LeetCode -  Find Peak Element</li> <li>LeetCode -  Search in Rotated Sorted Array</li> <li>LeetCode -  Find Right Interval</li> <li>Codeforces - Interesting Drink</li> <li>Codeforces - Magic Powder - 1</li> <li>Codeforces - Another Problem on Strings</li> <li>Codeforces - Frodo and pillows</li> <li>Codeforces - GukiZ hates Boxes</li> <li>Codeforces - Enduring Exodus</li> <li>Codeforces - Chip 'n Dale Rescue Rangers</li> </ul>","tags":["Original"]},{"location":"num_methods/roots_newton.html","title":"Newton's method for finding roots","text":"<p>This is an iterative method invented by Isaac Newton around 1664. However, this method is also sometimes called the Raphson method, since Raphson invented the same algorithm a few years after Newton, but his article was published much earlier.</p> <p>The task is as follows. Given the following equation:</p> $$f(x) = 0$$ <p>We want to solve the equation. More precisely, we want to find one of its roots (it is assumed that the root exists). It is assumed that $f(x)$ is continuous and differentiable on an interval $[a, b]$.</p>","tags":["Translated"]},{"location":"num_methods/roots_newton.html#algorithm","title":"Algorithm","text":"<p>The input parameters of the algorithm consist of not only the function $f(x)$ but also the initial approximation - some $x_0$, with which the algorithm starts.</p> <p> </p> <p>Suppose we have already calculated $x_i$, calculate $x_{i+1}$ as follows. Draw the tangent to the graph of the function $f(x)$ at the point $x = x_i$, and find the point of intersection of this tangent with the $x$-axis. $x_{i+1}$ is set equal to the $x$-coordinate of the point found, and we repeat the whole process from the beginning.</p> <p>It is not difficult to obtain the following formula,</p> $$ x_{i+1} = x_i - \\frac{f(x_i)}{f^\\prime(x_i)} $$ <p>First, we calculate the slope $f'(x)$, derivative of $f(x)$, and then determine the equation of the tangent which is,</p> $$ y - f(x_i) = f'(x_i)(x - x_i) $$ <p>The tangent intersects with the x-axis at cordinate, $y = 0$ and $x = x_{i+1}$,</p> $$ - f(x_i) = f'(x_i)(x_{i+1} - x_i) $$ <p>Now, solving the equation we get the value of $x_{i+1}$.</p> <p>It is intuitively clear that if the function $f(x)$ is \"good\" (smooth), and $x_i$ is close enough to the root, then $x_{i+1}$ will be even closer to the desired root.</p> <p>The rate of convergence is quadratic, which, conditionally speaking, means that the number of exact digits in the approximate value $x_i$ doubles with each iteration.</p>","tags":["Translated"]},{"location":"num_methods/roots_newton.html#application-for-calculating-the-square-root","title":"Application for calculating the square root","text":"<p>Let's use the calculation of square root as an example of Newton's method.</p> <p>If we substitute $f(x) = x^2 - n$, then after simplifying the expression, we get:</p> $$ x_{i+1} = \\frac{x_i + \\frac{n}{x_i}}{2} $$ <p>The first typical variant of the problem is when a rational number $n$ is given, and its root must be calculated with some accuracy <code>eps</code>:</p> <pre><code>double sqrt_newton(double n) {\n    const double eps = 1E-15;\n    double x = 1;\n    for (;;) {\n        double nx = (x + n / x) / 2;\n        if (abs(x - nx) &lt; eps)\n            break;\n        x = nx;\n    }\n    return x;\n}\n</code></pre> <p>Another common variant of the problem is when we need to calculate the integer root (for the given $n$ find the largest $x$ such that $x^2 \\le n$). Here it is necessary to slightly change the termination condition of the algorithm, since it may happen that $x$ will start to \"jump\" near the answer. Therefore, we add a condition that if the value $x$ has decreased in the previous step, and it tries to increase at the current step, then the algorithm must be stopped.</p> <pre><code>int isqrt_newton(int n) {\n    int x = 1;\n    bool decreased = false;\n    for (;;) {\n        int nx = (x + n / x) &gt;&gt; 1;\n        if (x == nx || nx &gt; x &amp;&amp; decreased)\n            break;\n        decreased = nx &lt; x;\n        x = nx;\n    }\n    return x;\n}\n</code></pre> <p>Finally, we are given the third variant - for the case of bignum arithmetic. Since the number $n$ can be large enough, it makes sense to pay attention to the initial approximation. Obviously, the closer it is to the root, the faster the result will be achieved. It is simple enough and effective to take the initial approximation as the number $2^{\\textrm{bits}/2}$, where $\\textrm{bits}$ is the number of bits in the number $n$. Here is the Java code that demonstrates this variant:</p> <pre><code>public static BigInteger isqrtNewton(BigInteger n) {\n    BigInteger a = BigInteger.ONE.shiftLeft(n.bitLength() / 2);\n    boolean p_dec = false;\n    for (;;) {\n        BigInteger b = n.divide(a).add(a).shiftRight(1);\n        if (a.compareTo(b) == 0 || a.compareTo(b) &lt; 0 &amp;&amp; p_dec)\n            break;\n        p_dec = a.compareTo(b) &gt; 0;\n        a = b;\n    }\n    return a;\n}\n</code></pre> <p>For example, this code is executed in $60$ milliseconds for $n = 10^{1000}$, and if we remove the improved selection of the initial approximation (just starting with $1$), then it will be executed in about $120$ milliseconds.</p>","tags":["Translated"]},{"location":"num_methods/roots_newton.html#practice-problems","title":"Practice Problems","text":"<ul> <li>UVa 10428 - The Roots</li> </ul>","tags":["Translated"]},{"location":"num_methods/simpson-integration.html","title":"Integration by Simpson's formula","text":"<p>We are going to calculate the value of a definite integral</p> $$\\int_a ^ b f (x) dx$$ <p>The solution described here was published in one of the dissertations of Thomas Simpson in 1743.</p>","tags":["Translated"]},{"location":"num_methods/simpson-integration.html#simpsons-formula","title":"Simpson's formula","text":"<p>Let $n$ be some natural number. We divide the integration segment $[a, b]$ into $2n$ equal parts:</p> $$x_i = a + i h, ~~ i = 0 \\ldots 2n,$$ $$h = \\frac {b-a} {2n}.$$ <p>Now we calculate the integral separately on each of the segments $[x_ {2i-2}, x_ {2i}]$, $i = 1 \\ldots n$, and then add all the values.</p> <p>So, suppose we consider the next segment $[x_ {2i-2}, x_ {2i}],  i = 1 \\ldots n$. Replace the function $f(x)$ on it with a parabola $P(x)$ passing through 3 points $(x_ {2i-2}, x_ {2i-1}, x_ {2i})$. Such a parabola always exists and is unique; it can be found analytically. For instance we could construct it using the Lagrange polynomial interpolation. The only remaining thing left to do is to integrate this polynomial. If you do this for a general function $f$, you receive a remarkably simple expression:</p> $$\\int_{x_ {2i-2}} ^ {x_ {2i}} f (x) ~dx \\approx \\int_{x_ {2i-2}} ^ {x_ {2i}} P (x) ~dx = \\left(f(x_{2i-2}) + 4f(x_{2i-1})+(f(x_{2i})\\right)\\frac {h} {3} $$ <p>Adding these values over all segments, we obtain the final Simpson's formula:</p> $$\\int_a ^ b f (x) dx \\approx \\left(f (x_0) + 4 f (x_1) + 2 f (x_2) + 4f(x_3) + 2 f(x_4) + \\ldots + 4 f(x_{2N-1}) + f(x_{2N}) \\right)\\frac {h} {3} $$","tags":["Translated"]},{"location":"num_methods/simpson-integration.html#error","title":"Error","text":"<p>The error in approximating an integral by Simpson's formula is</p> $$ -\\tfrac{1}{90} \\left(\\tfrac{b-a}{2}\\right)^5 f^{(4)}(\\xi)$$ <p>where $\\xi$ is some number between $a$ and $b$.</p> <p>The error is asymptotically proportional to $(b-a)^5$. However, the above derivations suggest an error proportional to $(b-a)^4$. Simpson's rule gains an extra order because the points at which the integrand is evaluated are distributed symmetrically in the interval $[a, b]$.</p>","tags":["Translated"]},{"location":"num_methods/simpson-integration.html#implementation","title":"Implementation","text":"<p>Here, $f(x)$ is some user-defined function.</p> <pre><code>const int N = 1000 * 1000; // number of steps (already multiplied by 2)\n\ndouble simpson_integration(double a, double b){\n    double h = (b - a) / N;\n    double s = f(a) + f(b); // a = x_0 and b = x_2n\n    for (int i = 1; i &lt;= N - 1; ++i) { // Refer to final Simpson's formula\n        double x = a + h * i;\n        s += f(x) * ((i &amp; 1) ? 4 : 2);\n    }\n    s *= h / 3;\n    return s;\n}\n</code></pre>","tags":["Translated"]},{"location":"num_methods/simpson-integration.html#practice-problems","title":"Practice Problems","text":"<ul> <li>Latin American Regionals 2012 - Environment Protection</li> </ul>","tags":["Translated"]},{"location":"num_methods/simulated_annealing.html","title":"Simulated Annealing","text":"<p>Simulated Annealing (SA) is a randomized algorithm, which approximates the global optimum of a function. It's called a randomized algorithm, because it employs a certain amount of randomness in its search and thus its output can vary for the same input.</p>","tags":["Original"]},{"location":"num_methods/simulated_annealing.html#the-problem","title":"The problem","text":"<p>We are given a function $E(s)$, which calculates the energy of the state $s$. We are tasked with finding the state $s_{best}$ at which $E(s)$ is minimized. SA is suited for problems where the states are discrete and $E(s)$ has multiple local minima. We'll take the example of the Travelling Salesman Problem (TSP). </p>","tags":["Original"]},{"location":"num_methods/simulated_annealing.html#travelling-salesman-problem-tsp","title":"Travelling Salesman Problem (TSP)","text":"<p>You are given a set of nodes in 2 dimensional space. Each node is characterised by its $x$ and $y$ coordinates. Your task is to find an ordering of the nodes, which will minimise the distance to be travelled when visiting these nodes in that order.</p>","tags":["Original"]},{"location":"num_methods/simulated_annealing.html#motivation","title":"Motivation","text":"<p>Annealing is a metallurgical process, wherein a material is heated up and allowed to cool, in order to allow the atoms inside to rearrange themselves in an arrangement with minimal internal energy, which in turn causes the material to have different properties. The state is the arrangement of atoms and the internal energy is the function being minimised. We can think of the original state of the atoms, as a local minima for its internal energy. To make the material rearrange its atoms, we need to motivate it to go across a region where its internal energy is not minimised in order to reach the global minima. This motivation is given by heating the material to a higher temperature. </p> <p>Simulated annealing, literally, simulates this process. We start off with some random state (material) and set a high temperature (heat it up). Now, the algorithm is ready to accept states which have a higher energy than the current state, as it is motivated by the high temperature. This prevents the algorithm from getting stuck inside local minimas and move towards the global minima. As time progresses, the algorithm cools down and refuses the states with higher energy and moves into the closest minima it has found.</p>","tags":["Original"]},{"location":"num_methods/simulated_annealing.html#the-energy-function-es","title":"The energy function E(s)","text":"<p>$E(s)$ is the function which needs to be minimised (or maximised). It maps every state to a real number. In the case of TSP, $E(s)$ returns the distance of travelling one full circle in the order of nodes in the state. </p>","tags":["Original"]},{"location":"num_methods/simulated_annealing.html#state","title":"State","text":"<p>The state space is the domain of the energy function, $E(s)$, and a state is any element which belongs to the state space. In the case of TSP, all possible paths that we can take to visit all the nodes is the state space, and any single one of these paths can be considered as a state.</p>","tags":["Original"]},{"location":"num_methods/simulated_annealing.html#neighbouring-state","title":"Neighbouring state","text":"<p>It is a state in the state space which is close to the previous state. This usually means that we can obtain the neighbouring state from the original state using a simple transform. In the case of the Travelling Salesman Problem, a neighbouring state is obtained by randomly choosing 2 nodes, and swapping their positions in the current state. </p>","tags":["Original"]},{"location":"num_methods/simulated_annealing.html#algorithm","title":"Algorithm","text":"<p>We start with a random state $s$. In every step, we choose a neighbouring state $s_{next}$ of the current state $s$. If $E(s_{next}) &lt; E(s)$, then we update $s = s_{next}$. Otherwise, we use a probability acceptance function $P(E(s),E(s_{next}),T)$ which decides whether we should move to $s_{next}$ or stay at $s$. T here is the temperature, which is initially set to a high value and decays slowly with every step. The higher the temperature, the more likely it is to move to $s_{next}$.  At the same time we also keep a track of the best state $s_{best}$ across all iterations. Proceeding till convergence or time runs out.</p> A visual representation of simulated annealing, searching for the maxima of this function with multiple local maxima.","tags":["Original"]},{"location":"num_methods/simulated_annealing.html#temperaturet-and-decayu","title":"Temperature(T) and decay(u)","text":"<p>The temperature of the system quantifies the willingness of the algorithm to accept a state with a higher energy. The decay is a constant which quantifies the \"cooling rate\" of the algorithm. A slow cooling rate (larger $u$) is known to give better results.</p>","tags":["Original"]},{"location":"num_methods/simulated_annealing.html#probability-acceptance-functionpaf","title":"Probability Acceptance Function(PAF)","text":"<p>$P(E,E_{next},T) =      \\begin{cases}        \\text{True} &amp;\\quad\\text{if }  \\mathcal{U}_{[0,1]} \\le \\exp(-\\frac{E_{next}-E}{T}) \\\\        \\text{False} &amp;\\quad\\text{otherwise}\\\\      \\end{cases}$</p> <p>Here, $\\mathcal{U}_{[0,1]}$ is a continuous uniform random value on $[0,1]$. This function takes in the current state, the next state and the temperature, returning a boolean value, which tells our search whether it should move to $s_{next}$ or stay at $s$. Note that for $E_{next} &lt; E$ , this function will always return True, otherwise it can still make the move with probability $\\exp(-\\frac{E_{next}-E}{T})$, which corresponds to the Gibbs measure.</p> <pre><code>bool P(double E,double E_next,double T,mt19937 rng){\n    double prob =  exp(-(E_next-E)/T);\n    if(prob &gt; 1) return true;\n    else{\n        bernoulli_distribution d(prob); \n        return d(rng);\n    }\n}\n</code></pre>","tags":["Original"]},{"location":"num_methods/simulated_annealing.html#code-template","title":"Code Template","text":"<pre><code>class state {\n    public:\n    state() {\n        // Generate the initial state\n    }\n    state next() {\n        state s_next;\n        // Modify s_next to a random neighboring state\n        return s_next;\n    }\n    double E() {\n        // Implement the energy function here\n    };\n};\n\n\npair&lt;double, state&gt; simAnneal() {\n    state s = state();\n    state best = s;\n    double T = 10000; // Initial temperature\n    double u = 0.995; // decay rate\n    double E = s.E();\n    double E_next;\n    double E_best = E;\n    mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n    while (T &gt; 1) {\n        state next = s.next();\n        E_next = next.E();\n        if (P(E, E_next, T, rng)) {\n            s = next;\n            if (E_next &lt; E_best) {\n                best = s;\n                E_best = E_next;\n            }\n            E = E_next;\n        }\n        T *= u;\n    }\n    return {E_best, best};\n}\n</code></pre>","tags":["Original"]},{"location":"num_methods/simulated_annealing.html#how-to-use","title":"How to use:","text":"<p>Fill in the state class functions as appropriate. If you are trying to find a global maxima and not a minima, ensure that the $E()$ function returns negative of the function you are maximizing and print $-E_{best}$ in the end. Set the below parameters as per your need.</p>","tags":["Original"]},{"location":"num_methods/simulated_annealing.html#parameters","title":"Parameters","text":"<ul> <li>$T$ : Initial temperature. Set it to a higher value if you want the search to run for a longer time.</li> <li>$u$ : Decay. Decides the rate of cooling. A slower cooling rate (larger value of u) usually gives better results, at the cost of running for a longer time. Ensure $u &lt; 1$. </li> </ul> <p>The number of iterations the loop will run for is given by the expression</p> <p>$N =   \\lceil -\\log_{u}{T} \\rceil$ </p> <p>Tips for choosing $T$ and $u$ : If there are many local minimas and a wide state space, set $u = 0.999$, for a slow cooling rate, which will allow the algorithm to explore more possibilities. On the other hand, if the state space is narrower, $u = 0.99$ should suffice. If you are not sure, play it safe by setting $u = 0.998$ or higher. Calculate the time complexity of a single iteration of the algorithm, and use this to approximate a value of $N$ which will prevent TLE, then use the below formula to obtain $T$.</p> <p>$T = u^{-N}$</p>","tags":["Original"]},{"location":"num_methods/simulated_annealing.html#example-implementation-for-tsp","title":"Example implementation for TSP","text":"<pre><code>class state {\n    public:\n    vector&lt;pair&lt;int, int&gt;&gt; points;\n    std::mt19937 mt{ static_cast&lt;std::mt19937::result_type&gt;(\n        std::chrono::steady_clock::now().time_since_epoch().count()\n        ) };\n    state() {\n        points =  {{0,0},{2,2},{0,2},{2,0},{0,1},{1,2},{2,1},{1,0}} ;\n    }\n    state next() {\n        state s_next;\n        s_next.points = points;\n        uniform_int_distribution&lt;&gt; choose(0, points.size()-1);\n        int a = choose(mt);\n        int b = choose(mt);\n        s_next.points[a].swap(s_next.points[b]);\n        return s_next;\n    }\n\n    double euclidean(pair&lt;int, int&gt; a, pair&lt;int, int&gt; b) {\n        return hypot(a.first - b.first, a.second - b.second);\n    }\n\n    double E() {\n        double dist = 0;\n        int n = points.size();\n        for (int i = 0;i &lt; n; i++)\n            dist += euclidean(points[i], points[(i+1)%n]);\n        return dist;\n    };\n};\n\nint main() {\n    pair&lt;double, state&gt; res;\n    res = simAnneal();\n    double E_best = res.first;\n    state best = res.second;\n    cout &lt;&lt; \"Lenght of shortest path found : \" &lt;&lt; E_best &lt;&lt; \"\\n\";\n    cout &lt;&lt; \"Order of points in shortest path : \\n\";\n    for(auto x: best.points) {\n        cout &lt;&lt; x.first &lt;&lt; \" \" &lt;&lt; x.second &lt;&lt; \"\\n\";\n    }\n}\n</code></pre>","tags":["Original"]},{"location":"num_methods/simulated_annealing.html#further-modifications-to-the-algorithm","title":"Further modifications to the algorithm:","text":"<ul> <li>Add a time based exit condition to the while loop to prevent TLE</li> <li>The decay implemented above is an exponential decay. You can always replace this with a decay function as per your needs.</li> <li>The Probability acceptance function given above, prefers accepting states which are lower in energy because of the $E_{next} - E$ factor in the numerator of the exponent. You can simply remove this factor, to make the PAF independent of the difference in energies.</li> <li>The effect of the difference in energies, $E_{next} - E$, on the PAF can be increased/decreased by increasing/decreasing the base of the exponent as shown below:  <pre><code>bool P(double E, double E_next, double T, mt19937 rng) {\n    double e = 2; // set e to any real number greater than 1\n    double prob =  pow(e,-(E_next-E)/T);\n    if (prob &gt; 1)\n        return true;\n    else {\n        bernoulli_distribution d(prob); \n        return d(rng);\n    }\n}\n</code></pre></li> </ul>","tags":["Original"]},{"location":"num_methods/simulated_annealing.html#problems","title":"Problems","text":"<ul> <li>USACO Jan 2017 - Subsequence Reversal</li> <li>Deltix Summer 2021 - DIY Tree</li> <li>AtCoder Contest Scheduling</li> </ul>","tags":["Original"]},{"location":"num_methods/ternary_search.html","title":"Ternary Search","text":"<p>We are given a function $f(x)$ which is unimodal on an interval $[l, r]$. By unimodal function, we mean one of two behaviors of the function: </p> <ol> <li> <p>The function strictly increases first, reaches a maximum (at a single point or over an interval), and then strictly decreases.</p> </li> <li> <p>The function strictly decreases first, reaches a minimum, and then strictly increases.</p> </li> </ol> <p>In this article, we will assume the first scenario. The second scenario is completely symmetrical to the first.</p> <p>The task is to find the maximum of function $f(x)$ on the interval $[l, r]$.</p>","tags":["Translated"]},{"location":"num_methods/ternary_search.html#algorithm","title":"Algorithm","text":"<p>Consider any 2 points $m_1$, and $m_2$ in this interval: $l &lt; m_1 &lt; m_2 &lt; r$. We evaluate the function at $m_1$ and $m_2$, i.e. find the values of $f(m_1)$ and $f(m_2)$. Now, we get one of three options:</p> <ul> <li> <p>$f(m_1) &lt; f(m_2)$</p> <p>The desired maximum can not be located on the left side of $m_1$, i.e. on the interval $[l, m_1]$, since either both points $m_1$ and $m_2$ or just $m_1$ belong to the area where the function increases. In either case, this means that we have to search for the maximum in the segment $[m_1, r]$.</p> </li> <li> <p>$f(m_1) &gt; f(m_2)$</p> <p>This situation is symmetrical to the previous one: the maximum can not be located on the right side of $m_2$, i.e. on the interval $[m_2, r]$, and the search space is reduced to the segment $[l, m_2]$.</p> </li> <li> <p>$f(m_1) = f(m_2)$</p> <p>We can see that either both of these points belong to the area where the value of the function is maximized, or $m_1$ is in the area of increasing values and $m_2$ is in the area of descending values (here we used the strictness of function increasing/decreasing). Thus, the search space is reduced to $[m_1, m_2]$. To simplify the code, this case can be combined with any of the previous cases.</p> </li> </ul> <p>Thus, based on the comparison of the values in the two inner points, we can replace the current interval $[l, r]$ with a new, shorter interval $[l^\\prime, r^\\prime]$. Repeatedly applying the described procedure to the interval, we can get an arbitrarily short interval. Eventually, its length will be less than a certain pre-defined constant (accuracy), and the process can be stopped. This is a numerical method, so we can assume that after that the function reaches its maximum at all points of the last interval $[l, r]$. Without loss of generality, we can take $f(l)$ as the return value.</p> <p>We didn't impose any restrictions on the choice of points $m_1$ and $m_2$. This choice will define the convergence rate and the accuracy of the implementation. The most common way is to choose the points so that they divide the interval $[l, r]$ into three equal parts. Thus, we have</p> $$m_1 = l + \\frac{(r - l)}{3}$$ $$m_2 = r - \\frac{(r - l)}{3}$$ <p>If $m_1$ and $m_2$ are chosen to be closer to each other, the convergence rate will increase slightly.</p>","tags":["Translated"]},{"location":"num_methods/ternary_search.html#run-time-analysis","title":"Run time analysis","text":"$$T(n) = T({2n}/{3}) + O(1) = \\Theta(\\log n)$$ <p>It can be visualized as follows: every time after evaluating the function at points $m_1$ and $m_2$, we are essentially ignoring about one third of the interval, either the left or right one. Thus the size of the search space is ${2n}/{3}$ of the original one. </p> <p>Applying Master's Theorem, we get the desired complexity estimate.</p>","tags":["Translated"]},{"location":"num_methods/ternary_search.html#the-case-of-the-integer-arguments","title":"The case of the integer arguments","text":"<p>If $f(x)$ takes integer parameter, the interval $[l, r]$ becomes discrete. Since we did not impose any restrictions on the choice of points $m_1$ and $m_2$, the correctness of the algorithm is not affected. $m_1$ and $m_2$ can still be chosen to divide $[l, r]$ into 3 approximately equal parts.</p> <p>The difference occurs in the stopping criterion of the algorithm. Ternary search will have to stop when $(r - l) &lt; 3$, because in that case we can no longer select $m_1$ and $m_2$ to be different from each other as well as from $l$ and $r$, and this can cause an infinite loop. Once $(r - l) &lt; 3$, the remaining pool of candidate points $(l, l + 1, \\ldots, r)$ needs to be checked to find the point which produces the maximum value $f(x)$.</p>","tags":["Translated"]},{"location":"num_methods/ternary_search.html#golden-section-search","title":"Golden section search","text":"<p>In some cases computing $f(x)$ may be quite slow, but reducing the number of iterations is infeasible due to precision issues. Fortunately, it is possible to compute $f(x)$ only once at each iteration (except the first one).</p> <p>To see how to do this, let's revisit the selection method for $m_1$ and $m_2$. Suppose that we select $m_1$ and $m_2$ on $[l, r]$ in such a way that $\\frac{r - l}{r - m_1} = \\frac{r - l}{m_2 - l} = \\varphi$ where $\\varphi$ is some constant. In order to reduce the amount of computations, we want to select such $\\varphi$ that on the next iteration one of the new evaluation points $m_1'$, $m_2'$ will coincide with either $m_1$ or $m_2$, so that we can reuse the already computed function value.</p> <p>Now suppose that after the current iteration we set $l = m_1$. Then the point $m_1'$ will satisfy $\\frac{r - m_1}{r - m_1'} = \\varphi$. We want this point to coincide with $m_2$, meaning that $\\frac{r - m_1}{r - m_2} = \\varphi$.</p> <p>Multiplying both sides of $\\frac{r - m_1}{r - m_2} = \\varphi$ by $\\frac{r - m_2}{r - l}$ we obtain $\\frac{r - m_1}{r - l} = \\varphi\\frac{r - m_2}{r - l}$. Note that $\\frac{r - m_1}{r - l} = \\frac{1}{\\varphi}$ and $\\frac{r - m_2}{r - l} = \\frac{r - l + l - m_2}{r - l} = 1 - \\frac{1}{\\varphi}$. Substituting that and multiplying by $\\varphi$, we obtain the following equation:</p> <p>$\\varphi^2 - \\varphi - 1 = 0$</p> <p>This is a well-known golden section equation. Solving it yields $\\frac{1 \\pm \\sqrt{5}}{2}$. Since $\\varphi$ must be positive, we obtain $\\varphi = \\frac{1 + \\sqrt{5}}{2}$. By applying the same logic to the case when we set $r = m_2$ and want $m_2'$ to coincide with $m_1$, we obtain the same value of $\\varphi$ as well. So, if we choose $m_1 = l + \\frac{r - l}{1 + \\varphi}$ and $m_2 = r - \\frac{r - l}{1 + \\varphi}$, on each iteration we can re-use one of the values $f(x)$ computed on the previous iteration.</p>","tags":["Translated"]},{"location":"num_methods/ternary_search.html#implementation","title":"Implementation","text":"<pre><code>double ternary_search(double l, double r) {\n    double eps = 1e-9;              //set the error limit here\n    while (r - l &gt; eps) {\n        double m1 = l + (r - l) / 3;\n        double m2 = r - (r - l) / 3;\n        double f1 = f(m1);      //evaluates the function at m1\n        double f2 = f(m2);      //evaluates the function at m2\n        if (f1 &lt; f2)\n            l = m1;\n        else\n            r = m2;\n    }\n    return f(l);                    //return the maximum of f(x) in [l, r]\n}\n</code></pre> <p>Here <code>eps</code> is in fact the absolute error (not taking into account errors due to the inaccurate calculation of the function).</p> <p>Instead of the criterion <code>r - l &gt; eps</code>, we can select a constant number of iterations as a stopping criterion. The number of iterations should be chosen to ensure the required accuracy. Typically, in most programming challenges the error limit is ${10}^{-6}$ and thus 200 - 300 iterations are sufficient. Also, the number of iterations doesn't depend on the values of $l$ and $r$, so the number of iterations corresponds to the required relative error.</p>","tags":["Translated"]},{"location":"num_methods/ternary_search.html#practice-problems","title":"Practice Problems","text":"<ul> <li>Codeforces - New Bakery</li> <li>Codechef - Race time</li> <li>Hackerearth - Rescuer</li> <li>Spoj - Building Construction</li> <li>Codeforces - Weakness and Poorness</li> <li>LOJ - Closest Distance</li> <li>GYM - Dome of Circus (D)</li> <li>UVA - Galactic Taxes</li> <li>GYM - Chasing the Cheetahs (A)</li> <li>UVA - 12197 - Trick or Treat</li> <li>SPOJ - Building Construction</li> <li>Codeforces - Devu and his Brother</li> <li>Codechef - Is This JEE </li> <li>Codeforces - Restorer Distance</li> <li>TIMUS 1058 Chocolate</li> <li>TIMUS 1436 Billboard</li> <li>TIMUS 1451 Beerhouse Tale</li> <li>TIMUS 1719 Kill the Shaitan-Boss</li> <li>TIMUS 1913 Titan Ruins: Alignment of Forces</li> </ul>","tags":["Translated"]},{"location":"others/15-puzzle.html","title":"15 Puzzle Game: Existence Of The Solution","text":"<p>This game is played on a $4 \\times 4$ board. On this board there are $15$ playing tiles numbered from 1 to 15. One cell is left empty (denoted by 0). You need to get the board to the position presented below by repeatedly moving one of the tiles to the free space:</p> $$\\begin{matrix} 1 &amp; 2 &amp; 3 &amp; 4 \\\\ 5 &amp; 6 &amp; 7 &amp; 8 \\\\ 9 &amp; 10 &amp; 11 &amp; 12 \\\\ 13 &amp; 14 &amp; 15 &amp; 0 \\end{matrix}$$ <p>The game \"15 Puzzle\u201d was created by Noyes Chapman in 1880.</p>","tags":["Translated"]},{"location":"others/15-puzzle.html#existence-of-the-solution","title":"Existence Of The Solution","text":"<p>Let's consider this problem: given a position on the board, determine whether a sequence of moves which leads to a solution exists.</p> <p>Suppose we have some position on the board:</p> $$\\begin{matrix} a_1 &amp; a_2 &amp; a_3 &amp; a_4 \\\\ a_5 &amp; a_6 &amp; a_7 &amp; a_8 \\\\ a_9 &amp; a_{10} &amp; a_{11} &amp; a_{12} \\\\ a_{13} &amp; a_{14} &amp; a_{15} &amp; a_{16} \\end{matrix}$$ <p>where one of the elements equals zero and indicates an empty cell $a_z  = 0$</p> <p>Let\u2019s consider the permutation:</p> $$a_1 a_2 ... a_{z-1} a_{z+1} ... a_{15} a_{16}$$ <p>i.e. the permutation of numbers corresponding to the position on the board without a zero element</p> <p>Let $N$ be the number of inversions in this permutation (i.e. the number of such elements $a_i$  and $a_j$  that $i &lt; j$, but $a_i  &gt; a_j$).</p> <p>Suppose $K$ is an index of a row where the empty element is located (i.e. using our convention, $K = (z - 1) \\div \\ 4 + 1$).</p> <p>Then, the solution exists iff $N + K$ is even.</p>","tags":["Translated"]},{"location":"others/15-puzzle.html#implementation","title":"Implementation","text":"<p>The algorithm above can be illustrated with the following program code:</p> <pre><code>int a[16];\nfor (int i=0; i&lt;16; ++i)\n    cin &gt;&gt; a[i];\n\nint inv = 0;\nfor (int i=0; i&lt;16; ++i)\n    if (a[i])\n        for (int j=0; j&lt;i; ++j)\n            if (a[j] &gt; a[i])\n                ++inv;\nfor (int i=0; i&lt;16; ++i)\n    if (a[i] == 0)\n        inv += 1 + i / 4;\n\nputs ((inv &amp; 1) ? \"No Solution\" : \"Solution Exists\");\n</code></pre>","tags":["Translated"]},{"location":"others/15-puzzle.html#proof","title":"Proof","text":"<p>In 1879 Johnson proved that if $N + K$ is odd, then the solution doesn\u2019t exist, and in the same year Story proved that all positions when $N + K$ is even have a solution.</p> <p>However, all these proofs were quite complex.</p> <p>In 1999 Archer proposed a much simpler proof (you can download his article here).</p>","tags":["Translated"]},{"location":"others/15-puzzle.html#practice-problems","title":"Practice Problems","text":"<ul> <li>Hackerrank - N-puzzle</li> </ul>","tags":["Translated"]},{"location":"others/josephus_problem.html","title":"Josephus Problem","text":"","tags":["Translated"]},{"location":"others/josephus_problem.html#statement","title":"Statement","text":"<p>We are given the natural numbers $n$ and $k$. All natural numbers from $1$ to $n$ are written in a circle.  First, count the $k$-th number starting from the first one and delete it. Then $k$ numbers are counted starting from the next one and the $k$-th one is removed again, and so on. The process stops when one number remains. It is required to find the last number.</p> <p>This task was set by Flavius Josephus in the 1st century (though in a somewhat narrower formulation: for $k = 2$).</p> <p>This problem can be solved by modeling the procedure. Brute force modeling will work $O(n^{2})$. Using a Segment Tree, we can improve it to $O(n \\log n)$. We want something better though.</p>","tags":["Translated"]},{"location":"others/josephus_problem.html#modeling-a-on-solution","title":"Modeling a $O(n)$ solution","text":"<p>We will try to find a pattern expressing the answer for the problem $J_{n, k}$ through the solution of the previous problems.</p> <p>Using brute force modeling we can construct a table of values, for example, the following:</p> $$\\begin{array}{ccccccccccc} n\\setminus k &amp; 1 &amp; 2 &amp; 3 &amp; 4 &amp; 5 &amp; 6 &amp; 7 &amp; 8 &amp; 9 &amp; 10 \\\\ 1 &amp; 1 &amp; 1 &amp; 1 &amp; 1 &amp; 1 &amp; 1 &amp; 1 &amp; 1 &amp; 1 &amp; 1 \\\\ 2 &amp; 2 &amp; 1 &amp; 2 &amp; 1 &amp; 2 &amp; 1 &amp; 2 &amp; 1 &amp; 2 &amp; 1 \\\\ 3 &amp; 3 &amp; 3 &amp; 2 &amp; 2 &amp; 1 &amp; 1 &amp; 3 &amp; 3 &amp; 2 &amp; 2 \\\\ 4 &amp; 4 &amp; 1 &amp; 1 &amp; 2 &amp; 2 &amp; 3 &amp; 2 &amp; 3 &amp; 3 &amp; 4 \\\\ 5 &amp; 5 &amp; 3 &amp; 4 &amp; 1 &amp; 2 &amp; 4 &amp; 4 &amp; 1 &amp; 2 &amp; 4 \\\\ 6 &amp; 6 &amp; 5 &amp; 1 &amp; 5 &amp; 1 &amp; 4 &amp; 5 &amp; 3 &amp; 5 &amp; 2 \\\\ 7 &amp; 7 &amp; 7 &amp; 4 &amp; 2 &amp; 6 &amp; 3 &amp; 5 &amp; 4 &amp; 7 &amp; 5 \\\\ 8 &amp; 8 &amp; 1 &amp; 7 &amp; 6 &amp; 3 &amp; 1 &amp; 4 &amp; 4 &amp; 8 &amp; 7 \\\\ 9 &amp; 9 &amp; 3 &amp; 1 &amp; 1 &amp; 8 &amp; 7 &amp; 2 &amp; 3 &amp; 8 &amp; 8 \\\\ 10 &amp; 10 &amp; 5 &amp; 4 &amp; 5 &amp; 3 &amp; 3 &amp; 9 &amp; 1 &amp; 7 &amp; 8 \\\\ \\end{array}$$ <p>And here we can clearly see the following pattern:</p> $$J_{n,k} = \\left( (J_{n-1,k} + k - 1) \\bmod n \\right) + 1$$ $$J_{1,k} = 1$$ <p>Here, 1-indexing makes for a somewhat messy formula; if you instead number the positions from 0, you get a very elegant formula:</p> $$J_{n,k} = (J_{n-1,k} + k) \\bmod n$$ <p>So, we found a solution to the problem of Josephus, working in $O(n)$ operations.</p>","tags":["Translated"]},{"location":"others/josephus_problem.html#implementation","title":"Implementation","text":"<p>Simple recursive implementation (in 1-indexing)</p> <pre><code>int josephus(int n, int k) {\n    return n &gt; 1 ? (josephus(n-1, k) + k - 1) % n + 1 : 1;\n}\n</code></pre> <p>Non-recursive form :</p> <pre><code>int josephus(int n, int k) {\n    int res = 0;\n    for (int i = 1; i &lt;= n; ++i)\n      res = (res + k) % i;\n    return res + 1;\n}\n</code></pre> <p>This formula can also be found analytically. Again here we assume 0-indexing. After we delete the first number, we have $n-1$ numbers left. When we repeat the procedure, we will start with the number that had originally the index $k \\bmod n$. $J_{n-1, k}$ would be the answer for the remaining circle, if we start counting at $0$, but because we actually start with $k$ we have $J_{n, k} = (J_{n-1,k} + k) \\ \\bmod n$.</p>","tags":["Translated"]},{"location":"others/josephus_problem.html#modeling-a-ok-log-n-solution","title":"Modeling a $O(k \\log n)$ solution","text":"<p>For relatively small $k$ we can come up with a better solution than the above recursive solution in $O(n)$. If $k$ is a lot smaller than $n$, then we can delete multiple numbers ($\\lfloor \\frac{n}{k} \\rfloor$) in one run without looping over. Afterwards we have $n - \\lfloor \\frac{n}{k} \\rfloor$ numbers left, and we start with the $(\\lfloor \\frac{n}{k} \\rfloor \\cdot k)$-th number. So we have to shift by that many. We can notice that $\\lfloor \\frac{n}{k} \\rfloor \\cdot k$ is simply $-n \\bmod k$. And because we removed every $k$-th number, we have to add the number of numbers that we removed before the result index. Which we can compute by dividing the result index by $k - 1$.</p> <p>Also, we need to handle the case when $n$ becomes less than $k$. In this case, the above optimization would cause an infinite loop.</p> <p>Implementation (for convenience in 0-indexing):</p> <pre><code>int josephus(int n, int k) {\n    if (n == 1)\n        return 0;\n    if (k == 1)\n        return n-1;\n    if (k &gt; n)\n        return (josephus(n-1, k) + k) % n;\n    int cnt = n / k;\n    int res = josephus(n - cnt, k);\n    res -= n % k;\n    if (res &lt; 0)\n        res += n;\n    else\n        res += res / (k - 1);\n    return res;\n}\n</code></pre> <p>Let us estimate the complexity of this algorithm. Immediately note that the case $n &lt; k$ is analyzed by the old solution, which will work in this case for $O(k)$. Now consider the algorithm itself. In fact, after every iteration, instead of $n$ numbers, we are left with $n \\left( 1 - \\frac{1}{k} \\right)$ numbers, so the total number of iterations $x$ of the algorithm can be found roughly from the following equation:</p> $$ n \\left(1 - \\frac{1}{k} \\right) ^ x = 1, $$ <p>on taking logarithm on both sides, we obtain:</p> $$\\ln n + x \\ln \\left(1 - \\frac{1}{k} \\right) = 0,$$  $$x = - \\frac{\\ln n}{\\ln \\left(1 - \\frac{1}{k} \\right)},$$ <p>using the decomposition of the logarithm into Taylor series, we obtain an approximate estimate:</p> $$x \\approx k \\ln n$$ <p>Thus, the complexity of the algorithm is actually $O (k \\log n)$.</p>","tags":["Translated"]},{"location":"others/josephus_problem.html#analytical-solution-for-k-2","title":"Analytical solution for $k = 2$","text":"<p>In this particular case (in which this task was set by Josephus Flavius) the problem is solved much easier.</p> <p>In the case of even $n$ we get that all even numbers will be crossed out, and then there will be a problem remaining for $\\frac{n}{2}$, then the answer for $n$ will be obtained from the answer for $\\frac{n}{2}$ by multiplying by two and subtracting one (by shifting positions):</p> $$ J_{2n, 2} = 2 J_{n, 2} - 1 $$ <p>Similarly, in the case of an odd $n$, all even numbers will be crossed out, then the first number, and the problem for $\\frac{n-1}{2}$ will remain, and taking into account the shift of positions, we obtain the second formula:</p> $$J_{2n+1,2} = 2 J_{n, 2} + 1 $$ <p>We can use this recurrent dependency directly in our implementation. This pattern can be translated into another form: $J_{n, 2}$ represents a sequence of all odd numbers, \"restarting\" from one whenever $n$ turns out to be a power of two. This can be written as a single formula:</p> $$J_{n, 2} = 1 + 2 \\left(n-2^{\\lfloor \\log_2 n \\rfloor} \\right)$$","tags":["Translated"]},{"location":"others/josephus_problem.html#analytical-solution-for-k-2_1","title":"Analytical solution for $k &gt; 2$","text":"<p>Despite the simple form of the problem and a large number of articles on this and related problems, a simple analytical representation of the solution of Josephus' problem has not yet been found. For small $k$, some formulas are derived, but apparently they are all difficult to apply in practice (for example, see Halbeisen, Hungerbuhler \"The Josephus Problem\" and Odlyzko, Wilf \"Functional iteration and the Josephus problem\").</p>","tags":["Translated"]},{"location":"others/maximum_average_segment.html","title":"Search the subarray with the maximum/minimum sum","text":"<p>Here, we consider the problem of finding a subarray with maximum sum, as well as some of its variations (including the algorithm for solving this problem online).</p>","tags":["Translated"]},{"location":"others/maximum_average_segment.html#problem-statement","title":"Problem statement","text":"<p>Given an array of numbers $a[1 \\ldots n]$. It is required to find a subarray $a[l \\ldots r]$ with the maximal sum:</p> $$ \\max_{ 1 \\le l \\le r \\le n } \\sum_{i=l}^{r} a[i].$$ <p>For example, if all integers in array $a[]$ were non-negative, then the answer would be the array itself. However, the solution is non-trivial when the array can contain both positive and negative numbers.</p> <p>It is clear that the problem of finding the minimum subarray is essentially the same, you just need to change the signs of all numbers.</p>","tags":["Translated"]},{"location":"others/maximum_average_segment.html#algorithm-1","title":"Algorithm 1","text":"<p>Here we consider an almost obvious algorithm. (Next, we'll look at another algorithm, which is a little harder to come up with, but its implementation is even shorter.)</p>","tags":["Translated"]},{"location":"others/maximum_average_segment.html#algorithm-description","title":"Algorithm description","text":"<p>The algorithm is very simple.</p> <p>We introduce for convenience the notation: $s[i] = \\sum_{j=1}^{i} a[j]$. That is, the array $s[i]$ is an array of partial sums of array $a[]$. Also, set $s[0] = 0$.</p> <p>Let us now iterate over the index $r = 1 \\ldots n$, and learn how to quickly find the optimal $l$ for each current value $r$, at which the maximum sum is reached on the subarray $[l, r]$.</p> <p>Formally, this means that for the current $r$ we need to find an $l$ (not exceeding $r$), so that the value of $s[r] - s[l-1]$ is maximal. After a trivial transformation, we can see that we need to find in the array $s[]$ a minimum on the segment $[0, r-1]$.</p> <p>From here, we immediately obtain a solution: we simply store where the current minimum is in the array $s[]$. Using this minimum, we find the current optimal index $l$ in $O(1)$, and when moving from the current index $r$ to the next one, we simply update this minimum.</p> <p>Obviously, this algorithm works in $O(n)$ and is asymptotically optimal.</p>","tags":["Translated"]},{"location":"others/maximum_average_segment.html#implementation","title":"Implementation","text":"<p>To implement it, we don't even need to explicitly store an array of partial sums $s[]$ \u2014 we will only need the current element from it.</p> <p>The implementation is given in 0-indexed arrays, not in 1-numbering as described above.</p> <p>We first give a solution that finds a simple numerical answer without finding the indices of the desired segment:</p> <pre><code>int ans = a[0], sum = 0, min_sum = 0;\n\nfor (int r = 0; r &lt; n; ++r) {\n    sum += a[r];\n    ans = max(ans, sum - min_sum);\n    min_sum = min(min_sum, sum);\n}\n</code></pre> <p>Now we give a full version of the solution, which additionally also finds the boundaries of the desired segment:</p> <pre><code>int ans = a[0], ans_l = 0, ans_r = 0;\nint sum = 0, min_sum = 0, min_pos = -1;\n\nfor (int r = 0; r &lt; n; ++r) {\n    sum += a[r];\n    int cur = sum - min_sum;\n    if (cur &gt; ans) {\n        ans = cur;\n        ans_l = min_pos + 1;\n        ans_r = r;\n    }\n    if (sum &lt; min_sum) {\n        min_sum = sum;\n        min_pos = r;\n    }\n}\n</code></pre>","tags":["Translated"]},{"location":"others/maximum_average_segment.html#algorithm-2","title":"Algorithm 2","text":"<p>Here we consider a different algorithm. It is a little more difficult to understand, but it is more elegant than the above, and its implementation is a little bit shorter. This algorithm was proposed by Jay Kadane in 1984.</p>","tags":["Translated"]},{"location":"others/maximum_average_segment.html#algorithm-description_1","title":"Algorithm description","text":"<p>The algorithm itself is as follows. Let's go through the array and accumulate the current partial sum in some variable $s$. If at some point $s$ is negative, we just assign $s=0$. It is argued that the maximum all the values that the variable $s$ is assigned to during the algorithm will be the answer to the problem.</p> <p>Proof:</p> <p>Consider the first index when the sum of $s$ becomes negative. This means that starting with a zero partial sum, we eventually obtain a negative partial sum \u2014 so this whole prefix of the array, as well as any suffix, has a negative sum. Therefore, this subarray never contributes to the partial sum of any subarray of which it is a prefix, and can simply be dropped.</p> <p>However, this is not enough to prove the algorithm. In the algorithm, we are actually limited in finding the answer only to such segments that begin immediately after the places when $s&lt;0$ happened.</p> <p>But, in fact, consider an arbitrary segment $[l, r]$, and $l$ is not in such a \"critical\" position (i.e. $l &gt; p+1$, where $p$ is the last such position, in which $s&lt;0$). Since the last critical position is strictly earlier than in $l-1$, it turns out that the sum of $a[p+1 \\ldots l-1]$ is non-negative. This means that by moving $l$ to position $p+1$, we will increase the answer or, in extreme cases, we will not change it.</p> <p>One way or another, it turns out that when searching for an answer, you can limit yourself to only segments that begin immediately after the positions in which $s&lt;0$ appeared. This proves that the algorithm is correct.</p>","tags":["Translated"]},{"location":"others/maximum_average_segment.html#implementation_1","title":"Implementation","text":"<p>As in algorithm 1, we first gave a simplified implementation that looks for only a numerical answer without finding the boundaries of the desired segment:</p> <pre><code>int ans = a[0], sum = 0;\n\nfor (int r = 0; r &lt; n; ++r) {\n    sum += a[r];\n    ans = max(ans, sum);\n    sum = max(sum, 0);\n}\n</code></pre> <p>A complete solution, maintaining the indexes of the boundaries of the corresponding segment:</p> <pre><code>int ans = a[0], ans_l = 0, ans_r = 0;\nint sum = 0, minus_pos = -1;\n\nfor (int r = 0; r &lt; n; ++r) {\n    sum += a[r];\n    if (sum &gt; ans) {\n        ans = sum;\n        ans_l = minus_pos + 1;\n        ans_r = r;\n    }\n    if (sum &lt; 0) {\n        sum = 0;\n        minus_pos = r;\n    }\n}\n</code></pre>","tags":["Translated"]},{"location":"others/maximum_average_segment.html#related-tasks","title":"Related tasks","text":"","tags":["Translated"]},{"location":"others/maximum_average_segment.html#finding-the-maximumminimum-subarray-with-constraints","title":"Finding the maximum/minimum subarray with constraints","text":"<p>If the problem condition imposes additional restrictions on the required segment $[l, r]$ (for example, that the length $r-l+1$ of the segment must be within the specified limits), then the described algorithm is likely to be easily generalized to these cases \u2014 anyway, the problem will still be to find the minimum in the array $s[]$ with the specified additional restrictions.</p>","tags":["Translated"]},{"location":"others/maximum_average_segment.html#two-dimensional-case-of-the-problem-search-for-maximumminimum-submatrix","title":"Two-dimensional case of the problem: search for maximum/minimum submatrix","text":"<p>The problem described in this article is naturally generalized to large dimensions. For example, in a two-dimensional case, it turns into a search for such a submatrix $[l_1 \\ldots r_1, l_2 \\ldots r_2]$ of a given matrix, which has the maximum sum of numbers in it.</p> <p>Using the solution for the one-dimensional case, it is easy to obtain a solution in $O(n^3)$ for the two-dimensions case: we iterate over all possible values of $l_1$ and $r_1$, and calculate the sums from $l_1$ to $r_1$ in each row of the matrix. Now we have the one-dimensional problem of finding the indices $l_2$ and $r_2$ in this array, which can already be solved in linear time.</p> <p>Faster algorithms for solving this problem are known, but they are not much faster than $O(n^3)$, and are very complex (so complex that many of them are inferior to the trivial algorithm for all reasonable constraints by the hidden constant). Currently, the best known algorithm works in $O\\left(n^3 \\frac{ \\log^3 \\log n }{ \\log^2 n} \\right)$ time (T. Chan 2007 \"More algorithms for all-pairs shortest paths in weighted graphs\")</p> <p>This algorithm by Chan, as well as many other results in this area, actually describe fast matrix multiplication (where matrix multiplication means modified multiplication: minimum is used instead of addition, and addition is used instead of multiplication). The problem of finding the submatrix with the largest sum can be reduced to the problem of finding the shortest paths between all pairs of vertices, and this problem, in turn, can be reduced to such a multiplication of matrices.</p>","tags":["Translated"]},{"location":"others/maximum_average_segment.html#search-for-a-subarray-with-a-maximumminimum-average","title":"Search for a subarray with a maximum/minimum average","text":"<p>This problem lies in finding such a segment $a[l, r]$, such that the average value is maximal:</p> $$ \\max_{l \\le r} \\frac{ 1 }{ r-l+1 } \\sum_{i=l}^{r} a[i].$$ <p>Of course, if no other conditions are imposed on the required segment $[l, r]$, then the solution will always be a segment of length $1$ at the maximum element of the array.  The problem only makes sense, if there are additional restrictions (for example, the length of the desired segment is bounded below).</p> <p>In this case, we apply the standard technique when working with the problems of the average value: we will select the desired maximum average value by binary search.</p> <p>To do this, we need to learn how to solve the following subproblem: given the number $x$, and we need to check whether there is a subarray of array $a[]$ (of course, satisfying all additional constraints of the problem), where the average value is greater than $x$.</p> <p>To solve this subproblem, subtract $x$ from each element of array $a[]$. Then our subproblem actually turns into this one: whether or not there are positive sum subarrays in this array. And we already know how to solve this problem.</p> <p>Thus, we obtained the solution for the asymptotic $O(T(n) \\log W)$, where $W$ is the required accuracy, $T(n)$ is the time of solving the subtask for an array of length $n$ (which may vary depending on the specific additional restrictions imposed).</p>","tags":["Translated"]},{"location":"others/maximum_average_segment.html#solving-the-online-problem","title":"Solving the online problem","text":"<p>The condition of the problem is as follows: given an array of $n$ numbers, and a number $L$. There are queries of the form $(l,r)$, and in response to each query, it is required to find a subarray of the segment $[l, r]$ of length not less than $L$ with the maximum possible arithmetic mean.</p> <p>The algorithm for solving this problem is quite complex. KADR (Yaroslav Tverdokhleb) described his algorithm on the Russian forum.</p>","tags":["Translated"]},{"location":"others/stern_brocot_tree_farey_sequences.html","title":"The Stern-Brocot tree and Farey sequences","text":"","tags":["Translated"]},{"location":"others/stern_brocot_tree_farey_sequences.html#stern-brocot-tree","title":"Stern-Brocot tree","text":"<p>The Stern-Brocot tree is an elegant construction to represent the set of all positive fractions. It was independently discovered by German mathematician Moritz Stern in 1858 and by French watchmaker Achille Brocot in 1861. However, some sources attribute the discovery to ancient Greek mathematician Eratosthenes.</p> <p>The construction starts at the zeroth iteration with the two fractions</p> $$     \\frac{0}{1}, \\frac{1}{0} $$ <p>where it should be noted that the second quantity is not strictly a fraction, but it can be interpreted as an irreducible fraction representing infinity.</p> <p>At every subsequent iteration, consider all adjacent fractions $\\frac{a}{b}$ and $\\frac{c}{d}$ and insert their mediant $\\frac{a+c}{b+d}$ between them.</p> <p>The first few iterations look like this:</p> $$     \\begin{array}{c}     \\dfrac{0}{1}, \\dfrac{1}{1}, \\dfrac{1}{0} \\\\     \\dfrac{0}{1}, \\dfrac{1}{2}, \\dfrac{1}{1}, \\dfrac{2}{1}, \\dfrac{1}{0} \\\\     \\dfrac{0}{1}, \\dfrac{1}{3}, \\dfrac{1}{2}, \\dfrac{2}{3}, \\dfrac{1}{1}, \\dfrac{3}{2}, \\dfrac{2}{1}, \\dfrac{3}{1}, \\dfrac{1}{0}     \\end{array} $$ <p>Continuing this process to infinity this covers all positive fractions. Additionally, all fractions will be unique and irreducible. Finally, the fractions will also appear in ascending order.</p> <p>Before proving these properties, let us actually show a visualization of the Stern-Brocot tree, rather than the list representation. Every fraction in the tree has two children. Each child is the mediant of the closest ancestor on the left and closest ancestor to the right.</p>","tags":["Translated"]},{"location":"others/stern_brocot_tree_farey_sequences.html#proofs","title":"Proofs","text":"<p>Ordering. Proving ordering is simple. We note that the mediant of two fractions is always in-between the fractions</p> $$     \\frac{a}{b} \\le \\frac{a+c}{b+d} \\le \\frac{c}{d} $$ <p>given that</p> $$     \\frac{a}{b} \\le \\frac{c}{d}. $$ <p>The two inequalities can be easily shown by rewriting the fractions with common denominators.</p> <p>As the ordering is ascending in the zeroth iteration, it will be maintained at every subsequent iteration.</p> <p>Irreducibility. To prove this we will show that for any two adjacent fractions $\\frac{a}{b}$ and $\\frac{c}{d}$ we have that</p> $$     bc - ad = 1. $$ <p>Recall that a Diophantine equation with two variables $ax+by=c$ has a solution iff $c$ is a multiple of $\\gcd(a,b)$. In our case this implies that $\\gcd(a,b) = \\gcd(c,d) = 1$, which is what we want to show.</p> <p>Clearly at the zeroth iteration $bc - ad = 1$. What remains to be shown is that mediants retain this property.</p> <p>Assume our two adjacent fractions uphold $bc - ad = 1$, after the mediant is added to the list</p> $$     \\frac{a}{b}, \\frac{a+c}{b+d}, \\frac{c}{d} $$ <p>the new expressions become</p> $$\\begin{align}     b(a+c) - a(b+d) &amp;= 1 \\\\     c(b+d) - d(a+c) &amp;= 1 \\end{align}$$ <p>which, using that $bc-ad=1$, can be easily shown to be true.</p> <p>From this we see that the property is always maintained and thus all fractions are irreducible.</p> <p>The presence of all fractions. This proof is closely related to locating a fraction in the Stern-Brocot tree. From the ordering property we have that left subtree of a fraction contains only fractions smaller than the parent fraction, and the right subtree contains only fractions larger than the parent fraction. This means we can search for a fraction by traversing the tree from the root, going left if the target is smaller than the fraction and going right if the target is larger.</p> <p>Pick an arbitrary positive target fraction $\\frac{x}{y}$. It is obviously between $\\frac{0}{1}$ and $\\frac{1}{0}$, so the only way for the fraction to not be in the tree is if it takes an infinite number of steps to get to it.</p> <p>If that is the case we would at all iterations have</p> $$     \\frac{a}{b} \\lt \\frac{x}{y} \\lt \\frac{c}{d} $$ <p>which (using the fact than an integer $z \\gt 0 \\iff z \\ge 1$) can be rewritten as</p> $$ \\begin{align}     bx - ay &amp;\\ge 1 \\\\     cy - dx &amp;\\ge 1. \\end{align} $$ <p>Now multiply the first inequality by $c+d$ and the second with $a+b$ and add them to get</p> $$     (c+d)(bx - ay) + (a+b)(cy - dx) \\ge a+b+c+d. $$ <p>Expanding this and using the previously shown property $bc-ad=1$ we get that</p> $$     x+y \\ge a+b+c+d. $$ <p>And given that at every iteration at least one of $a,b,c,d$ will increase, the fraction searching process will contain no more than $x+y$ iterations. This contradicts the assumption that the path to $\\frac{x}{y}$ was infinite and hence $\\frac{x}{y}$ must be part of the tree.</p>","tags":["Translated"]},{"location":"others/stern_brocot_tree_farey_sequences.html#tree-building-algorithm","title":"Tree Building Algorithm","text":"<p>To build any subtree of the Stern-Brocot tree, it suffices to know the left and right ancestor. On the first level, the left and right ancestors are $\\frac{0}{1}$ and $\\frac{1}{0}$ respectively. Using these, we calculate the mediant and proceed one level deeper, with the mediant replacing the right ancestor in the left subtree, and vice versa.</p> <p>This pseudocode tries to build the entire infinite tree:</p> <pre><code>void build(int a = 0, int b = 1, int c = 1, int d = 0, int level = 1) {\n    int x = a + c, y = b + d;\n\n    ... output the current fraction x/y at the current level in the tree\n\n    build(a, b, x, y, level + 1);\n    build(x, y, c, d, level + 1);\n}\n</code></pre>","tags":["Translated"]},{"location":"others/stern_brocot_tree_farey_sequences.html#fraction-search-algorithm","title":"Fraction Search Algorithm","text":"<p>The search algorithm was already described in the proof that all fractions appear in the tree, but we will repeat it here. The algorithm is a binary search algorithm. Initially we stand at the root of the tree and we compare our target with the current fraction. If they are the same we are done and stop the process. If our target is smaller we move to the left child, otherwise we move to the right child.</p>","tags":["Translated"]},{"location":"others/stern_brocot_tree_farey_sequences.html#naive-search","title":"Naive search","text":"<p>Here is an implementation that returns the path to a given fraction $\\frac{p}{q}$ as a sequence of <code>'L'</code> and <code>'R'</code> characters, meaning traversal to the left and right child respectively. This sequence of characters uniquely defines all positive fractions and is called the Stern-Brocot number system.</p> <pre><code>string find(int p, int q) {\n    int pL = 0, qL = 1;\n    int pR = 1, qR = 0;\n    int pM = 1, qM = 1;\n    string res;\n    while(pM != p || qM != q) {\n        if(p * qM &lt; pM * q) {\n            res += 'L';\n            tie(pR, qR) = {pM, qM};\n        } else {\n            res += 'R';\n            tie(pL, qL) = {pM, qM};\n        }\n        tie(pM, qM) = pair{pL + pR, qL + qR};\n    }\n    return res;\n}\n</code></pre> <p>Irrational numbers in the Stern-Brocot number system corresponds to infinite sequences of characters. Along the endless path towards the irrational number the algorithm will find reduced fractions with gradually increasing denominators that provides increasingly better approximations of the irrational number. So by taking a prefix of the infinite sequence approximations with any desired precision can be achieved. This application is important in watch-making, which explains why the tree was discovered in that domain.</p> <p>Note that for a fraction $\\frac{p}{q}$, the length of the resulting sequence could be as large as $O(p+q)$, for example when the fraction is of form $\\frac{p}{1}$. This means that the algorithm above should not be used, unless this is an acceptable complexity! </p>","tags":["Translated"]},{"location":"others/stern_brocot_tree_farey_sequences.html#logarithmic-search","title":"Logarithmic search","text":"<p>Fortunately, it is possible to enhance the algorithm above to guarantee $O(\\log (p+q))$ complexity. For this we should note that if the current boundary fractions are $\\frac{p_L}{q_L}$ and $\\frac{p_R}{q_R}$, then by doing $a$ steps to the right we move to the fraction $\\frac{p_L + a p_R}{q_L + a q_R}$, and by doing $a$ steps to the left, we move to the fraction $\\frac{a p_L + p_R}{a q_L + q_R}$. </p> <p>Therefore, instead of doing steps of <code>L</code> or <code>R</code> one by one, we can do $k$ steps in the same direction at once, after which we would switch to going into other direction, and so on. In this way, we can find the path to the fraction $\\frac{p}{q}$ as its run-length encoding.</p> <p>As the directions alternate this way, we will always know which one to take. So, for convenience we may represent a path to a fraction $\\frac{p}{q}$ as a sequence of fractions</p> $$ \\frac{p_0}{q_0}, \\frac{p_1}{q_1}, \\frac{p_2}{q_2}, \\dots, \\frac{p_n}{q_n}, \\frac{p_{n+1}}{q_{n+1}} = \\frac{p}{q} $$ <p>such that $\\frac{p_{k-1}}{q_{k-1}}$ and $\\frac{p_k}{q_k}$ are the boundaries of the search interval on the $k$-th step, starting with $\\frac{p_0}{q_0} = \\frac{0}{1}$ and $\\frac{p_1}{q_1} = \\frac{1}{0}$. Then, after the $k$-th step we move to a fraction</p> $$ \\frac{p_{k+1}}{q_{k+1}} = \\frac{p_{k-1} + a_k p_k}{q_{k-1} + a_k q_k}, $$ <p>where $a_k$ is a positive integer number. If you're familiar with continued fractions, you would recognize that the sequence $\\frac{p_i}{q_i}$ is the sequence of the convergent fractions of $\\frac{p}{q}$ and the sequence $[a_1; a_2, \\dots, a_{n}, 1]$ represents the continued fraction of $\\frac{p}{q}$.</p> <p>This allows to find the run-length encoding of the path to $\\frac{p}{q}$ in the manner which follows the algorithm for computing continued fraction representation of the fraction $\\frac{p}{q}$:</p> <pre><code>auto find(int p, int q) {\n    bool right = true;\n    vector&lt;pair&lt;int, char&gt;&gt; res;\n    while(q) {\n        res.emplace_back(p / q, right ? 'R' : 'L');\n        tie(p, q) = pair{q, p % q};\n        right ^= 1;\n    }\n    res.back().first--;\n    return res;\n}\n</code></pre> <p>However, this approach only works if we already know $\\frac{p}{q}$ and want to find its place in the Stern-Brocot tree.</p> <p>On practice, it is often the case that $\\frac{p}{q}$ is not known in advance, but we are able to check for specific $\\frac{x}{y}$ whether $\\frac{x}{y} &lt; \\frac{p}{q}$.</p> <p>Knowing this, we can emulate the search on Stern-Brocot tree by maintaining the current boundaries $\\frac{p_{k-1}}{q_{k-1}}$ and $\\frac{p_k}{q_k}$, and finding each $a_k$ via binary search. The algorithm then is a bit more technical and potentially have a complexity of $O(\\log^2(x+y))$, unless the problem formulation allows you to find $a_k$ faster (for example, using <code>floor</code> of some known expression).</p>","tags":["Translated"]},{"location":"others/stern_brocot_tree_farey_sequences.html#farey-sequence","title":"Farey Sequence","text":"<p>The Farey sequence of order $n$ is the sorted sequence of fractions between $0$ and $1$ whose denominators do not exceed $n$.</p> <p>The sequences are named after English geologist John Farey, who in 1816 conjectured that any fraction in a Farey sequence is the mediant of its neighbors. This was proven some time later by Cauchy, but independent of both of them, the mathematician Haros had come to almost the same conclusion in 1802.</p> <p>The Farey sequences have many interesting properties on their own, but the connection to the Stern-Brocot tree is the most obvious. In fact, the Farey sequences can be obtained by trimming branches from the tree.</p> <p>From the algorithm for building the Stern-Brocot tree, we get an algorithm for the Farey sequences. Start with the list of fractions $\\frac{0}{1}, \\frac{1}{0}$. At every subsequent iteration, insert the mediant only if the denominator does not exceed $n$. At some point the list will stop changing and the desired Farey sequence will have been found.</p>","tags":["Translated"]},{"location":"others/stern_brocot_tree_farey_sequences.html#length-of-a-farey-sequence","title":"Length of a Farey Sequence","text":"<p>A Farey sequence of order $n$ contains all elements of the Farey sequence of order $n-1$ as well as all irreducible fractions with denominator $n$, but the latter is just the totient $\\varphi(n)$. So the length $L_n$ of the Farey sequence of order $n$ is</p> $$     L_n = L_{n-1} + \\varphi(n) $$ <p>or equivalently, by unraveling the recursion we get</p> $$     L_n = 1 + \\sum_{k=1}^n \\varphi(k). $$","tags":["Translated"]},{"location":"others/tortoise_and_hare.html","title":"Floyd's Linked List Cycle Finding Algorithm","text":"<p>Given a linked list where the starting point of that linked list is denoted by head, and there may or may not be a cycle present. For instance:</p> <p>Here we need to find out the point C, i.e the starting point of the cycle.</p>","tags":["Original"]},{"location":"others/tortoise_and_hare.html#proposed-algorithm","title":"Proposed algorithm","text":"<p>The algorithm is called Floyd\u2019s Cycle Algorithm or Tortoise And Hare algorithm. In order to figure out the starting point of the cycle, we need to figure out if a cycle even exists. This involves two steps: 1. Figure out the presence of the cycle. 2. Find out the starting point of the cycle.</p>","tags":["Original"]},{"location":"others/tortoise_and_hare.html#step-1-presence-of-the-cycle","title":"Step 1: Presence of the cycle","text":"<ol> <li>Take two pointers $slow$ and $fast$.</li> <li>Both of them will point to head of the linked list initially.</li> <li>$slow$ will move one step at a time.</li> <li>$fast$ will move two steps at a time. (twice as speed as $slow$ pointer).</li> <li>Check if at any point they point to the same node before any one(or both) reach null.</li> <li>If they point to the same node at any point of their journey, it indicates that a cycle indeed exists in the linked list.</li> <li>If we get null, it indicates that the linked list has no cycle.</li> </ol> <p>Now, that we have figured out if there is a cycle present in the linked list, for the next step we need to find out the starting point of cycle, i.e., C.</p>","tags":["Original"]},{"location":"others/tortoise_and_hare.html#step-2-starting-point-of-the-cycle","title":"Step 2: Starting point of the cycle","text":"<ol> <li>Reset the $slow$ pointer to the head of the linked list.</li> <li>Move both pointers one step at a time.</li> <li>The point they will meet at will be the starting point of the cycle.</li> </ol> <pre><code>// Presence of cycle\npublic boolean hasCycle(ListNode head) {\n    ListNode slow = head;\n    ListNode fast = head;\n\n    while(fast != null &amp;&amp; fast.next != null){\n        slow = slow.next;\n        fast = fast.next.next;\n        if(slow==fast){\n            return true;\n        }\n    }\n\n    return false;\n}\n</code></pre> <pre><code>// Assuming there is a cycle present and slow and fast are point to their meeting point\nslow = head;\nwhile(slow!=fast){\n    slow = slow.next;\n    fast = fast.next;\n}\n\nreturn slow; // the starting point of the cycle.\n</code></pre>","tags":["Original"]},{"location":"others/tortoise_and_hare.html#why-does-it-work","title":"Why does it work","text":"","tags":["Original"]},{"location":"others/tortoise_and_hare.html#step-1-presence-of-the-cycle_1","title":"Step 1: Presence of the cycle","text":"<p>Since the pointer $fast$ is moving with twice as speed as $slow$, we can say that at any point of time, $fast$ would have covered twice as much distance as $slow$. We can also deduce that the difference between the distance covered by both of these pointers is increasing by $1$.  <pre><code>slow: 0 --&gt; 1 --&gt; 2 --&gt; 3 --&gt; 4 (distance covered)\nfast: 0 --&gt; 2 --&gt; 4 --&gt; 6 --&gt; 8 (distance covered)\ndiff: 0 --&gt; 1 --&gt; 2 --&gt; 3 --&gt; 4 (difference between distance covered by both pointers)\n</code></pre> Let $L$ denote the length of the cycle, and $a$ represent the number of steps required for the slow pointer to reach the entry of cycle. There exists a positive integer $k$ ($k &gt; 0$) such that $k \\cdot L \\geq a$. When the slow pointer has moved $k \\cdot L$ steps, and the fast pointer has covered $2 \\cdot k \\cdot L$ steps, both pointers find themselves within the cycle. At this point, there is a separation of $k \\cdot L$ between them. Given that the cycle's length remains $L$, this signifies that they meet at the same point within the cycle, resulting in their encounter.</p>","tags":["Original"]},{"location":"others/tortoise_and_hare.html#step-2-starting-point-of-the-cycle_1","title":"Step 2: Starting point of the cycle","text":"<p>Lets try to calculate the distance covered by both of the pointers till they point they met within the cycle.</p> <p>$slowDist = a + xL + b$            , $x\\ge0$</p> <p>$fastDist = a + yL + b$            , $y\\ge0$</p> <ul> <li>$slowDist$ is the total distance covered by slow pointer.</li> <li>$fastDist$ is the total distance covered by fast pointer.</li> <li>$a$ is the number of steps both pointers need to take to enter the cycle.</li> <li>$b$ is the distance between C and G, i.e., distance between the starting point of cycle and meeting point of both pointers.</li> <li>$x$ is the number of times the slow pointer has looped inside the cycle, starting from and ending at C.</li> <li>$y$ is the number of times the fast pointer has looped inside the cycle, starting from and ending at C.</li> </ul> <p>$fastDist = 2 \\cdot (slowDist)$</p> <p>$a + yL + b = 2(a + xL + b)$</p> <p>Resolving the formula we get:</p> <p>$a=(y-2x)L-b$</p> <p>where $y-2x$ is an integer</p> <p>This basically means that $a$ steps is same as doing some number of full loops in cycle and go $b$ steps backwards. Since the fast pointer already is $b$ steps ahead of the entry of cycle, if fast pointer moves another $a$ steps it will end up at the entry of the cycle. And since we let the slow pointer start at the start of the linked list, after $a$ steps it will also end up at the cycle entry. So, if they both move $a$ step they both will meet the entry of cycle.</p>","tags":["Original"]},{"location":"others/tortoise_and_hare.html#problems","title":"Problems:","text":"<ul> <li>Linked List Cycle (EASY)</li> <li>Happy Number (Easy)</li> <li>Find the Duplicate Number (Medium)</li> </ul>","tags":["Original"]},{"location":"schedules/schedule-with-completion-duration.html","title":"Optimal schedule of jobs given their deadlines and durations","text":"<p>Suppose, we have a set of jobs, and we are aware of every job\u2019s deadline and its duration. The execution of a job cannot be interrupted prior to its ending. It is required to create such a schedule to accomplish the biggest number of jobs.</p>","tags":["Translated"]},{"location":"schedules/schedule-with-completion-duration.html#solving","title":"Solving","text":"<p>The algorithm of the solving is greedy. Let\u2019s sort all the jobs by their deadlines and look at them in descending order. Also, let\u2019s create a queue $q$, in which we\u2019ll gradually put the jobs and extract one with the least run-time (for instance, we can use set or priority_queue). Initially, $q$ is empty.</p> <p>Suppose, we\u2019re looking at the $i$-th job. First of all, let\u2019s put it into $q$. Let\u2019s consider the period of time between the deadline of $i$-th job and the deadline of $i-1$-th job. That is the segment of some length $T$. We will extract jobs from $q$ (in their left duration ascending order) and execute them until the whole segment $T$ is filled. Important: if at any moment of time the extracted job can only be partly executed until segment $T$ is filled, then we execute this job partly just as far as possible, i.e., during the $T$-time, and we put the remaining part of a job back into $q$.</p> <p>On the algorithm\u2019s completion we\u2019ll choose the optimal solution (or, at least, one of several solutions). The running time of algorithm is $O(n \\log n)$.</p>","tags":["Translated"]},{"location":"schedules/schedule-with-completion-duration.html#implementation","title":"Implementation","text":"<p>The following function takes a vector of jobs (consisting of a deadline, a duration, and the job's index) and computes a vector containing all indices of the used jobs in the optimal schedule. Notice that you still need to sort these jobs by their deadline, if you want to write down the plan explicitly.</p> <pre><code>struct Job {\n    int deadline, duration, idx;\n\n    bool operator&lt;(Job o) const {\n        return deadline &lt; o.deadline;\n    }\n};\n\nvector&lt;int&gt; compute_schedule(vector&lt;Job&gt; jobs) {\n    sort(jobs.begin(), jobs.end());\n\n    set&lt;pair&lt;int,int&gt;&gt; s;\n    vector&lt;int&gt; schedule;\n    for (int i = jobs.size()-1; i &gt;= 0; i--) {\n        int t = jobs[i].deadline - (i ? jobs[i-1].deadline : 0);\n        s.insert(make_pair(jobs[i].duration, jobs[i].idx));\n        while (t &amp;&amp; !s.empty()) {\n            auto it = s.begin();\n            if (it-&gt;first &lt;= t) {\n                t -= it-&gt;first;\n                schedule.push_back(it-&gt;second);\n            } else {\n                s.insert(make_pair(it-&gt;first - t, it-&gt;second));\n                t = 0;\n            }\n            s.erase(it);\n        }\n    }\n    return schedule;\n}\n</code></pre>","tags":["Translated"]},{"location":"schedules/schedule_one_machine.html","title":"Scheduling jobs on one machine","text":"<p>This task is about finding an optimal schedule for $n$ jobs on a single machine, if the job $i$ can be processed in $t_i$ time, but for the $t$ seconds waiting before processing the job a penalty of $f_i(t)$ has to be paid.</p> <p>Thus the task asks to find such an permutation of the jobs, so that the total penalty is minimal. If we denote by $\\pi$ the permutation of the jobs ($\\pi_1$ is the first processed item, $\\pi_2$ the second, etc.), then the total penalty is equal to:</p> $$F(\\pi) = f_{\\pi_1}(0) + f_{\\pi_2}(t_{\\pi_1}) + f_{\\pi_3}(t_{\\pi_1} + t_{\\pi_2}) + \\dots + f_{\\pi_n}\\left(\\sum_{i=1}^{n-1} t_{\\pi_i}\\right)$$","tags":["Translated"]},{"location":"schedules/schedule_one_machine.html#solutions-for-special-cases","title":"Solutions for special cases","text":"","tags":["Translated"]},{"location":"schedules/schedule_one_machine.html#linear-penalty-functions","title":"Linear penalty functions","text":"<p>First we will solve the problem in the case that all penalty functions $f_i(t)$ are linear, i.e. they have the form $f_i(t) = c_i \\cdot t$, where $c_i$ is a non-negative number. Note that these functions don't have a constant term. Otherwise we can sum up all constant term, and resolve the problem without them.</p> <p>Let us fixate some permutation $\\pi$, and take an index $i = 1 \\dots n-1$. Let the permutation $\\pi'$ be equal to the permutation $\\pi$ with the elements $i$ and $i+1$ switched. Let's see how much the penalty changed.</p> $$F(\\pi') - F(\\pi) =$$ <p>It is easy to see that the changes only occur in the $i$-th and $(i+1)$-th summands:</p> $$\\begin{align} &amp;= c_{\\pi_i'} \\cdot \\sum_{k = 1}^{i-1} t_{\\pi_k'} + c_{\\pi_{i+1}'} \\cdot \\sum_{k = 1}^i t_{\\pi_k'} - c_{\\pi_i} \\cdot \\sum_{k = 1}^{i-1} t_{\\pi_k} - c_{\\pi_{i+1}} \\cdot \\sum_{k = 1}^i t_{\\pi_k} \\\\ &amp;= c_{\\pi_{i+1}} \\cdot \\sum_{k = 1}^{i-1} t_{\\pi_k'} + c_{\\pi_i} \\cdot \\sum_{k = 1}^i t_{\\pi_k'} - c_{\\pi_i} \\cdot \\sum_{k = 1}^{i-1} t_{\\pi_k} - c_{\\pi_{i+1}} \\cdot \\sum_{k = 1}^i t_{\\pi_k} \\\\ &amp;= c_{\\pi_i} \\cdot t_{\\pi_{i+1}} - c_{\\pi_{i+1}} \\cdot t_{\\pi_i} \\end{align}$$ <p>It is easy to see, that if the schedule $\\pi$ is optimal, than any change in it leads to an increased penalty (or to the identical penalty), therefore for the optimal schedule we can write down the following condition:</p> $$c_{\\pi_{i}} \\cdot t_{\\pi_{i+1}} - c_{\\pi_{i+1}} \\cdot t_{\\pi_i} \\ge 0 \\quad \\forall i = 1 \\dots n-1$$ <p>And after rearranging we get:</p> $$\\frac{c_{\\pi_i}}{t_{\\pi_i}} \\ge \\frac{c_{\\pi_{i+1}}}{t_{\\pi_{i+1}}} \\quad \\forall i = 1 \\dots n-1$$ <p>Thus we obtain the optimal schedule by simply sorting the jobs by the fraction $\\frac{c_i}{t_i}$ in non-ascending order.</p> <p>It should be noted, that we constructed this algorithm by the so-called permutation method: we tried to swap two adjacent elements, calculated how much the penalty changed, and then derived the algorithm for finding the optimal method.</p>","tags":["Translated"]},{"location":"schedules/schedule_one_machine.html#exponential-penalty-function","title":"Exponential penalty function","text":"<p>Let the penalty function look like this:</p> $$f_i(t) = c_i \\cdot e^{\\alpha \\cdot t},$$ <p>where all numbers $c_i$ are non-negative and the constant $\\alpha$ is positive.</p> <p>By applying the permutation method, it is easy to determine that the jobs must be sorted in non-ascending order of the value:</p> $$v_i = \\frac{1 - e^{\\alpha \\cdot t_i}}{c_i}$$","tags":["Translated"]},{"location":"schedules/schedule_one_machine.html#identical-monotone-penalty-function","title":"Identical monotone penalty function","text":"<p>In this case we consider the case that all $f_i(t)$ are equal, and this function is monotone increasing.</p> <p>It is obvious that in this case the optimal permutation is to arrange the jobs by non-descending processing time $t_i$.</p>","tags":["Translated"]},{"location":"schedules/schedule_one_machine.html#the-livshits-kladov-theorem","title":"The Livshits-Kladov theorem","text":"<p>The Livshits-Kladov theorem establishes that the permutation method is only applicable for the above mentioned three cases, i.e.:</p> <ul> <li>Linear case: $f_i(t) = c_i(t) + d_i$, where $c_i$ are non-negative constants,</li> <li>Exponential case: $f_i(t) = c_i \\cdot e_{\\alpha \\cdot t} + d_i$, where $c_i$ and $\\alpha$ are positive constants,</li> <li>Identical case: $f_i(t) = \\phi(t)$, where $\\phi$ is a monotone increasing function.</li> </ul> <p>In all other cases the method cannot be applied.</p> <p>The theorem is proven under the assumption that the penalty functions are sufficiently smooth (the third derivatives exists).</p> <p>In all three case we apply the permutation method, through which the desired optimal schedule can be found by sorting, hence in $O(n \\log n)$ time.</p>","tags":["Translated"]},{"location":"schedules/schedule_two_machines.html","title":"Scheduling jobs on two machines","text":"<p>This task is about finding an optimal schedule for $n$ jobs on two machines. Every item must first be processed on the first machine, and afterwards on the second one. The $i$-th job takes $a_i$ time on the first machine, and $b_i$ time on the second machine. Each machine can only process one job at a time.</p> <p>We want to find the optimal order of the jobs, so that the final processing time is the minimum possible.</p> <p>This solution that is discussed here is called Johnson's rule (named after S. M. Johnson).</p> <p>It is worth noting, that the task becomes NP-complete, if we have more than two machines.</p>","tags":["Translated"]},{"location":"schedules/schedule_two_machines.html#construction-of-the-algorithm","title":"Construction of the algorithm","text":"<p>Note first, that we can assume that the order of jobs for the first and the second machine have to coincide. In fact, since the jobs for the second machine become available after processing them at the first, and if there are several jobs available for the second machine, than the processing time will be equal to the sum of their $b_i$, regardless of their order. Therefore it is only advantageous to send the jobs to the second machine in the same order as we sent them to the first machine.</p> <p>Consider the order of the jobs, which coincides with their input order $1, 2, \\dots, n$.</p> <p>We denote by $x_i$ the idle time of the second machine immediately before processing $i$. Our goal is to minimize the total idle time:</p> $$F(x) = \\sum x_i ~ \\rightarrow \\min$$ <p>For the first job we have $x_1 = a_1$. For the second job, since it gets sent to the machine at the time $a_1 + a_2$, and the second machine gets free at $x_1 + b_1$, we have $x_2 = \\max\\left((a_1 + a_2) - (x_1 + b_1), 0\\right)$. In general we get the equation:</p> $$x_k = \\max\\left(\\sum_{i=1}^k a_i - \\sum_{i=1}^{k-1} b_i - \\sum_{i=1}^{k-1} x_i, 0 \\right)$$ <p>We can now calculate the total idle time $F(x)$. It is claimed that it has the form</p> $$F(x) = \\max_{k=1 \\dots n} K_i,$$ <p>where</p> $$K_i = \\sum_{i=1}^k a_i - \\sum_{i=1}^{k-1} b_i.$$ <p>This can be easily verified using induction.</p> <p>We now use the permutation method: we will exchange two neighboring jobs $j$ and $j+1$ and see how this will change the total idle time.</p> <p>By the form of the expression of $K_i$, it is clear that only $K_j$ and $K_{j+1}$ change, we denote their new values with $K_j'$ and $K_{j+1}'$.</p> <p>If this change from of the jobs $j$ and $j+1$ increased the total idle time, it has to be the case that:</p> $$\\max(K_j, K_{j+1}) \\le \\max(K_j', K_{j+1}')$$ <p>(Switching two jobs might also have no impact at all. The above condition is only a sufficient one, but not a necessary one.)</p> <p>After removing $\\sum_{i=1}^{j+1} a_i - \\sum_{i=1}^{j-1} b_i$ from both sides of the inequality, we get:</p> $$\\max(-a_{j+1}, -b_j) \\le \\max(-b_{j+1}, -a_j)$$ <p>And after getting rid of the negative signs:</p> $$\\min(a_j, b_{j+1}) \\le \\min(b_j, a_{j+1})$$ <p>Thus we obtained a comparator: by sorting the jobs on it, we obtain an optimal order of the jobs, in which no two jobs can be switched with an improvement of the final time.</p> <p>However you can further simplify the sorting, if you look at the comparator from a different angle. The comparator can be interpreted in the following way: If we have the four times $(a_j, a_{j+1}, b_j, b_{j+1})$, and the minimum of them is a time corresponding to the first machine, then the corresponding job should be done first. If the minimum time is a time from the second machine, then it should go later. Thus we can sort the jobs by $\\min(a_i, b_i)$, and if the processing time of the current job on the first machine is less then the processing time on the second machine, then this job must be done before all the remaining jobs, and otherwise after all remaining tasks.</p> <p>One way or another, it turns out that by Johnson's rule we can solve the problem by sorting the jobs, and thus receive a time complexity of $O(n \\log n)$.</p>","tags":["Translated"]},{"location":"schedules/schedule_two_machines.html#implementation","title":"Implementation","text":"<p>Here we implement the second variation of the described algorithm.</p> <pre><code>struct Job {\n    int a, b, idx;\n\n    bool operator&lt;(Job o) const {\n        return min(a, b) &lt; min(o.a, o.b);\n    }\n};\n\nvector&lt;Job&gt; johnsons_rule(vector&lt;Job&gt; jobs) {\n    sort(jobs.begin(), jobs.end());\n    vector&lt;Job&gt; a, b;\n    for (Job j : jobs) {\n        if (j.a &lt; j.b)\n            a.push_back(j);\n        else\n            b.push_back(j);\n    }\n    a.insert(a.end(), b.rbegin(), b.rend());\n    return a;\n}\n\npair&lt;int, int&gt; finish_times(vector&lt;Job&gt; const&amp; jobs) {\n    int t1 = 0, t2 = 0;\n    for (Job j : jobs) {\n        t1 += j.a;\n        t2 = max(t2, t1) + j.b;\n    }\n    return make_pair(t1, t2);\n}\n</code></pre> <p>All the information about each job is store in struct. The first function sorts all jobs and computes the optimal schedule. The second function computes the finish times of both machines given a schedule.</p>","tags":["Translated"]},{"location":"sequences/k-th.html","title":"$K$th order statistic in $O(N)$","text":"<p>Given an array $A$ of size $N$ and a number $K$. The problem is to find $K$-th largest number in the array, i.e., $K$-th order statistic.</p> <p>The basic idea - to use the idea of quick sort algorithm. Actually, the algorithm is simple, it is more difficult to prove that it runs in an average of $O(N)$, in contrast to the quick sort.</p>","tags":["Translated"]},{"location":"sequences/k-th.html#implementation-not-recursive","title":"Implementation (not recursive)","text":"<pre><code>template &lt;class T&gt;\nT order_statistics (std::vector&lt;T&gt; a, unsigned n, unsigned k)\n{\n    using std::swap;\n    for (unsigned l=1, r=n; ; )\n    {\n        if (r &lt;= l+1)\n        {\n            // the current part size is either 1 or 2, so it is easy to find the answer\n            if (r == l+1 &amp;&amp; a[r] &lt; a[l])\n                swap (a[l], a[r]);\n            return a[k];\n        }\n\n        // ordering a[l], a[l+1], a[r]\n        unsigned mid = (l + r) &gt;&gt; 1;\n        swap (a[mid], a[l+1]);\n        if (a[l] &gt; a[r])\n            swap (a[l], a[r]);\n        if (a[l+1] &gt; a[r])\n            swap (a[l+1], a[r]);\n        if (a[l] &gt; a[l+1])\n            swap (a[l], a[l+1]);\n\n        // performing division\n        // barrier is a[l + 1], i.e. median among a[l], a[l + 1], a[r]\n        unsigned\n            i = l+1,\n            j = r;\n        const T\n            cur = a[l+1];\n        for (;;)\n        {\n            while (a[++i] &lt; cur) ;\n            while (a[--j] &gt; cur) ;\n            if (i &gt; j)\n                break;\n            swap (a[i], a[j]);\n        }\n\n        // inserting the barrier\n        a[l+1] = a[j];\n        a[j] = cur;\n\n        // we continue to work in that part, which must contain the required element\n        if (j &gt;= k)\n            r = j-1;\n        if (j &lt;= k)\n            l = i;\n    }\n}\n</code></pre>","tags":["Translated"]},{"location":"sequences/k-th.html#notes","title":"Notes","text":"<ul> <li>The randomized algorithm above is named quickselect. You should do random shuffle on $A$ before calling it or use a random element as a barrier for it to run properly. There are also deterministic algorithms that solve the specified problem in linear time, such as median of medians.</li> <li>std::nth_element solves this in C++ but gcc's implementation runs in worst case $O(n \\log n )$ time.</li> <li>Finding $K$ smallest elements can be reduced to finding $K$-th element with a linear overhead, as they're exactly the elements that are smaller than $K$-th.</li> </ul>","tags":["Translated"]},{"location":"sequences/k-th.html#practice-problems","title":"Practice Problems","text":"<ul> <li>Leetcode: Kth Largest Element in an Array</li> <li>CODECHEF: Median</li> </ul>","tags":["Translated"]},{"location":"sequences/longest_increasing_subsequence.html","title":"Longest increasing subsequence","text":""},{"location":"sequences/longest_increasing_subsequence.html#longest-increasing-subsequence","title":"Longest increasing subsequence","text":"<p>This article has been moved to a Longest increasing subsequence.</p>"},{"location":"sequences/mex.html","title":"MEX (minimal excluded) of a sequence","text":"<p>Given an array $A$ of size $N$. You have to find the minimal non-negative element that is not present in the array. That number is commonly called the MEX (minimal excluded).</p> $$ \\begin{align} \\text{mex}(\\{0, 1, 2, 4, 5\\}) &amp;= 3 \\\\ \\text{mex}(\\{0, 1, 2, 3, 4\\}) &amp;= 5 \\\\ \\text{mex}(\\{1, 2, 3, 4, 5\\}) &amp;= 0 \\\\ \\end{align} $$ <p>Notice, that the MEX of an array of size $N$ can never be bigger than $N$ itself.</p> <p>The easiest approach is to create a set of all elements in the array $A$, so that we can quickly check if a number is part of the array or not. Then we can check all numbers from $0$ to $N$, if the current number is not present in the set, return it.</p>","tags":["Original"]},{"location":"sequences/mex.html#implementation","title":"Implementation","text":"<p>The following algorithm runs in $O(N \\log N)$ time.</p> <pre><code>int mex(vector&lt;int&gt; const&amp; A) {\n    set&lt;int&gt; b(A.begin(), A.end());\n\n    int result = 0;\n    while (b.count(result))\n        ++result;\n    return result;\n}\n</code></pre> <p>If an algorithm requires a $O(N)$ MEX computation, it is possible by using a boolean vector instead of a set. Notice, that the array needs to be as big as the biggest possible array size.</p> <pre><code>int mex(vector&lt;int&gt; const&amp; A) {\n    static bool used[MAX_N+1] = { 0 };\n\n    // mark the given numbers\n    for (int x : A) {\n        if (x &lt;= MAX_N)\n            used[x] = true;\n    }\n\n    // find the mex\n    int result = 0;\n    while (used[result])\n        ++result;\n\n    // clear the array again\n    for (int x : A) {\n        if (x &lt;= MAX_N)\n            used[x] = false;\n    }\n\n    return result;\n}\n</code></pre> <p>This approach is fast, but only works well if you have to compute the MEX once. If you need to compute the MEX over and over, e.g. because your array keeps changing, then it is not effective. For that, we need something better.</p>","tags":["Original"]},{"location":"sequences/mex.html#mex-with-array-updates","title":"MEX with array updates","text":"<p>In the problem you need to change individual numbers in the array, and compute the new MEX of the array after each such update.</p> <p>There is a need for a better data structure that handles such queries efficiently.</p> <p>One approach would be take the frequency of each number from $0$ to $N$, and build a tree-like data structure over it. E.g. a segment tree or a treap. Each node represents a range of numbers, and together to total frequency in the range, you additionally store the amount of distinct numbers in that range. It's possible to update this data structure in $O(\\log N)$ time, and also find the MEX in $O(\\log N)$ time, by doing a binary search for the MEX. If the node representing the range $[0, \\lfloor N/2 \\rfloor)$ doesn't contain $\\lfloor N/2 \\rfloor$ many distinct numbers, then one is missing and the MEX is smaller than $\\lfloor N/2 \\rfloor$, and you can recurse in the left branch of the tree. Otherwise it is at least $\\lfloor N/2 \\rfloor$, and you can recurse in the right branch of the tree.</p> <p>It's also possible to use the standard library data structures <code>map</code> and <code>set</code> (based on an approach explained here). With a <code>map</code> we will remember the frequency of each number, and with the <code>set</code> we represent the numbers that are currently missing from the array. Since a <code>set</code> is ordered, <code>*set.begin()</code> will be the MEX. In total we need $O(N \\log N)$ precomputation, and afterwards the MEX can be computed in $O(1)$ and an update can be performed in $O(\\log N)$.</p> <pre><code>class Mex {\nprivate:\n    map&lt;int, int&gt; frequency;\n    set&lt;int&gt; missing_numbers;\n    vector&lt;int&gt; A;\n\npublic:\n    Mex(vector&lt;int&gt; const&amp; A) : A(A) {\n        for (int i = 0; i &lt;= A.size(); i++)\n            missing_numbers.insert(i);\n\n        for (int x : A) {\n            ++frequency[x];\n            missing_numbers.erase(x);\n        }\n    }\n\n    int mex() {\n        return *missing_numbers.begin();\n    }\n\n    void update(int idx, int new_value) {\n        if (--frequency[A[idx]] == 0)\n            missing_numbers.insert(A[idx]);\n        A[idx] = new_value;\n        ++frequency[new_value];\n        missing_numbers.erase(new_value);\n    }\n};\n</code></pre>","tags":["Original"]},{"location":"sequences/mex.html#practice-problems","title":"Practice Problems","text":"<ul> <li>AtCoder: Neq Min</li> <li>Codeforces: Informatics in MAC</li> <li>Codeforces: Replace by MEX</li> <li>Codeforces: Vitya and Strange Lesson</li> <li>Codeforces: MEX Queries</li> </ul>","tags":["Original"]},{"location":"sequences/rmq.html","title":"Range Minimum Query","text":"<p>You are given an array $A[1..N]$. You have to answer incoming queries of the form $(L, R)$, which ask to find the minimum element in array $A$ between positions $L$ and $R$ inclusive.</p> <p>RMQ can appear in problems directly or can be applied in some other tasks, e.g. the Lowest Common Ancestor problem.</p>","tags":["Translated"]},{"location":"sequences/rmq.html#solution","title":"Solution","text":"<p>There are lots of possible approaches and data structures that you can use to solve the RMQ task.</p> <p>The ones that are explained on this site are listed below.</p> <p>First the approaches that allow modifications to the array between answering queries.</p> <ul> <li>Sqrt-decomposition - answers each query in $O(\\sqrt{N})$, preprocessing done in $O(N)$.   Pros: a very simple data structure. Cons: worse complexity.</li> <li>Segment tree - answers each query in $O(\\log N)$, preprocessing done in $O(N)$.   Pros: good time complexity. Cons: larger amount of code compared to the other data structures.</li> <li>Fenwick tree - answers each query in $O(\\log N)$, preprocessing done in $O(N \\log N)$.   Pros: the shortest code, good time complexity. Cons: Fenwick tree can only be used for queries with $L = 1$, so it is not applicable to many problems.</li> </ul> <p>And here are the approaches that only work on static arrays, i.e. it is not possible to change a value in the array without recomputing the complete data structure.</p> <ul> <li>Sparse Table - answers each query in $O(1)$, preprocessing done in $O(N \\log N)$.   Pros: simple data structure, excellent time complexity.</li> <li>Sqrt Tree - answers queries in $O(1)$, preprocessing done in $O(N \\log \\log N)$. Pros: fast. Cons: Complicated to implement.</li> <li>Disjoint Set Union / Arpa's Trick - answers queries in $O(1)$, preprocessing in $O(n)$. Pros: short, fast. Cons: only works if all queries are known in advance, i.e. only supports off-line processing of the queries.</li> <li>Cartesian Tree and Farach-Colton and Bender algorithm - answers queries in $O(1)$, preprocessing in $O(n)$. Pros: optimal complexity. Cons: large amount of code.</li> </ul> <p>Note: Preprocessing is the preliminary processing of the given array by building the corresponding data structure for it.</p>","tags":["Translated"]},{"location":"sequences/rmq.html#practice-problems","title":"Practice Problems","text":"<ul> <li>SPOJ: Range Minimum Query</li> <li>CODECHEF: Chef And Array</li> <li>Codeforces:  Array Partition</li> </ul>","tags":["Translated"]},{"location":"string/aho_corasick.html","title":"Aho-Corasick algorithm","text":"<p>The Aho-Corasick algorithm allows us to quickly search for multiple patterns in a text. The set of pattern strings is also called a dictionary. We will denote the total length of its constituent strings by $m$ and the size of the alphabet by $k$. The algorithm constructs a finite state automaton based on a trie in $O(m k)$ time and then uses it to process the text.</p> <p>The algorithm was proposed by Alfred Aho and Margaret Corasick in 1975.</p>","tags":["Translated"]},{"location":"string/aho_corasick.html#construction-of-the-trie","title":"Construction of the trie","text":"A trie based on words \"Java\", \"Rad\", \"Rand\", \"Rau\", \"Raum\" and \"Rose\". The image by [nd](https://de.wikipedia.org/wiki/Benutzer:Nd) is distributed under CC BY-SA 3.0 license. <p>Formally, a trie is a rooted tree, where each edge of the tree is labeled with some letter and outgoing edges of a vertex have distinct labels.</p> <p>We will identify each vertex in the trie with the string formed by the labels on the path from the root to that vertex.</p> <p>Each vertex will also have a flag $\\text{output}$ which will be set if the vertex corresponds to a pattern in the dictionary.</p> <p>Accordingly, a trie for a set of strings is a trie such that each $\\text{output}$ vertex corresponds to one string from the set, and conversely, each string of the set corresponds to one $\\text{output}$ vertex.</p> <p>We now describe how to construct a trie for a given set of strings in linear time with respect to their total length.</p> <p>We introduce a structure for the vertices of the tree: <pre><code>const int K = 26;\n\nstruct Vertex {\n    int next[K];\n    bool output = false;\n\n    Vertex() {\n        fill(begin(next), end(next), -1);\n    }\n};\n\nvector&lt;Vertex&gt; trie(1);\n</code></pre></p> <p>Here, we store the trie as an array of $\\text{Vertex}$. Each $\\text{Vertex}$ contains the flag $\\text{output}$ and the edges in the form of an array $\\text{next}[]$, where $\\text{next}[i]$ is the index of the vertex that we reach by following the character $i$, or $-1$ if there is no such edge. Initially, the trie consists of only one vertex - the root - with the index $0$.</p> <p>Now we implement a function that will add a string $s$ to the trie. The implementation is simple: we start at the root node, and as long as there are edges corresponding to the characters of $s$ we follow them. If there is no edge for one character, we generate a new vertex and connect it with an edge. At the end of the process we mark the last vertex with the flag $\\text{output}$.</p> <pre><code>void add_string(string const&amp; s) {\n    int v = 0;\n    for (char ch : s) {\n        int c = ch - 'a';\n        if (trie[v].next[c] == -1) {\n            trie[v].next[c] = trie.size();\n            trie.emplace_back();\n        }\n        v = trie[v].next[c];\n    }\n    trie[v].output = true;\n}\n</code></pre> <p>This implementation obviously runs in linear time, and since every vertex stores $k$ links, it will use $O(m k)$ memory.</p> <p>It is possible to decrease the memory consumption to $O(m)$ by using a map instead of an array in each vertex. However, this will increase the time complexity to $O(m \\log k)$.</p>","tags":["Translated"]},{"location":"string/aho_corasick.html#construction-of-an-automaton","title":"Construction of an automaton","text":"<p>Suppose we have built a trie for the given set of strings. Now let's look at it from a different side. If we look at any vertex, the string that corresponds to it is a prefix of one or more strings in the set, thus each vertex of the trie can be interpreted as a position in one or more strings from the set.</p> <p>In fact, the trie vertices can be interpreted as states in a finite deterministic automaton. From any state we can transition - using some input letter - to other states, i.e., to another position in the set of strings. For example, if there is only one string $abc$ in the dictionary, and we are standing at vertex $ab$, then using the letter $c$ we can go to the vertex $abc$.</p> <p>Thus we can understand the edges of the trie as transitions in an automaton according to the corresponding letter. However, in an automaton we need to have transitions for each combination of a state and a letter. If we try to perform a transition using a letter, and there is no corresponding edge in the trie, then we nevertheless must go into some state.</p> <p>More precisely, suppose we are in a state corresponding to a string $t$, and we want to transition to a different state using the character $c$. If there is an edge labeled with this letter $c$, then we can simply go over this edge, and get the vertex corresponding to $t + c$. If there is no such edge, since we want to maintain the invariant that the current state is the longest partial match in the processed string, we must find the longest string in the trie that's a proper suffix of the string $t$, and try to perform a transition from there.</p> <p>For example, let the trie be constructed by the strings $ab$ and $bc$, and we are currently at the vertex corresponding to $ab$, which is also an $\\text{output}$ vertex. To transition with the letter $c$, we are forced to go to the state corresponding to the string $b$, and from there follow the edge with the letter $c$.</p> An Aho-Corasick automaton based on words \"a\", \"ab\", \"bc\", \"bca\", \"c\" and \"caa\". Blue arrows are suffix links, green arrows are terminal links. <p>A suffix link for a vertex $p$ is an edge that points to the longest proper suffix of the string corresponding to the vertex $p$. The only special case is the root of the trie, whose suffix link will point to itself. Now we can reformulate the statement about the transitions in the automaton like this: while there is no transition from the current vertex of the trie using the current letter (or until we reach the root), we follow the suffix link.</p> <p>Thus we reduced the problem of constructing an automaton to the problem of finding suffix links for all vertices of the trie. However, we will build these suffix links, oddly enough, using the transitions constructed in the automaton.</p> <p>The suffix links of the root vertex and all its immediate children point to the root vertex. For any vertex $v$ deeper in the tree, we can calculate the suffix link as follows: if $p$ is the ancestor of $v$ with $c$ being the letter labeling the edge from $p$ to $v$, go to $p$, then follow its suffix link, and perform the transition with the letter $c$ from there.</p> <p>Thus, the problem of finding the transitions has been reduced to the problem of finding suffix links, and the problem of finding suffix links has been reduced to the problem of finding a suffix link and a transition, except for vertices closer to the root. So we have a recursive dependence that we can resolve in linear time.</p> <p>Let's move to the implementation. Note that we now will store the ancestor $p$ and the character $pch$ of the edge from $p$ to $v$ for each vertex $v$. Also, at each vertex we will store the suffix link $\\text{link}$ (or $-1$ if it hasn't been calculated yet), and in the array $\\text{go}[k]$ the transitions in the machine for each symbol (again $-1$ if it hasn't been calculated yet).</p> <pre><code>const int K = 26;\n\nstruct Vertex {\n    int next[K];\n    bool output = false;\n    int p = -1;\n    char pch;\n    int link = -1;\n    int go[K];\n\n    Vertex(int p=-1, char ch='$') : p(p), pch(ch) {\n        fill(begin(next), end(next), -1);\n        fill(begin(go), end(go), -1);\n    }\n};\n\nvector&lt;Vertex&gt; t(1);\n\nvoid add_string(string const&amp; s) {\n    int v = 0;\n    for (char ch : s) {\n        int c = ch - 'a';\n        if (t[v].next[c] == -1) {\n            t[v].next[c] = t.size();\n            t.emplace_back(v, ch);\n        }\n        v = t[v].next[c];\n    }\n    t[v].output = true;\n}\n\nint go(int v, char ch);\n\nint get_link(int v) {\n    if (t[v].link == -1) {\n        if (v == 0 || t[v].p == 0)\n            t[v].link = 0;\n        else\n            t[v].link = go(get_link(t[v].p), t[v].pch);\n    }\n    return t[v].link;\n}\n\nint go(int v, char ch) {\n    int c = ch - 'a';\n    if (t[v].go[c] == -1) {\n        if (t[v].next[c] != -1)\n            t[v].go[c] = t[v].next[c];\n        else\n            t[v].go[c] = v == 0 ? 0 : go(get_link(v), ch);\n    }\n    return t[v].go[c];\n} \n</code></pre> <p>It is easy to see that thanks to memoization of the suffix links and transitions, the total time for finding all suffix links and transitions will be linear.</p> <p>For an illustration of the concept refer to slide number 103 of the Stanford slides.</p>","tags":["Translated"]},{"location":"string/aho_corasick.html#bfs-based-construction","title":"BFS-based construction","text":"<p>Instead of computing transitions and suffix links with recursive calls to <code>go</code> and <code>get_link</code>, it is possible to compute them bottom-up starting from the root. (In fact, when the dictionary consists of only one string, we obtain the familiar Knuth-Morris-Pratt algorithm.)</p> <p>This approach will have some advantages over the one described above as, instead of the total length $m$, its running time depends only on the number of vertices $n$ in the trie. Moreover, it is possible to adapt it for large alphabets using a persistent array data structure, thus making the construction time $O(n \\log k)$ instead of $O(mk)$, which is a significant improvement granted that $m$ may go up to $n^2$.</p> <p>We can reason inductively using the fact that BFS from the root traverses vertices in order of increasing length. We may assume that when we're in a vertex $v$, its suffix link $u = link[v]$ is already successfully computed, and for all vertices with shorter length transitions from them are also fully computed.</p> <p>Assume that at the moment we stand in a vertex $v$ and consider a character $c$. We essentially have two cases:</p> <ol> <li>$go[v][c] = -1$. In this case, we may assign $go[v][c] = go[u][c]$, which is already known by the induction hypothesis;</li> <li>$go[v][c] = w \\neq -1$. In this case, we may assign $link[w] = go[u][c]$.</li> </ol> <p>In this way, we spend $O(1)$ time per each pair of a vertex and a character, making the running time $O(nk)$. The major overhead here is that we copy a lot of transitions from $u$ in the first case, while the transitions of the second case form the trie and sum up to $n$ over all vertices. To avoid the copying of $go[u][c]$, we may use a persistent array data structure, using which we initially copy $go[u]$ into $go[v]$ and then only update values for characters in which the transition would differ. This leads to the $O(n \\log k)$ algorithm.</p>","tags":["Translated"]},{"location":"string/aho_corasick.html#applications","title":"Applications","text":"","tags":["Translated"]},{"location":"string/aho_corasick.html#find-all-strings-from-a-given-set-in-a-text","title":"Find all strings from a given set in a text","text":"<p>We are given a set of strings and a text. We have to print all occurrences of all strings from the set in the given text in $O(\\text{len} + \\text{ans})$, where $\\text{len}$ is the length of the text and $\\text{ans}$ is the size of the answer.</p> <p>We construct an automaton for this set of strings. We will now process the text letter by letter using the automaton, starting at the root of the trie. If we are at any time at state $v$, and the next letter is $c$, then we transition to the next state with $\\text{go}(v, c)$, thereby either increasing the length of the current match substring by $1$, or decreasing it by following a suffix link.</p> <p>How can we find out for a state $v$, if there are any matches with strings for the set? First, it is clear that if we stand on a $\\text{output}$ vertex, then the string corresponding to the vertex ends at this position in the text. However this is by no means the only possible case of achieving a match: if we can reach one or more  $\\text{output}$ vertices by moving along the suffix links, then there will be also a match corresponding to each found $\\text{output}$ vertex. A simple example demonstrating this situation can be created using the set of strings $\\{dabce, abc, bc\\}$ and the text $dabc$.</p> <p>Thus if we store in each $\\text{output}$ vertex the index of the string corresponding to it (or the list of indices if duplicate strings appear in the set), then we can find in $O(n)$ time the indices of all strings which match the current state, by simply following the suffix links from the current vertex to the root. This is not the most efficient solution, since this results in $O(n ~ \\text{len})$ complexity overall. However, this can be optimized by computing and storing the nearest $\\text{output}$ vertex that is reachable using suffix links (this is sometimes called the exit link). This value we can compute lazily in linear time. Thus for each vertex we can advance in $O(1)$ time to the next marked vertex in the suffix link path, i.e. to the next match. Thus for each match we spend $O(1)$ time, and therefore we reach the complexity $O(\\text{len} + \\text{ans})$.</p> <p>If you only want to count the occurrences and not find the indices themselves, you can calculate the number of marked vertices in the suffix link path for each vertex $v$. This can be calculated in $O(n)$ time in total. Thus we can sum up all matches in $O(\\text{len})$.</p>","tags":["Translated"]},{"location":"string/aho_corasick.html#finding-the-lexicographically-smallest-string-of-a-given-length-that-doesnt-match-any-given-strings","title":"Finding the lexicographically smallest string of a given length that doesn't match any given strings","text":"<p>A set of strings and a length $L$ is given. We have to find a string of length $L$, which does not contain any of the strings, and derive the lexicographically smallest of such strings.</p> <p>We can construct the automaton for the set of strings. Recall that $\\text{output}$ vertices are the states where we have a match with a string from the set. Since in this task we have to avoid matches, we are not allowed to enter such states. On the other hand we can enter all other vertices. Thus we delete all \"bad\" vertices from the machine, and in the remaining graph of the automaton we find the lexicographically smallest path of length $L$. This task can be solved in $O(L)$ for example by depth first search.</p>","tags":["Translated"]},{"location":"string/aho_corasick.html#finding-the-shortest-string-containing-all-given-strings","title":"Finding the shortest string containing all given strings","text":"<p>Here we use the same ideas. For each vertex we store a mask that denotes the strings which match at this state. Then the problem can be reformulated as follows: initially being in the state $(v = \\text{root},~ \\text{mask} = 0)$, we want to reach the state $(v,~ \\text{mask} = 2^n - 1)$, where $n$ is the number of strings in the set. When we transition from one state to another using a letter, we update the mask accordingly. By running a breadth first search we can find a path to the state $(v,~ \\text{mask} = 2^n - 1)$ with the smallest length.</p>","tags":["Translated"]},{"location":"string/aho_corasick.html#finding-the-lexicographically-smallest-string-of-length-l-containing-k-strings","title":"Finding the lexicographically smallest string of length $L$ containing $k$ strings","text":"<p>As in the previous problem, we calculate for each vertex the number of matches that correspond to it (that is the number of marked vertices reachable using suffix links). We reformulate the problem: the current state is determined by a triple of numbers $(v,~ \\text{len},~ \\text{cnt})$, and we want to reach from the state $(\\text{root},~ 0,~ 0)$ the state $(v,~ L,~ k)$, where $v$ can be any vertex. Thus we can find such a path  using depth first search (and if the search looks at the edges in their natural order, then the found path will automatically be the lexicographically smallest).</p>","tags":["Translated"]},{"location":"string/aho_corasick.html#problems","title":"Problems","text":"<ul> <li>UVA #11590 - Prefix Lookup</li> <li>UVA #11171 - SMS</li> <li>UVA #10679 - I Love Strings!!</li> <li>Codeforces - x-prime Substrings</li> <li>Codeforces - Frequency of String</li> <li>CodeChef - TWOSTRS</li> </ul>","tags":["Translated"]},{"location":"string/aho_corasick.html#references","title":"References","text":"<ul> <li>Stanford's CS166 - Aho-Corasick Automata (Condensed)</li> </ul>","tags":["Translated"]},{"location":"string/expression_parsing.html","title":"Expression parsing","text":"<p>A string containing a mathematical expression containing numbers and various operators is given. We have to compute the value of it in $O(n)$, where $n$ is the length of the string.</p> <p>The algorithm discussed here translates an expression into the so-called reverse Polish notation (explicitly or implicitly), and evaluates this expression.</p>","tags":["Translated"]},{"location":"string/expression_parsing.html#reverse-polish-notation","title":"Reverse Polish notation","text":"<p>The reverse Polish notation is a form of writing mathematical expressions, in which the operators are located after their operands. For example the following expression</p> $$a + b * c * d + (e - f) * (g * h + i)$$ <p>can be written in reverse Polish notation in the following way:</p> $$a b c * d * + e f - g h * i + * +$$ <p>The reverse Polish notation was developed by the Australian philosopher and computer science specialist Charles Hamblin in the mid 1950s on the basis of the Polish notation, which was proposed in 1920 by the Polish mathematician Jan \u0141ukasiewicz.</p> <p>The convenience of the reverse Polish notation is, that expressions in this form are very easy to evaluate in linear time. We use a stack, which is initially empty. We will iterate over the operands and operators of the expression in reverse Polish notation. If the current element is a number, then we put the value on top of the stack, if the current element is an operator, then we get the top two elements from the stack, perform the operation, and put the result back on top of the stack. In the end there will be exactly one element left in the stack, which will be the value of the expression.</p> <p>Obviously this simple evaluation runs in $O(n)$ time.</p>","tags":["Translated"]},{"location":"string/expression_parsing.html#parsing-of-simple-expressions","title":"Parsing of simple expressions","text":"<p>For the time being we only consider a simplified problem: we assume that all operators are binary (i.e. they take two arguments), and all are left-associative (if the priorities are equal, they get executed from left to right). Parentheses are allowed.</p> <p>We will set up two stacks: one for numbers, and one for operators and parentheses. Initially both stacks are empty. For the second stack we will maintain the condition that all operations are ordered by strict descending priority. If there are parenthesis on the stack, than each block of operators (corresponding to one pair of parenthesis) is ordered, and the entire stack is not necessarily ordered.</p> <p>We will iterate over the characters of the expression from left to right. If the current character is a digit, then we put the value of this number on the stack. If the current character is an opening parenthesis, then we put it on the stack. If the current character is a closing parenthesis, the we execute all operators on the stack until we reach the opening bracket (in other words we perform all operations inside the parenthesis). Finally if the current character is an operator, then while the top of the stack has an operator with the same or higher priority, we will execute this operation, and put the new operation on the stack.</p> <p>After we processed the entire string, some operators might still be in the stack, so we execute them.</p> <p>Here is the implementation of this method for the four operators $+$ $-$ $*$ $/$:</p> <pre><code>bool delim(char c) {\n    return c == ' ';\n}\n\nbool is_op(char c) {\n    return c == '+' || c == '-' || c == '*' || c == '/';\n}\n\nint priority (char op) {\n    if (op == '+' || op == '-')\n        return 1;\n    if (op == '*' || op == '/')\n        return 2;\n    return -1;\n}\n\nvoid process_op(stack&lt;int&gt;&amp; st, char op) {\n    int r = st.top(); st.pop();\n    int l = st.top(); st.pop();\n    switch (op) {\n        case '+': st.push(l + r); break;\n        case '-': st.push(l - r); break;\n        case '*': st.push(l * r); break;\n        case '/': st.push(l / r); break;\n    }\n}\n\nint evaluate(string&amp; s) {\n    stack&lt;int&gt; st;\n    stack&lt;char&gt; op;\n    for (int i = 0; i &lt; (int)s.size(); i++) {\n        if (delim(s[i]))\n            continue;\n\n        if (s[i] == '(') {\n            op.push('(');\n        } else if (s[i] == ')') {\n            while (op.top() != '(') {\n                process_op(st, op.top());\n                op.pop();\n            }\n            op.pop();\n        } else if (is_op(s[i])) {\n            char cur_op = s[i];\n            while (!op.empty() &amp;&amp; priority(op.top()) &gt;= priority(cur_op)) {\n                process_op(st, op.top());\n                op.pop();\n            }\n            op.push(cur_op);\n        } else {\n            int number = 0;\n            while (i &lt; (int)s.size() &amp;&amp; isalnum(s[i]))\n                number = number * 10 + s[i++] - '0';\n            --i;\n            st.push(number);\n        }\n    }\n\n    while (!op.empty()) {\n        process_op(st, op.top());\n        op.pop();\n    }\n    return st.top();\n}\n</code></pre> <p>Thus we learned how to calculate the value of an expression in $O(n)$, at the same time we implicitly used the reverse Polish notation. By slightly modifying the above implementation it is also possible to obtain the expression in reverse Polish notation in an explicit form.</p>","tags":["Translated"]},{"location":"string/expression_parsing.html#unary-operators","title":"Unary operators","text":"<p>Now suppose that the expression also contains unary operators (operators that take one argument). The unary plus and unary minus are common examples of such operators.</p> <p>One of the differences in this case, is that we need to determine whether the current operator is a unary or a binary one.</p> <p>You can notice, that before an unary operator, there always is another operator or an opening parenthesis, or nothing at all (if it is at the very beginning of the expression). On the contrary before a binary operator there will always be an operand (number) or a closing parenthesis. Thus it is easy to flag whether the next operator can be unary or not. </p> <p>Additionally we need to execute a unary and a binary operator differently. And we need to chose the priority of a unary operator higher than all of the binary operators.</p> <p>In addition it should be noted, that some unary operators (e.g. unary plus and unary minus) are actually right-associative.</p>","tags":["Translated"]},{"location":"string/expression_parsing.html#right-associativity","title":"Right-associativity","text":"<p>Right-associative means, that whenever the priorities are equal, the operators must be evaluated from right to left.</p> <p>As noted above, unary operators are usually right-associative. Another example for an right-associative operator is the exponentiation operator ($a \\wedge b \\wedge c$ is usually perceived as $a^{b^c}$ and not as $(a^b)^c$).</p> <p>What difference do we need to make in order to correctly handle right-associative operators? It turns out that the changes are very minimal. The only difference will be, if the priorities are equal we will postpone the execution of the right-associative operation.</p> <p>The only line that needs to be replaced is <pre><code>while (!op.empty() &amp;&amp; priority(op.top()) &gt;= priority(cur_op))\n</code></pre> with <pre><code>while (!op.empty() &amp;&amp; (\n        (left_assoc(cur_op) &amp;&amp; priority(op.top()) &gt;= priority(cur_op)) ||\n        (!left_assoc(cur_op) &amp;&amp; priority(op.top()) &gt; priority(cur_op))\n    ))\n</code></pre> where <code>left_assoc</code> is a function that decides if an operator is left_associative or not.</p> <p>Here is an implementation for the binary operators $+$ $-$ $*$ $/$ and the unary  operators $+$ and $-$.</p> <pre><code>bool delim(char c) {\n    return c == ' ';\n}\n\nbool is_op(char c) {\n    return c == '+' || c == '-' || c == '*' || c == '/';\n}\n\nbool is_unary(char c) {\n    return c == '+' || c=='-';\n}\n\nint priority (char op) {\n    if (op &lt; 0) // unary operator\n        return 3;\n    if (op == '+' || op == '-')\n        return 1;\n    if (op == '*' || op == '/')\n        return 2;\n    return -1;\n}\n\nvoid process_op(stack&lt;int&gt;&amp; st, char op) {\n    if (op &lt; 0) {\n        int l = st.top(); st.pop();\n        switch (-op) {\n            case '+': st.push(l); break;\n            case '-': st.push(-l); break;\n        }\n    } else {\n        int r = st.top(); st.pop();\n        int l = st.top(); st.pop();\n        switch (op) {\n            case '+': st.push(l + r); break;\n            case '-': st.push(l - r); break;\n            case '*': st.push(l * r); break;\n            case '/': st.push(l / r); break;\n        }\n    }\n}\n\nint evaluate(string&amp; s) {\n    stack&lt;int&gt; st;\n    stack&lt;char&gt; op;\n    bool may_be_unary = true;\n    for (int i = 0; i &lt; (int)s.size(); i++) {\n        if (delim(s[i]))\n            continue;\n\n        if (s[i] == '(') {\n            op.push('(');\n            may_be_unary = true;\n        } else if (s[i] == ')') {\n            while (op.top() != '(') {\n                process_op(st, op.top());\n                op.pop();\n            }\n            op.pop();\n            may_be_unary = false;\n        } else if (is_op(s[i])) {\n            char cur_op = s[i];\n            if (may_be_unary &amp;&amp; is_unary(cur_op))\n                cur_op = -cur_op;\n            while (!op.empty() &amp;&amp; (\n                    (cur_op &gt;= 0 &amp;&amp; priority(op.top()) &gt;= priority(cur_op)) ||\n                    (cur_op &lt; 0 &amp;&amp; priority(op.top()) &gt; priority(cur_op))\n                )) {\n                process_op(st, op.top());\n                op.pop();\n            }\n            op.push(cur_op);\n            may_be_unary = true;\n        } else {\n            int number = 0;\n            while (i &lt; (int)s.size() &amp;&amp; isalnum(s[i]))\n                number = number * 10 + s[i++] - '0';\n            --i;\n            st.push(number);\n            may_be_unary = false;\n        }\n    }\n\n    while (!op.empty()) {\n        process_op(st, op.top());\n        op.pop();\n    }\n    return st.top();\n}\n</code></pre>","tags":["Translated"]},{"location":"string/lyndon_factorization.html","title":"Lyndon factorization","text":"","tags":["Translated"]},{"location":"string/lyndon_factorization.html#lyndon-factorization_1","title":"Lyndon factorization","text":"<p>First let us define the notion of the Lyndon factorization.</p> <p>A string is called simple (or a Lyndon word), if it is strictly smaller than any of its own nontrivial suffixes. Examples of simple strings are: $a$, $b$, $ab$, $aab$, $abb$, $ababb$, $abcd$. It can be shown that a string is simple, if and only if it is strictly smaller than all its nontrivial cyclic shifts.</p> <p>Next, let there be a given string $s$. The Lyndon factorization of the string $s$ is a factorization $s = w_1 w_2 \\dots w_k$, where all strings $w_i$ are simple, and they are in non-increasing order $w_1 \\ge w_2 \\ge \\dots \\ge w_k$.</p> <p>It can be shown, that for any string such a factorization exists and that it is unique.</p>","tags":["Translated"]},{"location":"string/lyndon_factorization.html#duval-algorithm","title":"Duval algorithm","text":"<p>The Duval algorithm constructs the Lyndon factorization in $O(n)$ time using $O(1)$ additional memory.</p> <p>First let us introduce another notion: a string $t$ is called pre-simple, if it has the form $t = w w \\dots w \\overline{w}$, where $w$ is a simple string and $\\overline{w}$ is a prefix of $w$ (possibly empty). A simple string is also pre-simple.</p> <p>The Duval algorithm is greedy. At any point during its execution, the string $s$ will actually be divided into three strings $s = s_1 s_2 s_3$, where the Lyndon factorization for $s_1$ is already found and finalized, the string $s_2$ is pre-simple (and we know the length of the simple string in it), and $s_3$ is completely untouched. In each iteration the Duval algorithm takes the first character of the string $s_3$ and tries to append it to the string $s_2$. It $s_2$ is no longer pre-simple, then the Lyndon factorization for some part of $s_2$ becomes known, and this part goes to $s_1$.</p> <p>Let's describe the algorithm in more detail. The pointer $i$ will always point to the beginning of the string $s_2$. The outer loop will be executed as long as $i &lt; n$. Inside the loop we use two additional pointers, $j$ which points to the beginning of $s_3$, and $k$ which points to the current character that we are currently comparing to. We want to add the character $s[j]$ to the string $s_2$, which requires a comparison with the character $s[k]$. There can be three different cases:</p> <ul> <li>$s[j] = s[k]$: if this is the case, then adding the symbol $s[j]$ to $s_2$ doesn't violate its pre-simplicity.   So we simply increment the pointers $j$ and $k$.</li> <li>$s[j] &gt; s[k]$: here, the string $s_2 + s[j]$ becomes simple.   We can increment $j$ and reset $k$ back to the beginning of $s_2$, so that the next character can be compared with the beginning of the simple word.</li> <li>$s[j] &lt; s[k]$: the string $s_2 + s[j]$ is no longer pre-simple.   Therefore we will split the pre-simple string $s_2$ into its simple strings and the remainder, possibly empty.   The simple string will have the length $j - k$.   In the next iteration we start again with the remaining $s_2$.</li> </ul>","tags":["Translated"]},{"location":"string/lyndon_factorization.html#implementation","title":"Implementation","text":"<p>Here we present the implementation of the Duval algorithm, which will return the desired Lyndon factorization of a given string $s$.</p> <pre><code>vector&lt;string&gt; duval(string const&amp; s) {\n    int n = s.size();\n    int i = 0;\n    vector&lt;string&gt; factorization;\n    while (i &lt; n) {\n        int j = i + 1, k = i;\n        while (j &lt; n &amp;&amp; s[k] &lt;= s[j]) {\n            if (s[k] &lt; s[j])\n                k = i;\n            else\n                k++;\n            j++;\n        }\n        while (i &lt;= k) {\n            factorization.push_back(s.substr(i, j - k));\n            i += j - k;\n        }\n    }\n    return factorization;\n}\n</code></pre>","tags":["Translated"]},{"location":"string/lyndon_factorization.html#complexity","title":"Complexity","text":"<p>Let us estimate the running time of this algorithm.</p> <p>The outer while loop does not exceed $n$ iterations, since at the end of each iteration $i$ increases. Also the second inner while loop runs in $O(n)$, since is only outputs the final factorization.</p> <p>So we are only interested in the first inner while loop. How many iterations does it perform in the worst case? It's easy to see that the simple words that we identify in each iteration of the outer loop are longer than the remainder that we additionally compared. Therefore also the sum of the remainders will be smaller than $n$, which means that we only perform at most $O(n)$ iterations of the first inner while loop. In fact the total number of character comparisons will not exceed $4n - 3$.</p>","tags":["Translated"]},{"location":"string/lyndon_factorization.html#finding-the-smallest-cyclic-shift","title":"Finding the smallest cyclic shift","text":"<p>Let there be a string $s$. We construct the Lyndon factorization for the string $s + s$ (in $O(n)$ time). We will look for a simple string in the factorization, which starts at a position less than $n$ (i.e. it starts in the first instance of $s$), and ends in a position greater than or equal to $n$ (i.e. in the second instance) of $s$). It is stated, that the position of the start of this simple string will be the beginning of the desired smallest cyclic shift. This can be easily verified using the definition of the Lyndon decomposition.</p> <p>The beginning of the simple block can be found easily - just remember the pointer $i$ at the beginning of each iteration of the outer loop, which indicated the beginning of the current pre-simple string.</p> <p>So we get the following implementation:</p> <pre><code>string min_cyclic_string(string s) {\n    s += s;\n    int n = s.size();\n    int i = 0, ans = 0;\n    while (i &lt; n / 2) {\n        ans = i;\n        int j = i + 1, k = i;\n        while (j &lt; n &amp;&amp; s[k] &lt;= s[j]) {\n            if (s[k] &lt; s[j])\n                k = i;\n            else\n                k++;\n            j++;\n        }\n        while (i &lt;= k)\n            i += j - k;\n    }\n    return s.substr(ans, n / 2);\n}\n</code></pre>","tags":["Translated"]},{"location":"string/lyndon_factorization.html#problems","title":"Problems","text":"<ul> <li>UVA #719 - Glass Beads</li> </ul>","tags":["Translated"]},{"location":"string/main_lorentz.html","title":"Finding repetitions","text":"<p>Given a string $s$ of length $n$.</p> <p>A repetition is two occurrences of a string in a row. In other words a repetition can be described by a pair of indices $i &lt; j$ such that the substring $s[i \\dots j]$ consists of two identical strings written after each other.</p> <p>The challenge is to find all repetitions in a given string $s$. Or a simplified task: find any repetition or find the longest repetition.</p> <p>The algorithm described here was published in 1982 by Main and Lorentz.</p>","tags":["Translated"]},{"location":"string/main_lorentz.html#example","title":"Example","text":"<p>Consider the repetitions in the following example string:</p> $$acababaee$$ <p>The string contains the following three repetitions:</p> <ul> <li>$s[2 \\dots 5] = abab$</li> <li>$s[3 \\dots 6] = baba$</li> <li>$s[7 \\dots 8] = ee$</li> </ul> <p>Another example:</p> $$abaaba$$ <p>Here there are only two repetitions</p> <ul> <li>$s[0 \\dots 5] = abaaba$</li> <li>$s[2 \\dots 3] = aa$</li> </ul>","tags":["Translated"]},{"location":"string/main_lorentz.html#number-of-repetitions","title":"Number of repetitions","text":"<p>In general there can be up to $O(n^2)$ repetitions in a string of length $n$. An obvious example is a string consisting of $n$ times the same letter, in this case any substring of even length is a repetition. In general any periodic string with a short period will contain a lot of repetitions.</p> <p>On the other hand this fact does not prevent computing the number of repetitions in $O(n \\log n)$ time, because the algorithm can give the repetitions in compressed form, in groups of several pieces at once.</p> <p>There is even the concept, that describes groups of periodic substrings with tuples of size four. It has been proven that we the number of such groups is at most linear with respect to the string length.</p> <p>Also, here are some more interesting results related to the number of repetitions:</p> <ul> <li>The number of primitive repetitions (those whose halves are not repetitions) is at most $O(n \\log n)$.</li> <li>If we encode repetitions with tuples of numbers (called Crochemore triples) $(i,~ p,~ r)$ (where $i$ is the position of the beginning, $p$ the length of the repeating substring, and $r$ the number of repetitions), then all repetitions can be described with $O(n \\log n)$ such triples.</li> <li> <p>Fibonacci strings, defined as </p> $$\\begin{align} t_0 &amp;= a, \\\\\\\\ t_1 &amp;= b, \\\\\\\\ t_i &amp;= t_{i-1} + t_{i-2}, \\end{align}$$ <p>are \"strongly\" periodic. The number of repetitions in the Fibonacci string $f_i$, even in the compressed with Crochemore triples, is $O(f_n \\log f_n)$. The number of primitive repetitions is also $O(f_n \\log f_n)$.</p> </li> </ul>","tags":["Translated"]},{"location":"string/main_lorentz.html#main-lorentz-algorithm","title":"Main-Lorentz algorithm","text":"<p>The idea behind the Main-Lorentz algorithm is divide-and-conquer.</p> <p>It splits the initial string into halves, and computes the number of repetitions that lie completely in each halve by two recursive calls. Then comes the difficult part. The algorithm finds all repetitions starting in the first half and ending in the second half (which we will call crossing repetitions). This is the essential part of the Main-Lorentz algorithm, and we will discuss it in detail here.</p> <p>The complexity of divide-and-conquer algorithms is well researched. The master theorem says, that we will end up with an $O(n \\log n)$ algorithm, if we can compute the crossing repetitions in $O(n)$ time.</p>","tags":["Translated"]},{"location":"string/main_lorentz.html#search-for-crossing-repetitions","title":"Search for crossing repetitions","text":"<p>So we want to find all such repetitions that start in the first half of the string, let's call it $u$, and end in the second half, let's call it $v$:</p> $$s = u + v$$ <p>Their lengths are approximately equal to the length of $s$ divided by two.</p> <p>Consider an arbitrary repetition and look at the middle character (more precisely the first character of the second half of the repetition). I.e. if the repetition is a substring $s[i \\dots j]$, then the middle character is $(i + j + 1) / 2$.</p> <p>We call a repetition left or right depending on which string this character is located - in the string $u$ or in the string $v$. In other words a string is called left, if the majority of it lies in $u$, otherwise we call it right.</p> <p>We will now discuss how to find all left repetitions. Finding all right repetitions can be done in the same way.</p> <p>Let us denote the length of the left repetition by $2l$ (i.e. each half of the repetition has length $l$). Consider the first character of the repetition falling into the string $v$ (it is at position $|u|$ in the string $s$). It coincides with the character $l$ positions before it, let's denote this position $cntr$.</p> <p>We will fixate this position $cntr$, and look for all repetitions at this position $cntr$.</p> <p>For example:</p> $$c ~ \\underset{cntr}{a} ~ c ~ | ~ a ~ d ~ a$$ <p>The vertical lines divides the two halves. Here we fixated the position $cntr = 1$, and at this position we find the repetition $caca$.</p> <p>It is clear, that if we fixate the position $cntr$, we simultaneously fixate the length of the possible repetitions: $l = |u| - cntr$. Once we know how to find these repetitions, we will iterate over all possible values for $cntr$ from $0$ to $|u|-1$, and find all left crossover repetitions of length $l = |u|,~ |u|-1,~ \\dots, 1$.</p>","tags":["Translated"]},{"location":"string/main_lorentz.html#criterion-for-left-crossing-repetitions","title":"Criterion for left crossing repetitions","text":"<p>Now, how can we find all such repetitions for a fixated $cntr$? Keep in mind that there still can be multiple such repetitions.</p> <p>Let's again look at a visualization, this time for the repetition $abcabc$:</p> $$\\overbrace{a}^{l_1} ~ \\overbrace{\\underset{cntr}{b} ~ c}^{l_2} ~ \\overbrace{a}^{l_1} ~ | ~ \\overbrace{b ~ c}^{l_2}$$ <p>Here we denoted the lengths of the two pieces of the repetition with $l_1$ and $l_2$: $l_1$ is the length of the repetition up to the position $cntr-1$, and $l_2$ is the length of the repetition from $cntr$ to the end of the half of the repetition. We have $2l = l_1 + l_2 + l_1 + l_2$ as the total length of the repetition.</p> <p>Let us generate necessary and sufficient conditions for such a repetition at position $cntr$ of length $2l = 2(l_1 + l_2) = 2(|u| - cntr)$:</p> <ul> <li>Let $k_1$ be the largest number such that the first $k_1$ characters before the position $cntr$ coincide with the last $k_1$ characters in the string $u$:</li> </ul> $$ u[cntr - k_1 \\dots cntr - 1] = u[|u| - k_1 \\dots |u| - 1] $$ <ul> <li>Let $k_2$ be the largest number such that the $k_2$ characters starting at position $cntr$ coincide with the first $k_2$ characters in the string $v$:</li> </ul> $$     u[cntr \\dots cntr + k_2 - 1] = v[0 \\dots k_2 - 1] $$ <ul> <li>Then we have a repetition exactly for any pair $(l_1,~ l_2)$ with</li> </ul> $$   \\begin{align}   l_1 &amp;\\le k_1, \\\\\\\\   l_2 &amp;\\le k_2. \\\\\\\\   \\end{align} $$ <p>To summarize:</p> <ul> <li>We fixate a specific position $cntr$.</li> <li>All repetition which we will find now have length $2l = 2(|u| - cntr)$.   There might be multiple such repetitions, they depend on the lengths $l_1$ and $l_2 = l - l_1$.</li> <li>We find $k_1$ and $k_2$ as described above.</li> <li>Then all suitable repetitions are the ones for which the lengths of the pieces $l_1$ and $l_2$ satisfy the conditions:</li> </ul> $$   \\begin{align}   l_1 + l_2 &amp;= l = |u| - cntr \\\\\\\\   l_1 &amp;\\le k_1, \\\\\\\\   l_2 &amp;\\le k_2. \\\\\\\\   \\end{align} $$ <p>Therefore the only remaining part is how we can compute the values $k_1$ and $k_2$ quickly for every position $cntr$. Luckily we can compute them in $O(1)$ using the Z-function:</p> <ul> <li>To can find the value $k_1$ for each position by calculating the Z-function for the string $\\overline{u}$ (i.e. the reversed string $u$).   Then the value $k_1$ for a particular $cntr$ will be equal to the corresponding value of the array of the Z-function.</li> <li>To precompute all values $k_2$, we calculate the Z-function for the string $v + \\# + u$ (i.e. the string $u$ concatenated with the separator character $\\#$ and the string $v$).   Again we just need to look up the corresponding value in the Z-function to get the $k_2$ value.</li> </ul> <p>So this is enough to find all left crossing repetitions.</p>","tags":["Translated"]},{"location":"string/main_lorentz.html#right-crossing-repetitions","title":"Right crossing repetitions","text":"<p>For computing the right crossing repetitions we act similarly: we define the center $cntr$ as the character corresponding to the last character in the string $u$.</p> <p>Then the length $k_1$ will be defined as the largest number of characters before the position $cntr$ (inclusive) that coincide with the last characters of the string $u$. And the length $k_2$ will be defined as the largest number of characters starting at $cntr + 1$ that coincide with the characters of the string $v$.</p> <p>Thus we can find the values $k_1$ and $k_2$ by computing the Z-function for the strings $\\overline{u} + \\# + \\overline{v}$ and $v$.</p> <p>After that we can find the repetitions by looking at all positions $cntr$, and use the same criterion as we had for left crossing repetitions.</p>","tags":["Translated"]},{"location":"string/main_lorentz.html#implementation","title":"Implementation","text":"<p>The implementation of the Main-Lorentz algorithm finds all repetitions in form of peculiar tuples of size four: $(cntr,~ l,~ k_1,~ k_2)$ in $O(n \\log n)$ time. If you only want to find the number of repetitions in a string, or only want to find the longest repetition in a string, this information is enough and the runtime will still be $O(n \\log n)$.</p> <p>Notice that if you want to expand these tuples to get the starting and end position of each repetition, then the runtime will be the runtime will be $O(n^2)$ (remember that there can be $O(n^2)$ repetitions). In this implementation we will do so, and store all found repetition in a vector of pairs of start and end indices.</p> <pre><code>vector&lt;int&gt; z_function(string const&amp; s) {\n    int n = s.size();\n    vector&lt;int&gt; z(n);\n    for (int i = 1, l = 0, r = 0; i &lt; n; i++) {\n        if (i &lt;= r)\n            z[i] = min(r-i+1, z[i-l]);\n        while (i + z[i] &lt; n &amp;&amp; s[z[i]] == s[i+z[i]])\n            z[i]++;\n        if (i + z[i] - 1 &gt; r) {\n            l = i;\n            r = i + z[i] - 1;\n        }\n    }\n    return z;\n}\n\nint get_z(vector&lt;int&gt; const&amp; z, int i) {\n    if (0 &lt;= i &amp;&amp; i &lt; (int)z.size())\n        return z[i];\n    else\n        return 0;\n}\n\nvector&lt;pair&lt;int, int&gt;&gt; repetitions;\n\nvoid convert_to_repetitions(int shift, bool left, int cntr, int l, int k1, int k2) {\n    for (int l1 = max(1, l - k2); l1 &lt;= min(l, k1); l1++) {\n        if (left &amp;&amp; l1 == l) break;\n        int l2 = l - l1;\n        int pos = shift + (left ? cntr - l1 : cntr - l - l1 + 1);\n        repetitions.emplace_back(pos, pos + 2*l - 1);\n    }\n}\n\nvoid find_repetitions(string s, int shift = 0) {\n    int n = s.size();\n    if (n == 1)\n        return;\n\n    int nu = n / 2;\n    int nv = n - nu;\n    string u = s.substr(0, nu);\n    string v = s.substr(nu);\n    string ru(u.rbegin(), u.rend());\n    string rv(v.rbegin(), v.rend());\n\n    find_repetitions(u, shift);\n    find_repetitions(v, shift + nu);\n\n    vector&lt;int&gt; z1 = z_function(ru);\n    vector&lt;int&gt; z2 = z_function(v + '#' + u);\n    vector&lt;int&gt; z3 = z_function(ru + '#' + rv);\n    vector&lt;int&gt; z4 = z_function(v);\n\n    for (int cntr = 0; cntr &lt; n; cntr++) {\n        int l, k1, k2;\n        if (cntr &lt; nu) {\n            l = nu - cntr;\n            k1 = get_z(z1, nu - cntr);\n            k2 = get_z(z2, nv + 1 + cntr);\n        } else {\n            l = cntr - nu + 1;\n            k1 = get_z(z3, nu + 1 + nv - 1 - (cntr - nu));\n            k2 = get_z(z4, (cntr - nu) + 1);\n        }\n        if (k1 + k2 &gt;= l)\n            convert_to_repetitions(shift, cntr &lt; nu, cntr, l, k1, k2);\n    }\n}\n</code></pre>","tags":["Translated"]},{"location":"string/manacher.html","title":"Manacher's Algorithm - Finding all sub-palindromes in $O(N)$","text":"","tags":["Translated"]},{"location":"string/manacher.html#statement","title":"Statement","text":"<p>Given string $s$ with length $n$. Find all the pairs $(i, j)$ such that substring $s[i\\dots j]$ is a palindrome. String $t$ is a palindrome when $t = t_{rev}$ ($t_{rev}$ is a reversed string for $t$).</p>","tags":["Translated"]},{"location":"string/manacher.html#more-precise-statement","title":"More precise statement","text":"<p>In the worst case string might have up to $O(n^2)$ palindromic substrings, and at the first glance it seems that there is no linear algorithm for this problem.</p> <p>But the information about the palindromes can be kept in a compact way: for each position $i$ we will find the number of non-empty palindromes centered at this position.</p> <p>Palindromes with a common center form a contiguous chain, that is if we have a palindrome of length $l$ centered in $i$, we also have palindromes of lengths $l-2$, $l-4$ and so on also centered in $i$. Therefore, we will collect the information about all palindromic substrings in this way.</p> <p>Palindromes of odd and even lengths are accounted for separately as $d_{odd}[i]$ and $d_{even}[i]$. For the palindromes of even length we assume that they're centered in the position $i$ if their two central characters are $s[i]$ and $s[i-1]$.</p> <p>For instance, string $s = abababc$ has three palindromes with odd length with centers in the position $s[3] = b$, i. e. $d_{odd}[3] = 3$:</p> $$a\\ \\overbrace{b\\ a\\ \\underbrace{b}_{s_3}\\ a\\ b}^{d_{odd}[3]=3} c$$ <p>And string $s = cbaabd$ has two palindromes with even length with centers in the position $s[3] = a$, i. e. $d_{even}[3] = 2$:</p> $$c\\ \\overbrace{b\\ a\\ \\underbrace{a}_{s_3}\\ b}^{d_{even}[3]=2} d$$ <p>It's a surprising fact that there is an algorithm, which is simple enough, that calculates these \"palindromity arrays\" $d_{odd}[]$ and $d_{even}[]$ in linear time. The algorithm is described in this article.</p>","tags":["Translated"]},{"location":"string/manacher.html#solution","title":"Solution","text":"<p>In general, this problem has many solutions: with String Hashing it can be solved in $O(n\\cdot \\log n)$, and with Suffix Trees and fast LCA this problem can be solved in $O(n)$.</p> <p>But the method described here is sufficiently simpler and has less hidden constant in time and memory complexity. This algorithm was discovered by Glenn K. Manacher in 1975.</p> <p>Another modern way to solve this problem and to deal with palindromes in general is through the so-called palindromic tree, or eertree.</p>","tags":["Translated"]},{"location":"string/manacher.html#trivial-algorithm","title":"Trivial algorithm","text":"<p>To avoid ambiguities in the further description we denote what \"trivial algorithm\" is.</p> <p>It's the algorithm that does the following. For each center position $i$ it tries to increase the answer by one as long as it's possible, comparing a pair of corresponding characters each time.</p> <p>Such an algorithm is slow, it can calculate the answer only in $O(n^2)$.</p> <p>The implementation of the trivial algorithm is:</p> <pre><code>vector&lt;int&gt; manacher_odd_trivial(string s) {\n    int n = s.size();\n    s = \"$\" + s + \"^\";\n    vector&lt;int&gt; p(n + 2);\n    for(int i = 1; i &lt;= n; i++) {\n        while(s[i - p[i]] == s[i + p[i]]) {\n            p[i]++;\n        }\n    }\n    return vector&lt;int&gt;(begin(p) + 1, end(p) - 1);\n}\n</code></pre> <p>Terminal characters <code>$</code> and <code>^</code> were used to avoid dealing with ends of the string separately.</p>","tags":["Translated"]},{"location":"string/manacher.html#manachers-algorithm","title":"Manacher's algorithm","text":"<p>We describe the algorithm to find all the sub-palindromes with odd length, i. e. to calculate $d_{odd}[]$.</p> <p>For fast calculation we'll maintain the exclusive borders $(l, r)$ of the rightmost found (sub-)palindrome (i. e. the current rightmost (sub-)palindrome is $s[l+1] s[l+2] \\dots s[r-1]$). Initially we set $l = 0, r = 1$, which corresponds to the empty string.</p> <p>So, we want to calculate $d_{odd}[i]$ for the next $i$, and all the previous values in $d_{odd}[]$ have been already calculated. We do the following:</p> <ul> <li> <p>If $i$ is outside the current sub-palindrome, i. e. $i \\geq r$, we'll just launch the trivial algorithm.</p> <p>So we'll increase $d_{odd}[i]$ consecutively and check each time if the current rightmost substring $[i - d_{odd}[i]\\dots i + d_{odd}[i]]$ is a palindrome. When we find the first mismatch or meet the boundaries of $s$, we'll stop. In this case we've finally calculated $d_{odd}[i]$. After this, we must not forget to update $(l, r)$. $r$ should be updated in such a way that it represents the last index of the current rightmost sub-palindrome.</p> </li> <li> <p>Now consider the case when $i \\le r$. We'll try to extract some information from the already calculated values in $d_{odd}[]$. So, let's find the \"mirror\" position of $i$ in the sub-palindrome $(l, r)$, i.e. we'll get the position $j = l + (r - i)$, and we check the value of $d_{odd}[j]$. Because $j$ is the position symmetrical to $i$ with respect to $(l+r)/2$, we can almost always assign $d_{odd}[i] = d_{odd}[j]$. Illustration of this (palindrome around $j$ is actually \"copied\" into the palindrome around $i$):</p> $$ \\ldots\\  \\overbrace{     s_{l+1}\\ \\ldots\\      \\underbrace{         s_{j-d_{odd}[j]+1}\\ \\ldots\\ s_j\\ \\ldots\\ s_{j+d_{odd}[j]-1}\\      }_\\text{palindrome}\\      \\ldots\\      \\underbrace{         s_{i-d_{odd}[j]+1}\\ \\ldots\\ s_i\\ \\ldots\\ s_{i+d_{odd}[j]-1}\\      }_\\text{palindrome}\\      \\ldots\\ s_{r-1}\\  }^\\text{palindrome}\\  \\ldots $$ <p>But there is a tricky case to be handled correctly: when the \"inner\" palindrome reaches the borders of the \"outer\" one, i. e. $j - d_{odd}[j] \\le l$ (or, which is the same, $i + d_{odd}[j] \\ge r$). Because the symmetry outside the \"outer\" palindrome is not guaranteed, just assigning $d_{odd}[i] = d_{odd}[j]$ will be incorrect: we do not have enough data to state that the palindrome in the position $i$ has the same length.</p> <p>Actually, we should restrict the length of our palindrome for now, i. e. assign $d_{odd}[i] = r - i$, to handle such situations correctly. After this we'll run the trivial algorithm which will try to increase $d_{odd}[i]$ while it's possible.</p> <p>Illustration of this case (the palindrome with center $j$ is restricted to fit the \"outer\" palindrome):</p> $$ \\ldots\\  \\overbrace{     \\underbrace{         s_{l+1}\\ \\ldots\\ s_j\\ \\ldots\\ s_{j+(j-l)-1}\\      }_\\text{palindrome}\\      \\ldots\\      \\underbrace{         s_{i-(r-i)+1}\\ \\ldots\\ s_i\\ \\ldots\\ s_{r-1}     }_\\text{palindrome}\\  }^\\text{palindrome}\\  \\underbrace{     \\ldots \\ldots \\ldots \\ldots \\ldots }_\\text{try moving here} $$ <p>It is shown in the illustration that though the palindrome with center $j$ could be larger and go outside the \"outer\" palindrome, but with $i$ as the center we can use only the part that entirely fits into the \"outer\" palindrome. But the answer for the position $i$ ($d_{odd}[i]$) can be much bigger than this part, so next we'll run our trivial algorithm that will try to grow it outside our \"outer\" palindrome, i. e. to the region \"try moving here\".</p> </li> </ul> <p>Again, we should not forget to update the values $(l, r)$ after calculating each $d_{odd}[i]$.</p>","tags":["Translated"]},{"location":"string/manacher.html#complexity-of-manachers-algorithm","title":"Complexity of Manacher's algorithm","text":"<p>At the first glance it's not obvious that this algorithm has linear time complexity, because we often run the naive algorithm while searching the answer for a particular position.</p> <p>However, a more careful analysis shows that the algorithm is linear. In fact, Z-function building algorithm, which looks similar to this algorithm, also works in linear time.</p> <p>We can notice that every iteration of trivial algorithm increases $r$ by one. Also $r$ cannot be decreased during the algorithm. So, trivial algorithm will make $O(n)$ iterations in total.</p> <p>Other parts of Manacher's algorithm work obviously in linear time. Thus, we get $O(n)$ time complexity.</p>","tags":["Translated"]},{"location":"string/manacher.html#implementation-of-manachers-algorithm","title":"Implementation of Manacher's algorithm","text":"<p>For calculating $d_{odd}[]$, we get the following code. Things to note:</p> <ul> <li>$i$ is the index of the center letter of the current palindrome.</li> <li>If $i$ exceeds $r$, $d_{odd}[i]$ is initialized to 0.</li> <li>If $i$ does not exceed $r$, $d_{odd}[i]$ is either initialized to the $d_{odd}[j]$, where $j$ is the mirror position of $i$ in $(l,r)$, or $d_{odd}[i]$ is restricted to the size of the \"outer\" palindrome.</li> <li>The while loop denotes the trivial algorithm. We launch it irrespective of the value of $k$.</li> <li>If the size of palindrome centered at $i$ is $x$, then $d_{odd}[i]$ stores $\\frac{x+1}{2}$.</li> </ul> <pre><code>vector&lt;int&gt; manacher_odd(string s) {\n    int n = s.size();\n    s = \"$\" + s + \"^\";\n    vector&lt;int&gt; p(n + 2);\n    int l = 0, r = 1;\n    for(int i = 1; i &lt;= n; i++) {\n        p[i] = min(r - i, p[l + (r - i)]);\n        while(s[i - p[i]] == s[i + p[i]]) {\n            p[i]++;\n        }\n        if(i + p[i] &gt; r) {\n            l = i - p[i], r = i + p[i];\n        }\n    }\n    return vector&lt;int&gt;(begin(p) + 1, end(p) - 1);\n}\n</code></pre>","tags":["Translated"]},{"location":"string/manacher.html#working-with-parities","title":"Working with parities","text":"<p>Although it is possible to implement Manacher's algorithm for odd and even lengths separately, the implementation of the version for even lengths is often deemed more difficult, as it is less natural and easily leads to off-by-one errors.</p> <p>To mitigate this, it is possible to reduce the whole problem to the case when we only deal with the palindromes of odd length. To do this, we can put an additional <code>#</code> character between each letter in the string and also in the beginning and the end of the string:</p> $$abcbcba \\to \\#a\\#b\\#c\\#b\\#c\\#b\\#a\\#,$$ $$d = [1,2,1,2,1,4,1,8,1,4,1,2,1,2,1].$$ <p>As you can see, $d[2i]=2 d_{even}[i]+1$ and $d[2i+1]=2 d_{odd}[i]$ where $d$ denotes the Manacher array for odd-length palindromes in <code>#</code>-joined string, while $d_{odd}$ and $d_{even}$ correspond to the arrays defined above in the initial string.</p> <p>Indeed, <code>#</code> characters do not affect the odd-length palindromes, which are still centered in the initial string's characters, but now even-length palindromes of the initial string are odd-length palindromes of the new string centered in <code>#</code> characters.</p> <p>Note that $d[2i]$ and $d[2i+1]$ are essentially the increased by $1$ lengths of the largest odd- and even-length palindromes centered in $i$ correspondingly.</p> <p>The reduction is implemented in the following way:</p> <pre><code>vector&lt;int&gt; manacher(string s) {\n    string t;\n    for(auto c: s) {\n        t += string(\"#\") + c;\n    }\n    auto res = manacher_odd(t + \"#\");\n    return vector&lt;int&gt;(begin(res) + 1, end(res) - 1);\n}\n</code></pre> <p>For simplicity, splitting the array into $d_{odd}$ and $d_{even}$ as well as their explicit calculation is omitted.</p>","tags":["Translated"]},{"location":"string/manacher.html#problems","title":"Problems","text":"<ul> <li>Library Checker - Enumerate Palindromes</li> <li>Longest Palindrome</li> <li>UVA 11475 - Extend to Palindrome</li> <li>GYM - (Q) QueryreuQ</li> <li>CF - Prefix-Suffix Palindrome</li> <li>SPOJ - Number of Palindromes</li> <li>Kattis - Palindromes</li> </ul>","tags":["Translated"]},{"location":"string/prefix-function.html","title":"Prefix function. Knuth\u2013Morris\u2013Pratt algorithm","text":"","tags":["Translated"]},{"location":"string/prefix-function.html#prefix-function-definition","title":"Prefix function definition","text":"<p>You are given a string $s$ of length $n$. The prefix function for this string is defined as an array $\\pi$ of length $n$, where $\\pi[i]$ is the length of the longest proper prefix of the substring $s[0 \\dots i]$ which is also a suffix of this substring. A proper prefix of a string is a prefix that is not equal to the string itself. By definition, $\\pi[0] = 0$.</p> <p>Mathematically the definition of the prefix function can be written as follows:</p> $$\\pi[i] = \\max_ {k = 0 \\dots i} \\{k : s[0 \\dots k-1] = s[i-(k-1) \\dots i] \\}$$ <p>For example, prefix function of string \"abcabcd\" is $[0, 0, 0, 1, 2, 3, 0]$, and prefix function of string \"aabaaab\" is $[0, 1, 0, 1, 2, 2, 3]$.</p>","tags":["Translated"]},{"location":"string/prefix-function.html#trivial-algorithm","title":"Trivial Algorithm","text":"<p>An algorithm which follows the definition of prefix function exactly is the following:</p> <pre><code>vector&lt;int&gt; prefix_function(string s) {\n    int n = (int)s.length();\n    vector&lt;int&gt; pi(n);\n    for (int i = 0; i &lt; n; i++)\n        for (int k = 0; k &lt;= i; k++)\n            if (s.substr(0, k) == s.substr(i-k+1, k))\n                pi[i] = k;\n    return pi;\n}\n</code></pre> <p>It is easy to see that its complexity is $O(n^3)$, which has room for improvement.</p>","tags":["Translated"]},{"location":"string/prefix-function.html#efficient-algorithm","title":"Efficient Algorithm","text":"<p>This algorithm was proposed by Knuth and Pratt and independently from them by Morris in 1977.  It was used as the main function of a substring search algorithm.</p>","tags":["Translated"]},{"location":"string/prefix-function.html#first-optimization","title":"First optimization","text":"<p>The first important observation is, that the values of the prefix function can only increase by at most one.</p> <p>Indeed, otherwise, if $\\pi[i + 1] \\gt \\pi[i] + 1$, then we can take this suffix ending in position $i + 1$ with the length $\\pi[i + 1]$ and remove the last character from it. We end up with a suffix ending in position $i$ with the length $\\pi[i + 1] - 1$, which is better than $\\pi[i]$, i.e. we get a contradiction.</p> <p>The following illustration shows this contradiction. The longest proper suffix at position $i$ that also is a prefix is of length $2$, and at position $i+1$ it is of length $4$. Therefore the string $s_0 ~ s_1 ~ s_2 ~ s_3$ is equal to the string $s_{i-2} ~ s_{i-1} ~ s_i ~ s_{i+1}$, which means that also the strings $s_0 ~ s_1 ~ s_2$ and $s_{i-2} ~ s_{i-1} ~ s_i$ are equal, therefore $\\pi[i]$ has to be $3$.</p> $$\\underbrace{\\overbrace{s_0 ~ s_1}^{\\pi[i] = 2} ~ s_2 ~ s_3}_{\\pi[i+1] = 4} ~ \\dots ~ \\underbrace{s_{i-2} ~ \\overbrace{s_{i-1} ~ s_{i}}^{\\pi[i] = 2} ~ s_{i+1}}_{\\pi[i+1] = 4}$$ <p>Thus when moving to the next position, the value of the prefix function can either increase by one, stay the same, or decrease by some amount. This fact already allows us to reduce the complexity of the algorithm to $O(n^2)$, because in one step the prefix function can grow at most by one. In total the function can grow at most $n$ steps, and therefore also only can decrease a total of $n$ steps. This means we only have to perform $O(n)$ string comparisons, and reach the complexity $O(n^2)$.</p>","tags":["Translated"]},{"location":"string/prefix-function.html#second-optimization","title":"Second optimization","text":"<p>Let's go further, we want to get rid of the string comparisons. To accomplish this, we have to use all the information computed in the previous steps.</p> <p>So let us compute the value of the prefix function $\\pi$ for $i + 1$. If $s[i+1] = s[\\pi[i]]$, then we can say with certainty that $\\pi[i+1] = \\pi[i] + 1$, since we already know that the suffix at position $i$ of length $\\pi[i]$ is equal to the prefix of length $\\pi[i]$. This is illustrated again with an example.</p> $$\\underbrace{\\overbrace{s_0 ~ s_1 ~ s_2}^{\\pi[i]} ~ \\overbrace{s_3}^{s_3 = s_{i+1}}}_{\\pi[i+1] = \\pi[i] + 1} ~ \\dots ~ \\underbrace{\\overbrace{s_{i-2} ~ s_{i-1} ~ s_{i}}^{\\pi[i]} ~ \\overbrace{s_{i+1}}^{s_3 = s_{i + 1}}}_{\\pi[i+1] = \\pi[i] + 1}$$ <p>If this is not the case, $s[i+1] \\neq s[\\pi[i]]$, then we need to try a shorter string. In order to speed things up, we would like to immediately move to the longest length $j \\lt \\pi[i]$, such that the prefix property in the position $i$ holds, i.e. $s[0 \\dots j-1] = s[i-j+1 \\dots i]$:</p> $$\\overbrace{\\underbrace{s_0 ~ s_1}_j ~ s_2 ~ s_3}^{\\pi[i]} ~ \\dots ~ \\overbrace{s_{i-3} ~ s_{i-2} ~ \\underbrace{s_{i-1} ~ s_{i}}_j}^{\\pi[i]} ~ s_{i+1}$$ <p>Indeed, if we find such a length $j$, then we again only need to compare the characters $s[i+1]$ and $s[j]$. If they are equal, then we can assign $\\pi[i+1] = j + 1$. Otherwise we will need to find the largest value smaller than $j$, for which the prefix property holds, and so on. It can happen that this goes until $j = 0$. If then $s[i+1] = s[0]$, we assign $\\pi[i+1] = 1$, and $\\pi[i+1] = 0$ otherwise.</p> <p>So we already have a general scheme of the algorithm. The only question left is how do we effectively find the lengths for $j$. Let's recap: for the current length $j$ at the position $i$ for which the prefix property holds, i.e. $s[0 \\dots j-1] = s[i-j+1 \\dots i]$, we want to find the greatest $k \\lt j$, for which the prefix property holds.</p> $$\\overbrace{\\underbrace{s_0 ~ s_1}_k ~ s_2 ~ s_3}^j ~ \\dots ~ \\overbrace{s_{i-3} ~ s_{i-2} ~ \\underbrace{s_{i-1} ~ s_{i}}_k}^j ~s_{i+1}$$ <p>The illustration shows, that this has to be the value of $\\pi[j-1]$, which we already calculated earlier.</p>","tags":["Translated"]},{"location":"string/prefix-function.html#final-algorithm","title":"Final algorithm","text":"<p>So we finally can build an algorithm that doesn't perform any string comparisons and only performs $O(n)$ actions.</p> <p>Here is the final procedure:</p> <ul> <li>We compute the prefix values $\\pi[i]$ in a loop by iterating from $i = 1$ to $i = n-1$ ($\\pi[0]$ just gets assigned with $0$).</li> <li>To calculate the current value $\\pi[i]$ we set the variable $j$ denoting the length of the best suffix for $i-1$. Initially $j = \\pi[i-1]$.</li> <li>Test if the suffix of length $j+1$ is also a prefix by comparing $s[j]$ and $s[i]$. If they are equal then we assign $\\pi[i] = j + 1$, otherwise we reduce $j$ to $\\pi[j-1]$ and repeat this step.</li> <li>If we have reached the length $j = 0$ and still don't have a match, then we assign $\\pi[i] = 0$ and go to the next index $i + 1$.</li> </ul>","tags":["Translated"]},{"location":"string/prefix-function.html#implementation","title":"Implementation","text":"<p>The implementation ends up being surprisingly short and expressive.</p> <pre><code>vector&lt;int&gt; prefix_function(string s) {\n    int n = (int)s.length();\n    vector&lt;int&gt; pi(n);\n    for (int i = 1; i &lt; n; i++) {\n        int j = pi[i-1];\n        while (j &gt; 0 &amp;&amp; s[i] != s[j])\n            j = pi[j-1];\n        if (s[i] == s[j])\n            j++;\n        pi[i] = j;\n    }\n    return pi;\n}\n</code></pre> <p>This is an online algorithm, i.e. it processes the data as it arrives - for example, you can read the string characters one by one and process them immediately, finding the value of prefix function for each next character. The algorithm still requires storing the string itself and the previously calculated values of prefix function, but if we know beforehand the maximum value $M$ the prefix function can take on the string, we can store only $M+1$ first characters of the string and the same number of values of the prefix function.</p>","tags":["Translated"]},{"location":"string/prefix-function.html#applications","title":"Applications","text":"","tags":["Translated"]},{"location":"string/prefix-function.html#search-for-a-substring-in-a-string-the-knuth-morris-pratt-algorithm","title":"Search for a substring in a string. The Knuth-Morris-Pratt algorithm","text":"<p>The task is the classical application of the prefix function.</p> <p>Given a text $t$ and a string $s$, we want to find and display the positions of all occurrences of the string $s$ in the text $t$.</p> <p>For convenience we denote with $n$ the length of the string s and with $m$ the length of the text $t$.</p> <p>We generate the string $s + \\# + t$, where $\\#$ is a separator that appears neither in $s$ nor in $t$. Let us calculate the prefix function for this string. Now think about the meaning of the values of the prefix function, except for the first $n + 1$ entries (which belong to the string $s$ and the separator). By definition the value $\\pi[i]$ shows the longest length of a substring ending in position $i$ that coincides with the prefix. But in our case this is nothing more than the largest block that coincides with $s$ and ends at position $i$. This length cannot be bigger than $n$ due to the separator. But if equality $\\pi[i] = n$ is achieved, then it means that the string $s$ appears completely in at this position, i.e. it ends at position $i$. Just do not forget that the positions are indexed in the string $s + \\# + t$.</p> <p>Thus if at some position $i$ we have $\\pi[i] = n$, then at the position $i - (n + 1) - n + 1 = i - 2n$ in the string $t$ the string $s$ appears.</p> <p>As already mentioned in the description of the prefix function computation, if we know that the prefix values never exceed a certain value, then we do not need to store the entire string and the entire function, but only its beginning. In our case this means that we only need to store the string $s + \\#$ and the values of the prefix function for it. We can read one character at a time of the string $t$ and calculate the current value of the prefix function.</p> <p>Thus the Knuth-Morris-Pratt algorithm solves the problem in $O(n + m)$ time and $O(n)$ memory.</p>","tags":["Translated"]},{"location":"string/prefix-function.html#counting-the-number-of-occurrences-of-each-prefix","title":"Counting the number of occurrences of each prefix","text":"<p>Here we discuss two problems at once. Given a string $s$ of length $n$. In the first variation of the problem we want to count the number of appearances of each prefix $s[0 \\dots i]$ in the same string. In the second variation of the problem another string $t$ is given and we want to count the number of appearances of each prefix $s[0 \\dots i]$ in $t$.</p> <p>First we solve the first problem. Consider the value of the prefix function $\\pi[i]$ at a position $i$. By definition it means that the prefix of length $\\pi[i]$ of the string $s$ occurs and ends at position $i$, and there is no longer prefix that follows this definition. At the same time shorter prefixes can end at this position. It is not difficult to see, that we have the same question that we already answered when we computed the prefix function itself: Given a prefix of length $j$ that is a suffix ending at position $i$, what is the next smaller prefix $\\lt j$ that is also a suffix ending at position $i$. Thus at the position $i$ ends the prefix of length $\\pi[i]$, the prefix of length $\\pi[\\pi[i] - 1]$, the prefix $\\pi[\\pi[\\pi[i] - 1] - 1]$, and so on, until the index becomes zero. Thus we can compute the answer in the following way.</p> <pre><code>vector&lt;int&gt; ans(n + 1);\nfor (int i = 0; i &lt; n; i++)\n    ans[pi[i]]++;\nfor (int i = n-1; i &gt; 0; i--)\n    ans[pi[i-1]] += ans[i];\nfor (int i = 0; i &lt;= n; i++)\n    ans[i]++;\n</code></pre> <p>Here for each value of the prefix function we first count how many times it occurs in the array $\\pi$, and then compute the final answers: if we know that the length prefix $i$ appears exactly $\\text{ans}[i]$ times, then this number must be added to the number of occurrences of its longest suffix that is also a prefix. At the end we need to add $1$ to each result, since we also need to count the original prefixes also.</p> <p>Now let us consider the second problem. We apply the trick from Knuth-Morris-Pratt: we create the string $s + \\# + t$ and compute its prefix function. The only differences to the first task is, that we are only interested in the prefix values that relate to the string $t$, i.e. $\\pi[i]$ for $i \\ge n + 1$. With those values we can perform the exact same computations as in the first task.</p>","tags":["Translated"]},{"location":"string/prefix-function.html#the-number-of-different-substring-in-a-string","title":"The number of different substring in a string","text":"<p>Given a string $s$ of length $n$. We want to compute the number of different substrings appearing in it.</p> <p>We will solve this problem iteratively. Namely we will learn, knowing the current number of different substrings, how to recompute this count by adding a character to the end.</p> <p>So let $k$ be the current number of different substrings in $s$, and we add the character $c$ to the end of $s$. Obviously some new substrings ending in $c$ will appear. We want to count these new substrings that didn't appear before.</p> <p>We take the string $t = s + c$ and reverse it. Now the task is transformed into computing how many prefixes there are that don't appear anywhere else. If we compute the maximal value of the prefix function $\\pi_{\\text{max}}$ of the reversed string $t$, then the longest prefix that appears in $s$ is $\\pi_{\\text{max}}$ long. Clearly also all prefixes of smaller length appear in it.</p> <p>Therefore the number of new substrings appearing when we add a new character $c$ is $|s| + 1 - \\pi_{\\text{max}}$.</p> <p>So for each character appended we can compute the number of new substrings in $O(n)$ times, which gives a time complexity of $O(n^2)$ in total.</p> <p>It is worth noting, that we can also compute the number of different substrings by appending the characters at the beginning, or by deleting characters from the beginning or the end.</p>","tags":["Translated"]},{"location":"string/prefix-function.html#compressing-a-string","title":"Compressing a string","text":"<p>Given a string $s$ of length $n$. We want to find the shortest \"compressed\" representation of the string, i.e. we want to find a string $t$ of smallest length such that $s$ can be represented as a concatenation of one or more copies of $t$.</p> <p>It is clear, that we only need to find the length of $t$. Knowing the length, the answer to the problem will be the prefix of $s$ with this length.</p> <p>Let us compute the prefix function for $s$. Using the last value of it we define the value $k = n - \\pi[n - 1]$. We will show, that if $k$ divides $n$, then $k$ will be the answer, otherwise there is no effective compression and the answer is $n$.</p> <p>Let $n$ be divisible by $k$. Then the string can be partitioned into blocks of the length $k$. By definition of the prefix function, the prefix of length $n - k$ will be equal with its suffix. But this means that the last block is equal to the block before. And the block before has to be equal to the block before it. And so on. As a result, it turns out that all blocks are equal, therefore we can compress the string $s$ to length $k$.</p> <p>Of course we still need to show that this is actually the optimum. Indeed, if there was a smaller compression than $k$, than the prefix function at the end would be greater than $n - k$. Therefore $k$ is really the answer.</p> <p>Now let us assume that $n$ is not divisible by $k$. We show that this implies that the length of the answer is $n$. We prove it by contradiction. Assuming there exists an answer, and the compression has length $p$ ($p$ divides $n$). Then the last value of the prefix function has to be greater than $n - p$, i.e. the suffix will partially cover the first block. Now consider the second block of the string. Since the prefix is equal with the suffix, and both the prefix and the suffix cover this block and their displacement relative to each other $k$ does not divide the block length $p$ (otherwise $k$ divides $n$), then all the characters of the block have to be identical. But then the string consists of only one character repeated over and over, hence we can compress it to a string of size $1$, which gives $k = 1$, and $k$ divides $n$. Contradiction.</p> $$\\overbrace{s_0 ~ s_1 ~ s_2 ~ s_3}^p ~ \\overbrace{s_4 ~ s_5 ~ s_6 ~ s_7}^p$$ $$s_0 ~ s_1 ~ s_2 ~ \\underbrace{\\overbrace{s_3 ~ s_4 ~ s_5 ~ s_6}^p ~ s_7}_{\\pi[7] = 5}$$ $$s_4 = s_3, ~ s_5 = s_4, ~ s_6 = s_5, ~ s_7 = s_6 ~ \\Rightarrow ~ s_0 = s_1 = s_2 = s_3$$","tags":["Translated"]},{"location":"string/prefix-function.html#building-an-automaton-according-to-the-prefix-function","title":"Building an automaton according to the prefix function","text":"<p>Let's return to the concatenation to the two strings through a separator, i.e. for the strings $s$ and $t$ we compute the prefix function for the string $s + \\# + t$. Obviously, since $\\#$ is a separator, the value of the prefix function will never exceed $|s|$. It follows, that it is sufficient to only store the string $s + \\#$ and the values of the prefix function for it, and we can compute the prefix function for all subsequent character on the fly:</p> $$\\underbrace{s_0 ~ s_1 ~ \\dots ~ s_{n-1} ~ \\#}_{\\text{need to store}} ~ \\underbrace{t_0 ~ t_1 ~ \\dots ~ t_{m-1}}_{\\text{do not need to store}}$$ <p>Indeed, in such a situation, knowing the next character $c \\in t$ and the value of the prefix function of the previous position is enough information to compute the next value of the prefix function, without using any previous characters of the string $t$ and the value of the prefix function in them.</p> <p>In other words, we can construct an automaton (a finite state machine): the state in it is the current value of the prefix function, and the transition from one state to another will be performed via the next character.</p> <p>Thus, even without having the string $t$, we can construct such a transition table $(\\text{old}_\\pi, c) \\rightarrow \\text{new}_\\pi$ using the same algorithm as for calculating the transition table:</p> <pre><code>void compute_automaton(string s, vector&lt;vector&lt;int&gt;&gt;&amp; aut) {\n    s += '#';\n    int n = s.size();\n    vector&lt;int&gt; pi = prefix_function(s);\n    aut.assign(n, vector&lt;int&gt;(26));\n    for (int i = 0; i &lt; n; i++) {\n        for (int c = 0; c &lt; 26; c++) {\n            int j = i;\n            while (j &gt; 0 &amp;&amp; 'a' + c != s[j])\n                j = pi[j-1];\n            if ('a' + c == s[j])\n                j++;\n            aut[i][c] = j;\n        }\n    }\n}\n</code></pre> <p>However in this form the algorithm runs in $O(n^2 26)$ time for the lowercase letters of the alphabet. Note that we can apply dynamic programming and use the already calculated parts of the table. Whenever we go from the value $j$ to the value $\\pi[j-1]$, we actually mean that the transition $(j, c)$ leads to the same state as the transition as $(\\pi[j-1], c)$, and this answer is already accurately computed.</p> <pre><code>void compute_automaton(string s, vector&lt;vector&lt;int&gt;&gt;&amp; aut) {\n    s += '#';\n    int n = s.size();\n    vector&lt;int&gt; pi = prefix_function(s);\n    aut.assign(n, vector&lt;int&gt;(26));\n    for (int i = 0; i &lt; n; i++) {\n        for (int c = 0; c &lt; 26; c++) {\n            if (i &gt; 0 &amp;&amp; 'a' + c != s[i])\n                aut[i][c] = aut[pi[i-1]][c];\n            else\n                aut[i][c] = i + ('a' + c == s[i]);\n        }\n    }\n}\n</code></pre> <p>As a result we construct the automaton in $O(26 n)$ time.</p> <p>When is such a automaton useful? To begin with, remember that we use the prefix function for the string $s + \\# + t$ and its values mostly for a single purpose: find all occurrences of the string $s$ in the string $t$.</p> <p>Therefore the most obvious benefit of this automaton is the acceleration of calculating the prefix function for the string $s + \\# + t$. By building the automaton for $s + \\#$, we no longer need to store the string $s$ or the values of the prefix function in it. All transitions are already computed in the table.</p> <p>But there is a second, less obvious, application. We can use the automaton when the string $t$ is a gigantic string constructed using some rules. This can for instance be the Gray strings, or a string formed by a recursive combination of several short strings from the input.</p> <p>For completeness we will solve such a problem: given a number $k \\le 10^5$ and a string $s$ of length $\\le 10^5$. We have to compute the number of occurrences of $s$ in the $k$-th Gray string. Recall that Gray's strings are define in the following way:</p> $$\\begin{align} g_1 &amp;= \\text{\"a\"}\\\\ g_2 &amp;= \\text{\"aba\"}\\\\ g_3 &amp;= \\text{\"abacaba\"}\\\\ g_4 &amp;= \\text{\"abacabadabacaba\"} \\end{align}$$ <p>In such cases even constructing the string $t$ will be impossible, because of its astronomical length. The $k$-th Gray string is $2^k-1$ characters long. However we can calculate the value of the prefix function at the end of the string effectively, by only knowing the value of the prefix function at the start.</p> <p>In addition to the automaton itself, we also compute values $G[i][j]$ - the value of the automaton after processing the string $g_i$ starting with the state $j$. And additionally we compute values $K[i][j]$ - the number of occurrences of $s$ in $g_i$, before during the processing of $g_i$ starting with the state $j$. Actually $K[i][j]$ is the number of times that the prefix function took the value $|s|$ while performing the operations. The answer to the problem will then be $K[k][0]$.</p> <p>How can we compute these values? First the basic values are $G[0][j] = j$ and $K[0][j] = 0$. And all subsequent values can be calculated from the previous values and using the automaton. To calculate the value for some $i$ we remember that the string $g_i$ consists of $g_{i-1}$, the $i$ character of the alphabet, and $g_{i-1}$. Thus the automaton will go into the state:</p> $$\\text{mid} = \\text{aut}[G[i-1][j]][i]$$ $$G[i][j] = G[i-1][\\text{mid}]$$ <p>The values for $K[i][j]$ can also be easily counted.</p> $$K[i][j] = K[i-1][j] + (\\text{mid} == |s|) + K[i-1][\\text{mid}]$$ <p>So we can solve the problem for Gray strings, and similarly also a huge number of other similar problems. For example the exact same method also solves the following problem: we are given a string $s$ and some patterns $t_i$, each of which is specified as follows: it is a string of ordinary characters, and there might be some recursive insertions of the previous strings of the form $t_k^{\\text{cnt}}$, which means that at this place we have to insert the string $t_k$ $\\text{cnt}$ times. An example of such patterns:</p> $$\\begin{align} t_1 &amp;= \\text{\"abdeca\"}\\\\ t_2 &amp;= \\text{\"abc\"} + t_1^{30} + \\text{\"abd\"}\\\\ t_3 &amp;= t_2^{50} + t_1^{100}\\\\ t_4 &amp;= t_2^{10} + t_3^{100} \\end{align}$$ <p>The recursive substitutions blow the string up, so that their lengths can reach the order of $100^{100}$.</p> <p>We have to find the number of times the string $s$ appears in each of the strings.</p> <p>The problem can be solved in the same way by constructing the automaton of the prefix function, and then we calculate the transitions in for each pattern by using the previous results.</p>","tags":["Translated"]},{"location":"string/prefix-function.html#practice-problems","title":"Practice Problems","text":"<ul> <li>UVA # 455 \"Periodic Strings\"</li> <li>UVA # 11022 \"String Factoring\"</li> <li>UVA # 11452 \"Dancing the Cheeky-Cheeky\"</li> <li>UVA 12604 - Caesar Cipher</li> <li>UVA 12467 - Secret Word</li> <li>UVA 11019 - Matrix Matcher</li> <li>SPOJ - Pattern Find</li> <li>SPOJ - A Needle in the Haystack</li> <li>Codeforces - Anthem of Berland</li> <li>Codeforces - MUH and Cube Walls</li> <li>Codeforces - Prefixes and Suffixes</li> </ul>","tags":["Translated"]},{"location":"string/rabin-karp.html","title":"Rabin-Karp Algorithm for string matching","text":"<p>This algorithm is based on the concept of hashing, so if you are not familiar with string hashing, refer to the string hashing article.</p> <p>This algorithm was authored by Rabin and Karp in 1987.</p> <p>Problem: Given two strings - a pattern $s$ and a text $t$, determine if the pattern appears in the text and if it does, enumerate all its occurrences in $O(|s| + |t|)$ time.</p> <p>Algorithm: Calculate the hash for the pattern $s$. Calculate hash values for all the prefixes of the text $t$. Now, we can compare a substring of length $|s|$ with $s$ in constant time using the calculated hashes. So, compare each substring of length $|s|$ with the pattern. This will take a total of $O(|t|)$ time. Hence the final complexity of the algorithm is $O(|t| + |s|)$: $O(|s|)$ is required for calculating the hash of the pattern and $O(|t|)$ for comparing each substring of length $|s|$ with the pattern.</p>","tags":["Translated"]},{"location":"string/rabin-karp.html#implementation","title":"Implementation","text":"<pre><code>vector&lt;int&gt; rabin_karp(string const&amp; s, string const&amp; t) {\n    const int p = 31; \n    const int m = 1e9 + 9;\n    int S = s.size(), T = t.size();\n\n    vector&lt;long long&gt; p_pow(max(S, T)); \n    p_pow[0] = 1; \n    for (int i = 1; i &lt; (int)p_pow.size(); i++) \n        p_pow[i] = (p_pow[i-1] * p) % m;\n\n    vector&lt;long long&gt; h(T + 1, 0); \n    for (int i = 0; i &lt; T; i++)\n        h[i+1] = (h[i] + (t[i] - 'a' + 1) * p_pow[i]) % m; \n    long long h_s = 0; \n    for (int i = 0; i &lt; S; i++) \n        h_s = (h_s + (s[i] - 'a' + 1) * p_pow[i]) % m; \n\n    vector&lt;int&gt; occurrences;\n    for (int i = 0; i + S - 1 &lt; T; i++) {\n        long long cur_h = (h[i+S] + m - h[i]) % m;\n        if (cur_h == h_s * p_pow[i] % m)\n            occurrences.push_back(i);\n    }\n    return occurrences;\n}\n</code></pre>","tags":["Translated"]},{"location":"string/rabin-karp.html#practice-problems","title":"Practice Problems","text":"<ul> <li>SPOJ - Pattern Find</li> <li>Codeforces - Good Substrings</li> <li>Codeforces - Palindromic characteristics</li> <li>Leetcode - Longest Duplicate Substring</li> </ul>","tags":["Translated"]},{"location":"string/string-hashing.html","title":"String Hashing","text":"<p>Hashing algorithms are helpful in solving a lot of problems.</p> <p>We want to solve the problem of comparing strings efficiently. The brute force way of doing so is just to compare the letters of both strings, which has a time complexity of $O(\\min(n_1, n_2))$ if $n_1$ and $n_2$ are the sizes of the two strings. We want to do better. The idea behind the string hashing is the following: we map each string into an integer and compare those instead of the strings. Doing this allows us to reduce the execution time of the string comparison to $O(1)$.</p> <p>For the conversion, we need a so-called hash function. The goal of it is to convert a string into an integer, the so-called hash of the string. The following condition has to hold: if two strings $s$ and $t$ are equal ($s = t$), then their hashes also have to be equal ($\\text{hash}(s) = \\text{hash}(t)$). Otherwise, we will not be able to compare strings.</p> <p>Notice, the opposite direction doesn't have to hold. If the hashes are equal ($\\text{hash}(s) = \\text{hash}(t)$), then the strings do not necessarily have to be equal. E.g. a valid hash function would be simply $\\text{hash}(s) = 0$ for each $s$. Now, this is just a stupid example, because this function will be completely useless, but it is a valid hash function. The reason why the opposite direction doesn't have to hold, is because there are exponentially many strings. If we only want this hash function to distinguish between all strings consisting of lowercase characters of length smaller than 15, then already the hash wouldn't fit into a 64-bit integer (e.g. unsigned long long) any more, because there are so many of them. And of course, we don't want to compare arbitrary long integers, because this will also have the complexity $O(n)$.</p> <p>So usually we want the hash function to map strings onto numbers of a fixed range $[0, m)$, then comparing strings is just a comparison of two integers with a fixed length. And of course, we want $\\text{hash}(s) \\neq \\text{hash}(t)$ to be very likely if $s \\neq t$.</p> <p>That's the important part that you have to keep in mind. Using hashing will not be 100% deterministically correct, because two complete different strings might have the same hash (the hashes collide). However, in a wide majority of tasks, this can be safely ignored as the probability of the hashes of two different strings colliding is still very small. And we will discuss some techniques in this article how to keep the probability of collisions very low.</p>","tags":["Translated"]},{"location":"string/string-hashing.html#calculation-of-the-hash-of-a-string","title":"Calculation of the hash of a string","text":"<p>The good and widely used way to define the hash of a string $s$ of length $n$ is</p> $$\\begin{align} \\text{hash}(s) &amp;= s[0] + s[1] \\cdot p + s[2] \\cdot p^2 + ... + s[n-1] \\cdot p^{n-1} \\mod m \\\\ &amp;= \\sum_{i=0}^{n-1} s[i] \\cdot p^i \\mod m, \\end{align}$$ <p>where $p$ and $m$ are some chosen, positive numbers. It is called a polynomial rolling hash function.</p> <p>It is reasonable to make $p$ a prime number roughly equal to the number of characters in the input alphabet. For example, if the input is composed of only lowercase letters of the English alphabet, $p = 31$ is a good choice. If the input may contain both uppercase and lowercase letters, then $p = 53$ is a possible choice. The code in this article will use $p = 31$.</p> <p>Obviously $m$ should be a large number since the probability of two random strings colliding is about $\\approx \\frac{1}{m}$. Sometimes $m = 2^{64}$ is chosen, since then the integer overflows of 64-bit integers work exactly like the modulo operation. However, there exists a method, which generates colliding strings (which work independently from the choice of $p$). So in practice, $m = 2^{64}$ is not recommended. A good choice for $m$ is some large prime number. The code in this article will just use $m = 10^9+9$. This is a large number, but still small enough so that we can perform multiplication of two values using 64-bit integers.</p> <p>Here is an example of calculating the hash of a string $s$, which contains only lowercase letters. We convert each character of $s$ to an integer. Here we use the conversion $a \\rightarrow 1$, $b \\rightarrow 2$, $\\dots$, $z \\rightarrow 26$. Converting $a \\rightarrow 0$ is not a good idea, because then the hashes of the strings $a$, $aa$, $aaa$, $\\dots$ all evaluate to $0$.</p> <pre><code>long long compute_hash(string const&amp; s) {\n    const int p = 31;\n    const int m = 1e9 + 9;\n    long long hash_value = 0;\n    long long p_pow = 1;\n    for (char c : s) {\n        hash_value = (hash_value + (c - 'a' + 1) * p_pow) % m;\n        p_pow = (p_pow * p) % m;\n    }\n    return hash_value;\n}\n</code></pre> <p>Precomputing the powers of $p$ might give a performance boost.</p>","tags":["Translated"]},{"location":"string/string-hashing.html#example-tasks","title":"Example tasks","text":"","tags":["Translated"]},{"location":"string/string-hashing.html#search-for-duplicate-strings-in-an-array-of-strings","title":"Search for duplicate strings in an array of strings","text":"<p>Problem: Given a list of $n$ strings $s_i$, each no longer than $m$ characters, find all the duplicate strings and divide them into groups.</p> <p>From the obvious algorithm involving sorting the strings, we would get a time complexity of $O(n m \\log n)$ where the sorting requires $O(n \\log n)$ comparisons and each comparison take $O(m)$ time. However, by using hashes, we reduce the comparison time to $O(1)$, giving us an algorithm that runs in $O(n m + n \\log n)$ time.</p> <p>We calculate the hash for each string, sort the hashes together with the indices, and then group the indices by identical hashes.</p> <pre><code>vector&lt;vector&lt;int&gt;&gt; group_identical_strings(vector&lt;string&gt; const&amp; s) {\n    int n = s.size();\n    vector&lt;pair&lt;long long, int&gt;&gt; hashes(n);\n    for (int i = 0; i &lt; n; i++)\n        hashes[i] = {compute_hash(s[i]), i};\n\n    sort(hashes.begin(), hashes.end());\n\n    vector&lt;vector&lt;int&gt;&gt; groups;\n    for (int i = 0; i &lt; n; i++) {\n        if (i == 0 || hashes[i].first != hashes[i-1].first)\n            groups.emplace_back();\n        groups.back().push_back(hashes[i].second);\n    }\n    return groups;\n}\n</code></pre>","tags":["Translated"]},{"location":"string/string-hashing.html#fast-hash-calculation-of-substrings-of-given-string","title":"Fast hash calculation of substrings of given string","text":"<p>Problem: Given a string $s$ and indices $i$ and $j$, find the hash of the substring $s [i \\dots j]$.</p> <p>By definition, we have:</p> $$\\text{hash}(s[i \\dots j]) = \\sum_{k = i}^j s[k] \\cdot p^{k-i} \\mod m$$ <p>Multiplying by $p^i$ gives:</p> $$\\begin{align} \\text{hash}(s[i \\dots j]) \\cdot p^i &amp;= \\sum_{k = i}^j s[k] \\cdot p^k \\mod m \\\\ &amp;= \\text{hash}(s[0 \\dots j]) - \\text{hash}(s[0 \\dots i-1]) \\mod m \\end{align}$$ <p>So by knowing the hash value of each prefix of the string $s$, we can compute the hash of any substring directly using this formula. The only problem that we face in calculating it is that we must be able to divide $\\text{hash}(s[0 \\dots j]) - \\text{hash}(s[0 \\dots i-1])$ by $p^i$. Therefore we need to find the modular multiplicative inverse of $p^i$ and then perform multiplication with this inverse. We can precompute the inverse of every $p^i$, which allows computing the hash of any substring of $s$ in $O(1)$ time.</p> <p>However, there does exist an easier way. In most cases, rather than calculating the hashes of substring exactly, it is enough to compute the hash multiplied by some power of $p$. Suppose we have two hashes of two substrings, one multiplied by $p^i$ and the other by $p^j$. If $i &lt; j$ then we multiply the first hash by $p^{j-i}$, otherwise, we multiply the second hash by $p^{i-j}$. By doing this, we get both the hashes multiplied by the same power of $p$ (which is the maximum of $i$ and $j$) and now these hashes can be compared easily with no need for any division.</p>","tags":["Translated"]},{"location":"string/string-hashing.html#applications-of-hashing","title":"Applications of Hashing","text":"<p>Here are some typical applications of Hashing:</p> <ul> <li>Rabin-Karp algorithm for pattern matching in a string in $O(n)$ time</li> <li>Calculating the number of different substrings of a string in $O(n^2)$ (see below)</li> <li>Calculating the number of palindromic substrings in a string.</li> </ul>","tags":["Translated"]},{"location":"string/string-hashing.html#determine-the-number-of-different-substrings-in-a-string","title":"Determine the number of different substrings in a string","text":"<p>Problem: Given a string $s$ of length $n$, consisting only of lowercase English letters, find the number of different substrings in this string.</p> <p>To solve this problem, we iterate over all substring lengths $l = 1 \\dots n$. For every substring length $l$ we construct an array of hashes of all substrings of length $l$ multiplied by the same power of $p$. The number of different elements in the array is equal to the number of distinct substrings of length $l$ in the string. This number is added to the final answer.</p> <p>For convenience, we will use $h[i]$ as the hash of the prefix with $i$ characters, and define $h[0] = 0$.</p> <pre><code>int count_unique_substrings(string const&amp; s) {\n    int n = s.size();\n\n    const int p = 31;\n    const int m = 1e9 + 9;\n    vector&lt;long long&gt; p_pow(n);\n    p_pow[0] = 1;\n    for (int i = 1; i &lt; n; i++)\n        p_pow[i] = (p_pow[i-1] * p) % m;\n\n    vector&lt;long long&gt; h(n + 1, 0);\n    for (int i = 0; i &lt; n; i++)\n        h[i+1] = (h[i] + (s[i] - 'a' + 1) * p_pow[i]) % m;\n\n    int cnt = 0;\n    for (int l = 1; l &lt;= n; l++) {\n        unordered_set&lt;long long&gt; hs;\n        for (int i = 0; i &lt;= n - l; i++) {\n            long long cur_h = (h[i + l] + m - h[i]) % m;\n            cur_h = (cur_h * p_pow[n-i-1]) % m;\n            hs.insert(cur_h);\n        }\n        cnt += hs.size();\n    }\n    return cnt;\n}\n</code></pre> <p>Notice, that $O(n^2)$ is not the best possible time complexity for this problem. A solution with $O(n \\log n)$ is described in the article about Suffix Arrays, and it's even possible to compute it in $O(n)$ using a Suffix Tree or a Suffix Automaton.</p>","tags":["Translated"]},{"location":"string/string-hashing.html#improve-no-collision-probability","title":"Improve no-collision probability","text":"<p>Quite often the above mentioned polynomial hash is good enough, and no collisions will happen during tests. Remember, the probability that collision happens is only $\\approx \\frac{1}{m}$. For $m = 10^9 + 9$ the probability is $\\approx 10^{-9}$ which is quite low. But notice, that we only did one comparison. What if we compared a string $s$ with $10^6$ different strings. The probability that at least one collision happens is now $\\approx 10^{-3}$. And if we want to compare $10^6$ different strings with each other (e.g. by counting how many unique strings exists), then the probability of at least one collision happening is already $\\approx 1$. It is pretty much guaranteed that this task will end with a collision and returns the wrong result.</p> <p>There is a really easy trick to get better probabilities. We can just compute two different hashes for each string (by using two different $p$, and/or different $m$, and compare these pairs instead. If $m$ is about $10^9$ for each of the two hash functions than this is more or less equivalent as having one hash function with $m \\approx 10^{18}$. When comparing $10^6$ strings with each other, the probability that at least one collision happens is now reduced to $\\approx 10^{-6}$.</p>","tags":["Translated"]},{"location":"string/string-hashing.html#practice-problems","title":"Practice Problems","text":"<ul> <li>Good Substrings - Codeforces</li> <li>A Needle in the Haystack - SPOJ</li> <li>String Hashing - Kattis</li> <li>Double Profiles - Codeforces</li> <li>Password - Codeforces</li> <li>SUB_PROB - SPOJ</li> <li>INSQ15_A</li> <li>SPOJ - Ada and Spring Cleaning</li> <li>GYM - Text Editor</li> <li>12012 - Detection of Extraterrestrial</li> <li>Codeforces - Games on a CD</li> <li>UVA 11855 - Buzzwords</li> <li>Codeforces - Santa Claus and a Palindrome</li> <li>Codeforces - String Compression</li> <li>Codeforces - Palindromic Characteristics</li> <li>SPOJ - Test</li> <li>Codeforces - Palindrome Degree</li> <li>Codeforces - Deletion of Repeats</li> <li>HackerRank - Gift Boxes</li> </ul>","tags":["Translated"]},{"location":"string/suffix-array.html","title":"Suffix Array","text":"","tags":["Translated"]},{"location":"string/suffix-array.html#definition","title":"Definition","text":"<p>Let $s$ be a string of length $n$. The $i$-th suffix of $s$ is the substring $s[i \\ldots n - 1]$.</p> <p>A suffix array will contain integers that represent the starting indexes of the all the suffixes of a given string, after the aforementioned suffixes are sorted.</p> <p>As an example look at the string $s = abaab$. All suffixes are as follows</p> $$\\begin{array}{ll} 0. &amp; abaab \\\\ 1. &amp; baab \\\\ 2. &amp; aab \\\\ 3. &amp; ab \\\\ 4. &amp; b \\end{array}$$ <p>After sorting these strings:</p> $$\\begin{array}{ll} 2. &amp; aab \\\\ 3. &amp; ab \\\\ 0. &amp; abaab \\\\ 4. &amp; b \\\\ 1. &amp; baab \\end{array}$$ <p>Therefore the suffix array for $s$ will be $(2,~ 3,~ 0,~ 4,~ 1)$.</p> <p>As a data structure it is widely used in areas such as data compression, bioinformatics and, in general, in any area that deals with strings and string matching problems.</p>","tags":["Translated"]},{"location":"string/suffix-array.html#construction","title":"Construction","text":"","tags":["Translated"]},{"location":"string/suffix-array.html#on2-log-n-approach","title":"$O(n^2 \\log n)$ approach","text":"<p>This is the most naive approach. Get all the suffixes and sort them using quicksort or mergesort and simultaneously retain their original indices. Sorting uses $O(n \\log n)$ comparisons, and since comparing two strings will additionally take $O(n)$ time, we get the final complexity of $O(n^2 \\log n)$.</p>","tags":["Translated"]},{"location":"string/suffix-array.html#on-log-n-approach","title":"$O(n \\log n)$ approach","text":"<p>Strictly speaking the following algorithm will not sort the suffixes, but rather the cyclic shifts of a string. However we can very easily derive an algorithm for sorting suffixes from it: it is enough to append an arbitrary character to the end of the string which is smaller than any character from the string. It is common to use the symbol $. Then the order of the sorted cyclic shifts is equivalent to the order of the sorted suffixes, as demonstrated here with the string $dabbb$.</p> $$\\begin{array}{lll} 1. &amp; abbb\\$d &amp; abbb \\\\ 4. &amp; b\\$dabb &amp; b \\\\ 3. &amp; bb\\$dab &amp; bb \\\\ 2. &amp; bbb\\$da &amp; bbb \\\\ 0. &amp; dabbb\\$ &amp; dabbb \\end{array}$$ <p>Since we are going to sort cyclic shifts, we will consider cyclic substrings. We will use the notation $s[i \\dots j]$ for the substring of $s$ even if $i &gt; j$. In this case we actually mean the string $s[i \\dots n-1] + s[0 \\dots j]$. In addition we will take all indices modulo the length of $s$, and will omit the modulo operation for simplicity.</p> <p>The algorithm we discuss will perform $\\lceil \\log n \\rceil + 1$ iterations. In the $k$-th iteration ($k = 0 \\dots \\lceil \\log n \\rceil$) we sort the $n$ cyclic substrings of $s$ of length $2^k$. After the $\\lceil \\log n \\rceil$-th iteration the substrings of length $2^{\\lceil \\log n \\rceil} \\ge n$ will be sorted, so this is equivalent to sorting the cyclic shifts altogether.</p> <p>In each iteration of the algorithm, in addition to the permutation $p[0 \\dots n-1]$, where $p[i]$ is the index of the $i$-th substring (starting at $i$ and with length $2^k$) in the sorted order, we will also maintain an array $c[0 \\dots n-1]$, where $c[i]$ corresponds to the equivalence class to which the substring belongs. Because some of the substrings will be identical, and the algorithm needs to treat them equally. For convenience the classes will be labeled by numbers started from zero. In addition the numbers $c[i]$ will be assigned in such a way that they preserve information about the order: if one substring is smaller than the other, then it should also have a smaller class label. The number of equivalence classes will be stored in a variable $\\text{classes}$.</p> <p>Let's look at an example. Consider the string $s = aaba$. The cyclic substrings and the corresponding arrays $p[]$ and $c[]$ are given for each iteration:</p> $$\\begin{array}{cccc} 0: &amp; (a,~ a,~ b,~ a) &amp; p = (0,~ 1,~ 3,~ 2) &amp; c = (0,~ 0,~ 1,~ 0)\\\\ 1: &amp; (aa,~ ab,~ ba,~ aa) &amp; p = (0,~ 3,~ 1,~ 2) &amp; c = (0,~ 1,~ 2,~ 0)\\\\ 2: &amp; (aaba,~ abaa,~ baaa,~ aaab) &amp; p = (3,~ 0,~ 1,~ 2) &amp; c = (1,~ 2,~ 3,~ 0)\\\\ \\end{array}$$ <p>It is worth noting that the values of $p[]$ can be different. For example in the $0$-th iteration the array could also be $p = (3,~ 1,~ 0,~ 2)$ or $p = (3,~ 0,~ 1,~ 2)$. All these options permutation the substrings into a sorted order. So they are all valid. At the same time the array $c[]$ is fixed, there can be no ambiguities.</p> <p>Let us now focus on the implementation of the algorithm. We will write a function that takes a string $s$ and returns the permutations of the sorted cyclic shifts.</p> <pre><code>vector&lt;int&gt; sort_cyclic_shifts(string const&amp; s) {\n    int n = s.size();\n    const int alphabet = 256;\n</code></pre> <p>At the beginning (in the $0$-th iteration) we must sort the cyclic substrings of length $1$, that is we have to sort all characters of the string and divide them into equivalence classes (same symbols get assigned to the same class). This can be done trivially, for example, by using counting sort. For each character we count how many times it appears in the string, and then use this information to create the array $p[]$. After that we go through the array $p[]$ and construct $c[]$ by comparing adjacent characters.</p> <pre><code>    vector&lt;int&gt; p(n), c(n), cnt(max(alphabet, n), 0);\n    for (int i = 0; i &lt; n; i++)\n        cnt[s[i]]++;\n    for (int i = 1; i &lt; alphabet; i++)\n        cnt[i] += cnt[i-1];\n    for (int i = 0; i &lt; n; i++)\n        p[--cnt[s[i]]] = i;\n    c[p[0]] = 0;\n    int classes = 1;\n    for (int i = 1; i &lt; n; i++) {\n        if (s[p[i]] != s[p[i-1]])\n            classes++;\n        c[p[i]] = classes - 1;\n    }\n</code></pre> <p>Now we have to talk about the iteration step. Let's assume we have already performed the $k-1$-th step and computed the values of the arrays $p[]$ and $c[]$ for it. We want to compute the values for the $k$-th step in $O(n)$ time. Since we perform this step $O(\\log n)$ times, the complete algorithm will have a time complexity of $O(n \\log n)$.</p> <p>To do this, note that the cyclic substrings of length $2^k$ consists of two substrings of length $2^{k-1}$ which we can compare with each other in $O(1)$ using the information from the previous phase - the values of the equivalence classes $c[]$. Thus, for two substrings of length $2^k$ starting at position $i$ and $j$, all necessary information to compare them is contained in the pairs $(c[i],~ c[i + 2^{k-1}])$ and $(c[j],~ c[j + 2^{k-1}])$.</p> $$\\dots \\overbrace{ \\underbrace{s_i \\dots s_{i+2^{k-1}-1}}_{\\text{length} = 2^{k-1},~ \\text{class} = c[i]} \\quad \\underbrace{s_{i+2^{k-1}} \\dots s_{i+2^k-1}}_{\\text{length} = 2^{k-1},~ \\text{class} = c[i + 2^{k-1}]} }^{\\text{length} = 2^k} \\dots \\overbrace{ \\underbrace{s_j \\dots s_{j+2^{k-1}-1}}_{\\text{length} = 2^{k-1},~ \\text{class} = c[j]} \\quad \\underbrace{s_{j+2^{k-1}} \\dots s_{j+2^k-1}}_{\\text{length} = 2^{k-1},~ \\text{class} = c[j + 2^{k-1}]} }^{\\text{length} = 2^k} \\dots $$ <p>This gives us a very simple solution: sort the substrings of length $2^k$ by these pairs of numbers. This will give us the required order $p[]$. However a normal sort runs in $O(n \\log n)$ time, with which we are not satisfied. This will only give us an algorithm for constructing a suffix array in $O(n \\log^2 n)$ times.</p> <p>How do we quickly perform such a sorting of the pairs? Since the elements of the pairs do not exceed $n$, we can use counting sort again. However sorting pairs with counting sort is not the most efficient. To achieve a better hidden constant in the complexity, we will use another trick.</p> <p>We use here the technique on which radix sort is based: to sort the pairs we first sort them by the second element, and then by the first element (with a stable sort, i.e. sorting without breaking the relative order of equal elements). However the second elements were already sorted in the previous iteration. Thus, in order to sort the pairs by the second elements, we just need to subtract $2^{k-1}$ from the indices in $p[]$ (e.g. if the smallest substring of length $2^{k-1}$ starts at position $i$, then the substring of length $2^k$ with the smallest second half starts at $i - 2^{k-1}$).</p> <p>So only by simple subtractions we can sort the second elements of the pairs in $p[]$. Now we need to perform a stable sort by the first elements. As already mentioned, this can be accomplished with counting sort.</p> <p>The only thing left is to compute the equivalence classes $c[]$, but as before this can be done by simply iterating over the sorted permutation $p[]$ and comparing neighboring pairs.</p> <p>Here is the remaining implementation. We use temporary arrays $pn[]$ and $cn[]$ to store the permutation by the second elements and the new equivalent class indices.</p> <p><pre><code>    vector&lt;int&gt; pn(n), cn(n);\n    for (int h = 0; (1 &lt;&lt; h) &lt; n; ++h) {\n        for (int i = 0; i &lt; n; i++) {\n            pn[i] = p[i] - (1 &lt;&lt; h);\n            if (pn[i] &lt; 0)\n                pn[i] += n;\n        }\n        fill(cnt.begin(), cnt.begin() + classes, 0);\n        for (int i = 0; i &lt; n; i++)\n            cnt[c[pn[i]]]++;\n        for (int i = 1; i &lt; classes; i++)\n            cnt[i] += cnt[i-1];\n        for (int i = n-1; i &gt;= 0; i--)\n            p[--cnt[c[pn[i]]]] = pn[i];\n        cn[p[0]] = 0;\n        classes = 1;\n        for (int i = 1; i &lt; n; i++) {\n            pair&lt;int, int&gt; cur = {c[p[i]], c[(p[i] + (1 &lt;&lt; h)) % n]};\n            pair&lt;int, int&gt; prev = {c[p[i-1]], c[(p[i-1] + (1 &lt;&lt; h)) % n]};\n            if (cur != prev)\n                ++classes;\n            cn[p[i]] = classes - 1;\n        }\n        c.swap(cn);\n    }\n    return p;\n}\n</code></pre> The algorithm requires $O(n \\log n)$ time and $O(n)$ memory. For simplicity we used the complete ASCII range as alphabet.</p> <p>If it is known that the string only contains a subset of characters, e.g. only lowercase letters, then the implementation can be optimized, but the optimization factor would likely be insignificant, as the size of the alphabet only matters on the first iteration. Every other iteration depends on the number of equivalence classes, which may quickly reach $O(n)$ even if initially it was a string over the alphabet of size $2$.</p> <p>Also note, that this algorithm only sorts the cycle shifts. As mentioned at the beginning of this section we can generate the sorted order of the suffixes by appending a character that is smaller than all other characters of the string, and sorting this resulting string by cycle shifts, e.g. by sorting the cycle shifts of $s + \\$$. This will obviously give the suffix array of $s$, however prepended with $|s|$.</p> <pre><code>vector&lt;int&gt; suffix_array_construction(string s) {\n    s += \"$\";\n    vector&lt;int&gt; sorted_shifts = sort_cyclic_shifts(s);\n    sorted_shifts.erase(sorted_shifts.begin());\n    return sorted_shifts;\n}\n</code></pre>","tags":["Translated"]},{"location":"string/suffix-array.html#applications","title":"Applications","text":"","tags":["Translated"]},{"location":"string/suffix-array.html#finding-the-smallest-cyclic-shift","title":"Finding the smallest cyclic shift","text":"<p>The algorithm above sorts all cyclic shifts (without appending a character to the string), and therefore $p[0]$ gives the position of the smallest cyclic shift. </p>","tags":["Translated"]},{"location":"string/suffix-array.html#finding-a-substring-in-a-string","title":"Finding a substring in a string","text":"<p>The task is to find a string $s$ inside some text $t$ online - we know the text $t$ beforehand, but not the string $s$. We can create the suffix array for the text $t$ in $O(|t| \\log |t|)$ time. Now we can look for the substring $s$ in the following way. The occurrence of $s$ must be a prefix of some suffix from $t$. Since we sorted all the suffixes we can perform a binary search for $s$ in $p$. Comparing the current suffix and the substring $s$ within the binary search can be done in $O(|s|)$ time, therefore the complexity for finding the substring is $O(|s| \\log |t|)$. Also notice that if the substring occurs multiple times in $t$, then all occurrences will be next to each other in $p$. Therefore the number of occurrences can be found with a second binary search, and all occurrences can be printed easily.</p>","tags":["Translated"]},{"location":"string/suffix-array.html#comparing-two-substrings-of-a-string","title":"Comparing two substrings of a string","text":"<p>We want to be able to compare two substrings of the same length of a given string $s$ in $O(1)$ time, i.e. checking if the first substring is smaller than the second one.</p> <p>For this we construct the suffix array in $O(|s| \\log |s|)$ time and store all the intermediate results of the equivalence classes $c[]$.</p> <p>Using this information we can compare any two substring whose length is equal to a power of two in O(1): for this it is sufficient to compare the equivalence classes of both substrings. Now we want to generalize this method to substrings of arbitrary length.</p> <p>Let's compare two substrings of length $l$ with the starting indices $i$ and $j$. We find the largest length of a block that is placed inside a substring of this length: the greatest $k$ such that $2^k \\le l$. Then comparing the two substrings can be replaced by comparing two overlapping blocks of length $2^k$: first you need to compare the two blocks starting at $i$ and $j$, and if these are equal then compare the two blocks ending in positions $i + l - 1$ and $j + l - 1$:</p> $$\\dots \\overbrace{\\underbrace{s_i \\dots s_{i+l-2^k} \\dots s_{i+2^k-1}}_{2^k} \\dots s_{i+l-1}}^{\\text{first}} \\dots \\overbrace{\\underbrace{s_j \\dots s_{j+l-2^k} \\dots s_{j+2^k-1}}_{2^k} \\dots s_{j+l-1}}^{\\text{second}} \\dots$$ $$\\dots \\overbrace{s_i \\dots \\underbrace{s_{i+l-2^k} \\dots s_{i+2^k-1} \\dots s_{i+l-1}}_{2^k}}^{\\text{first}} \\dots \\overbrace{s_j \\dots \\underbrace{s_{j+l-2^k} \\dots s_{j+2^k-1} \\dots s_{j+l-1}}_{2^k}}^{\\text{second}} \\dots$$ <p>Here is the implementation of the comparison. Note that it is assumed that the function gets called with the already calculated $k$. $k$ can be computed with $\\lfloor \\log l \\rfloor$, but it is more efficient to precompute all $k$ values for every $l$. See for instance the article about the Sparse Table, which uses a similar idea and computes all $\\log$ values.</p> <pre><code>int compare(int i, int j, int l, int k) {\n    pair&lt;int, int&gt; a = {c[k][i], c[k][(i+l-(1 &lt;&lt; k))%n]};\n    pair&lt;int, int&gt; b = {c[k][j], c[k][(j+l-(1 &lt;&lt; k))%n]};\n    return a == b ? 0 : a &lt; b ? -1 : 1;\n}\n</code></pre>","tags":["Translated"]},{"location":"string/suffix-array.html#longest-common-prefix-of-two-substrings-with-additional-memory","title":"Longest common prefix of two substrings with additional memory","text":"<p>For a given string $s$ we want to compute the longest common prefix (LCP)  of two arbitrary suffixes with position $i$ and $j$.</p> <p>The method described here uses $O(|s| \\log |s|)$ additional memory. A completely different approach that will only use a linear amount of memory is described in the next section.</p> <p>We construct the suffix array in $O(|s| \\log |s|)$ time, and remember the intermediate results of the arrays $c[]$ from each iteration.</p> <p>Let's compute the LCP for two suffixes starting at $i$ and $j$. We can compare any two substrings with a length equal to a power of two in $O(1)$. To do this, we compare the strings by power of twos (from highest to lowest power) and if the substrings of this length are the same, then we add the equal length to the answer and continue checking for the LCP to the right of the equal part, i.e. $i$ and $j$ get added by the current power of two.</p> <pre><code>int lcp(int i, int j) {\n    int ans = 0;\n    for (int k = log_n; k &gt;= 0; k--) {\n        if (c[k][i % n] == c[k][j % n]) {\n            ans += 1 &lt;&lt; k;\n            i += 1 &lt;&lt; k;\n            j += 1 &lt;&lt; k;\n        }\n    }\n    return ans;\n}\n</code></pre> <p>Here <code>log_n</code> denotes a constant that is equal to the logarithm of $n$ in base $2$ rounded down.</p>","tags":["Translated"]},{"location":"string/suffix-array.html#longest-common-prefix-of-two-substrings-without-additional-memory","title":"Longest common prefix of two substrings without additional memory","text":"<p>We have the same task as in the previous section. We have compute the longest common prefix (LCP) for two suffixes of a string $s$.</p> <p>Unlike the previous method this one will only use $O(|s|)$ memory. The result of the preprocessing will be an array (which itself is an important source of information about the string, and therefore also used to solve other tasks). LCP queries can be answered by performing RMQ queries (range minimum queries) in this array, so for different implementations it is possible to achieve logarithmic and even constant query time. </p> <p>The basis for this algorithm is the following idea: we will compute the longest common prefix for each pair of adjacent suffixes in the sorted order. In other words we construct an array $\\text{lcp}[0 \\dots n-2]$, where $\\text{lcp}[i]$ is equal to the length of the longest common prefix of the suffixes starting at $p[i]$ and $p[i+1]$. This array will give us an answer for any two adjacent suffixes of the string. Then the answer for arbitrary two suffixes, not necessarily neighboring ones, can be obtained from this array. In fact, let the request be to compute the LCP of the suffixes $p[i]$ and $p[j]$. Then the answer to this query will be $\\min(lcp[i],~ lcp[i+1],~ \\dots,~ lcp[j-1])$.</p> <p>Thus if we have such an array $\\text{lcp}$, then the problem is reduced to the RMQ, which has many wide number of different solutions with different complexities.</p> <p>So the main task is to build this array $\\text{lcp}$. We will use Kasai's algorithm, which can compute this array in $O(n)$ time.</p> <p>Let's look at two adjacent suffixes in the sorted order (order of the suffix array). Let their starting positions be $i$ and $j$ and their $\\text{lcp}$ equal to $k &gt; 0$. If we remove the first letter of both suffixes - i.e. we take the suffixes $i+1$ and $j+1$ - then it should be obvious that the $\\text{lcp}$ of these two is $k - 1$. However we cannot use this value and write it in the $\\text{lcp}$ array, because these two suffixes might not be next to each other in the sorted order. The suffix $i+1$ will of course be smaller than the suffix $j+1$, but there might be some suffixes between them. However, since we know that the LCP between two suffixes is the minimum value of all transitions, we also know that the LCP between any two pairs in that interval has to be at least $k-1$, especially also between $i+1$ and the next suffix. And possibly it can be bigger.</p> <p>Now we already can implement the algorithm. We will iterate over the suffixes in order of their length. This way we can reuse the last value $k$, since going from suffix $i$ to the suffix $i+1$ is exactly the same as removing the first letter. We will need an additional array $\\text{rank}$, which will give us the position of a suffix in the sorted list of suffixes.</p> <pre><code>vector&lt;int&gt; lcp_construction(string const&amp; s, vector&lt;int&gt; const&amp; p) {\n    int n = s.size();\n    vector&lt;int&gt; rank(n, 0);\n    for (int i = 0; i &lt; n; i++)\n        rank[p[i]] = i;\n\n    int k = 0;\n    vector&lt;int&gt; lcp(n-1, 0);\n    for (int i = 0; i &lt; n; i++) {\n        if (rank[i] == n - 1) {\n            k = 0;\n            continue;\n        }\n        int j = p[rank[i] + 1];\n        while (i + k &lt; n &amp;&amp; j + k &lt; n &amp;&amp; s[i+k] == s[j+k])\n            k++;\n        lcp[rank[i]] = k;\n        if (k)\n            k--;\n    }\n    return lcp;\n}\n</code></pre> <p>It is easy to see, that we decrease $k$ at most $O(n)$ times (each iteration at most once, except for $\\text{rank}[i] == n-1$, where we directly reset it to $0$), and the LCP between two strings is at most $n-1$, we will also increase $k$ only $O(n)$ times. Therefore the algorithm runs in $O(n)$ time.</p>","tags":["Translated"]},{"location":"string/suffix-array.html#number-of-different-substrings","title":"Number of different substrings","text":"<p>We preprocess the string $s$ by computing the suffix array and the LCP array. Using this information we can compute the number of different substrings in the string.</p> <p>To do this, we will think about which new substrings begin at position $p[0]$, then at $p[1]$, etc. In fact we take the suffixes in sorted order and see what prefixes give new substrings. Thus we will not overlook any by accident.</p> <p>Because the suffixes are sorted, it is clear that the current suffix $p[i]$ will give new substrings for all its prefixes, except for the prefixes that coincide with the suffix $p[i-1]$. Thus, all its prefixes except the first $\\text{lcp}[i-1]$ one. Since the length of the current suffix is $n - p[i]$, $n - p[i] - \\text{lcp}[i-1]$ new prefixes start at $p[i]$. Summing over all the suffixes, we get the final answer:</p> $$\\sum_{i=0}^{n-1} (n - p[i]) - \\sum_{i=0}^{n-2} \\text{lcp}[i] = \\frac{n^2 + n}{2} - \\sum_{i=0}^{n-2} \\text{lcp}[i]$$","tags":["Translated"]},{"location":"string/suffix-array.html#practice-problems","title":"Practice Problems","text":"<ul> <li>Uva 760 - DNA Sequencing</li> <li>Uva 1223 - Editor</li> <li>Codechef - Tandem</li> <li>Codechef - Substrings and Repetitions</li> <li>Codechef - Entangled Strings</li> <li>Codeforces - Martian Strings</li> <li>Codeforces - Little Elephant and Strings</li> <li>SPOJ - Ada and Terramorphing</li> <li>SPOJ - Ada and Substring</li> <li>UVA - 1227 - The longest constant gene</li> <li>SPOJ - Longest Common Substring</li> <li>UVA 11512 - GATTACA</li> <li>LA 7502 - Suffixes and Palindromes</li> <li>GYM - Por Costel and the Censorship Committee</li> <li>UVA 1254 - Top 10</li> <li>UVA 12191 - File Recover</li> <li>UVA 12206 - Stammering Aliens</li> <li>Codechef - Jarvis and LCP</li> <li>LA 3943 - Liking's Letter</li> <li>UVA 11107 - Life Forms</li> <li>UVA 12974 - Exquisite Strings</li> <li>UVA 10526 - Intellectual Property</li> <li>UVA 12338 - Anti-Rhyme Pairs</li> <li>UVA 12191 - File Recover</li> <li>SPOJ - Suffix Array</li> <li>LA 4513 - Stammering Aliens</li> <li>SPOJ - LCS2</li> <li>Codeforces - Fake News (hard)</li> <li>SPOJ - Longest Commong Substring</li> <li>SPOJ - Lexicographical Substring Search</li> <li>Codeforces - Forbidden Indices</li> <li>Codeforces - Tricky and Clever Password</li> <li>LA 6856 - Circle of digits</li> </ul>","tags":["Translated"]},{"location":"string/suffix-automaton.html","title":"Suffix Automaton","text":"<p>A suffix automaton is a powerful data structure that allows solving many string-related problems. </p> <p>For example, you can search for all occurrences of one string in another, or count the amount of different substrings of a given string. Both tasks can be solved in linear time with the help of a suffix automaton.</p> <p>Intuitively a suffix automaton can be understood as a compressed form of all substrings of a given string. An impressive fact is, that the suffix automaton contains all this information in a highly compressed form. For a string of length $n$ it only requires $O(n)$ memory. Moreover, it can also be built in $O(n)$ time (if we consider the size $k$ of the alphabet as a constant), otherwise both the memory and the time complexity will be $O(n \\log k)$.</p> <p>The linearity of the size of the suffix automaton was first discovered in 1983 by Blumer et al., and in 1985 the first linear algorithms for the construction was presented by Crochemore and Blumer.</p>","tags":["Translated"]},{"location":"string/suffix-automaton.html#definition-of-a-suffix-automaton","title":"Definition of a suffix automaton","text":"<p>A suffix automaton for a given string $s$ is a minimal DFA (deterministic finite automaton / deterministic finite state machine) that accepts all the suffixes of the string $s$.</p> <p>In other words:</p> <ul> <li>A suffix automaton is an oriented acyclic graph.     The vertices are called states, and the edges are called transitions between states.</li> <li>One of the states $t_0$ is the initial state, and it must be the source of the graph (all other states are reachable from $t_0$).</li> <li>Each transition is labeled with some character.     All transitions originating from a state must have different labels.</li> <li>One or multiple states are marked as terminal states.     If we start from the initial state $t_0$ and move along transitions to a terminal state, then the labels of the passed transitions must spell one of the suffixes of the string $s$.     Each of the suffixes of $s$ must be spellable using a path from $t_0$ to a terminal state.</li> <li>The suffix automaton contains the minimum number of vertices among all automata satisfying the conditions described above.</li> </ul>","tags":["Translated"]},{"location":"string/suffix-automaton.html#substring-property","title":"Substring property","text":"<p>The simplest and most important property of a suffix automaton is, that it contains information about all substrings of the string $s$. Any path starting at the initial state $t_0$, if we write down the labels of the transitions, forms a substring of $s$. And conversely every substring of $s$ corresponds to a certain path starting at $t_0$.</p> <p>In order to simplify the explanations, we will say that the substring corresponds to that path (starting at $t_0$ and the labels spell the substring). And conversely we say that any path corresponds to the string spelled by its labels.</p> <p>One or multiple paths can lead to a state. Thus, we will say that a state corresponds to the set of strings, which correspond to these paths.</p>","tags":["Translated"]},{"location":"string/suffix-automaton.html#examples-of-constructed-suffix-automata","title":"Examples of constructed suffix automata","text":"<p>Here we will show some examples of suffix automata for several simple strings.</p> <p>We will denote the initial state with blue and the terminal states with green.</p> <p>For the string $s =~ \\text{\"\"}$:</p> <p></p> <p>For the string $s =~ \\text{\"a\"}$:</p> <p></p> <p>For the string $s =~ \\text{\"aa\"}$:</p> <p></p> <p>For the string $s =~ \\text{\"ab\"}$:</p> <p></p> <p>For the string $s =~ \\text{\"aba\"}$:</p> <p></p> <p>For the string $s =~ \\text{\"abb\"}$:</p> <p></p> <p>For the string $s =~ \\text{\"abbb\"}$:</p> <p></p>","tags":["Translated"]},{"location":"string/suffix-automaton.html#construction-in-linear-time","title":"Construction in linear time","text":"<p>Before we describe the algorithm to construct a suffix automaton in linear time, we need to introduce several new concepts and simple proofs, which will be very important in understanding the construction.</p>","tags":["Translated"]},{"location":"string/suffix-automaton.html#end-positions-endpos","title":"End positions $endpos$","text":"<p>Consider any non-empty substring $t$ of the string $s$. We will denote with $endpos(t)$ the set of all positions in the string $s$, in which the occurrences of $t$ end. For instance, we have $endpos(\\text{\"bc\"}) = \\{2, 4\\}$ for the string $\\text{\"abcbc\"}$.</p> <p>We will call two substrings $t_1$ and $t_2$ $endpos$-equivalent, if their ending sets coincide: $endpos(t_1) = endpos(t_2)$. Thus all non-empty substrings of the string $s$ can be decomposed into several equivalence classes according to their sets $endpos$.</p> <p>It turns out, that in a suffix machine $endpos$-equivalent substrings correspond to the same state. In other words the number of states in a suffix automaton is equal to the number of equivalence classes among all substrings, plus the initial state. Each state of a suffix automaton corresponds to one or more substrings having the same value $endpos$.</p> <p>We will later describe the construction algorithm using this assumption. We will then see, that all the required properties of a suffix automaton, except for the minimality, are fulfilled. And the minimality follows from Nerode's theorem (which will not be proven in this article).</p> <p>We can make some important observations concerning the values $endpos$:</p> <p>Lemma 1: Two non-empty substrings $u$ and $w$ (with $length(u) \\le length(w)$) are $endpos$-equivalent, if and only if the string $u$ occurs in $s$ only in the form of a suffix of $w$.</p> <p>The proof is obvious. If $u$ and $w$ have the same $endpos$ values, then $u$ is a suffix of $w$ and appears only in the form of a suffix of $w$ in $s$. And if $u$ is a suffix of $w$ and appears only in the form as a suffix in $s$, then the values $endpos$ are equal by definition.</p> <p>Lemma 2: Consider two non-empty substrings $u$ and $w$ (with $length(u) \\le length(w)$). Then their sets $endpos$ either don't intersect at all, or $endpos(w)$ is a subset of $endpos(u)$. And it depends on if $u$ is a suffix of $w$ or not.</p> $$\\begin{cases} endpos(w) \\subseteq endpos(u) &amp; \\text{if } u \\text{ is a suffix of } w \\\\\\\\ endpos(w) \\cap endpos(u) = \\emptyset &amp; \\text{otherwise} \\end{cases}$$ <p>Proof: If the sets $endpos(u)$ and $endpos(w)$ have at least one common element, then the strings $u$ and $w$ both end in that position, i.e. $u$ is a suffix of $w$. But then at every occurrence of $w$ also appears the substring $u$, which means that $endpos(w)$ is a subset of $endpos(u)$.</p> <p>Lemma 3: Consider an $endpos$-equivalence class. Sort all the substrings in this class by decreasing length. Then in the resulting sequence each substring will be one shorter than the previous one, and at the same time will be a suffix of the previous one. In other words, in a same equivalence class, the shorter substrings are actually suffixes of the longer substrings, and they take all possible lengths in a certain interval $[x; y]$.</p> <p>Proof: Fix some $endpos$-equivalence class. If it only contains one string, then the lemma is obviously true. Now let's say that the number of strings in the class is greater than one.</p> <p>According to Lemma 1, two different $endpos$-equivalent strings are always in such a way, that the shorter one is a proper suffix of the longer one. Consequently, there cannot be two strings of the same length in the equivalence class.</p> <p>Let's denote by $w$ the longest, and through $u$ the shortest string in the equivalence class. According to Lemma 1, the string $u$ is a proper suffix of the string $w$. Consider now any suffix of $w$ with a length in the interval $[length(u); length(w)]$. It is easy to see, that this suffix is also contained in the same equivalence class. Because this suffix can only appear in the form of a suffix of $w$ in the string $s$ (since also the shorter suffix $u$ occurs in $s$ only in the form of a suffix of $w$). Consequently, according to Lemma 1, this suffix is $endpos$-equivalent to the string $w$.</p>","tags":["Translated"]},{"location":"string/suffix-automaton.html#suffix-links-link","title":"Suffix links $link$","text":"<p>Consider some state $v \\ne t_0$ in the automaton. As we know, the state $v$ corresponds to the class of strings with the same $endpos$ values. And if we denote by $w$ the longest of these strings, then all the other strings are suffixes of $w$.</p> <p>We also know the first few suffixes of a string $w$ (if we consider suffixes in descending order of their length) are all contained in this equivalence class, and all other suffixes (at least one other - the empty suffix) are in some other classes. We denote by $t$ the biggest such suffix, and make a suffix link to it.</p> <p>In other words, a suffix link $link(v)$ leads to the state that corresponds to the longest suffix of $w$ that is in another $endpos$-equivalence class.</p> <p>Here we assume that the initial state $t_0$ corresponds to its own equivalence class (containing only the empty string), and for convenience we set $endpos(t_0) = \\{-1, 0, \\dots, length(s)-1\\}$.</p> <p>Lemma 4: Suffix links form a tree with the root $t_0$.</p> <p>Proof: Consider an arbitrary state $v \\ne t_0$. A suffix link $link(v)$ leads to a state corresponding to strings with strictly smaller length (this follows from the definition of the suffix links and from Lemma 3). Therefore, by moving along the suffix links, we will sooner or later come to the initial state $t_0$, which corresponds to the empty string.</p> <p>Lemma 5: If we construct a tree using the sets $endpos$ (by the rule that the set of a parent node contains the sets of all children as subsets), then the structure will coincide with the tree of suffix links.</p> <p>Proof: The fact that we can construct a tree using the sets $endpos$ follows directly from Lemma 2 (that any two sets either do not intersect or one is contained in the other).</p> <p>Let us now consider an arbitrary state $v \\ne t_0$, and its suffix link $link(v)$. From the definition of the suffix link and from Lemma 2 it follows that</p> $$endpos(v) \\subseteq endpos(link(v)),$$ <p>which together with the previous lemma proves the assertion: the tree of suffix links is essentially a tree of sets $endpos$.</p> <p>Here is an example of a tree of suffix links in the suffix automaton build for the string $\\text{\"abcbc\"}$. The nodes are labeled with the longest substring from the corresponding equivalence class.</p> <p></p>","tags":["Translated"]},{"location":"string/suffix-automaton.html#recap","title":"Recap","text":"<p>Before proceeding to the algorithm itself, we recap the accumulated knowledge, and introduce a few auxiliary notations.</p> <ul> <li>The substrings of the string $s$ can be decomposed into equivalence classes according to their end positions $endpos$.</li> <li>The suffix automaton consists of the initial state $t_0$, as well as of one state for each $endpos$-equivalence class.</li> <li>For each state $v$ one or multiple substrings match.   We denote by $longest(v)$ the longest such string, and through $len(v)$ its length.   We denote by $shortest(v)$ the shortest such substring, and its length with $minlen(v)$.   Then all the strings corresponding to this state are different suffixes of the string $longest(v)$ and have all possible lengths in the interval $[minlen(v); len(v)]$.</li> <li>For each state $v \\ne t_0$ a suffix link is defined as a link, that leads to a state that corresponds to the suffix of the string $longest(v)$ of length $minlen(v) - 1$.   The suffix links form a tree with the root in $t_0$, and at the same time this tree forms an inclusion relationship between the sets $endpos$.</li> <li>We can express $minlen(v)$ for $v \\ne t_0$ using the suffix link $link(v)$ as:</li> </ul> $$minlen(v) = len(link(v)) + 1$$ <ul> <li>If we start from an arbitrary state $v_0$ and follow the suffix links, then sooner or later we will reach the initial state $t_0$.   In this case we obtain a sequence of disjoint intervals $[minlen(v_i); len(v_i)]$, which in union forms the continuous interval $[0; len(v_0)]$.</li> </ul>","tags":["Translated"]},{"location":"string/suffix-automaton.html#algorithm","title":"Algorithm","text":"<p>Now we can proceed to the algorithm itself. The algorithm will be online, i.e. we will add the characters of the string one by one, and modify the automaton accordingly in each step.</p> <p>To achieve linear memory consumption, we will only store the values $len$, $link$ and a list of transitions in each state. We will not label terminal states (but we will later show how to arrange these labels after constructing the suffix automaton).</p> <p>Initially the automaton consists of a single state $t_0$, which will be the index $0$ (the remaining states will receive the indices $1, 2, \\dots$). We assign it $len = 0$ and $link = -1$ for convenience ($-1$ will be a fictional, non-existing state).</p> <p>Now the whole task boils down to implementing the process of adding one character $c$ to the end of the current string. Let us describe this process:</p> <ul> <li>Let $last$ be the state corresponding to the entire string before adding the character $c$.     (Initially we set $last = 0$, and we will change $last$ in the last step of the algorithm accordingly.)</li> <li>Create a new state $cur$, and assign it with $len(cur) = len(last) + 1$.     The value $link(cur)$ is not known at the time.</li> <li>Now we do the following procedure:     We start at the state $last$.     While there isn't a transition through the letter $c$, we will add a transition to the state $cur$, and follow the suffix link.     If at some point there already exists a transition through the letter $c$, then we will stop and denote this state with $p$.</li> <li>If we haven't found such a state $p$, then we reached the fictitious state $-1$, then we can just assign $link(cur) = 0$ and leave.</li> <li>Suppose now that we have found a state $p$, from which there exists a transition through the letter $c$.     We will denote the state, to which the transition leads,  with $q$.</li> <li>Now we have two cases. Either $len(p) + 1 = len(q)$, or not.</li> <li>If $len(p) + 1 = len(q)$, then we can simply assign $link(cur) = q$ and leave.</li> <li> <p>Otherwise it is a bit more complicated.     It is necessary to clone the state $q$:     we create a new state $clone$, copy all the data from $q$ (suffix link and transition) except the value $len$.     We will assign $len(clone) = len(p) + 1$.</p> <p>After cloning we direct the suffix link from $cur$ to $clone$, and also from $q$ to clone.</p> <p>Finally we need to walk from the state $p$ back using suffix links as long as there is a transition through $c$ to the state $q$, and redirect all those to the state $clone$.</p> </li> <li> <p>In any of the three cases, after completing the procedure, we update the value $last$ with the state $cur$.</p> </li> </ul> <p>If we also want to know which states are terminal and which are not, we can find all terminal states after constructing the complete suffix automaton for the entire string $s$. To do this, we take the state corresponding to the entire string (stored in the variable $last$), and follow its suffix links until we reach the initial state. We will mark all visited states as terminal. It is easy to understand that by doing so we will mark exactly the states corresponding to all the suffixes of the string $s$, which are exactly the terminal states.</p> <p>In the next section we will look in detail at each step and show its correctness.</p> <p>Here we only note that, since we only create one or two new states for each character of $s$, the suffix automaton contains a linear number of states.</p> <p>The linearity of the number of transitions, and in general the linearity of the runtime of the algorithm is less clear, and they will be proven after we proved the correctness.</p>","tags":["Translated"]},{"location":"string/suffix-automaton.html#correctness","title":"Correctness","text":"<ul> <li> <p>We will call a transition $(p, q)$ continuous if $len(p) + 1 = len(q)$.     Otherwise, i.e. when $len(p) + 1 &lt; len(q)$, the transition will be called non-continuous.</p> <p>As we can see from the description of the algorithm, continuous and non-continuous transitions will lead to different cases of the algorithm. Continuous transitions are fixed, and will never change again. In contrast non-continuous transition may change, when new letters are added to the string (the end of the transition edge may change).</p> </li> <li> <p>To avoid ambiguity we will denote the string, for which the suffix automaton was built before adding the current character $c$, with $s$.</p> </li> <li> <p>The algorithm begins with creating a new state $cur$, which will correspond to the entire string $s + c$.     It is clear why we have to create a new state.     Together with the new character a new equivalence class is created.</p> </li> <li> <p>After creating a new state we traverse by suffix links starting from the state corresponding to the entire string $s$.     For each state we try to add a transition with the character $c$ to the new state $cur$.     Thus we append to each suffix of $s$ the character $c$.     However we can only add these new transitions, if they don't conflict with an already existing one.     Therefore as soon as we find an already existing transition with $c$ we have to stop.</p> </li> <li> <p>In the simplest case we reached the fictitious state $-1$.     This means we added the transition with $c$ to all suffixes of $s$.     This also means, that the character $c$ hasn't been part of the string $s$ before.     Therefore the suffix link of $cur$ has to lead to the state $0$.</p> </li> <li> <p>In the second case we came across an existing transition $(p, q)$.     This means that we tried to add a string $x + c$ (where $x$ is a suffix of $s$) to the machine that already exists in the machine (the string $x + c$ already appears as a substring of $s$).     Since we assume that the automaton for the string $s$ is built correctly, we should not add a new transition here.</p> <p>However there is a difficulty. To which state should the suffix link from the state $cur$ lead? We have to make a suffix link to a state, in which the longest string is exactly $x + c$, i.e. the $len$ of this state should be $len(p) + 1$. However it is possible, that such a state doesn't yet exists, i.e. $len(q) &gt; len(p) + 1$. In this case we have to create such a state, by splitting the state $q$.</p> </li> <li> <p>If the transition $(p, q)$ turns out to be continuous, then $len(q) = len(p) + 1$.     In this case everything is simple.     We direct the suffix link from $cur$ to the state $q$.</p> </li> <li> <p>Otherwise the transition is non-continuous, i.e. $len(q) &gt; len(p) + 1$.     This means that the state $q$ corresponds to not only the suffix of $s + c$ with length $len(p) + 1$, but also to longer substrings of $s$.     We can do nothing other than splitting the state $q$ into two sub-states, so that the first one has length $len(p) + 1$.</p> <p>How can we split a state? We clone the state $q$, which gives us the state $clone$, and we set $len(clone) = len(p) + 1$. We copy all the transitions from $q$ to $clone$, because we don't want to change the paths that traverse through $q$. Also we set the suffix link from $clone$ to the target of the suffix link of $q$, and set the suffix link of $q$ to $clone$.</p> <p>And after splitting the state, we set the suffix link from $cur$ to $clone$.</p> <p>In the last step we change some of the transitions to $q$, we redirect them to $clone$. Which transitions do we have to change? It is enough to redirect only the transitions corresponding to all the suffixes of the string $w + c$ (where $w$ is the longest string of $p$), i.e. we need to continue to move along the suffix links, starting from the vertex $p$ until we reach the fictitious state $-1$ or a transition that leads to a different state than $q$.</p> </li> </ul>","tags":["Translated"]},{"location":"string/suffix-automaton.html#linear-number-of-operations","title":"Linear number of operations","text":"<p>First we immediately make the assumption that the size of the alphabet is constant. If this is not the case, then it will not be possible to talk about the linear time complexity. The list of transitions from one vertex will be stored in a balanced tree, which allows you to quickly perform key search operations and adding keys. Therefore if we denote with $k$ the size of the alphabet, then the asymptotic behavior of the algorithm will be $O(n \\log k)$ with $O(n)$ memory. However if the alphabet is small enough, then you can sacrifice memory by avoiding balanced trees, and store the transitions at each vertex as an array of length $k$ (for quick searching by key) and a dynamic list (to quickly traverse all available keys). Thus we reach the $O(n)$ time complexity for the algorithm, but at a cost of $O(n k)$ memory complexity.</p> <p>So we will consider the size of the alphabet to be constant, i.e. each operation of searching for a transition on a character, adding a transition, searching for the next transition - all these operations can be done in $O(1)$.</p> <p>If we consider all parts of the algorithm, then it contains three places in the algorithm in which the linear complexity is not obvious:</p> <ul> <li>The first place is the traversal through the suffix links from the state $last$, adding transitions with the character $c$.</li> <li>The second place is the copying of transitions when the state $q$ is cloned into a new state $clone$.</li> <li>Third place is changing the transition leading to $q$, redirecting them to $clone$.</li> </ul> <p>We use the fact that the size of the suffix automaton (both in the number of states and in the number of transitions) is linear. (The proof of the linearity of the number of states is the algorithm itself, and the proof of linearity of the number of states is given below, after the implementation of the algorithm).</p> <p>Thus the total complexity of the first and second places is obvious, after all each operation adds only one amortized new transition to the automaton.</p> <p>It remains to estimate the total complexity of the third place, in which we redirect transitions, that pointed originally to $q$, to $clone$. We denote $v = longest(p)$. This is a suffix of the string $s$, and with each iteration its length decreases - and therefore the position $v$ as the suffix of the string $s$ increases monotonically with each iteration. In this case, if before the first iteration of the loop, the corresponding string $v$ was at the depth $k$ ($k \\ge 2$) from $last$ (by counting the depth as the number of suffix links), then after the last iteration the string $v + c$ will be a $2$-th suffix link on the path from $cur$ (which will become the new value $last$).</p> <p>Thus, each iteration of this loop leads to the fact that the position of the string $longest(link(link(last))$ as a suffix of the current string will monotonically increase. Therefore this cycle cannot be executed more than $n$ iterations, which was required to prove.</p>","tags":["Translated"]},{"location":"string/suffix-automaton.html#implementation","title":"Implementation","text":"<p>First we describe a data structure that will store all information about a specific transition ($len$, $link$ and the list of transitions). If necessary you can add a terminal flag here, as well as other information. We will store the list of transitions in the form of a $map$, which allows us to achieve total $O(n)$ memory and $O(n \\log k)$ time for processing the entire string.</p> <pre><code>struct state {\n    int len, link;\n    map&lt;char, int&gt; next;\n};\n</code></pre> <p>The suffix automaton itself will be stored in an array of these structures $state$. We store the current size $sz$ and also the variable $last$, the state corresponding to the entire string at the moment.</p> <pre><code>const int MAXLEN = 100000;\nstate st[MAXLEN * 2];\nint sz, last;\n</code></pre> <p>We give a function that initializes a suffix automaton (creating a suffix automaton with a single state).</p> <pre><code>void sa_init() {\n    st[0].len = 0;\n    st[0].link = -1;\n    sz++;\n    last = 0;\n}\n</code></pre> <p>And finally we give the implementation of the main function - which adds the next character to the end of the current line, rebuilding the machine accordingly.</p> <pre><code>void sa_extend(char c) {\n    int cur = sz++;\n    st[cur].len = st[last].len + 1;\n    int p = last;\n    while (p != -1 &amp;&amp; !st[p].next.count(c)) {\n        st[p].next[c] = cur;\n        p = st[p].link;\n    }\n    if (p == -1) {\n        st[cur].link = 0;\n    } else {\n        int q = st[p].next[c];\n        if (st[p].len + 1 == st[q].len) {\n            st[cur].link = q;\n        } else {\n            int clone = sz++;\n            st[clone].len = st[p].len + 1;\n            st[clone].next = st[q].next;\n            st[clone].link = st[q].link;\n            while (p != -1 &amp;&amp; st[p].next[c] == q) {\n                st[p].next[c] = clone;\n                p = st[p].link;\n            }\n            st[q].link = st[cur].link = clone;\n        }\n    }\n    last = cur;\n}\n</code></pre> <p>As mentioned above, if you sacrifice memory ($O(n k)$, where $k$ is the size of the alphabet), then you can achieve the build time of the machine in $O(n)$, even for any alphabet size $k$. But for this you will have to store an array of size $k$ in each state (for quickly jumping to the transition of the letter), and additional a list of all transitions (to quickly iterate over the transitions them).</p>","tags":["Translated"]},{"location":"string/suffix-automaton.html#additional-properties","title":"Additional properties","text":"","tags":["Translated"]},{"location":"string/suffix-automaton.html#number-of-states","title":"Number of states","text":"<p>The number of states in a suffix automaton of the string $s$ of length $n$ doesn't exceed $2n - 1$ (for $n \\ge 2$).</p> <p>The proof is the construction algorithm itself, since initially the automaton consists of one state, and in the first and second iteration only a single state will be created, and in the remaining $n-2$ steps at most $2$ states will be created each.</p> <p>However we can also show this estimation without knowing the algorithm. Let us recall that the number of states is equal to the number of different sets $endpos$. In addition theses sets $endpos$ form a tree (a parent vertex contains all children sets in his set). Consider this tree and transform it a little bit: as long as it has an internal vertex with only one child (which means that the set of the child misses at least one position from the parent set), we create a new child with the set of the missing positions. In the end we have a tree in which each inner vertex has a degree greater than one, and the number of leaves does not exceed $n$. Therefore there are no more than $2n - 1$ vertices in such a tree.</p> <p>This bound of the number of states can actually be achieved for each $n$. A possible string is:</p> $$\\text{\"abbb}\\dots \\text{bbb\"}$$ <p>In each iteration, starting at the third one, the algorithm will split a state, resulting in exactly $2n - 1$ states.</p>","tags":["Translated"]},{"location":"string/suffix-automaton.html#number-of-transitions","title":"Number of transitions","text":"<p>The number of transitions in a suffix automaton of a string $s$ of length $n$ doesn't exceed $3n - 4$ (for $n \\ge 3$).</p> <p>Let us prove this:</p> <p>Let us first estimate the number of continuous transitions. Consider a spanning tree of the longest paths in the automaton starting in the state $t_0$. This skeleton will consist of only the continuous edges, and therefore their number is less than the number of states, i.e. it does not exceed $2n - 2$.</p> <p>Now let us estimate the number of non-continuous transitions. Let the current non-continuous transition be $(p, q)$ with the character $c$. We take the correspondent string $u + c + w$, where the string $u$ corresponds to the longest path from the initial state to $p$, and $w$ to the longest path from $q$ to any terminal state. On one hand, each such string $u + c + w$ for each incomplete strings will be different (since the strings $u$ and $w$ are formed only by complete transitions). On the other hand each such string $u + c + w$, by the definition of the terminal states, will be a suffix of the entire string $s$. Since there are only $n$ non-empty suffixes of $s$, and none of the strings $u + c + w$ can contain $s$ (because the entire string only contains complete transitions), the total number of incomplete transitions does not exceed $n - 1$.</p> <p>Combining these two estimates gives us the bound $3n - 3$. However, since the maximum number of states can only be achieved with the test case $\\text{\"abbb\\dots bbb\"}$ and this case has clearly less than $3n - 3$ transitions, we get the tighter bound of $3n - 4$ for the number of transitions in a suffix automaton.</p> <p>This bound can also be achieved with the string:</p> $$\\text{\"abbb}\\dots \\text{bbbc\"}$$","tags":["Translated"]},{"location":"string/suffix-automaton.html#applications","title":"Applications","text":"<p>Here we look at some tasks that can be solved using the suffix automaton. For the simplicity we assume that the alphabet size $k$ is constant, which allows us to consider the complexity of appending a character and the traversal as constant.</p>","tags":["Translated"]},{"location":"string/suffix-automaton.html#check-for-occurrence","title":"Check for occurrence","text":"<p>Given a text $T$, and multiple patterns $P$. We have to check whether or not the strings $P$ appear as a substring of $T$.</p> <p>We build a suffix automaton of the text $T$ in $O(length(T))$ time. To check if a pattern $P$ appears in $T$, we follow the transitions, starting from $t_0$, according to the characters of $P$. If at some point there doesn't exists a transition, then the pattern $P$ doesn't appear as a substring of $T$. If we can process the entire string $P$ this way, then the string appears in $T$.</p> <p>It is clear that this will take $O(length(P))$ time for each string $P$. Moreover the algorithm actually finds the length of the longest prefix of $P$ that appears in the text.</p>","tags":["Translated"]},{"location":"string/suffix-automaton.html#number-of-different-substrings","title":"Number of different substrings","text":"<p>Given a string $S$. You want to compute the number of different substrings.</p> <p>Let us build a suffix automaton for the string $S$.</p> <p>Each substring of $S$ corresponds to some path in the automaton. Therefore the number of different substrings is equal to the number of different paths in the automaton starting at $t_0$.</p> <p>Given that the suffix automaton is a directed acyclic graph, the number of different ways can be computed using dynamic programming.</p> <p>Namely, let $d[v]$ be the number of ways, starting at the state $v$ (including the path of length zero). Then we have the recursion:</p> $$d[v] = 1 + \\sum_{w : (v, w, c) \\in DAWG} d[w]$$ <p>I.e. $d[v]$ can be expressed as the sum of answers for all ends of the transitions of $v$.</p> <p>The number of different substrings is the value $d[t_0] - 1$ (since we don't count the empty substring).</p> <p>Total time complexity: $O(length(S))$</p> <p>Alternatively, we can take advantage of the fact that each state $v$ matches to substrings of length $[minlen(v),len(v)]$. Therefore, given $minlen(v) = 1 + len(link(v))$, we have total distinct substrings at state $v$ being $len(v) - minlen(v) + 1 = len(v) - (1 + len(link(v))) + 1 = len(v) - len(link(v))$.</p> <p>This is demonstrated succinctly below:</p> <pre><code>long long get_diff_strings(){\n    long long tot = 0;\n    for(int i = 1; i &lt; sz; i++) {\n        tot += st[i].len - st[st[i].link].len;\n    }\n    return tot;\n}\n</code></pre> <p>While this is also $O(length(S))$, it requires no extra space and no recursive calls, consequently running faster in practice.</p>","tags":["Translated"]},{"location":"string/suffix-automaton.html#total-length-of-all-different-substrings","title":"Total length of all different substrings","text":"<p>Given a string $S$. We want to compute the total length of all its various substrings.</p> <p>The solution is similar to the previous one, only now it is necessary to consider two quantities for the dynamic programming part: the number of different substrings $d[v]$ and their total length $ans[v]$.</p> <p>We already described how to compute $d[v]$ in the previous task. The value $ans[v]$ can be computed using the recursion:</p> $$ans[v] = \\sum_{w : (v, w, c) \\in DAWG} d[w] + ans[w]$$ <p>We take the answer of each adjacent vertex $w$, and add to it $d[w]$ (since every substring is one character longer when starting from the state $v$).</p> <p>Again this task can be computed in $O(length(S))$ time.</p> <p>Alternatively, we can, again, take advantage of the fact that each state $v$ matches to substrings of length $[minlen(v),len(v)]$. Since $minlen(v) = 1 + len(link(v))$ and the arithmetic series formula $S_n = n \\cdot \\frac{a_1+a_n}{2}$ (where $S_n$ denotes the sum of $n$ terms, $a_1$ representing the first term, and $a_n$ representing the last), we can compute the length of substrings at a state in constant time.  We then sum up these totals for each state $v \\neq t_0$ in the automaton. This is shown by the code below:</p> <pre><code>long long get_tot_len_diff_substings() {\n    long long tot = 0;\n    for(int i = 1; i &lt; sz; i++) {\n        long long shortest = st[st[i].link].len + 1;\n        long long longest = st[i].len;\n\n        long long num_strings = longest - shortest + 1;\n        long long cur = num_strings * (longest + shortest) / 2;\n        tot += cur;\n    }\n    return tot;\n}\n</code></pre> <p>This approach runs in  $O(length(S))$ time, but experimentally runs 20x faster than the memoized dynamic programming version on randomized strings. It requires no extra space and no recursion.</p>","tags":["Translated"]},{"location":"string/suffix-automaton.html#lexicographically-k-th-substring","title":"Lexicographically $k$-th substring","text":"<p>Given a string $S$. We have to answer multiple queries. For each given number $K_i$ we have to find the $K_i$-th string in the lexicographically ordered list of all substrings.</p> <p>The solution to this problem is based on the idea of the previous two problems. The lexicographically $k$-th substring corresponds to the lexicographically $k$-th path in the suffix automaton. Therefore after counting the number of paths from each state, we can easily search for the $k$-th path starting from the root of the automaton.</p> <p>This takes $O(length(S))$ time for preprocessing and then $O(length(ans) \\cdot k)$ for each query (where $ans$ is the answer for the query and $k$ is the size of the alphabet).</p>","tags":["Translated"]},{"location":"string/suffix-automaton.html#smallest-cyclic-shift","title":"Smallest cyclic shift","text":"<p>Given a string $S$. We want to find the lexicographically smallest cyclic shift.</p> <p>We construct a suffix automaton for the string $S + S$. Then the automaton will contain in itself as paths all the cyclic shifts of the string $S$.</p> <p>Consequently the problem is reduced to finding the lexicographically smallest path of length $length(S)$, which can be done in a trivial way: we start in the initial state and greedily pass through the transitions with the minimal character.</p> <p>Total time complexity is $O(length(S))$.</p>","tags":["Translated"]},{"location":"string/suffix-automaton.html#number-of-occurrences","title":"Number of occurrences","text":"<p>For a given text $T$. We have to answer multiple queries. For each given pattern $P$ we have to find out how many times the string $P$ appears in the string $T$ as a substring.</p> <p>We construct the suffix automaton for the text $T$.</p> <p>Next we do the following preprocessing: for each state $v$ in the automaton we calculate the number $cnt[v]$ that is equal to the size of the set $endpos(v)$. In fact all strings corresponding to the same state $v$ appear in the text $T$ an equal amount of times, which is equal to the number of positions in the set $endpos$.</p> <p>However we cannot construct the sets $endpos$ explicitly, therefore we only consider their sizes $cnt$.</p> <p>To compute them we proceed as follows. For each state, if it was not created by cloning (and if it is not the initial state $t_0$), we initialize it with $cnt = 1$. Then we will go through all states in decreasing order of their length $len$, and add the current value $cnt[v]$ to the suffix links:</p> $$cnt[link(v)] \\text{ += } cnt[v]$$ <p>This gives the correct value for each state.</p> <p>Why is this correct? The total number of states obtained not via cloning is exactly $length(T)$, and the first $i$ of them appeared when we added the first $i$ characters. Consequently for each of these states we count the corresponding position at which it was processed. Therefore initially we have $cnt = 1$ for each such state, and $cnt = 0$ for all other.</p> <p>Then we apply the following operation for each $v$: $cnt[link(v)] \\text{ += } cnt[v]$. The meaning behind this is, that if a string $v$ appears $cnt[v]$ times, then also all its suffixes appear at the exact same end positions, therefore also $cnt[v]$ times.</p> <p>Why don't we overcount in this procedure (i.e. don't count some positions twice)? Because we add the positions of a state to only one other state, so it can not happen that one state directs its positions to another state twice in two different ways.</p> <p>Thus we can compute the quantities $cnt$ for all states in the automaton in $O(length(T))$ time.</p> <p>After that answering a query by just looking up the value $cnt[t]$, where $t$ is the state corresponding to the pattern, if such a state exists. Otherwise answer with $0$. Answering a query takes $O(length(P))$ time.</p>","tags":["Translated"]},{"location":"string/suffix-automaton.html#first-occurrence-position","title":"First occurrence position","text":"<p>Given a text $T$ and multiple queries. For each query string $P$ we want to find the position of the first occurrence of $P$ in the string $T$ (the position of the beginning of $P$).</p> <p>We again construct a suffix automaton. Additionally we precompute the position $firstpos$ for all states in the automaton, i.e. for each state $v$ we want to find the position $firstpos[v]$ of the end of the first occurrence. In other words, we want to find in advance the minimal element of each set $endpos$ (since obviously cannot maintain all sets $endpos$ explicitly).</p> <p>To maintain these positions $firstpos$ we extend the function <code>sa_extend()</code>. When we create a new state $cur$, we set:</p> $$firstpos(cur) = len(cur) - 1$$ <p>And when we clone a vertex $q$ as $clone$, we set:</p> $$firstpos(clone) = firstpos(q)$$ <p>(since the only other option for a value would be $firstpos(cur)$ which is definitely too big)</p> <p>Thus the answer for a query is simply $firstpos(t) - length(P) + 1$, where $t$ is the state corresponding to the string $P$. Answering a query again takes only $O(length(P))$ time.</p>","tags":["Translated"]},{"location":"string/suffix-automaton.html#all-occurrence-positions","title":"All occurrence positions","text":"<p>This time we have to display all positions of the occurrences in the string $T$.</p> <p>Again we construct a suffix automaton for the text $T$. Similar as in the previous task we compute the position $firstpos$ for all states.</p> <p>Clearly $firstpos(t)$ is part of the answer, if $t$ is the state corresponding to a query string $P$. So we took into account the state of the automaton containing $P$. What other states do we need to take into account? All states that correspond to strings for which $P$ is a suffix. In other words we need to find all the states that can reach the state $t$ via suffix links.</p> <p>Therefore to solve the problem we need to save for each state a list of suffix references leading to it. The answer to the query then will then contain all $firstpos$ for each state that we can find on a DFS / BFS starting from the state $t$ using only the suffix references.</p> <p>Overall, this requires $O(length (T))$ for preprocessing and $O(length(P) + answer(P))$ for each request, where $answer(P)$ \u2014 this is the size of the answer.</p> <p>First, we walk down the automaton for each character in the pattern to find our starting node requiring $O(length(P))$.  Then, we use our workaround which will work in time $O(answer(P))$, because we will not visit a state twice (because only one suffix link leaves each state, so there cannot be two different paths leading to the same state).</p> <p>We only must take into account that two different states can have the same $firstpos$ value. This happens if one state was obtained by cloning another. However, this doesn't ruin the complexity, since each state can only have at most one clone.</p> <p>Moreover, we can also get rid of the duplicate positions, if we don't output the positions from the cloned states. In fact a state, that a cloned state can reach, is also reachable from the original state. Thus if we remember the flag <code>is_cloned</code> for each state, we can simply ignore the cloned states and only output $firstpos$ for all other states.</p> <p>Here are some implementation sketches:</p> <pre><code>struct state {\n    ...\n    bool is_clone;\n    int first_pos;\n    vector&lt;int&gt; inv_link;\n};\n\n// after constructing the automaton\nfor (int v = 1; v &lt; sz; v++) {\n    st[st[v].link].inv_link.push_back(v);\n}\n\n// output all positions of occurrences\nvoid output_all_occurrences(int v, int P_length) {\n    if (!st[v].is_clone)\n        cout &lt;&lt; st[v].first_pos - P_length + 1 &lt;&lt; endl;\n    for (int u : st[v].inv_link)\n        output_all_occurrences(u, P_length);\n}\n</code></pre>","tags":["Translated"]},{"location":"string/suffix-automaton.html#shortest-non-appearing-string","title":"Shortest non-appearing string","text":"<p>Given a string $S$ and a certain alphabet. We have to find a string of the smallest length, that doesn't appear in $S$.</p> <p>We will apply dynamic programming on the suffix automaton built for the string $S$.</p> <p>Let $d[v]$ be the answer for the node $v$, i.e. we already processed part of the substring, are currently in the state $v$, and want to find the smallest number of characters that have to be added to find a non-existent transition. Computing $d[v]$ is very simple. If there is not transition using at least one character of the alphabet, then $d[v] = 1$. Otherwise one character is not enough, and so we need to take the minimum of all answers of all transitions:</p> $$d[v] = 1 + \\min_{w:(v,w,c) \\in SA} d[w].$$ <p>The answer to the problem will be $d[t_0]$, and the actual string can be restored using the computed array $d[]$.</p>","tags":["Translated"]},{"location":"string/suffix-automaton.html#longest-common-substring-of-two-strings","title":"Longest common substring of two strings","text":"<p>Given two strings $S$ and $T$. We have to find the longest common substring, i.e. such a string $X$ that appears as a substring in $S$ and also in $T$.</p> <p>We construct a suffix automaton for the string $S$.</p> <p>We will now take the string $T$, and for each prefix look for the longest suffix of this prefix in $S$. In other words, for each position in the string $T$, we want to find the longest common substring of $S$ and $T$ ending in that position.</p> <p>For this we will use two variables, the current state $v$, and the current length $l$. These two variables will describe the current matching part: its length and the state that corresponds to it.</p> <p>Initially $v = t_0$ and $l = 0$, i.e. the match is empty.</p> <p>Now let us describe how we can add a character $T[i]$ and recalculate the answer for it.</p> <ul> <li>If there is a transition from $v$ with the character $T[i]$, then we simply follow the transition and increase $l$ by one.</li> <li>If there is no such transition, we have to shorten the current matching part, which means that we need to follow the suffix link: $v = link(v)$.     At the same time, the current length has to be shortened.     Obviously we need to assign $l = len(v)$, since after passing through the suffix link we end up in state whose corresponding longest string is a substring.</li> <li>If there is still no transition using the required character, we repeat and again go through the suffix link and decrease $l$, until we find a transition or we reach the fictional state $-1$ (which means that the symbol $T[i]$ doesn't appear at all in $S$, so we assign $v = l = 0$).</li> </ul> <p>The answer to the task will be the maximum of all the values $l$.</p> <p>The complexity of this part is $O(length(T))$, since in one move we can either increase $l$ by one, or make several passes through the suffix links, each one ends up reducing the value $l$.</p> <p>Implementation:</p> <pre><code>string lcs (string S, string T) {\n    sa_init();\n    for (int i = 0; i &lt; S.size(); i++)\n        sa_extend(S[i]);\n\n    int v = 0, l = 0, best = 0, bestpos = 0;\n    for (int i = 0; i &lt; T.size(); i++) {\n        while (v &amp;&amp; !st[v].next.count(T[i])) {\n            v = st[v].link ;\n            l = st[v].len;\n        }\n        if (st[v].next.count(T[i])) {\n            v = st [v].next[T[i]];\n            l++;\n        }\n        if (l &gt; best) {\n            best = l;\n            bestpos = i;\n        }\n    }\n    return T.substr(bestpos - best + 1, best);\n} \n</code></pre>","tags":["Translated"]},{"location":"string/suffix-automaton.html#largest-common-substring-of-multiple-strings","title":"Largest common substring of multiple strings","text":"<p>There are $k$ strings $S_i$ given. We have to find the longest common substring, i.e. such a string $X$ that appears as substring in each string $S_i$.</p> <p>We join all strings into one large string $T$, separating the strings by a special characters $D_i$ (one for each string):</p> $$T = S_1 + D_1 + S_2 + D_2 + \\dots + S_k + D_k.$$ <p>Then we construct the suffix automaton for the string $T$.</p> <p>Now we need to find a string in the machine, which is contained in all the strings $S_i$, and this can be done by using the special added characters. Note that if a substring is included in some string $S_j$, then in the suffix automaton exists a path starting from this substring containing the character $D_j$ and not containing the other characters $D_1, \\dots, D_{j-1}, D_{j+1}, \\dots, D_k$.</p> <p>Thus we need to calculate the attainability, which tells us for each state of the machine and each symbol $D_i$ if there exists such a path. This can easily be computed by DFS or BFS and dynamic programming. After that, the answer to the problem will be the string $longest(v)$ for the state $v$, from which the paths were exists for all special characters.</p>","tags":["Translated"]},{"location":"string/suffix-automaton.html#practice-problems","title":"Practice Problems","text":"<ul> <li>CSES - Finding Patterns</li> <li>CSES - Counting Patterns</li> <li>CSES - String Matching</li> <li>CSES - Patterns Positions</li> <li>CSES - Distinct Substrings</li> <li>CSES - Word Combinations</li> <li>CSES - String Distribution</li> <li>AtCoder - K-th Substring</li> <li>SPOJ - SUBLEX</li> <li>Codeforces - Cyclical Quest</li> <li>Codeforces - String</li> </ul>","tags":["Translated"]},{"location":"string/suffix-tree-ukkonen.html","title":"Suffix Tree. Ukkonen's Algorithm","text":"<p>This article is a stub and doesn't contain any descriptions. For a description of the algorithm, refer to other sources, such as Algorithms on Strings, Trees, and Sequences by Dan Gusfield.</p> <p>This algorithm builds a suffix tree for a given string $s$ of length $n$ in $O(n\\log(k))$) time, where $k$ is the size of the alphabet (if $k$ is considered to be a constant, the asymptotic behavior is linear).</p> <p>The input to the algorithm are the string $s$ and its length $n$, which are passed as global variables.</p> <p>The main function <code>build_tree</code> builds a suffix tree. It is stored as an array of structures <code>node</code>, where <code>node[0]</code> is the root of the tree.</p> <p>In order to simplify the code, the edges are stored in the same structures: for each vertex its structure <code>node</code> stores the information about the edge between it and its parent. Overall each <code>node</code> stores the following information: </p> <ul> <li><code>(l, r)</code> - left and right boundaries of the substring <code>s[l..r-1]</code> which correspond to the edge to this node,</li> <li><code>par</code> - the parent node,</li> <li><code>link</code> - the suffix link,</li> <li><code>next</code> - the list of edges going out from this node.</li> </ul> <pre><code>string s;\nint n;\n\nstruct node {\n    int l, r, par, link;\n    map&lt;char,int&gt; next;\n\n    node (int l=0, int r=0, int par=-1)\n        : l(l), r(r), par(par), link(-1) {}\n    int len()  {  return r - l;  }\n    int &amp;get (char c) {\n        if (!next.count(c))  next[c] = -1;\n        return next[c];\n    }\n};\nnode t[MAXN];\nint sz;\n\nstruct state {\n    int v, pos;\n    state (int v, int pos) : v(v), pos(pos)  {}\n};\nstate ptr (0, 0);\n\nstate go (state st, int l, int r) {\n    while (l &lt; r)\n        if (st.pos == t[st.v].len()) {\n            st = state (t[st.v].get( s[l] ), 0);\n            if (st.v == -1)  return st;\n        }\n        else {\n            if (s[ t[st.v].l + st.pos ] != s[l])\n                return state (-1, -1);\n            if (r-l &lt; t[st.v].len() - st.pos)\n                return state (st.v, st.pos + r-l);\n            l += t[st.v].len() - st.pos;\n            st.pos = t[st.v].len();\n        }\n    return st;\n}\n\nint split (state st) {\n    if (st.pos == t[st.v].len())\n        return st.v;\n    if (st.pos == 0)\n        return t[st.v].par;\n    node v = t[st.v];\n    int id = sz++;\n    t[id] = node (v.l, v.l+st.pos, v.par);\n    t[v.par].get( s[v.l] ) = id;\n    t[id].get( s[v.l+st.pos] ) = st.v;\n    t[st.v].par = id;\n    t[st.v].l += st.pos;\n    return id;\n}\n\nint get_link (int v) {\n    if (t[v].link != -1)  return t[v].link;\n    if (t[v].par == -1)  return 0;\n    int to = get_link (t[v].par);\n    return t[v].link = split (go (state(to,t[to].len()), t[v].l + (t[v].par==0), t[v].r));\n}\n\nvoid tree_extend (int pos) {\n    for(;;) {\n        state nptr = go (ptr, pos, pos+1);\n        if (nptr.v != -1) {\n            ptr = nptr;\n            return;\n        }\n\n        int mid = split (ptr);\n        int leaf = sz++;\n        t[leaf] = node (pos, n, mid);\n        t[mid].get( s[pos] ) = leaf;\n\n        ptr.v = get_link (mid);\n        ptr.pos = t[ptr.v].len();\n        if (!mid)  break;\n    }\n}\n\nvoid build_tree() {\n    sz = 1;\n    for (int i=0; i&lt;n; ++i)\n        tree_extend (i);\n}\n</code></pre>","tags":["Translated"]},{"location":"string/suffix-tree-ukkonen.html#compressed-implementation","title":"Compressed Implementation","text":"<p>This compressed implementation was proposed by freopen.</p> <pre><code>const int N=1000000,INF=1000000000;\nstring a;\nint t[N][26],l[N],r[N],p[N],s[N],tv,tp,ts,la;\n\nvoid ukkadd (int c) {\n    suff:;\n    if (r[tv]&lt;tp) {\n        if (t[tv][c]==-1) { t[tv][c]=ts;  l[ts]=la;\n            p[ts++]=tv;  tv=s[tv];  tp=r[tv]+1;  goto suff; }\n        tv=t[tv][c]; tp=l[tv];\n    }\n    if (tp==-1 || c==a[tp]-'a') tp++; else {\n        l[ts+1]=la;  p[ts+1]=ts;\n        l[ts]=l[tv];  r[ts]=tp-1;  p[ts]=p[tv];  t[ts][c]=ts+1;  t[ts][a[tp]-'a']=tv;\n        l[tv]=tp;  p[tv]=ts;  t[p[ts]][a[l[ts]]-'a']=ts;  ts+=2;\n        tv=s[p[ts-2]];  tp=l[ts-2];\n        while (tp&lt;=r[ts-2]) {  tv=t[tv][a[tp]-'a'];  tp+=r[tv]-l[tv]+1;}\n        if (tp==r[ts-2]+1)  s[ts-2]=tv;  else s[ts-2]=ts; \n        tp=r[tv]-(tp-r[ts-2])+2;  goto suff;\n    }\n}\n\nvoid build() {\n    ts=2;\n    tv=0;\n    tp=0;\n    fill(r,r+N,(int)a.size()-1);\n    s[0]=1;\n    l[0]=-1;\n    r[0]=-1;\n    l[1]=-1;\n    r[1]=-1;\n    memset (t, -1, sizeof t);\n    fill(t[1],t[1]+26,0);\n    for (la=0; la&lt;(int)a.size(); ++la)\n        ukkadd (a[la]-'a');\n}\n</code></pre> <p>Same code with comments:</p> <pre><code>const int N=1000000,    // maximum possible number of nodes in suffix tree\n    INF=1000000000; // infinity constant\nstring a;       // input string for which the suffix tree is being built\nint t[N][26],   // array of transitions (state, letter)\n    l[N],   // left...\n    r[N],   // ...and right boundaries of the substring of a which correspond to incoming edge\n    p[N],   // parent of the node\n    s[N],   // suffix link\n    tv,     // the node of the current suffix (if we're mid-edge, the lower node of the edge)\n    tp,     // position in the string which corresponds to the position on the edge (between l[tv] and r[tv], inclusive)\n    ts,     // the number of nodes\n    la;     // the current character in the string\n\nvoid ukkadd(int c) { // add character s to the tree\n    suff:;      // we'll return here after each transition to the suffix (and will add character again)\n    if (r[tv]&lt;tp) { // check whether we're still within the boundaries of the current edge\n        // if we're not, find the next edge. If it doesn't exist, create a leaf and add it to the tree\n        if (t[tv][c]==-1) {t[tv][c]=ts;l[ts]=la;p[ts++]=tv;tv=s[tv];tp=r[tv]+1;goto suff;}\n        tv=t[tv][c];tp=l[tv];\n    } // otherwise just proceed to the next edge\n    if (tp==-1 || c==a[tp]-'a')\n        tp++; // if the letter on the edge equal c, go down that edge\n    else { \n        // otherwise split the edge in two with middle in node ts\n        l[ts]=l[tv];r[ts]=tp-1;p[ts]=p[tv];t[ts][a[tp]-'a']=tv;\n        // add leaf ts+1. It corresponds to transition through c.\n        t[ts][c]=ts+1;l[ts+1]=la;p[ts+1]=ts;\n        // update info for the current node - remember to mark ts as parent of tv\n        l[tv]=tp;p[tv]=ts;t[p[ts]][a[l[ts]]-'a']=ts;ts+=2;\n        // prepare for descent\n        // tp will mark where are we in the current suffix\n        tv=s[p[ts-2]];tp=l[ts-2];\n        // while the current suffix is not over, descend\n        while (tp&lt;=r[ts-2]) {tv=t[tv][a[tp]-'a'];tp+=r[tv]-l[tv]+1;}\n        // if we're in a node, add a suffix link to it, otherwise add the link to ts\n        // (we'll create ts on next iteration).\n        if (tp==r[ts-2]+1) s[ts-2]=tv; else s[ts-2]=ts; \n        // add tp to the new edge and return to add letter to suffix\n        tp=r[tv]-(tp-r[ts-2])+2;goto suff;\n    }\n}\n\nvoid build() {\n    ts=2;\n    tv=0;\n    tp=0;\n    fill(r,r+N,(int)a.size()-1);\n    // initialize data for the root of the tree\n    s[0]=1;\n    l[0]=-1;\n    r[0]=-1;\n    l[1]=-1;\n    r[1]=-1;\n    memset (t, -1, sizeof t);\n    fill(t[1],t[1]+26,0);\n    // add the text to the tree, letter by letter\n    for (la=0; la&lt;(int)a.size(); ++la)\n        ukkadd (a[la]-'a');\n}\n</code></pre>","tags":["Translated"]},{"location":"string/suffix-tree-ukkonen.html#practice-problems","title":"Practice Problems","text":"<ul> <li>UVA 10679 - I Love Strings!!!</li> </ul>","tags":["Translated"]},{"location":"string/z-function.html","title":"Z-function and its calculation","text":"<p>Suppose we are given a string $s$ of length $n$. The Z-function for this string is an array of length $n$ where the $i$-th element is equal to the greatest number of characters starting from the position $i$ that coincide with the first characters of $s$.</p> <p>In other words, $z[i]$ is the length of the longest string that is, at the same time, a prefix of $s$ and a prefix of the suffix of $s$ starting at $i$.</p> <p>Note. In this article, to avoid ambiguity, we assume $0$-based indexes; that is: the first character of $s$ has index $0$ and the last one has index $n-1$.</p> <p>The first element of Z-function, $z[0]$, is generally not well defined. In this article we will assume it is zero (although it doesn't change anything in the algorithm implementation).</p> <p>This article presents an algorithm for calculating the Z-function in $O(n)$ time, as well as various of its applications.</p>","tags":["Translated"]},{"location":"string/z-function.html#examples","title":"Examples","text":"<p>For example, here are the values of the Z-function computed for different strings:</p> <ul> <li>\"aaaaa\" - $[0, 4, 3, 2, 1]$</li> <li>\"aaabaab\" - $[0, 2, 1, 0, 2, 1, 0]$</li> <li>\"abacaba\" - $[0, 0, 1, 0, 3, 0, 1]$</li> </ul>","tags":["Translated"]},{"location":"string/z-function.html#trivial-algorithm","title":"Trivial algorithm","text":"<p>Formal definition can be represented in the following elementary $O(n^2)$ implementation.</p> <pre><code>vector&lt;int&gt; z_function_trivial(string s) {\n    int n = s.size();\n    vector&lt;int&gt; z(n);\n    for (int i = 1; i &lt; n; i++) {\n        while (i + z[i] &lt; n &amp;&amp; s[z[i]] == s[i + z[i]]) {\n            z[i]++;\n        }\n    }\n    return z;\n}\n</code></pre> <p>We just iterate through every position $i$ and update $z[i]$ for each one of them, starting from $z[i] = 0$ and incrementing it as long as we don't find a mismatch (and as long as we don't reach the end of the line).</p> <p>Of course, this is not an efficient implementation. We will now show the construction of an efficient implementation.</p>","tags":["Translated"]},{"location":"string/z-function.html#efficient-algorithm-to-compute-the-z-function","title":"Efficient algorithm to compute the Z-function","text":"<p>To obtain an efficient algorithm we will compute the values of $z[i]$ in turn from $i = 1$ to $n - 1$ but at the same time, when computing a new value, we'll try to make the best use possible of the previously computed values.</p> <p>For the sake of brevity, let's call segment matches those substrings that coincide with a prefix of $s$. For example, the value of the desired Z-function $z[i]$ is the length of the segment match starting at position $i$ (and that ends at position $i + z[i] - 1$).</p> <p>To do this, we will keep the $[l, r)$ indices of the rightmost segment match. That is, among all detected segments we will keep the one that ends rightmost. In a way, the index $r$ can be seen as the \"boundary\" to which our string $s$ has been scanned by the algorithm; everything beyond that point is not yet known.</p> <p>Then, if the current index (for which we have to compute the next value of the Z-function) is $i$, we have one of two options:</p> <ul> <li> <p>$i \\geq r$ -- the current position is outside of what we have already processed.</p> <p>We will then compute $z[i]$ with the trivial algorithm (that is, just comparing values one by one). Note that in the end, if $z[i] &gt; 0$, we'll have to update the indices of the rightmost segment, because it's guaranteed that the new $r = i + z[i]$ is better than the previous $r$.</p> </li> <li> <p>$i &lt; r$ -- the current position is inside the current segment match $[l, r)$.</p> <p>Then we can use the already calculated Z-values to \"initialize\" the value of $z[i]$ to something (it sure is better than \"starting from zero\"), maybe even some big number.</p> <p>For this, we observe that the substrings $s[l \\dots r)$ and $s[0 \\dots r-l)$ match. This means that as an initial approximation for $z[i]$ we can take the value already computed for the corresponding segment $s[0 \\dots r-l)$, and that is $z[i-l]$.</p> <p>However, the value $z[i-l]$ could be too large: when applied to position $i$ it could exceed the index $r$. This is not allowed because we know nothing about the characters to the right of $r$: they may differ from those required.</p> <p>Here is an example of a similar scenario:</p> $$ s = \"aaaabaa\" $$ <p>When we get to the last position ($i = 6$), the current match segment will be $[5, 7)$. Position $6$ will then match position $6 - 5 = 1$, for which the value of the Z-function is $z[1] = 3$. Obviously, we cannot initialize $z[6]$ to $3$, it would be completely incorrect. The maximum value we could initialize it to is $1$ -- because it's the largest value that doesn't bring us beyond the index $r$ of the match segment $[l, r)$.</p> <p>Thus, as an initial approximation for $z[i]$ we can safely take:</p> $$ z_0[i] = \\min(r - i,\\; z[i-l]) $$ <p>After having $z[i]$ initialized to $z_0[i]$, we try to increment $z[i]$ by running the trivial algorithm -- because in general, after the border $r$, we cannot know if the segment will continue to match or not.</p> </li> </ul> <p>Thus, the whole algorithm is split in two cases, which differ only in the initial value of $z[i]$: in the first case it's assumed to be zero, in the second case it is determined by the previously computed values (using the above formula). After that, both branches of this algorithm can be reduced to the implementation of the trivial algorithm, which starts immediately after we specify the initial value.</p> <p>The algorithm turns out to be very simple. Despite the fact that on each iteration the trivial algorithm is run, we have made significant progress, having an algorithm that runs in linear time. Later on we will prove that the running time is linear.</p>","tags":["Translated"]},{"location":"string/z-function.html#implementation","title":"Implementation","text":"<p>Implementation turns out to be rather concise:</p> <pre><code>vector&lt;int&gt; z_function(string s) {\n    int n = s.size();\n    vector&lt;int&gt; z(n);\n    int l = 0, r = 0;\n    for(int i = 1; i &lt; n; i++) {\n        if(i &lt; r) {\n            z[i] = min(r - i, z[i - l]);\n        }\n        while(i + z[i] &lt; n &amp;&amp; s[z[i]] == s[i + z[i]]) {\n            z[i]++;\n        }\n        if(i + z[i] &gt; r) {\n            l = i;\n            r = i + z[i];\n        }\n    }\n    return z;\n}\n</code></pre>","tags":["Translated"]},{"location":"string/z-function.html#comments-on-this-implementation","title":"Comments on this implementation","text":"<p>The whole solution is given as a function which returns an array of length $n$ -- the Z-function of $s$.</p> <p>Array $z$ is initially filled with zeros. The current rightmost match segment is assumed to be $[0; 0)$ (that is, a deliberately small segment which doesn't contain any $i$).</p> <p>Inside the loop for $i = 1 \\dots n - 1$ we first determine the initial value $z[i]$ -- it will either remain zero or be computed using the above formula.</p> <p>Thereafter, the trivial algorithm attempts to increase the value of $z[i]$ as much as possible.</p> <p>In the end, if it's required (that is, if $i + z[i] &gt; r$), we update the rightmost match segment $[l, r)$.</p>","tags":["Translated"]},{"location":"string/z-function.html#asymptotic-behavior-of-the-algorithm","title":"Asymptotic behavior of the algorithm","text":"<p>We will prove that the above algorithm has a running time that is linear in the length of the string -- thus, it's $O(n)$.</p> <p>The proof is very simple.</p> <p>We are interested in the nested <code>while</code> loop, since everything else is just a bunch of constant operations which sums up to $O(n)$.</p> <p>We will show that each iteration of the <code>while</code> loop will increase the right border $r$ of the match segment.</p> <p>To do that, we will consider both branches of the algorithm:</p> <ul> <li> <p>$i \\geq r$</p> <p>In this case, either the <code>while</code> loop won't make any iteration (if $s[0] \\ne s[i]$), or it will take a few iterations, starting at position $i$, each time moving one character to the right. After that, the right border $r$ will necessarily be updated.</p> <p>So we have found that, when $i \\geq r$, each iteration of the <code>while</code> loop increases the value of the new $r$ index.</p> </li> <li> <p>$i &lt; r$</p> <p>In this case, we initialize $z[i]$ to a certain value $z_0$ given by the above formula. Let's compare this initial value $z_0$ to the value $r - i$. We will have three cases:</p> <ul> <li> <p>$z_0 &lt; r - i$</p> <p>We prove that in this case no iteration of the <code>while</code> loop will take place.</p> <p>It's easy to prove, for example, by contradiction: if the <code>while</code> loop made at least one iteration, it would mean that initial approximation $z[i] = z_0$ was inaccurate (less than the match's actual length). But since $s[l \\dots r)$ and $s[0 \\dots r-l)$ are the same, this would imply that $z[i-l]$ holds the wrong value (less than it should be).</p> <p>Thus, since $z[i-l]$ is correct and it is less than $r - i$, it follows that this value coincides with the required value $z[i]$.</p> </li> <li> <p>$z_0 = r - i$</p> <p>In this case, the <code>while</code> loop can make a few iterations, but each of them will lead to an increase in the value of the $r$ index because we will start comparing from $s[r]$, which will climb beyond the $[l, r)$ interval.</p> </li> <li> <p>$z_0 &gt; r - i$</p> <p>This option is impossible, by definition of $z_0$.</p> </li> </ul> </li> </ul> <p>So, we have proved that each iteration of the inner loop make the $r$ pointer advance to the right. Since $r$ can't be more than $n-1$, this means that the inner loop won't make more than $n-1$ iterations.</p> <p>As the rest of the algorithm obviously works in $O(n)$, we have proved that the whole algorithm for computing Z-functions runs in linear time.</p>","tags":["Translated"]},{"location":"string/z-function.html#applications","title":"Applications","text":"<p>We will now consider some uses of Z-functions for specific tasks.</p> <p>These applications will be largely similar to applications of prefix function.</p>","tags":["Translated"]},{"location":"string/z-function.html#search-the-substring","title":"Search the substring","text":"<p>To avoid confusion, we call $t$ the string of text, and $p$ the pattern. The problem is: find all occurrences of the pattern $p$ inside the text $t$.</p> <p>To solve this problem, we create a new string $s = p + \\diamond + t$, that is, we apply string concatenation to $p$ and $t$ but we also put a separator character $\\diamond$ in the middle (we'll choose $\\diamond$ so that it will certainly not be present anywhere in the strings $p$ or $t$).</p> <p>Compute the Z-function for $s$. Then, for any $i$ in the interval $[0; \\; \\operatorname{length}(t) - 1]$, we will consider the corresponding value $k = z[i + \\operatorname{length}(p) + 1]$. If $k$ is equal to $\\operatorname{length}(p)$ then we know there is one occurrence of $p$ in the $i$-th position of $t$, otherwise there is no occurrence of $p$ in the $i$-th position of $t$.</p> <p>The running time (and memory consumption) is $O(\\operatorname{length}(t) + \\operatorname{length}(p))$.</p>","tags":["Translated"]},{"location":"string/z-function.html#number-of-distinct-substrings-in-a-string","title":"Number of distinct substrings in a string","text":"<p>Given a string $s$ of length $n$, count the number of distinct substrings of $s$.</p> <p>We'll solve this problem iteratively. That is: knowing the current number of different substrings, recalculate this amount after adding to the end of $s$ one character.</p> <p>So, let $k$ be the current number of distinct substrings of $s$. We append a new character $c$ to $s$. Obviously, there can be some new substrings ending in this new character $c$ (namely, all those strings that end with this symbol and that we haven't encountered yet).</p> <p>Take a string $t = s + c$ and invert it (write its characters in reverse order). Our task is now to count how many prefixes of $t$ are not found anywhere else in $t$. Let's compute the Z-function of $t$ and find its maximum value $z_{max}$. Obviously, $t$'s prefix of length $z_{max}$ occurs also somewhere in the middle of $t$. Clearly, shorter prefixes also occur.</p> <p>So, we have found that the number of new substrings that appear when symbol $c$ is appended to $s$ is equal to $\\operatorname{length}(t) - z_{max}$.</p> <p>Consequently, the running time of this solution is $O(n^2)$ for a string of length $n$.</p> <p>It's worth noting that in exactly the same way we can recalculate, still in $O(n)$ time, the number of distinct substrings when appending a character in the beginning of the string, as well as when removing it (from the end or the beginning).</p>","tags":["Translated"]},{"location":"string/z-function.html#string-compression","title":"String compression","text":"<p>Given a string $s$ of length $n$. Find its shortest \"compressed\" representation, that is: find a string $t$ of shortest length such that $s$ can be represented as a concatenation of one or more copies of $t$.</p> <p>A solution is: compute the Z-function of $s$, loop through all $i$ such that $i$ divides $n$. Stop at the first $i$ such that $i + z[i] = n$. Then, the string $s$ can be compressed to the length $i$.</p> <p>The proof for this fact is the same as the solution which uses the prefix function.</p>","tags":["Translated"]},{"location":"string/z-function.html#practice-problems","title":"Practice Problems","text":"<ul> <li>CSES - Finding Borders</li> <li>eolymp - Blocks of string</li> <li>Codeforces - Password [Difficulty: Easy]</li> <li>UVA # 455 \"Periodic Strings\" [Difficulty: Medium]</li> <li>UVA # 11022 \"String Factoring\" [Difficulty: Medium]</li> <li>UVa 11475 - Extend to Palindrome</li> <li>LA 6439 - Pasti Pas!</li> <li>Codechef - Chef and Strings</li> <li>Codeforces - Prefixes and Suffixes</li> </ul>","tags":["Translated"]}]}